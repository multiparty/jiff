<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.3/leaflet.css" />
  </head>
  <body style="width:100%; height:100%; margin:0; padding:0;">
	<div id="leaflet" style="width:100vw; height:100vh;"></div>
  <script
    src="https://code.jquery.com/jquery-3.3.1.min.js"
    integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
    crossorigin="anonymous">
  </script>

  <script src="/socket.io/socket.io.js"></script>
  <script src="/lib/sodium.js"></script>
  <script src="lib/jiff-client.js"></script>
  <script src="static/sodium-sumo.js"></script>
  <script src="static/client-boston.js"></script>
  <script src="static/oprf-client.js"></script>
  <script src="client.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.3/leaflet.js"></script>

	<script>
      $( document ).ready(function() {
        console.log( "ready!" );
        document.getElementById('leaflet').style.cursor = 'crosshair';
      });

      // var oprf = new OPRF_(sodium);

        sodium.ready.then(function () {
        var points = obj.features;
        for(var i = 0; i < points.length; i++) {
          var id = points[i].properties.point_id;
          points[i].properties.point_id = oprf.hashToPoint(id.toString());
        }

        var pointCount = 0
        var path = Array();
        var isPathRendered = false;

        function randomColor() {
          var color = '', letters = '0123456'; //789ABCDEF
          for (var i=0; i<6; i++) {color += letters[Math.floor(Math.random() * letters.length)];}
          return '#' + color;
        }

        function drawLineBetweenPoints(start,stop){
          //start and stop are strng arrays containng start and stop latlns respectively
          var latlngs = Array();
          latlngs.push(start);
          latlngs.push(stop);
          // latlngs.push([parseFloat(start.split(",")[0]), parseFloat(start.split(",")[1])])
          // latlngs.push([parseFloat(stop.split(",")[0]), parseFloat(stop.split(",")[1])])
          var polyline = L.polyline(latlngs, {color: 'midnightblue'});
          path.push(polyline);
          polyline.addTo(leaflet);
          //Optional, enable for zooming in on the map area with line
          //leaflet.fitBounds(polyline.getBounds());

        }

        function drawPath(points){
          pointCount = 0;
          for(jump in points){
            console.log("rendering path...");
            jump = parseInt(jump);
            if(jump < points.length-1){
              source = obj["features"][points[jump]]["coordinates"].slice().reverse();
              dest = obj["features"][points[jump+1]]["coordinates"].slice().reverse();
              drawLineBetweenPoints(source,dest)
            }

            isPathRendered = true;

            //attach event
            $( "#leaflet" ).mousedown(function() {
          
              if(isPathRendered){
                //erase everything
                for(item in path){
                  leaflet.removeLayer(path[item])
                }
                //clear path
                path = Array()
                //remove this event
                $( "#leaflet" ).off("mousedown");
                //Reset variable for tracking
                // var isPathRendered = false;
              }
            });

            // console.log(points[jump]);
          }
        }
        var leaflet = L.map('leaflet').setView([42.3469,-71.0709], 17);
        L.tileLayer("http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom:20, attribution:'', id:'mapbox.light'
        }).addTo(leaflet);
        function onEachFeature(feature, layer) {
          // if (feature.properties) {
            // var popupContent = " You have selected:<p>" + feature.coordinates[0] + ' , ' + feature.coordinates[1] + ".</p>";
            // layer.bindPopup(popupContent);
          }
        L.geoJson(obj, {
          filter: function (feature, layer) { return true; },
          onEachFeature: onEachFeature,
          style: function (feature) { return {"color": randomColor()}; },
          pointToLayer:
            function (feature, latlng) {
              var circle = L.circleMarker(latlng, {radius:7, weight:0.1, fillColor:"red", color:"red", opacity:1, fillOpacity:1});
              circle.on('mouseover', function(){
                circle.setStyle({ color: 'red' });
              });
              circle.on('click', function(){
                lat = circle._latlng["lat"];
                lng = circle._latlng["lng"]
                console.log(circle);         
                var marker = L.marker([lat, lng])
                path.push(marker);
                leaflet.addLayer(marker);

                if(pointCount == 0){
                  window.localStorage.setItem("StartLatLng",[lat,lng]);
                  window.localStorage.setItem("StartPointId", circle.feature.geometry.properties["point_id"]);
                }else if (pointCount == 1){
                  window.localStorage.setItem("StopPointId", circle.feature.geometry.properties["point_id"]);
                  window.localStorage.setItem("StopLatLng",[lat,lng]);

                  //make ajax call to server
                  //'https://hri.appliedmpc.org/calculate/'
                  make_query();
                  
                }
                pointCount++;
              });
              return circle;
            }
        }).addTo(leaflet);
      });
	</script>
  </body>
</html>
