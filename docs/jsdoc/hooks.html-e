<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Home</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">JIFF</h1>

    



    


    <h3> </h3>










    




    <section>
        <article><h1>Hooks</h1><h2>Supported Hooks</h2><h3>Crypto Hooks:</h3><ul>
<li><code>generateKeyPair[Single]: function()</code><ul>
<li>Return: an object with two attributes: public_key and secret_key. Both keys must be in a format understandable
by dumpKey, encryptSign, and decryptSign hooks.</li>
</ul>
</li>
<li><code>dumpKey[Single]: function(public_key)</code><ul>
<li><code>public_key</code>: the public key (as generated by generateKeyPair) which must be dumped to string.</li>
<li>Return: a string representing the public key.</li>
</ul>
</li>
<li><code>parseKey[Single]: function(public_key_string)</code><ul>
<li><code>public_key_string</code>: string representation of the public key to be parsed (as generated by dumpKey).</li>
<li>Return: parsed public key in a format understandable by dumpKey, encryptSign, and decryptSign.</li>
</ul>
</li>
<li><code>encryptSign[Single]: function(message, encryption_public_key, signing_private_key, operation_type)</code><ul>
<li><code>message</code>: the message to encrypt (message type depends on operation type)</li>
<li><code>encryption_public_key</code>: public key to encrypt with (corresponding to the receiving party)</li>
<li><code>signing_private_key</code>: secret key to sign with (corresponding to this party)</li>
<li><code>operation_type</code>: the operation for which this encryption is performed, one of the following: 'share', 'open', 'triplet', 'number', and 'custom'
   if type is either share or open, then message is a number (or bigNumber if using bigNumber extension),
   otherwise message is a string.<ul>
<li>Return: the signed cipher with any additional properties desired to be sent with it (tags, meta-info, etc.) as a JavaScript object</li>
</ul>
</li>
</ul>
</li>
<li><code>decryptSign[Single]: function(cipher_text, decryption_secret_key, signing_public_key, operation_type)</code><ul>
<li><code>cipher_text</code>: the cipher_text to decrypt, the format and type matches that returned by encryptSign</li>
<li><code>decryption_secret_key</code>: secret key to decrypt with (corresponding to this party)</li>
<li><code>signing_public_key</code>: public key to verify signature with (corresponding to sending party)</li>
<li><code>operation_type</code>: the operation for which this encryption is performed, one of the following: 'share', 'open', 'triplet', 'number', and 'custom'<ul>
<li>Throw: if signature did not check out correctly</li>
<li>Return: the decrypted message (format and type must match that of the message passed to the corresponding <code>encryptSign</code>)
if type is either share or open, then return type must be a number (or bigNumber if using bigNumber extension),
otherwise must be a string.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Share Hooks:</h3><ul>
<li><code>beforeShare[Array]: function(instance, secret, threshold, receivers_list, senders_list, Zp)</code><ul>
<li>Initially, parameters are as passed to <code>jiff_instance.share</code> in the client code:<ul>
<li><code>instance</code>: the JIFF instance</li>
<li><code>secret</code>: the secret to share</li>
<li><code>threshold</code>: the threshold for sharing</li>
<li><code>receivers_list</code>: array of ids of receiving parties</li>
<li><code>senders_list</code>: array of ids of sending parties (parties that have secrets)</li>
<li><code>Zp</code>: the modulos</li>
</ul>
</li>
<li>Return: must return the (possibly modified) secret to share (to be used as the secret for subsequent hooks in the array).</li>
</ul>
</li>
<li><code>computeShares[Single]: function(instance, secret, parties_list, threshold, Zp)</code><ul>
<li><code>instance</code>: the JIFF instance</li>
<li><code>secret</code>: the secret to share</li>
<li><code>parties_list</code>: array of ids of parties for which to create shares of the secret</li>
<li><code>threshold</code>: the threshold for sharing</li>
<li><code>Zp</code>: the modulus<ul>
<li>Return: must return a map from <code>party_id</code> to its corresponding share value (for every <code>party_id</code> in <code>parties_list</code>).</li>
</ul>
</li>
</ul>
</li>
<li><code>afterComputeShare[Array]: function(instance, shares, threshold, receivers_list, senders_list, Zp)</code><ul>
<li><code>instance</code>: the JIFF instance</li>
<li><code>shares</code>: a map from party_id to the corresponding share value</li>
<li><code>threshold</code>: the threshold for sharing</li>
<li><code>receivers_list</code>: array of ids of receiving parties</li>
<li><code>senders_list</code>: array of ids of sending parties (parties that have secrets)</li>
<li><code>Zp</code>: the modulus<ul>
<li>Return: must return a map from <code>party_id</code> to its corresponding share value (for every <code>party_id</code> in <code>receivers_list</code>).</li>
</ul>
</li>
</ul>
</li>
<li><code>receiveShare[Array]: function(instance, sender_id, share)</code><ul>
<li><code>instance</code>: the JIFF instance</li>
<li><code>sender_id</code>: party_id of the sender</li>
<li><code>share</code>: the received share (after decryption)<ul>
<li>Return: the share, possibly modified (this is used as share for the subsequent hooks in the array).</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Open Hooks:</h3><ul>
<li><code>beforeOpen[Array]: function(instance, share, parties)</code><ul>
<li><code>instance</code>: the JIFF instance</li>
<li><code>share</code>: the share to open {type: secret_share}</li>
<li><code>parties</code>: the parties that will receive the open<ul>
<li>Return: the share to open, possibly modified (this is used as share for the subsequent hooks in the array).</li>
</ul>
</li>
</ul>
</li>
<li><code>receiveOpen[Array]: function(instance, sender_id, share, Zp)</code><ul>
<li><code>instance</code>: the JIFF instance</li>
<li><code>sender_id</code>: party_id of the sender</li>
<li><code>share</code>: the received share (after decryption)</li>
<li><code>Zp</code>: the modulus<ul>
<li>Return: the share, possibly modified (this is used as share for the subsequent hooks in the array).</li>
</ul>
</li>
</ul>
</li>
<li><code>reconstructShare[Single]: function(instance, shares)</code><ul>
<li><code>instance</code>: the JIFF instance</li>
<li><code>shares</code>: a map from party_id to its corresponding object: <code>{&quot;value&quot;:share, &quot;sender_id&quot;:sender_id, &quot;Zp&quot;:Zp }</code><ul>
<li>Return: the reconstructed secret.</li>
</ul>
</li>
</ul>
</li>
<li><code>afterReconstructShare[Array]: function(instance, value)</code><ul>
<li><code>instance</code>: the JIFF instance</li>
<li><code>value</code>: the reconstructed value as returned by reconstructShare<ul>
<li>Return: the reconstructed secret, possibly modified (this is used as value for the subsequent hooks in the array).</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Miscellaneous Hooks:</h3><ul>
<li><code>receiveTriplet[Array]: function(instance, triplet)</code><ul>
<li><code>instance</code>: the JIFF instance</li>
<li><code>triplet</code>: the received triplet after decryption (a map from <em>a</em>, <em>b</em>, <em>c</em> to the corresponding shares such that <em>a</em> <em> </em>b<em> = </em>c*`)<ul>
<li>Return: the triplet, possibly modified (this is used as triplet for the subsequent hooks in the array).</li>
</ul>
</li>
</ul>
</li>
<li><code>receiveNumbers[Array]: function(instance, numbers)</code><ul>
<li><code>instance</code>: the JIFF instance</li>
<li><code>numbers</code>: an array with format: [ {&quot;number&quot;: {value}, &quot;number_id&quot;: <string> } ] that contains number values (i.e. shares of numbers) and their ids (after decryption).<ul>
<li>Return: an array with th same format as the numbers parameter: the values and ids inside it may be possibly modified (this is used as the numbers parameter for the subsequent hooks in the hook array).</li>
</ul>
</li>
</ul>
</li>
<li><code>createSecretShare[Array]: function(instance, secret_share)</code><ul>
<li><code>instance</code>: the JIFF instance</li>
<li><code>secret_share</code>: the secret_share object as created by JIFF<ul>
<li>Return: the <code>secret_share</code> object to be used by JIFF, possibly modified (this is used for the subsequent hooks in the array).</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Example</h2><p>Hooks can be passed to an instance at creation time via the options object.</p>
<p>Single Hooks expect the value to be a function, while Array Hooks expect the value to be an array (even when only a single hooks is used).</p>
<pre class="prettyprint source lang-javascript"><code>var options = {};
options.hooks = {
  /* Example hooks. */
  'beforeShare': [
    function(instance, secret, threshold, receivers_list, senders_list, Zp) {
      /* Some code. */
      return modified_secret;
    } 
  ],
  'computeShares':
    function(secret, party_count, parties_list, threshold, Zp) {
      /* Some code. */
      return shares_map;
    }
};
var instance = make_jiff('hostname', 'computation_id', options);</code></pre><h2>Flows Supported By Hooks</h2><p>Hooks allow to customize the following flows in JIFF without having to explicity modify JIFF's source code.</p>
<h3>Custom crypto libraries</h3><p>Allows using a different crypto library (e.g. for browser compatibility purposes), or disabling/changing the crypto primitives
all together. Note that the same/compatible implementation of these hooks must be passed to jiff-server, <em>and</em> any participating computation
instances created on the server side.</p>
<ol>
<li>hook: <code>generateKeyPair</code> called on initialization.</li>
<li>hook: <code>dumpKey</code> called to marshal the public key to a string that can be transmitted to other parties.</li>
<li>hook: <code>parseKey</code> called when a marshaled public key is received from some party to parse it.</li>
<li>hook: <code>encryptSign</code> called to sign and encrypt messages sent by this party for various operations, including share, open, and custom messages.</li>
<li>hook: <code>decryptSign</code> called to decrypt and verify messages received by this party. </li>
</ol>
<h3>Share flow</h3><p>Determines how shares are generated and sent to parties:</p>
<ol>
<li><code>jiff_instance.share</code></li>
<li>hook: <code>beforeShare</code></li>
<li>hook: <code>computeShare</code></li>
<li>hook: <code>afterComputeShare</code></li>
<li>hook: <code>encryptSign</code> (<code>operation_type</code> = <code>'share'</code>)</li>
<li>send shares to parties</li>
<li>party receives share</li>
<li>hook: <code>decryptSign</code> (<code>operation_type</code> = <code>'share'</code>)</li>
<li>hook: <code>receiveShare</code></li>
<li>resolve value into corresponding <code>secret_share</code> object</li>
</ol>
<p>Note that:</p>
<ul>
<li>the party may be receiving a share without sharing anything, in which case only steps 1 and 7-10 are executed;</li>
<li>the party may be sharing a value without receiving shares of anything, in which case only steps 1-6 are executed.</li>
</ul>
<h3>Open flow</h3><p>Determine show parties can open (reveal) a share and get the result:</p>
<ol>
<li><code>jiff_instance.open/share.open</code></li>
<li>hook: <code>beforeOpen</code></li>
<li>share is refreshed and refreshed value is used going forward</li>
<li>hook: <code>encryptSign</code> (<code>operation_type</code> = <code>'open'</code>)</li>
<li>send share to parties</li>
<li>party receives share to open</li>
<li>hook: <code>decryptSign</code> (<code>operation_type</code> = <code>'open'</code>)</li>
<li>hook: <code>receiveOpen</code></li>
<li>hook (once enough shares are received in step 8 above): <code>reconstructShare</code></li>
<li>hook: <code>afterReconstructShare</code></li>
<li>resolve reconstructed value into open promise/callback</li>
</ol>
<p>Alternatively, a party may receive the result for a share that it does not own, in which case the flow becomes:</p>
<ul>
<li><code>jiff_instance.receive_open</code></li>
<li>party receives share to open (step 6 from above sequence)</li>
<li>steps 7-11 from above sequence</li>
</ul>
<p>A party may also hold a share of the result but not receive the result, in which case only steps 1-5 of the original flow are executed.</p>
<h3>Triplet request</h3><ol>
<li><code>jiff_instance.triplet</code> (e.g. when a multiplication is performed)</li>
<li>hook: <code>encryptSign</code> (<code>operation_type</code> = <code>'triplet'</code>)</li>
<li>request is sent to server</li>
<li>server replies</li>
<li>hook: <code>decryptSign</code> (<code>operation_type</code> = <code>'triplet'</code>)</li>
<li>hook: <code>receiveTriplet</code></li>
<li>resolve triplet into corresponding <code>secret_share</code> objects</li>
</ol>
<h3>Number request</h3><ol>
<li><code>jiff_instance.server_generate_and_share</code> (e.g. when a constant division or share refresh is performed)</li>
<li>hook: <code>encryptSign</code> (<code>operation_type</code> = <code>'number'</code>)</li>
<li>request is sent to server</li>
<li>server replies</li>
<li>hook: <code>decryptSign</code> (<code>operation_type</code> = <code>'number'</code>)</li>
<li>hook: <code>receiveNumbers</code></li>
<li>resolve triplet into corresponding <code>secret_share</code> objects</li>
</ol>
<h3>Creation of secret_share objects</h3><p>This flow is particularly useful when developing extensions for JIFF. This allows the user to modify the implementation of a <code>secret_share</code> object, including changing how operations are implemented (e.g. addition, multiplication, etc.), registering callbacks for when the share is computed, or adding additional operations:</p>
<ol>
<li>a share is created (e.g. by <code>jiff_instance.share</code> or by operating on shares)</li>
<li><code>new secret_share</code> is invoked</li>
<li>the default <code>secret_share</code> object is created</li>
<li>hook: <code>createSecretShare</code></li>
<li>returned <code>secret_share</code> object is used by JIFF</li>
</ol></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="jiff.html">jiff</a></li><li><a href="jiff.sharing_schemes.html">sharing_schemes</a></li><li><a href="jiff.utils.html">utils</a></li><li><a href="jiff-instance.html">jiff-instance</a></li><li><a href="jiff-instance.helpers.html">helpers</a></li><li><a href="jiff-instance.protocols.html">protocols</a></li><li><a href="SecretShare.html">SecretShare</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Nov 13 2018 23:05:45 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
