<html>
  <head>
    <meta charset="UTF-8">
    <title>voting - Neptune-notebook.js</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <style>
      /* neptune.css */
      /*
 * General styling
 */
* {
  box-sizing: border-box;
}

body {
  padding: 50px;
}

/*
 * Tabs layout
 * https://kyusuf.com/post/completely-css-tabs/
 */
.code-tabs {
  /* box-shadow: 0 48px 80px -32px rgba(0,0,0,0.3); */
  padding: 30px 10px 10px 10px;
  background: #e5e5e5;
  overflow: hidden;
  border: dashed 1px #333333;
  border-radius: 20px;
}
.tab-input {
  position: absolute;
  opacity: 0;
}
.tab-label {
  border-radius: 10px 10px 0 0;
  width: 100%;
  padding: 20px 30px;
  background: #e5e5e5;
  cursor: pointer;
  font-weight: bold;
  font-size: 18px;
  color: #7f7f7f;
  transition background 0.1s, color 0.1s;

}
.tab-label-selected {
  background: rgb(45, 45, 45);
  color: #FFFFFF;
}
.tab-label:hover {
  color: #4CAF50;
}
.code-tab {
  display: none;
  clear: both;
}
.tab-input:checked + .code-tab {
  display: block;
}

/*
 * Code editor
 * Use a "transparent" <textarea> super-imposed right on top of <code> in parent <pre>
 */
.code-editor {
  /* overlay this perfectly on top of code */
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  height: calc(100% - 1px);

  /* Make sure nothing is visible from this text area */
  border: none;
  overflow: hidden;
  resize: none;
  background-color: transparent;
  color: transparent;
  caret-color: white;
  
  /* have the same exact font as <code> */
  font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
  font-size: 16px;
  line-height: 24px;
  overflow-wrap: normal;
  text-align: left;
  word-break: normal;
  word-spacing: 0px;
  -moz-tab-size: 4;

  /* have the same padding as <code> (due to line numbers) */
  padding-left: 3.8em;
  padding-right: 1em;
  padding-top: 1em;
  padding-bottom: 1em;
}

.code-tab pre {
  min-height: 80px;
  overflow: hidden;
}

/*
 * bar with execute button 
 * Inspired by https://www.w3schools.com/howto/howto_css_icon_bar.asp
 */
.code-top-toolbar {
  float: right;
  position: relative;
  top: -10px;
  padding: 0;
}

.code-top-toolbar a {
  text-align: center;
  padding: 10px;
  transition: all 0.3s ease;
  color: #333333;
  font-size: 30px;
  z-index: 2;
}

.code-top-toolbar a:hover {
  background-color: rgb(45, 45, 45);
  color: #FFFFFF;
}

/*
 * output terminal like panel
 */
.output-panel {
  display: none;
}

/*
 * Custom output divs
 */
.custom-output-div {
}

    </style>
    <style>
      /* prism.css */
      /* PrismJS 1.17.1
https://prismjs.com/download.html#themes=prism-tomorrow&languages=markup+css+clike+javascript&plugins=line-numbers+command-line */
/**
 * prism.js tomorrow night eighties for JavaScript, CoffeeScript, CSS and HTML
 * Based on https://github.com/chriskempson/tomorrow-theme
 * @author Rose Pritchard
 */

code[class*="language-"],
pre[class*="language-"] {
	color: #ccc;
	background: none;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	font-size: 1em;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;

}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #2d2d2d;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.block-comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: #999;
}

.token.punctuation {
	color: #ccc;
}

.token.tag,
.token.attr-name,
.token.namespace,
.token.deleted {
	color: #e2777a;
}

.token.function-name {
	color: #6196cc;
}

.token.boolean,
.token.number,
.token.function {
	color: #f08d49;
}

.token.property,
.token.class-name,
.token.constant,
.token.symbol {
	color: #f8c555;
}

.token.selector,
.token.important,
.token.atrule,
.token.keyword,
.token.builtin {
	color: #cc99cd;
}

.token.string,
.token.char,
.token.attr-value,
.token.regex,
.token.variable {
	color: #7ec699;
}

.token.operator,
.token.entity,
.token.url {
	color: #67cdcc;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}

.token.inserted {
	color: green;
}

pre[class*="language-"].line-numbers {
	position: relative;
	padding-left: 3.8em;
	counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
	position: relative;
	white-space: inherit;
}

.line-numbers .line-numbers-rows {
	position: absolute;
	pointer-events: none;
	top: 0;
	font-size: 100%;
	left: -3.8em;
	width: 3em; /* works for line-numbers below 1000 lines */
	letter-spacing: -1px;
	border-right: 1px solid #999;

	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;

}

	.line-numbers-rows > span {
		pointer-events: none;
		display: block;
		counter-increment: linenumber;
	}

		.line-numbers-rows > span:before {
			content: counter(linenumber);
			color: #999;
			display: block;
			padding-right: 0.8em;
			text-align: right;
		}

.command-line-prompt {
	border-right: 1px solid #999;
	display: block;
	float: left;
	font-size: 100%;
	letter-spacing: -1px;
	margin-right: 1em;
	pointer-events: none;

	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
}

.command-line-prompt > span:before {
	color: #999;
	content: ' ';
	display: block;
	padding-right: 0.8em;
}

.command-line-prompt > span[data-user]:before {
	content: "[" attr(data-user) "@" attr(data-host) "] $";
}

.command-line-prompt > span[data-user="root"]:before {
	content: "[" attr(data-user) "@" attr(data-host) "] #";
}

.command-line-prompt > span[data-prompt]:before {
	content: attr(data-prompt);
}


    </style>
    <style>
      /* injected CSS */
      
    </style>
    
  </head>
  <body>
    <h1 id="intermediateprogrammingwithjiff">Intermediate Programming with JIFF</h1>
<p>In the last tutorial, we saw how we can write a simple MPC voting application in JIFF. However, we left a few issues unresolved:</p>
<ol>
<li>Inputs are not sanitized.</li>
<li>Output may be very leaky.</li>
</ol>
<h4 id="tutorialcontent">Tutorial content:</h4>
<ol>
<li>Comparison primitives in JIFF: encoding input sanitization under MPC.</li>
<li>Control flow and branching under MPC: making the output reveal less.</li>
</ol>
<h1 id="setup">Setup</h1>
<p>Our setup is similar to the one from the previous tutorial.</p>
<pre><code class="neptune[title=Server,frame=frame1,env=server] language-neptune[title=Server,frame=frame1,env=server]">var jiff = require('../../../../../lib/jiff-server.js'); // replace this with your actual path to jiff-server.js
var jiff_instance = jiff.make_jiff(server, { logs:true });
Console.log('Server is running on port 9111');
</code></pre>
<pre><code class="neptune[title=Party&nbsp;1,frame=frame1,scope=1] language-neptune[title=Party&nbsp;1,frame=frame1,scope=1]">function onConnect() {
  Console.log('All parties connected!');
}

var options = { party_count: 3, crypto_provider: true, onConnect: onConnect, Zp: 11 };
var jiff_instance = jiff.make_jiff('http://localhost:9111', 'our-setup-application', options);
</code></pre>
<pre><code class="neptune[title=Party&nbsp;2,frame=frame1,scope=2] language-neptune[title=Party&nbsp;2,frame=frame1,scope=2]">function onConnect() {
  Console.log('All parties connected!');
}

var options = { party_count: 3, crypto_provider: true, onConnect: onConnect, Zp: 11 };
var jiff_instance = jiff.make_jiff('http://localhost:9111', 'our-setup-application', options);
</code></pre>
<pre><code class="neptune[title=Party&nbsp;3,frame=frame1,scope=3] language-neptune[title=Party&nbsp;3,frame=frame1,scope=3]">function onConnect() {
  Console.log('All parties connected!');
}

var options = { party_count: 3, crypto_provider: true, onConnect: onConnect, Zp: 11 };
var jiff_instance = jiff.make_jiff('http://localhost:9111', 'our-setup-application', options);
</code></pre>
<h1 id="inputsanitization">Input sanitization</h1>
<p>Note that a valid input to our voting application satisifies these two constraints:</p>
<ol>
<li>Single option voting: all values are zero except exactly one.</li>
<li>Single vote: the non-zero value has to be exactly one.</li>
</ol>
<p>Our input sanitization function must therefore check that these two conditions are true.</p>
<pre><code class="neptune[title=Party&nbsp;1,frame=frame2,scope=1] language-neptune[title=Party&nbsp;1,frame=frame2,scope=1]">// shares is an array representing a single party's input shares
function sanityCheck(shares) {
  // first check
  var sum = shares[0];
  for (var i = 1; i &lt; shares.length; i++) {
    sum = sum.sadd(shares[i]);
  }
  var check1 = sum.ceq(1);

  // second check
  var check2 = shares[0].clteq(1);
  for (var j = 1; j &lt; shares.length; j++) {
    check2 = check2.smult(shares[j].clteq(1));
  }

  // logical and is a multiplication
  return jiff_instance.open(check1.smult(check2));
}
</code></pre>
<pre><code class="neptune[title=Party&nbsp;2,frame=frame2,scope=2] language-neptune[title=Party&nbsp;2,frame=frame2,scope=2]">// shares is an array representing a single party's input shares
function sanityCheck(shares) {
  // first check
  var sum = shares[0];
  for (var i = 1; i &lt; shares.length; i++) {
    sum = sum.sadd(shares[i]);
  }
  var check1 = sum.ceq(1);

  // second check
  var check2 = shares[0].clteq(1);
  for (var j = 1; j &lt; shares.length; j++) {
    check2 = check2.smult(shares[j].clteq(1));
  }

  // logical and is a multiplication
  return jiff_instance.open(check1.smult(check2));
}
</code></pre>
<pre><code class="neptune[title=Party&nbsp;3,frame=frame2,scope=3] language-neptune[title=Party&nbsp;3,frame=frame2,scope=3]">// shares is an array representing a single party's input shares
function sanityCheck(shares) {
  // first check
  var sum = shares[0];
  for (var i = 1; i &lt; shares.length; i++) {
    sum = sum.sadd(shares[i]);
  }
  var check1 = sum.ceq(1);

  // second check
  var check2 = shares[0].clteq(1);
  for (var j = 1; j &lt; shares.length; j++) {
    check2 = check2.smult(shares[j].clteq(1));
  }

  // logical and is a multiplication
  return jiff_instance.open(check1.smult(check2));
}
</code></pre>
<p>Note that our implementation of check 1 by itself is not really sufficient to perform the single option voting correctly.
For example, if the inputs were <strong>[10, Prime-9, 0, 0]</strong>, their sum would be <strong>Prime + 1 = 1 (mod Prime)</strong>.</p>
<p>However, since the second check ensures that such invalid inputs are detected. We do not have an issue with negative votes,
since JIFF works in domain [0, prime) by default. To support negative numbers, the client code must use the negative numbers
extension explicitly.</p>
<p>Now we can use the sanityCheck function to determine if inputs are OK!</p>
<pre><code class="neptune[title=Party&nbsp;1,frame=frame3,scope=1] language-neptune[title=Party&nbsp;1,frame=frame3,scope=1]">var options = ['IPA', 'Lager', 'Stout', 'Pilsner'];
var input = [1,0,0,0] // this is ok

function sanitize(input, callback) {
  var promise = jiff_instance.share_array(input); // helper for sharing arrays
  promise.then(function (arrays) {
    var sanity1 = sanityCheck(arrays[1]); // check first party's input and open result
    var sanity2 = sanityCheck(arrays[2]);
    var sanity3 = sanityCheck(arrays[3]);
    Promise.all([sanity1, sanity2, sanity3]).then(function (results) {
      Console.log(results);
      callback((results[0] + results[1] + results[2]) === 3, arrays);
    });
  });
}
sanitize(input, function () {});
</code></pre>
<pre><code class="neptune[title=Party&nbsp;2,frame=frame3,scope=2] language-neptune[title=Party&nbsp;2,frame=frame3,scope=2]">var options = ['IPA', 'Lager', 'Stout', 'Pilsner'];
var input = [1,0,1,0] // this is not ok

function sanitize(input, callback) {
  var promise = jiff_instance.share_array(input); // helper for sharing arrays
  promise.then(function (arrays) {
    var sanity1 = sanityCheck(arrays[1]); // check first party's input and open result
    var sanity2 = sanityCheck(arrays[2]);
    var sanity3 = sanityCheck(arrays[3]);
    Promise.all([sanity1, sanity2, sanity3]).then(function (results) {
      Console.log(results);
      callback((results[0] + results[1] + results[2]) === 3, arrays);
    });
  });
}
sanitize(input, function () {});
</code></pre>
<pre><code class="neptune[title=Party&nbsp;3,frame=frame3,scope=3] language-neptune[title=Party&nbsp;3,frame=frame3,scope=3]">var options = ['IPA', 'Lager', 'Stout', 'Pilsner'];
var input = [10,0,0,0] // this is not ok

function sanitize(input, callback) {
  var promise = jiff_instance.share_array(input); // helper for sharing arrays
  promise.then(function (arrays) {
    var sanity1 = sanityCheck(arrays[1]); // check first party's input and open result
    var sanity2 = sanityCheck(arrays[2]);
    var sanity3 = sanityCheck(arrays[3]);
    Promise.all([sanity1, sanity2, sanity3]).then(function (results) {
      Console.log(results);
      callback((results[0] + results[1] + results[2]) === 3, arrays);
    });
  });
}
sanitize(input, function () {});
</code></pre>
<p>The <em>share_array</em> function is a JIFF helper that allows sharing of arrays easily. The lengths of the arrays
are communicated implicitly first, and then each element in each array is shared according to JIFF's share function.</p>
<p>In the actual application, instead of outputing the result of the sanity, the code should check if all inputs are sane,
then proceed to execute the actual protocol.</p>
<p>Finally, JIFF is secure only against semi-honest parties. A cheating party that is incentivized to act maliciously can still
cheat by deviating from the protocol (i.e. running a different piece of code, denial of service).</p>
<h1 id="controlflowandbranching">Control Flow and Branching</h1>
<p>The output of the vote remains too granular. Therefore, it has a risk of leaking too much about the inputs. However,
in this scenario, all what we are really interested about is learning the winner, but not the entire vote tally.</p>
<p>We can re-configure the MPC code to compute the tally, then check for which option is the winner, and output only that.</p>
<pre><code class="neptune[title=Party&nbsp;1,frame=frame4,scope=1] language-neptune[title=Party&nbsp;1,frame=frame4,scope=1]">var options = ['IPA', 'Lager', 'Stout', 'Pilsner'];
var input = [1,0,0,0] // this is ok

function findWinner(valid, arrays) {
  if (!valid) {
    Console.log('invalid inputs');
    return;
  }

  var tally = arrays[1];
  for (var party = 2; party &lt;= jiff_instance.party_count; party++) {
    for (var option = 0; option &lt; options.length; option++) {
      tally[option] = tally[option].sadd(arrays[party][option]);
    }
  }

  var winner = 0; // find winner by finding the max tally
  var max = tally[0];
  for (var i = 1; i &lt; tally.length; i++) {
    var iIsMax = tally[i].sgt(max);
    max = iIsMax.if_else(tally[i], max);
    winner = iIsMax.if_else(i, winner);
  }

  jiff_instance.open(winner).then(function (winner) {
    Console.log(options[winner]);
  });
}

sanitize(input, findWinner);
</code></pre>
<pre><code class="neptune[title=Party&nbsp;2,frame=frame4,scope=2] language-neptune[title=Party&nbsp;2,frame=frame4,scope=2]">var options = ['IPA', 'Lager', 'Stout', 'Pilsner'];
var input = [0,1,0,0] // this is ok

function findWinner(valid, arrays) {
  if (!valid) {
    Console.log('invalid inputs');
    return;
  }

  var tally = arrays[1];
  for (var party = 2; party &lt;= jiff_instance.party_count; party++) {
    for (var option = 0; option &lt; options.length; option++) {
      tally[option] = tally[option].sadd(arrays[party][option]);
    }
  }

  var winner = 0; // find winner by finding the max tally
  var max = tally[0];
  for (var i = 1; i &lt; tally.length; i++) {
    var iIsMax = tally[i].sgt(max);
    max = iIsMax.if_else(tally[i], max);
    winner = iIsMax.if_else(i, winner);
  }

  jiff_instance.open(winner).then(function (winner) {
    Console.log(options[winner]);
  });
}

sanitize(input, findWinner);
</code></pre>
<pre><code class="neptune[title=Party&nbsp;3,frame=frame4,scope=3] language-neptune[title=Party&nbsp;3,frame=frame4,scope=3]">var options = ['IPA', 'Lager', 'Stout', 'Pilsner'];
var input = [0,0,1,0] // this is ok

function findWinner(valid, arrays) {
  if (!valid) {
    Console.log('invalid inputs');
    return;
  }

  var tally = arrays[1];
  for (var party = 2; party &lt;= jiff_instance.party_count; party++) {
    for (var option = 0; option &lt; options.length; option++) {
      tally[option] = tally[option].sadd(arrays[party][option]);
    }
  }

  var winner = 0; // find winner by finding the max tally
  var max = tally[0];
  for (var i = 1; i &lt; tally.length; i++) {
    var copy = max; // just for logging

    var iIsMax = tally[i].sgt(max);
    max = iIsMax.if_else(tally[i], max);
    winner = iIsMax.if_else(i, winner);

    // logging
    Console.log('iteration', i, winner.toString());
    max.wThen(function (i, copy, max) {
      Console.log('iteration', i, 'new max', max.value, 'new option', tally[i].value, 'old max', copy.value);
    }.bind(null, i, copy, max));
  }

  jiff_instance.open(winner).then(function (winner) {
    Console.log(options[winner]);
  });
}

sanitize(input, findWinner);
</code></pre>
<p>Branching statements and conditional are problematic under MPC. A traditional if-else statement inherently leaks
the result of condition, since that can be learned by observing which instructions / branch is executed.</p>
<p>MPC implementations of such statements operate differently. All possible branches are executed concurrently, and
the condition is used to select which of the branches to keep, and which to throw away. This choice must be done
obliviously. Chosen values must be re-randomized so that syntactic comparisons cannot detect which values were chosen.</p>
<p>JIFF's <em>if_else</em> function implements such an oblivious choice. Given two parameters, if the condition is equal to 1,
the first parameter is returned, otherwise the second parameter is returned. Looking at the third party's output,
the log statements demonstrate that JIFF re-randomizes the secret shares returned by the if_else statement. This is a side
effect of how if_else is internally implemented.</p>
<p>Finally, <em>if_else</em> can operate on SecretShare as well as public constant parameters for ease of use.</p>
<p>The internal implementation of if_else relies on the following mathematical expression.</p>
<pre><code class="neptune[title=If&nbsp;Else,frame=frame5,scope=NONE] language-neptune[title=If&nbsp;Else,frame=frame5,scope=NONE]">condition.if_else = function (opt1, opt2) {
  var not = condition.cmult(-1).cadd(1); // 1 - c = not c
  var v1 = condition.smult(opt1); // opt1 if condition = 1, 0 if condition = 0
  var v2 = not.smult(opt2); // opt 2 if condition = 0, 0 if condition = 1
  return v1.sadd(v2);
}

// optimized
condition.if_else = function (opt1, opt2) {
  // assume condition is false, if it is not, correct the result!
  // if condition = 1 =&gt; opt2 + 1 * (opt1 - opt2) = opt1
  // if condition = 0 =&gt; opt2 + 0 * (opt1 - opt2) = opt2
  return opt2.sadd(condition.smult(opt1.ssub(opt2)));
}
</code></pre>
<h1 id="otherprimitives">Other Primitives</h1>
<p>JIFF provides many primitives and protocols built-in. A list of all such primitives and their costs in terms of rounds of communication and
total bandwidth, is available in the JIFF jsdocs.</p>
<p>As a rule of thumb, version of operations that operate on public constant are always cheaper than their counterparts that operates on secret.</p>
<p>For example, <em>cmult</em> which multiplies a SecretShare by a public constant requires no communication, while <em>smult</em> which multiplies two SecretShares
requires one round of online communication and one round in preprocessing.</p>
<p>Comparison and inequality operations, as well as division and bit operations, require rounds of communcation proportional to the number of bits
in the prime (i.e. log of the size of the domain), the exact constants and relationship varies by operation. Other relevant parameters include
the number of parties, the precision (in case of fixedpoint numbers), error probability, and the size of inputs, etc..</p>
<p>These differences in MPC operations that are similar cost-wise without MPC leads to interesting tradeoffs and algorithmic choices.</p>

    <script type="text/javascript">
      // prism.js
      /* PrismJS 1.17.1
https://prismjs.com/download.html#themes=prism-tomorrow&languages=markup+css+clike+javascript&plugins=line-numbers+command-line */
var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(u){var c=/\blang(?:uage)?-([\w-]+)\b/i,a=0;var _={manual:u.Prism&&u.Prism.manual,disableWorkerMessageHandler:u.Prism&&u.Prism.disableWorkerMessageHandler,util:{encode:function(e){return e instanceof L?new L(e.type,_.util.encode(e.content),e.alias):Array.isArray(e)?e.map(_.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++a}),e.__id},clone:function n(e,r){var t,a,i=_.util.type(e);switch(r=r||{},i){case"Object":if(a=_.util.objId(e),r[a])return r[a];for(var o in t={},r[a]=t,e)e.hasOwnProperty(o)&&(t[o]=n(e[o],r));return t;case"Array":return a=_.util.objId(e),r[a]?r[a]:(t=[],r[a]=t,e.forEach(function(e,a){t[a]=n(e,r)}),t);default:return e}}},languages:{extend:function(e,a){var n=_.util.clone(_.languages[e]);for(var r in a)n[r]=a[r];return n},insertBefore:function(n,e,a,r){var t=(r=r||_.languages)[n],i={};for(var o in t)if(t.hasOwnProperty(o)){if(o==e)for(var l in a)a.hasOwnProperty(l)&&(i[l]=a[l]);a.hasOwnProperty(o)||(i[o]=t[o])}var s=r[n];return r[n]=i,_.languages.DFS(_.languages,function(e,a){a===s&&e!=n&&(this[e]=i)}),i},DFS:function e(a,n,r,t){t=t||{};var i=_.util.objId;for(var o in a)if(a.hasOwnProperty(o)){n.call(a,o,a[o],r||o);var l=a[o],s=_.util.type(l);"Object"!==s||t[i(l)]?"Array"!==s||t[i(l)]||(t[i(l)]=!0,e(l,n,o,t)):(t[i(l)]=!0,e(l,n,null,t))}}},plugins:{},highlightAll:function(e,a){_.highlightAllUnder(document,e,a)},highlightAllUnder:function(e,a,n){var r={callback:n,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};_.hooks.run("before-highlightall",r);for(var t,i=e.querySelectorAll(r.selector),o=0;t=i[o++];)_.highlightElement(t,!0===a,r.callback)},highlightElement:function(e,a,n){var r=function(e){for(;e&&!c.test(e.className);)e=e.parentNode;return e?(e.className.match(c)||[,"none"])[1].toLowerCase():"none"}(e),t=_.languages[r];e.className=e.className.replace(c,"").replace(/\s+/g," ")+" language-"+r;var i=e.parentNode;i&&"pre"===i.nodeName.toLowerCase()&&(i.className=i.className.replace(c,"").replace(/\s+/g," ")+" language-"+r);var o={element:e,language:r,grammar:t,code:e.textContent};function l(e){o.highlightedCode=e,_.hooks.run("before-insert",o),o.element.innerHTML=o.highlightedCode,_.hooks.run("after-highlight",o),_.hooks.run("complete",o),n&&n.call(o.element)}if(_.hooks.run("before-sanity-check",o),!o.code)return _.hooks.run("complete",o),void(n&&n.call(o.element));if(_.hooks.run("before-highlight",o),o.grammar)if(a&&u.Worker){var s=new Worker(_.filename);s.onmessage=function(e){l(e.data)},s.postMessage(JSON.stringify({language:o.language,code:o.code,immediateClose:!0}))}else l(_.highlight(o.code,o.grammar,o.language));else l(_.util.encode(o.code))},highlight:function(e,a,n){var r={code:e,grammar:a,language:n};return _.hooks.run("before-tokenize",r),r.tokens=_.tokenize(r.code,r.grammar),_.hooks.run("after-tokenize",r),L.stringify(_.util.encode(r.tokens),r.language)},matchGrammar:function(e,a,n,r,t,i,o){for(var l in n)if(n.hasOwnProperty(l)&&n[l]){var s=n[l];s=Array.isArray(s)?s:[s];for(var u=0;u<s.length;++u){if(o&&o==l+","+u)return;var c=s[u],g=c.inside,f=!!c.lookbehind,h=!!c.greedy,d=0,m=c.alias;if(h&&!c.pattern.global){var p=c.pattern.toString().match(/[imsuy]*$/)[0];c.pattern=RegExp(c.pattern.source,p+"g")}c=c.pattern||c;for(var y=r,v=t;y<a.length;v+=a[y].length,++y){var k=a[y];if(a.length>e.length)return;if(!(k instanceof L)){if(h&&y!=a.length-1){if(c.lastIndex=v,!(x=c.exec(e)))break;for(var b=x.index+(f&&x[1]?x[1].length:0),w=x.index+x[0].length,A=y,P=v,O=a.length;A<O&&(P<w||!a[A].type&&!a[A-1].greedy);++A)(P+=a[A].length)<=b&&(++y,v=P);if(a[y]instanceof L)continue;j=A-y,k=e.slice(v,P),x.index-=v}else{c.lastIndex=0;var x=c.exec(k),j=1}if(x){f&&(d=x[1]?x[1].length:0);w=(b=x.index+d)+(x=x[0].slice(d)).length;var N=k.slice(0,b),S=k.slice(w),C=[y,j];N&&(++y,v+=N.length,C.push(N));var E=new L(l,g?_.tokenize(x,g):x,m,x,h);if(C.push(E),S&&C.push(S),Array.prototype.splice.apply(a,C),1!=j&&_.matchGrammar(e,a,n,y,v,!0,l+","+u),i)break}else if(i)break}}}}},tokenize:function(e,a){var n=[e],r=a.rest;if(r){for(var t in r)a[t]=r[t];delete a.rest}return _.matchGrammar(e,n,a,0,0,!1),n},hooks:{all:{},add:function(e,a){var n=_.hooks.all;n[e]=n[e]||[],n[e].push(a)},run:function(e,a){var n=_.hooks.all[e];if(n&&n.length)for(var r,t=0;r=n[t++];)r(a)}},Token:L};function L(e,a,n,r,t){this.type=e,this.content=a,this.alias=n,this.length=0|(r||"").length,this.greedy=!!t}if(u.Prism=_,L.stringify=function(e,a){if("string"==typeof e)return e;if(Array.isArray(e))return e.map(function(e){return L.stringify(e,a)}).join("");var n={type:e.type,content:L.stringify(e.content,a),tag:"span",classes:["token",e.type],attributes:{},language:a};if(e.alias){var r=Array.isArray(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(n.classes,r)}_.hooks.run("wrap",n);var t=Object.keys(n.attributes).map(function(e){return e+'="'+(n.attributes[e]||"").replace(/"/g,"&quot;")+'"'}).join(" ");return"<"+n.tag+' class="'+n.classes.join(" ")+'"'+(t?" "+t:"")+">"+n.content+"</"+n.tag+">"},!u.document)return u.addEventListener&&(_.disableWorkerMessageHandler||u.addEventListener("message",function(e){var a=JSON.parse(e.data),n=a.language,r=a.code,t=a.immediateClose;u.postMessage(_.highlight(r,_.languages[n],n)),t&&u.close()},!1)),_;var e=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();if(e&&(_.filename=e.src,e.hasAttribute("data-manual")&&(_.manual=!0)),!_.manual){function n(){_.manual||_.highlightAll()}"loading"!==document.readyState?window.requestAnimationFrame?window.requestAnimationFrame(n):window.setTimeout(n,16):document.addEventListener("DOMContentLoaded",n)}return _}(_self);"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
Prism.languages.markup={comment:/<!--[\s\S]*?-->/,prolog:/<\?[\s\S]+?\?>/,doctype:/<!DOCTYPE[\s\S]+?>/i,cdata:/<!\[CDATA\[[\s\S]*?]]>/i,tag:{pattern:/<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/i,greedy:!0,inside:{tag:{pattern:/^<\/?[^\s>\/]+/i,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"attr-value":{pattern:/=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/i,inside:{punctuation:[/^=/,{pattern:/^(\s*)["']|["']$/,lookbehind:!0}]}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:/&#?[\da-z]{1,8};/i},Prism.languages.markup.tag.inside["attr-value"].inside.entity=Prism.languages.markup.entity,Prism.hooks.add("wrap",function(a){"entity"===a.type&&(a.attributes.title=a.content.replace(/&amp;/,"&"))}),Object.defineProperty(Prism.languages.markup.tag,"addInlined",{value:function(a,e){var s={};s["language-"+e]={pattern:/(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,lookbehind:!0,inside:Prism.languages[e]},s.cdata=/^<!\[CDATA\[|\]\]>$/i;var n={"included-cdata":{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,inside:s}};n["language-"+e]={pattern:/[\s\S]+/,inside:Prism.languages[e]};var i={};i[a]={pattern:RegExp("(<__[\\s\\S]*?>)(?:<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\s*|[\\s\\S])*?(?=<\\/__>)".replace(/__/g,a),"i"),lookbehind:!0,greedy:!0,inside:n},Prism.languages.insertBefore("markup","cdata",i)}}),Prism.languages.xml=Prism.languages.extend("markup",{}),Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup;
!function(s){var t=/("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;s.languages.css={comment:/\/\*[\s\S]*?\*\//,atrule:{pattern:/@[\w-]+[\s\S]*?(?:;|(?=\s*\{))/,inside:{rule:/@[\w-]+/}},url:{pattern:RegExp("url\\((?:"+t.source+"|[^\n\r()]*)\\)","i"),inside:{function:/^url/i,punctuation:/^\(|\)$/}},selector:RegExp("[^{}\\s](?:[^{};\"']|"+t.source+")*?(?=\\s*\\{)"),string:{pattern:t,greedy:!0},property:/[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,important:/!important\b/i,function:/[-a-z0-9]+(?=\()/i,punctuation:/[(){};:,]/},s.languages.css.atrule.inside.rest=s.languages.css;var e=s.languages.markup;e&&(e.tag.addInlined("style","css"),s.languages.insertBefore("inside","attr-value",{"style-attr":{pattern:/\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,inside:{"attr-name":{pattern:/^\s*style/i,inside:e.tag.inside},punctuation:/^\s*=\s*['"]|['"]\s*$/,"attr-value":{pattern:/.+/i,inside:s.languages.css}},alias:"language-css"}},e.tag))}(Prism);
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,boolean:/\b(?:true|false)\b/,function:/\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};
Prism.languages.javascript=Prism.languages.extend("clike",{"class-name":[Prism.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,lookbehind:!0}],keyword:[{pattern:/((?:^|})\s*)(?:catch|finally)\b/,lookbehind:!0},{pattern:/(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],number:/\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,function:/#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,operator:/-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/}),Prism.languages.javascript["class-name"][0].pattern=/(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/,Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:/((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,lookbehind:!0,greedy:!0},"function-variable":{pattern:/#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,alias:"function"},parameter:[{pattern:/(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,inside:Prism.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,lookbehind:!0,inside:Prism.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/}),Prism.languages.insertBefore("javascript","string",{"template-string":{pattern:/`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\${)[^\\`])*`/,greedy:!0,inside:{"template-punctuation":{pattern:/^`|`$/,alias:"string"},interpolation:{pattern:/((?:^|[^\\])(?:\\{2})*)\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,lookbehind:!0,inside:{"interpolation-punctuation":{pattern:/^\${|}$/,alias:"punctuation"},rest:Prism.languages.javascript}},string:/[\s\S]+/}}}),Prism.languages.markup&&Prism.languages.markup.tag.addInlined("script","javascript"),Prism.languages.js=Prism.languages.javascript;
!function(){if("undefined"!=typeof self&&self.Prism&&self.document){var l="line-numbers",c=/\n(?!$)/g,m=function(e){var t=a(e)["white-space"];if("pre-wrap"===t||"pre-line"===t){var n=e.querySelector("code"),r=e.querySelector(".line-numbers-rows"),s=e.querySelector(".line-numbers-sizer"),i=n.textContent.split(c);s||((s=document.createElement("span")).className="line-numbers-sizer",n.appendChild(s)),s.style.display="block",i.forEach(function(e,t){s.textContent=e||"\n";var n=s.getBoundingClientRect().height;r.children[t].style.height=n+"px"}),s.textContent="",s.style.display="none"}},a=function(e){return e?window.getComputedStyle?getComputedStyle(e):e.currentStyle||null:null};window.addEventListener("resize",function(){Array.prototype.forEach.call(document.querySelectorAll("pre."+l),m)}),Prism.hooks.add("complete",function(e){if(e.code){var t=e.element,n=t.parentNode;if(n&&/pre/i.test(n.nodeName)&&!t.querySelector(".line-numbers-rows")){for(var r=!1,s=/(?:^|\s)line-numbers(?:\s|$)/,i=t;i;i=i.parentNode)if(s.test(i.className)){r=!0;break}if(r){t.className=t.className.replace(s," "),s.test(n.className)||(n.className+=" line-numbers");var l,a=e.code.match(c),o=a?a.length+1:1,u=new Array(o+1).join("<span></span>");(l=document.createElement("span")).setAttribute("aria-hidden","true"),l.className="line-numbers-rows",l.innerHTML=u,n.hasAttribute("data-start")&&(n.style.counterReset="linenumber "+(parseInt(n.getAttribute("data-start"),10)-1)),e.element.appendChild(l),m(n),Prism.hooks.run("line-numbers",e)}}}}),Prism.hooks.add("line-numbers",function(e){e.plugins=e.plugins||{},e.plugins.lineNumbers=!0}),Prism.plugins.lineNumbers={getLine:function(e,t){if("PRE"===e.tagName&&e.classList.contains(l)){var n=e.querySelector(".line-numbers-rows"),r=parseInt(e.getAttribute("data-start"),10)||1,s=r+(n.children.length-1);t<r&&(t=r),s<t&&(t=s);var i=t-r;return n.children[i]}}}}}();
!function(){if("undefined"!=typeof self&&self.Prism&&self.document){var u=/(?:^|\s)command-line(?:\s|$)/;Prism.hooks.add("before-highlight",function(e){var t=e.vars=e.vars||{},a=t["command-line"]=t["command-line"]||{};if(!a.complete&&e.code){var n=e.element.parentNode;if(n&&/pre/i.test(n.nodeName)&&(u.test(n.className)||u.test(e.element.className)))if(e.element.querySelector(".command-line-prompt"))a.complete=!0;else{var r=e.code.split("\n");a.numberOfLines=r.length;var s=a.outputLines=[],o=n.getAttribute("data-output"),i=n.getAttribute("data-filter-output");if(o||""===o){o=o.split(",");for(var l=0;l<o.length;l++){var m=o[l].split("-"),p=parseInt(m[0],10),d=2===m.length?parseInt(m[1],10):p;if(!isNaN(p)&&!isNaN(d)){p<1&&(p=1),d>r.length&&(d=r.length),d--;for(var c=--p;c<=d;c++)s[c]=r[c],r[c]=""}}}else if(i)for(l=0;l<r.length;l++)0===r[l].indexOf(i)&&(s[l]=r[l].slice(i.length),r[l]="");e.code=r.join("\n")}else a.complete=!0}else a.complete=!0}),Prism.hooks.add("before-insert",function(e){var t=e.vars=e.vars||{},a=t["command-line"]=t["command-line"]||{};if(!a.complete){for(var n=e.highlightedCode.split("\n"),r=0,s=(a.outputLines||[]).length;r<s;r++)a.outputLines.hasOwnProperty(r)&&(n[r]=a.outputLines[r]);e.highlightedCode=n.join("\n")}}),Prism.hooks.add("complete",function(e){var t=e.vars=e.vars||{},a=t["command-line"]=t["command-line"]||{};if(!a.complete){var n=e.element.parentNode;u.test(e.element.className)&&(e.element.className=e.element.className.replace(u," ")),u.test(n.className)||(n.className+=" command-line");var r=function(e,t){return(n.getAttribute(e)||t).replace(/"/g,"&quot")},s=new Array((a.numberOfLines||0)+1),o=r("data-prompt","");if(""!==o)s=s.join('<span data-prompt="'+o+'"></span>');else{var i=r("data-user","user"),l=r("data-host","localhost");s=s.join('<span data-user="'+i+'" data-host="'+l+'"></span>')}var m=document.createElement("span");m.className="command-line-prompt",m.innerHTML=s;for(var p=0,d=(a.outputLines||[]).length;p<d;p++)if(a.outputLines.hasOwnProperty(p)){var c=m.children[p];c.removeAttribute("data-user"),c.removeAttribute("data-host"),c.removeAttribute("data-prompt")}e.element.insertBefore(m,e.element.firstChild),a.complete=!0}})}}();

    </script>
    <script type="text/javascript">
      
      window.$__offline__$ = true;
      
      // neptune.js
      (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/* global Prism */

// bind input to the textarea to the code tag
const codeInputHandler = function (codeTag, textAreaTag) {
  textAreaTag.scrollTop = 0;
  let code = textAreaTag.value;

  codeTag.innerHTML = code + ' ';
  Prism.highlightElement(codeTag);
};

// creates a transparent textarea that serves as an 'editor' for the code in
// the associated <code> tag
module.exports = function (codeTag) {
  codeTag.innerHTML += ' ';

  const element = document.createElement('textarea');
  element.classList.add('code-editor');
  element.setAttribute('spellcheck', 'false');

  // expose handler for input binding
  element.handler = codeInputHandler.bind(null, codeTag, element);

  // listen to any input changes
  if (element.addEventListener) {
    element.addEventListener('input', element.handler);
  } else if (element.attachEvent) { // for IE11
    element.attachEvent('onpropertychange', element.handler);
  }

  // put code in textarea
  element.value = codeTag.textContent;

  return element;
};

},{}],2:[function(require,module,exports){
(function (global){
/*
 * Handles scoped evaluation of user code.
 * Uses eval within function closures to isolate the different scope and persist eval variables
 * and scope after execution in case the scope must be re-used!
 *
 * Code running inside eval has access to the following global variables:
 *   Constants: $__scopes__$, $__logMiddlewareBrowser__$, $__logMiddlewareServer__$
 *   Variables: $__eval__$, $__code__$, Console
 *   Browser-only: require, module, exports from browserify.
 * It is unsafe to modify any of these variables inside user code. Console should be used to log outputs to the UI.
 *
 * User code that uses 'let' or 'const' causes eval to use strict mode, and scope the executed code further using code blocks
 * in a way that our function-closures scoping mechanism cannot handle properly. Such user code will run properly if it is in
 * a stand-alone code block, but variables defined in it will not be visible to other code blocks (or re-runs of the same code
 * block), even if they are configured to have the same scope!
 */

// Store all scopes
const $__scopes__$ = {};

// creates the function without a closure (in global scope)
// protects the scope of this file and other neptune files from interferance from inside eval
const $__eval__$ = function $__eval__$(Console, $__code__$) {
  // Quine for scoping evals: relies on function closures to return a handler to the scope after an eval is executed!
  // Simplified fiddle to help understand why this quine is useful: https://jsfiddle.net/kjvo6h2x/
  try {
    eval($__code__$);
    eval($__eval__$.toString());
    return $__eval__$;
  } catch (exception) {
    Console.log(exception);
    return $__eval__$;
  }
};

const $__logMiddlewareBrowser__$ = function (tabID) {
  return document.getElementById(tabID+'-output').Console;
}

const $__logMiddlewareServer__$ = function () {
  const Console = {};
  Console.log = function () {
    global.$__logs__$.push(arguments);
  };
  return Console;
}

// determine scope and eval within it!
module.exports = function (code, scopeName, tabID) {
  const Console = tabID ? $__logMiddlewareBrowser__$(tabID) : $__logMiddlewareServer__$();

  if (scopeName == null) {
    scopeName = '$__DEFAULT__$';
  }

  // create empty scope if it does not exist
  if ($__scopes__$[scopeName] == null) {
    $__scopes__$[scopeName] = $__eval__$;
  }

  // eval within scope
  $__scopes__$[scopeName] = $__scopes__$[scopeName](Console, code);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){
// format arguments as if console.log
module.exports = function () {
  var msg = '';

  // loop over arguments and format each
  for (var i = 0; i < arguments.length; i++) {
    // argument is an error: display error name and stack information if available
    if (arguments[i] instanceof Error) {
      msg += arguments[i].toString();

      // vendo-specific error API
      if (arguments[i].lineNumber) {
        msg += '\t' + arguments[i].lineNumber;
        if (arguments[i].columnNumber) {
          msg += ':' + arguments[i].columnNumber;
        }
      }
      if (arguments[i].stack) {
        var stackStr = arguments[i].stack.toString().split('\n').join('\n\t\t');
        msg += '\nStack:\t' + stackStr;
      }

      msg += '\n';
    } else if (typeof(arguments[i]) === 'object') {
      // Object, use JSON
      msg += JSON.stringify(arguments[i]) + ' ';
    } else {
      // Primitive type, use toString
      msg += arguments[i].toString() + ' ';
    }
  }

  return msg;
};

},{}],4:[function(require,module,exports){
module.exports = function (preTag, codeTag) {
  // Parse options from markdown
  const options = JSON.parse(codeTag.dataset.options);

  // create placeholder span element and put code inside it!
  let element;
  if (options['language'] === 'javascript') {
    element = document.createElement('script');
    element.type = 'text/javascript';
    element.innerHTML = codeTag.textContent;
  } else if (options['language'] === 'css') {
    element = document.createElement('style');
    element.innerHTML = codeTag.textContent;
  } else {
    element = document.createElement('span');
    element.innerHTML = codeTag.textContent;
  }

  // replace <pre> with this
  preTag.parentNode.replaceChild(element, preTag);
};

},{}],5:[function(require,module,exports){
(function () {
  const Tabs = require('./tabs.js');
  const Inject = require('./inject.js');

  const outputIDs = []; // stores all reserved output <div> IDs

  /*
   * Detect <pre> and <code> tags of interest
   */
  const preTags = Array.from(document.getElementsByTagName('pre'));
  const codeTags = preTags.map(function (preTag) {
    return Array.from(preTag.getElementsByTagName('code'));
  }).reduce(function (codeTags1, codeTags2) {
    return codeTags1.concat(codeTags2);
  }, []).filter(function (codeTag) {
    return codeTag.className.indexOf('language-neptune') > -1;
  });

  /*
   * Helper functions
   */
  const getOptions = function (codeTag) {
    const defaultOptions = {
      title: 'Javascript',
      env: 'browser',
      language: 'javascript',
      inject: false
    };

    // result
    const options = Object.assign({}, defaultOptions);
    const addOption = function (key, val) {
      options[key] = val;

      if (key === 'env' && options['title'] === defaultOptions['title']) {
        options['title'] = val;
      } else if (key === 'language') {
        options['language'] = options['language'].toLowerCase();
      } else if (key === 'outputID') {
        const id = options['outputID'];
        if (outputIDs.indexOf(id) > -1) {
          throw new Error('Duplicated outputID ' + id);
        }
        outputIDs.push(id);
      }
    };

    // parse options
    for (let className of codeTag.classList) {
      className = className.trim();
      if (!className.startsWith('neptune') || className.indexOf('[') === -1) {
        continue;
      }

      className = className.substring(('neptune[').length, className.length-1);
      className.split(',').map(function (option) {
        const index = option.indexOf('=');
        const key = option.substring(0, index);
        const val = option.substring(index + 1);
        addOption(key, val);
      });
    }

    return options;
  };

  const styleCodeBlock = function (codeTag) {
    const preTag = codeTag.parentNode;

    // get neptune code options from markdown
    const options = getOptions(codeTag);
    codeTag.dataset.options = JSON.stringify(options);

    // Make sure PRISM understands that this is JS
    codeTag.className = 'language-' + options['language'];
    preTag.className = 'language-' + options['language'];
    preTag.classList.add('line-numbers'); // add line numbering

    // If inject property is true, then inject code into page at this point without displaying it
    if (options['inject']) {
      Inject(preTag, codeTag);
    } else {
      // Style code as a tabbed frame with a toolbar and editor!
      Tabs(preTag, codeTag);
    }
  };

  /*
   * Apply styling and functionality
   */
  codeTags.map(function (codeTag) {
    styleCodeBlock(codeTag);
  });
})();

},{"./inject.js":4,"./tabs.js":8}],6:[function(require,module,exports){
/* global Prism */

const formatter = require('./formatter.js');

function reset(hideOutput) {
  this.dataset.shown = true;
  if (this.dataset.hideOutput !== 'true') {
    this.style.display = 'block';
  }
  if (this.dataset.language === 'javascript') {
    this.children[0].innerHTML = 'Running...';
  }
}

function display(output) {
  if (this.children[0].textContent === 'Running...') {
    this.children[0].innerHTML = '';
  } else {
    this.children[0].innerHTML += '\n';
  }

  this.children[0].innerHTML += output;
  Prism.highlightElement(this.children[0]);
}

function hide() {
  this.style.display = 'none';
  this.dataset.hideOutput = 'true';
}

function unhide() {
  this.dataset.hideOutput = 'false';
  if (this.dataset.shown) {
    this.style.display = 'block';
  }
}

// mimic console.log / console.time / etc
const Console = {
  // this here is bound to the output panel HTML element
  log: function () {
    console.log.apply(console, arguments);
    this.display(formatter.apply(null, arguments));
  }
};

// Creates a terminal-like area for javascript or an empty div for HTML/CSS
module.exports = function (tabID, options) {
  let outputElement;
  if (options['language'] === 'javascript') {
    outputElement = document.createElement('pre');

    outputElement.classList.add('command-line');
    outputElement.dataset.user = options['title'].toLowerCase();
    outputElement.dataset.host = options['env'].toLowerCase();

    // create code tag
    const codeElement = document.createElement('code');
    codeElement.className = 'language-bash';
    outputElement.appendChild(codeElement);

    // bind util functions to HTML element
    outputElement.display = display.bind(outputElement);
    outputElement.Console = {};
    for (const attr in Console) {
      outputElement.Console[attr] = Console[attr].bind(outputElement);
    }
  } else {
    outputElement = document.createElement('div');
  }

  // style output area
  outputElement.id = tabID + '-output';
  outputElement.classList.add('output-panel');
  outputElement.dataset.language = options['language'];

  // bind logging functions to output panel HTML element
  outputElement.reset = reset.bind(outputElement);
  outputElement.hide = hide.bind(outputElement);
  outputElement.unhide = unhide.bind(outputElement);

  return outputElement;
};

},{"./formatter.js":3}],7:[function(require,module,exports){
// Execute this code using in the given scope name in the server via node, and get back results!
module.exports = function (code, scopeName, tabID) {
  if (window.$__offline__$) {
    alert('Cannot execute server-side code while offline!');
    return;
  }

  const xhr = new XMLHttpRequest();
  xhr.open('POST', window.location.href + '/__exec');
  xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
  xhr.onreadystatechange = function (e) {
    if (xhr.readyState === 4 && xhr.status === 200) {
      const outputPanel = document.getElementById(tabID + '-output');
      for (const record of JSON.parse(xhr.responseText)) {
        outputPanel.Console.log(record);
      }
    }
  };
  xhr.send(JSON.stringify({scopeName: scopeName, code: code}));
};

},{}],8:[function(require,module,exports){
/*
 * dependencies
 */
const Toolbar = require('./toolbar.js');
const Editor = require('./editor.js');
const OutputPanel = require('./outputPanel.js');

let autoCounter = 0;

const createTab = function (title, tabsContainer, preTag, options) {
  const tabRadio = document.createElement('input');
  const tabLabel = document.createElement('label');
  const codeTab = document.createElement('div');

  // create ID for radio
  const count = tabsContainer.getElementsByTagName('input').length;
  const tabID = tabsContainer.id + '-tab-' + (count + 1);

  // style lable and radio
  tabRadio.className = 'tab-input';
  tabRadio.id = tabID;
  tabRadio.name = tabsContainer.id;
  tabRadio.type = 'radio';

  tabLabel.className = 'tab-label';
  tabLabel.id = tabID + '-label';
  tabLabel.setAttribute('for', tabID);
  tabLabel.innerHTML = title;
  if (count === 0) {
    tabRadio.setAttribute('checked', 'checked');
    tabLabel.classList.add('tab-label-selected');
    tabsContainer.dataset.selected = tabID;
  }

  tabRadio.onclick = function (e) {
    // remove selection from previous label
    const lastVal = tabsContainer.dataset.selected;
    const prevLabel = document.getElementById(lastVal + '-label');
    prevLabel.classList.remove('tab-label-selected');
    // select this label
    tabsContainer.dataset.selected = tabID;
    tabLabel.classList.add('tab-label-selected');
    // unminize icon if needed
    const topToolbar = tabsContainer.getElementsByClassName('code-top-toolbar')[0];
    const minimizeIcon = topToolbar.children[topToolbar.children.length - 1].children[0];
    minimizeIcon.classList.remove('fa-arrow-down');
    minimizeIcon.classList.add('fa-arrow-up');
  };

  // style container
  codeTab.id = tabID + '-tab';
  codeTab.classList.add('code-tab');

  codeTab.appendChild(preTag);

  // built-in default ouput panel
  codeTab.appendChild(OutputPanel(tabID, options));

  // create output div if requested
  if (options['outputID']) {
    const outputDiv = document.createElement('div');
    outputDiv.id = options['outputID'];
    outputDiv.classList.add('custom-output-div');
    codeTab.appendChild(outputDiv);
  }

  // add the code container to the tabs
  tabsContainer.insertBefore(tabLabel, tabsContainer.children[count]);
  tabsContainer.appendChild(tabRadio);
  tabsContainer.appendChild(codeTab);
};

const createTabsContainer = function (frameID) {
  const container = document.createElement('div');
  container.id = frameID;
  container.classList.add('code-tabs');
  return container;
};

const getOrCreateTabsContainer = function (frameID, preTag) {
  frameID = frameID || 'neptune-frame-' + (autoCounter++);
  let container = document.getElementById(frameID);

  if (container == null) {
    container = createTabsContainer(frameID);
    preTag.parentNode.replaceChild(container, preTag);
    container.appendChild(Toolbar());
  } else {
    preTag.parentNode.removeChild(preTag);
  }

  return container;
};

module.exports = function (preTag, codeTag) {
  // Parse options from markdown
  const options = JSON.parse(codeTag.dataset.options);
  const frameID = options['frame'];
  const title = options['title'];

  // Create (or get if exists) the tabs frame container
  const tabsContainer = getOrCreateTabsContainer(frameID, preTag);

  // Add this <pre><code> tags as a tab to the container
  createTab(title, tabsContainer, preTag, options);

  // add transparent text area that mimics the code tag
  preTag.appendChild(Editor(codeTag));
};

},{"./editor.js":1,"./outputPanel.js":6,"./toolbar.js":9}],9:[function(require,module,exports){
const scopedEval = require('./eval.js');
const serverExec = require('./serverExec.js');

// handles clicking on a run icon for non-javascript code!
const executeNonJavascript = function (code, language, tabID) {
  if (language === 'css') {
    code = '<style>'+code+'</style>';
  }

  document.getElementById(tabID + '-output').innerHTML = code;
}

// handles clicking on an icon in the code toolbar
const toolbarClick = function () {
  const type = this.children[0].classList[1].split('-').slice(1).join('-');

  const tabID = this.parentNode.parentNode.dataset.selected;
  const tabRadio = document.getElementById(tabID);
  const tabLabel = document.getElementById(tabID + '-label');
  const codeTab = document.getElementById(tabID + '-tab');
  const codeTag = codeTab.getElementsByTagName('code')[0];
  const textAreaTag = codeTab.getElementsByTagName('textarea')[0];
  const outputPanel = document.getElementById(tabID + '-output');

  const options = JSON.parse(codeTag.dataset.options);

  let range;
  switch (type) {
    case 'copy':
      window.getSelection().removeAllRanges();
      range = document.createRange();
      range.selectNode(codeTag);
      window.getSelection().addRange(range);
      document.execCommand('copy');
      window.getSelection().removeAllRanges();
      break;

    case 'trash':
      textAreaTag.value = '';
      textAreaTag.handler();
      break;

    case 'play':
      outputPanel.reset();
      if (options['language'] === 'javascript') {
        if (options['env'] === 'server') {
          serverExec(codeTag.textContent, options['scope'], tabID);
        } else {
          scopedEval(codeTag.textContent, options['scope'], tabID);
        }
      } else {
        executeNonJavascript(codeTag.textContent, options['language'], tabID);
      }
      break;

    case 'arrow-up':
      tabRadio.checked = false;
      tabLabel.classList.remove('tab-label-selected');
      this.children[0].classList.remove('fa-arrow-up');
      this.children[0].classList.add('fa-arrow-down');
      break;

    case 'arrow-down':
      tabRadio.checked = true;
      tabLabel.classList.add('tab-label-selected');
      this.children[0].classList.remove('fa-arrow-down');
      this.children[0].classList.add('fa-arrow-up');
      break;

    case 'eye-slash':
      this.children[0].classList.remove('fa-eye-slash');
      this.children[0].classList.add('fa-eye');
      Array.from(this.parentNode.parentNode.getElementsByClassName('output-panel')).map(function (panel) {
        panel.hide();
      });
      break;

    case 'eye':
      this.children[0].classList.remove('fa-eye');
      this.children[0].classList.add('fa-eye-slash');
      Array.from(this.parentNode.parentNode.getElementsByClassName('output-panel')).map(function (panel) {
        panel.unhide();
      });
      break;
  }
};

// creates HTML elements for the toolbar on top of <code> tags
module.exports = function () {
  const element = document.createElement('span');
  element.classList.add('code-top-toolbar');
  element.innerHTML = '<a href="javascript:void(0)"><i class="fa fa-play"></i></a>' +
    '<a href="javascript:void(0)"><i class="fa fa-copy"></i></a>' +
    '<a href="javascript:void(0)"><i class="fa fa-trash"></i></a>' +
    '<a href="javascript:void(0)"><i class="fa fa-eye-slash"></i></a>' +
    '<a href="javascript:void(0)"><i class="fa fa-arrow-up"></i></a>';

  Array.from(element.children).map(function (aTag) {
    aTag.onclick = toolbarClick;
  });

  return element;
};

},{"./eval.js":2,"./serverExec.js":7}]},{},[5]);

    </script>
    <script type="text/javascript">
      // injected JS
      /* bignumber.js v5.0.0 https://github.com/MikeMcl/bignumber.js/LICENCE */
!function(e){"use strict";function n(e){function a(e,n){var t,r,i,o,u,s,l=this;if(!(l instanceof a))return new a(e,n);if(null!=n&&V(n,2,64,C,"base")){if(n=0|n,s=e+"",10==n)return l=new a(e instanceof a?e:s),I(l,B+l.e+1,P);if((o="number"==typeof e)&&0*e!=0||!new RegExp("^-?"+(t="["+v.slice(0,n)+"]+")+"(?:\\."+t+")?$",37>n?"i":"").test(s))return U(l,s,o,n);o?(l.s=0>1/e?(s=s.slice(1),-1):1,z&&s.replace(/^0\.0*|\./,"").length>15&&x(C,w,e),o=!1):l.s=45===s.charCodeAt(0)?(s=s.slice(1),-1):1,s=A(s,10,n,l.s)}else{if(e instanceof a)return l.s=e.s,l.e=e.e,l.c=(e=e.c)?e.slice():e,void(C=0);if((o="number"==typeof e)&&0*e==0){if(l.s=0>1/e?(e=-e,-1):1,e===~~e){for(r=0,i=e;i>=10;i/=10,r++);return l.e=r,l.c=[e],void(C=0)}s=e+""}else{if(!h.test(s=e+""))return U(l,s,o);l.s=45===s.charCodeAt(0)?(s=s.slice(1),-1):1}}for((r=s.indexOf("."))>-1&&(s=s.replace(".","")),(i=s.search(/e/i))>0?(0>r&&(r=i),r+=+s.slice(i+1),s=s.substring(0,i)):0>r&&(r=s.length),i=0;48===s.charCodeAt(i);i++);for(u=s.length;48===s.charCodeAt(--u););if(s=s.slice(i,u+1))if(u=s.length,o&&z&&u>15&&(e>y||e!==p(e))&&x(C,w,l.s*e),r=r-i-1,r>G)l.c=l.e=null;else if($>r)l.c=[l.e=0];else{if(l.e=r,l.c=[],i=(r+1)%b,0>r&&(i+=b),u>i){for(i&&l.c.push(+s.slice(0,i)),u-=b;u>i;)l.c.push(+s.slice(i,i+=b));s=s.slice(i),i=b-s.length}else i-=u;for(;i--;s+="0");l.c.push(+s)}else l.c=[l.e=0];C=0}function A(e,n,t,i){var o,u,l,f,h,g,p,d=e.indexOf("."),m=B,w=P;for(37>t&&(e=e.toLowerCase()),d>=0&&(l=W,W=0,e=e.replace(".",""),p=new a(t),h=p.pow(e.length-d),W=l,p.c=s(c(r(h.c),h.e),10,n),p.e=p.c.length),g=s(e,t,n),u=l=g.length;0==g[--l];g.pop());if(!g[0])return"0";if(0>d?--u:(h.c=g,h.e=u,h.s=i,h=L(h,p,m,w,n),g=h.c,f=h.r,u=h.e),o=u+m+1,d=g[o],l=n/2,f=f||0>o||null!=g[o+1],f=4>w?(null!=d||f)&&(0==w||w==(h.s<0?3:2)):d>l||d==l&&(4==w||f||6==w&&1&g[o-1]||w==(h.s<0?8:7)),1>o||!g[0])e=f?c("1",-m):"0";else{if(g.length=o,f)for(--n;++g[--o]>n;)g[o]=0,o||(++u,g=[1].concat(g));for(l=g.length;!g[--l];);for(d=0,e="";l>=d;e+=v.charAt(g[d++]));e=c(e,u)}return e}function E(e,n,t,i){var o,u,s,f,h;if(t=null!=t&&V(t,0,8,i,m)?0|t:P,!e.c)return e.toString();if(o=e.c[0],s=e.e,null==n)h=r(e.c),h=19==i||24==i&&q>=s?l(h,s):c(h,s);else if(e=I(new a(e),n,t),u=e.e,h=r(e.c),f=h.length,19==i||24==i&&(u>=n||q>=u)){for(;n>f;h+="0",f++);h=l(h,u)}else if(n-=s,h=c(h,u),u+1>f){if(--n>0)for(h+=".";n--;h+="0");}else if(n+=u-f,n>0)for(u+1==f&&(h+=".");n--;h+="0");return e.s<0&&o?"-"+h:h}function D(e,n){var t,r,i=0;for(u(e[0])&&(e=e[0]),t=new a(e[0]);++i<e.length;){if(r=new a(e[i]),!r.s){t=r;break}n.call(t,r)&&(t=r)}return t}function F(e,n,t,r,i){return(n>e||e>t||e!=f(e))&&x(r,(i||"decimal places")+(n>e||e>t?" out of range":" not an integer"),e),!0}function _(e,n,t){for(var r=1,i=n.length;!n[--i];n.pop());for(i=n[0];i>=10;i/=10,r++);return(t=r+t*b-1)>G?e.c=e.e=null:$>t?e.c=[e.e=0]:(e.e=t,e.c=n),e}function x(e,n,t){var r=new Error(["new BigNumber","cmp","config","div","divToInt","eq","gt","gte","lt","lte","minus","mod","plus","precision","random","round","shift","times","toDigits","toExponential","toFixed","toFormat","toFraction","pow","toPrecision","toString","BigNumber"][e]+"() "+n+": "+t);throw r.name="BigNumber Error",C=0,r}function I(e,n,t,r){var i,o,u,s,l,c,f,a=e.c,h=O;if(a){e:{for(i=1,s=a[0];s>=10;s/=10,i++);if(o=n-i,0>o)o+=b,u=n,l=a[c=0],f=l/h[i-u-1]%10|0;else if(c=g((o+1)/b),c>=a.length){if(!r)break e;for(;a.length<=c;a.push(0));l=f=0,i=1,o%=b,u=o-b+1}else{for(l=s=a[c],i=1;s>=10;s/=10,i++);o%=b,u=o-b+i,f=0>u?0:l/h[i-u-1]%10|0}if(r=r||0>n||null!=a[c+1]||(0>u?l:l%h[i-u-1]),r=4>t?(f||r)&&(0==t||t==(e.s<0?3:2)):f>5||5==f&&(4==t||r||6==t&&(o>0?u>0?l/h[i-u]:0:a[c-1])%10&1||t==(e.s<0?8:7)),1>n||!a[0])return a.length=0,r?(n-=e.e+1,a[0]=h[(b-n%b)%b],e.e=-n||0):a[0]=e.e=0,e;if(0==o?(a.length=c,s=1,c--):(a.length=c+1,s=h[b-o],a[c]=u>0?p(l/h[i-u]%h[u])*s:0),r)for(;;){if(0==c){for(o=1,u=a[0];u>=10;u/=10,o++);for(u=a[0]+=s,s=1;u>=10;u/=10,s++);o!=s&&(e.e++,a[0]==N&&(a[0]=1));break}if(a[c]+=s,a[c]!=N)break;a[c--]=0,s=1}for(o=a.length;0===a[--o];a.pop());}e.e>G?e.c=e.e=null:e.e<$&&(e.c=[e.e=0])}return e}var L,U,C=0,M=a.prototype,T=new a(1),B=20,P=4,q=-7,k=21,$=-1e7,G=1e7,z=!0,V=F,j=!1,H=1,W=0,J={decimalSeparator:".",groupSeparator:",",groupSize:3,secondaryGroupSize:0,fractionGroupSeparator:" ",fractionGroupSize:0};return a.another=n,a.ROUND_UP=0,a.ROUND_DOWN=1,a.ROUND_CEIL=2,a.ROUND_FLOOR=3,a.ROUND_HALF_UP=4,a.ROUND_HALF_DOWN=5,a.ROUND_HALF_EVEN=6,a.ROUND_HALF_CEIL=7,a.ROUND_HALF_FLOOR=8,a.EUCLID=9,a.config=a.set=function(){var e,n,t=0,r={},i=arguments,s=i[0],l=s&&"object"==typeof s?function(){return s.hasOwnProperty(n)?null!=(e=s[n]):void 0}:function(){return i.length>t?null!=(e=i[t++]):void 0};return l(n="DECIMAL_PLACES")&&V(e,0,S,2,n)&&(B=0|e),r[n]=B,l(n="ROUNDING_MODE")&&V(e,0,8,2,n)&&(P=0|e),r[n]=P,l(n="EXPONENTIAL_AT")&&(u(e)?V(e[0],-S,0,2,n)&&V(e[1],0,S,2,n)&&(q=0|e[0],k=0|e[1]):V(e,-S,S,2,n)&&(q=-(k=0|(0>e?-e:e)))),r[n]=[q,k],l(n="RANGE")&&(u(e)?V(e[0],-S,-1,2,n)&&V(e[1],1,S,2,n)&&($=0|e[0],G=0|e[1]):V(e,-S,S,2,n)&&(0|e?$=-(G=0|(0>e?-e:e)):z&&x(2,n+" cannot be zero",e))),r[n]=[$,G],l(n="ERRORS")&&(e===!!e||1===e||0===e?(C=0,V=(z=!!e)?F:o):z&&x(2,n+d,e)),r[n]=z,l(n="CRYPTO")&&(e===!0||e===!1||1===e||0===e?e?(e="undefined"==typeof crypto,!e&&crypto&&(crypto.getRandomValues||crypto.randomBytes)?j=!0:z?x(2,"crypto unavailable",e?void 0:crypto):j=!1):j=!1:z&&x(2,n+d,e)),r[n]=j,l(n="MODULO_MODE")&&V(e,0,9,2,n)&&(H=0|e),r[n]=H,l(n="POW_PRECISION")&&V(e,0,S,2,n)&&(W=0|e),r[n]=W,l(n="FORMAT")&&("object"==typeof e?J=e:z&&x(2,n+" not an object",e)),r[n]=J,r},a.max=function(){return D(arguments,M.lt)},a.min=function(){return D(arguments,M.gt)},a.random=function(){var e=9007199254740992,n=Math.random()*e&2097151?function(){return p(Math.random()*e)}:function(){return 8388608*(1073741824*Math.random()|0)+(8388608*Math.random()|0)};return function(e){var t,r,i,o,u,s=0,l=[],c=new a(T);if(e=null!=e&&V(e,0,S,14)?0|e:B,o=g(e/b),j)if(crypto.getRandomValues){for(t=crypto.getRandomValues(new Uint32Array(o*=2));o>s;)u=131072*t[s]+(t[s+1]>>>11),u>=9e15?(r=crypto.getRandomValues(new Uint32Array(2)),t[s]=r[0],t[s+1]=r[1]):(l.push(u%1e14),s+=2);s=o/2}else if(crypto.randomBytes){for(t=crypto.randomBytes(o*=7);o>s;)u=281474976710656*(31&t[s])+1099511627776*t[s+1]+4294967296*t[s+2]+16777216*t[s+3]+(t[s+4]<<16)+(t[s+5]<<8)+t[s+6],u>=9e15?crypto.randomBytes(7).copy(t,s):(l.push(u%1e14),s+=7);s=o/7}else j=!1,z&&x(14,"crypto unavailable",crypto);if(!j)for(;o>s;)u=n(),9e15>u&&(l[s++]=u%1e14);for(o=l[--s],e%=b,o&&e&&(u=O[b-e],l[s]=p(o/u)*u);0===l[s];l.pop(),s--);if(0>s)l=[i=0];else{for(i=-1;0===l[0];l.splice(0,1),i-=b);for(s=1,u=l[0];u>=10;u/=10,s++);b>s&&(i-=b-s)}return c.e=i,c.c=l,c}}(),L=function(){function e(e,n,t){var r,i,o,u,s=0,l=e.length,c=n%R,f=n/R|0;for(e=e.slice();l--;)o=e[l]%R,u=e[l]/R|0,r=f*o+u*c,i=c*o+r%R*R+s,s=(i/t|0)+(r/R|0)+f*u,e[l]=i%t;return s&&(e=[s].concat(e)),e}function n(e,n,t,r){var i,o;if(t!=r)o=t>r?1:-1;else for(i=o=0;t>i;i++)if(e[i]!=n[i]){o=e[i]>n[i]?1:-1;break}return o}function r(e,n,t,r){for(var i=0;t--;)e[t]-=i,i=e[t]<n[t]?1:0,e[t]=i*r+e[t]-n[t];for(;!e[0]&&e.length>1;e.splice(0,1));}return function(i,o,u,s,l){var c,f,h,g,d,m,w,v,y,O,R,S,A,E,D,F,_,x=i.s==o.s?1:-1,L=i.c,U=o.c;if(!(L&&L[0]&&U&&U[0]))return new a(i.s&&o.s&&(L?!U||L[0]!=U[0]:U)?L&&0==L[0]||!U?0*x:x/0:NaN);for(v=new a(x),y=v.c=[],f=i.e-o.e,x=u+f+1,l||(l=N,f=t(i.e/b)-t(o.e/b),x=x/b|0),h=0;U[h]==(L[h]||0);h++);if(U[h]>(L[h]||0)&&f--,0>x)y.push(1),g=!0;else{for(E=L.length,F=U.length,h=0,x+=2,d=p(l/(U[0]+1)),d>1&&(U=e(U,d,l),L=e(L,d,l),F=U.length,E=L.length),A=F,O=L.slice(0,F),R=O.length;F>R;O[R++]=0);_=U.slice(),_=[0].concat(_),D=U[0],U[1]>=l/2&&D++;do{if(d=0,c=n(U,O,F,R),0>c){if(S=O[0],F!=R&&(S=S*l+(O[1]||0)),d=p(S/D),d>1)for(d>=l&&(d=l-1),m=e(U,d,l),w=m.length,R=O.length;1==n(m,O,w,R);)d--,r(m,w>F?_:U,w,l),w=m.length,c=1;else 0==d&&(c=d=1),m=U.slice(),w=m.length;if(R>w&&(m=[0].concat(m)),r(O,m,R,l),R=O.length,-1==c)for(;n(U,O,F,R)<1;)d++,r(O,R>F?_:U,R,l),R=O.length}else 0===c&&(d++,O=[0]);y[h++]=d,O[0]?O[R++]=L[A]||0:(O=[L[A]],R=1)}while((A++<E||null!=O[0])&&x--);g=null!=O[0],y[0]||y.splice(0,1)}if(l==N){for(h=1,x=y[0];x>=10;x/=10,h++);I(v,u+(v.e=h+f*b-1)+1,s,g)}else v.e=f,v.r=+g;return v}}(),U=function(){var e=/^(-?)0([xbo])(?=\w[\w.]*$)/i,n=/^([^.]+)\.$/,t=/^\.([^.]+)$/,r=/^-?(Infinity|NaN)$/,i=/^\s*\+(?=[\w.])|^\s+|\s+$/g;return function(o,u,s,l){var c,f=s?u:u.replace(i,"");if(r.test(f))o.s=isNaN(f)?null:0>f?-1:1;else{if(!s&&(f=f.replace(e,function(e,n,t){return c="x"==(t=t.toLowerCase())?16:"b"==t?2:8,l&&l!=c?e:n}),l&&(c=l,f=f.replace(n,"$1").replace(t,"0.$1")),u!=f))return new a(f,c);z&&x(C,"not a"+(l?" base "+l:"")+" number",u),o.s=null}o.c=o.e=null,C=0}}(),M.absoluteValue=M.abs=function(){var e=new a(this);return e.s<0&&(e.s=1),e},M.ceil=function(){return I(new a(this),this.e+1,2)},M.comparedTo=M.cmp=function(e,n){return C=1,i(this,new a(e,n))},M.decimalPlaces=M.dp=function(){var e,n,r=this.c;if(!r)return null;if(e=((n=r.length-1)-t(this.e/b))*b,n=r[n])for(;n%10==0;n/=10,e--);return 0>e&&(e=0),e},M.dividedBy=M.div=function(e,n){return C=3,L(this,new a(e,n),B,P)},M.dividedToIntegerBy=M.divToInt=function(e,n){return C=4,L(this,new a(e,n),0,1)},M.equals=M.eq=function(e,n){return C=5,0===i(this,new a(e,n))},M.floor=function(){return I(new a(this),this.e+1,3)},M.greaterThan=M.gt=function(e,n){return C=6,i(this,new a(e,n))>0},M.greaterThanOrEqualTo=M.gte=function(e,n){return C=7,1===(n=i(this,new a(e,n)))||0===n},M.isFinite=function(){return!!this.c},M.isInteger=M.isInt=function(){return!!this.c&&t(this.e/b)>this.c.length-2},M.isNaN=function(){return!this.s},M.isNegative=M.isNeg=function(){return this.s<0},M.isZero=function(){return!!this.c&&0==this.c[0]},M.lessThan=M.lt=function(e,n){return C=8,i(this,new a(e,n))<0},M.lessThanOrEqualTo=M.lte=function(e,n){return C=9,-1===(n=i(this,new a(e,n)))||0===n},M.minus=M.sub=function(e,n){var r,i,o,u,s=this,l=s.s;if(C=10,e=new a(e,n),n=e.s,!l||!n)return new a(NaN);if(l!=n)return e.s=-n,s.plus(e);var c=s.e/b,f=e.e/b,h=s.c,g=e.c;if(!c||!f){if(!h||!g)return h?(e.s=-n,e):new a(g?s:NaN);if(!h[0]||!g[0])return g[0]?(e.s=-n,e):new a(h[0]?s:3==P?-0:0)}if(c=t(c),f=t(f),h=h.slice(),l=c-f){for((u=0>l)?(l=-l,o=h):(f=c,o=g),o.reverse(),n=l;n--;o.push(0));o.reverse()}else for(i=(u=(l=h.length)<(n=g.length))?l:n,l=n=0;i>n;n++)if(h[n]!=g[n]){u=h[n]<g[n];break}if(u&&(o=h,h=g,g=o,e.s=-e.s),n=(i=g.length)-(r=h.length),n>0)for(;n--;h[r++]=0);for(n=N-1;i>l;){if(h[--i]<g[i]){for(r=i;r&&!h[--r];h[r]=n);--h[r],h[i]+=N}h[i]-=g[i]}for(;0==h[0];h.splice(0,1),--f);return h[0]?_(e,h,f):(e.s=3==P?-1:1,e.c=[e.e=0],e)},M.modulo=M.mod=function(e,n){var t,r,i=this;return C=11,e=new a(e,n),!i.c||!e.s||e.c&&!e.c[0]?new a(NaN):!e.c||i.c&&!i.c[0]?new a(i):(9==H?(r=e.s,e.s=1,t=L(i,e,0,3),e.s=r,t.s*=r):t=L(i,e,0,H),i.minus(t.times(e)))},M.negated=M.neg=function(){var e=new a(this);return e.s=-e.s||null,e},M.plus=M.add=function(e,n){var r,i=this,o=i.s;if(C=12,e=new a(e,n),n=e.s,!o||!n)return new a(NaN);if(o!=n)return e.s=-n,i.minus(e);var u=i.e/b,s=e.e/b,l=i.c,c=e.c;if(!u||!s){if(!l||!c)return new a(o/0);if(!l[0]||!c[0])return c[0]?e:new a(l[0]?i:0*o)}if(u=t(u),s=t(s),l=l.slice(),o=u-s){for(o>0?(s=u,r=c):(o=-o,r=l),r.reverse();o--;r.push(0));r.reverse()}for(o=l.length,n=c.length,0>o-n&&(r=c,c=l,l=r,n=o),o=0;n;)o=(l[--n]=l[n]+c[n]+o)/N|0,l[n]=N===l[n]?0:l[n]%N;return o&&(l=[o].concat(l),++s),_(e,l,s)},M.precision=M.sd=function(e){var n,t,r=this,i=r.c;if(null!=e&&e!==!!e&&1!==e&&0!==e&&(z&&x(13,"argument"+d,e),e!=!!e&&(e=null)),!i)return null;if(t=i.length-1,n=t*b+1,t=i[t]){for(;t%10==0;t/=10,n--);for(t=i[0];t>=10;t/=10,n++);}return e&&r.e+1>n&&(n=r.e+1),n},M.round=function(e,n){var t=new a(this);return(null==e||V(e,0,S,15))&&I(t,~~e+this.e+1,null!=n&&V(n,0,8,15,m)?0|n:P),t},M.shift=function(e){var n=this;return V(e,-y,y,16,"argument")?n.times("1e"+f(e)):new a(n.c&&n.c[0]&&(-y>e||e>y)?n.s*(0>e?0:1/0):n)},M.squareRoot=M.sqrt=function(){var e,n,i,o,u,s=this,l=s.c,c=s.s,f=s.e,h=B+4,g=new a("0.5");if(1!==c||!l||!l[0])return new a(!c||0>c&&(!l||l[0])?NaN:l?s:1/0);if(c=Math.sqrt(+s),0==c||c==1/0?(n=r(l),(n.length+f)%2==0&&(n+="0"),c=Math.sqrt(n),f=t((f+1)/2)-(0>f||f%2),c==1/0?n="1e"+f:(n=c.toExponential(),n=n.slice(0,n.indexOf("e")+1)+f),i=new a(n)):i=new a(c+""),i.c[0])for(f=i.e,c=f+h,3>c&&(c=0);;)if(u=i,i=g.times(u.plus(L(s,u,h,1))),r(u.c).slice(0,c)===(n=r(i.c)).slice(0,c)){if(i.e<f&&--c,n=n.slice(c-3,c+1),"9999"!=n&&(o||"4999"!=n)){(!+n||!+n.slice(1)&&"5"==n.charAt(0))&&(I(i,i.e+B+2,1),e=!i.times(i).eq(s));break}if(!o&&(I(u,u.e+B+2,0),u.times(u).eq(s))){i=u;break}h+=4,c+=4,o=1}return I(i,i.e+B+1,P,e)},M.times=M.mul=function(e,n){var r,i,o,u,s,l,c,f,h,g,p,d,m,w,v,y=this,O=y.c,S=(C=17,e=new a(e,n)).c;if(!(O&&S&&O[0]&&S[0]))return!y.s||!e.s||O&&!O[0]&&!S||S&&!S[0]&&!O?e.c=e.e=e.s=null:(e.s*=y.s,O&&S?(e.c=[0],e.e=0):e.c=e.e=null),e;for(i=t(y.e/b)+t(e.e/b),e.s*=y.s,c=O.length,g=S.length,g>c&&(m=O,O=S,S=m,o=c,c=g,g=o),o=c+g,m=[];o--;m.push(0));for(w=N,v=R,o=g;--o>=0;){for(r=0,p=S[o]%v,d=S[o]/v|0,s=c,u=o+s;u>o;)f=O[--s]%v,h=O[s]/v|0,l=d*f+h*p,f=p*f+l%v*v+m[u]+r,r=(f/w|0)+(l/v|0)+d*h,m[u--]=f%w;m[u]=r}return r?++i:m.splice(0,1),_(e,m,i)},M.toDigits=function(e,n){var t=new a(this);return e=null!=e&&V(e,1,S,18,"precision")?0|e:null,n=null!=n&&V(n,0,8,18,m)?0|n:P,e?I(t,e,n):t},M.toExponential=function(e,n){return E(this,null!=e&&V(e,0,S,19)?~~e+1:null,n,19)},M.toFixed=function(e,n){return E(this,null!=e&&V(e,0,S,20)?~~e+this.e+1:null,n,20)},M.toFormat=function(e,n){var t=E(this,null!=e&&V(e,0,S,21)?~~e+this.e+1:null,n,21);if(this.c){var r,i=t.split("."),o=+J.groupSize,u=+J.secondaryGroupSize,s=J.groupSeparator,l=i[0],c=i[1],f=this.s<0,a=f?l.slice(1):l,h=a.length;if(u&&(r=o,o=u,u=r,h-=r),o>0&&h>0){for(r=h%o||o,l=a.substr(0,r);h>r;r+=o)l+=s+a.substr(r,o);u>0&&(l+=s+a.slice(r)),f&&(l="-"+l)}t=c?l+J.decimalSeparator+((u=+J.fractionGroupSize)?c.replace(new RegExp("\\d{"+u+"}\\B","g"),"$&"+J.fractionGroupSeparator):c):l}return t},M.toFraction=function(e){var n,t,i,o,u,s,l,c,f,h=z,g=this,p=g.c,d=new a(T),m=t=new a(T),w=l=new a(T);if(null!=e&&(z=!1,s=new a(e),z=h,(!(h=s.isInt())||s.lt(T))&&(z&&x(22,"max denominator "+(h?"out of range":"not an integer"),e),e=!h&&s.c&&I(s,s.e+1,1).gte(T)?s:null)),!p)return g.toString();for(f=r(p),o=d.e=f.length-g.e-1,d.c[0]=O[(u=o%b)<0?b+u:u],e=!e||s.cmp(d)>0?o>0?d:m:s,u=G,G=1/0,s=new a(f),l.c[0]=0;c=L(s,d,0,1),i=t.plus(c.times(w)),1!=i.cmp(e);)t=w,w=i,m=l.plus(c.times(i=m)),l=i,d=s.minus(c.times(i=d)),s=i;return i=L(e.minus(t),w,0,1),l=l.plus(i.times(m)),t=t.plus(i.times(w)),l.s=m.s=g.s,o*=2,n=L(m,w,o,P).minus(g).abs().cmp(L(l,t,o,P).minus(g).abs())<1?[m.toString(),w.toString()]:[l.toString(),t.toString()],G=u,n},M.toNumber=function(){return+this},M.toPower=M.pow=function(e,n){var t,r,i,o=p(0>e?-e:+e),u=this;if(null!=n&&(C=23,n=new a(n)),!V(e,-y,y,23,"exponent")&&(!isFinite(e)||o>y&&(e/=0)||parseFloat(e)!=e&&!(e=NaN))||0==e)return t=Math.pow(+u,e),new a(n?t%n:t);for(n?e>1&&u.gt(T)&&u.isInt()&&n.gt(T)&&n.isInt()?u=u.mod(n):(i=n,n=null):W&&(t=g(W/b+2)),r=new a(T);;){if(o%2){if(r=r.times(u),!r.c)break;t?r.c.length>t&&(r.c.length=t):n&&(r=r.mod(n))}if(o=p(o/2),!o)break;u=u.times(u),t?u.c&&u.c.length>t&&(u.c.length=t):n&&(u=u.mod(n))}return n?r:(0>e&&(r=T.div(r)),i?r.mod(i):t?I(r,W,P):r)},M.toPrecision=function(e,n){return E(this,null!=e&&V(e,1,S,24,"precision")?0|e:null,n,24)},M.toString=function(e){var n,t=this,i=t.s,o=t.e;return null===o?i?(n="Infinity",0>i&&(n="-"+n)):n="NaN":(n=r(t.c),n=null!=e&&V(e,2,64,25,"base")?A(c(n,o),0|e,10,i):q>=o||o>=k?l(n,o):c(n,o),0>i&&t.c[0]&&(n="-"+n)),n},M.truncated=M.trunc=function(){return I(new a(this),this.e+1,1)},M.valueOf=M.toJSON=function(){var e,n=this,t=n.e;return null===t?n.toString():(e=r(n.c),e=q>=t||t>=k?l(e,t):c(e,t),n.s<0?"-"+e:e)},M.isBigNumber=!0,null!=e&&a.config(e),a}function t(e){var n=0|e;return e>0||e===n?n:n-1}function r(e){for(var n,t,r=1,i=e.length,o=e[0]+"";i>r;){for(n=e[r++]+"",t=b-n.length;t--;n="0"+n);o+=n}for(i=o.length;48===o.charCodeAt(--i););return o.slice(0,i+1||1)}function i(e,n){var t,r,i=e.c,o=n.c,u=e.s,s=n.s,l=e.e,c=n.e;if(!u||!s)return null;if(t=i&&!i[0],r=o&&!o[0],t||r)return t?r?0:-s:u;if(u!=s)return u;if(t=0>u,r=l==c,!i||!o)return r?0:!i^t?1:-1;if(!r)return l>c^t?1:-1;for(s=(l=i.length)<(c=o.length)?l:c,u=0;s>u;u++)if(i[u]!=o[u])return i[u]>o[u]^t?1:-1;return l==c?0:l>c^t?1:-1}function o(e,n,t){return(e=f(e))>=n&&t>=e}function u(e){return"[object Array]"==Object.prototype.toString.call(e)}function s(e,n,t){for(var r,i,o=[0],u=0,s=e.length;s>u;){for(i=o.length;i--;o[i]*=n);for(o[r=0]+=v.indexOf(e.charAt(u++));r<o.length;r++)o[r]>t-1&&(null==o[r+1]&&(o[r+1]=0),o[r+1]+=o[r]/t|0,o[r]%=t)}return o.reverse()}function l(e,n){return(e.length>1?e.charAt(0)+"."+e.slice(1):e)+(0>n?"e":"e+")+n}function c(e,n){var t,r;if(0>n){for(r="0.";++n;r+="0");e=r+e}else if(t=e.length,++n>t){for(r="0",n-=t;--n;r+="0");e+=r}else t>n&&(e=e.slice(0,n)+"."+e.slice(n));return e}function f(e){return e=parseFloat(e),0>e?g(e):p(e)}var a,h=/^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,g=Math.ceil,p=Math.floor,d=" not a boolean or binary digit",m="rounding mode",w="number type has more than 15 significant digits",v="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_",N=1e14,b=14,y=9007199254740991,O=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13],R=1e7,S=1e9;a=n(),a["default"]=a.BigNumber=a,"function"==typeof define&&define.amd?define(function(){return a}):"undefined"!=typeof module&&module.exports?module.exports=a:(e||(e="undefined"!=typeof self?self:Function("return this")()),e.BigNumber=a)}(this);
//# sourceMappingURL=bignumber.js.map
/*!
 * Socket.IO v2.2.0
 * (c) 2014-2018 Guillermo Rauch
 * Released under the MIT License.
 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.io=e():t.io=e()}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports}var n={};return e.m=t,e.c=n,e.p="",e(0)}([function(t,e,n){"use strict";function r(t,e){"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{};var n,r=i(t),s=r.source,u=r.id,h=r.path,f=p[u]&&h in p[u].nsps,l=e.forceNew||e["force new connection"]||!1===e.multiplex||f;return l?(c("ignoring socket cache for %s",s),n=a(s,e)):(p[u]||(c("new io instance for %s",s),p[u]=a(s,e)),n=p[u]),r.query&&!e.query&&(e.query=r.query),n.socket(r.path,e)}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=n(1),s=n(7),a=n(12),c=n(3)("socket.io-client");t.exports=e=r;var p=e.managers={};e.protocol=s.protocol,e.connect=r,e.Manager=n(12),e.Socket=n(36)},function(t,e,n){"use strict";function r(t,e){var n=t;e=e||"undefined"!=typeof location&&location,null==t&&(t=e.protocol+"//"+e.host),"string"==typeof t&&("/"===t.charAt(0)&&(t="/"===t.charAt(1)?e.protocol+t:e.host+t),/^(https?|wss?):\/\//.test(t)||(i("protocol-less url %s",t),t="undefined"!=typeof e?e.protocol+"//"+t:"https://"+t),i("parse %s",t),n=o(t)),n.port||(/^(http|ws)$/.test(n.protocol)?n.port="80":/^(http|ws)s$/.test(n.protocol)&&(n.port="443")),n.path=n.path||"/";var r=n.host.indexOf(":")!==-1,s=r?"["+n.host+"]":n.host;return n.id=n.protocol+"://"+s+":"+n.port,n.href=n.protocol+"://"+s+(e&&e.port===n.port?"":":"+n.port),n}var o=n(2),i=n(3)("socket.io-client:url");t.exports=r},function(t,e){var n=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,r=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];t.exports=function(t){var e=t,o=t.indexOf("["),i=t.indexOf("]");o!=-1&&i!=-1&&(t=t.substring(0,o)+t.substring(o,i).replace(/:/g,";")+t.substring(i,t.length));for(var s=n.exec(t||""),a={},c=14;c--;)a[r[c]]=s[c]||"";return o!=-1&&i!=-1&&(a.source=e,a.host=a.host.substring(1,a.host.length-1).replace(/;/g,":"),a.authority=a.authority.replace("[","").replace("]","").replace(/;/g,":"),a.ipv6uri=!0),a}},function(t,e,n){(function(r){function o(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))}function i(t){var n=this.useColors;if(t[0]=(n?"%c":"")+this.namespace+(n?" %c":" ")+t[0]+(n?"%c ":" ")+"+"+e.humanize(this.diff),n){var r="color: "+this.color;t.splice(1,0,r,"color: inherit");var o=0,i=0;t[0].replace(/%[a-zA-Z%]/g,function(t){"%%"!==t&&(o++,"%c"===t&&(i=o))}),t.splice(i,0,r)}}function s(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function a(t){try{null==t?e.storage.removeItem("debug"):e.storage.debug=t}catch(n){}}function c(){var t;try{t=e.storage.debug}catch(n){}return!t&&"undefined"!=typeof r&&"env"in r&&(t=r.env.DEBUG),t}function p(){try{return window.localStorage}catch(t){}}e=t.exports=n(5),e.log=s,e.formatArgs=i,e.save=a,e.load=c,e.useColors=o,e.storage="undefined"!=typeof chrome&&"undefined"!=typeof chrome.storage?chrome.storage.local:p(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],e.formatters.j=function(t){try{return JSON.stringify(t)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}},e.enable(c())}).call(e,n(4))},function(t,e){function n(){throw new Error("setTimeout has not been defined")}function r(){throw new Error("clearTimeout has not been defined")}function o(t){if(u===setTimeout)return setTimeout(t,0);if((u===n||!u)&&setTimeout)return u=setTimeout,setTimeout(t,0);try{return u(t,0)}catch(e){try{return u.call(null,t,0)}catch(e){return u.call(this,t,0)}}}function i(t){if(h===clearTimeout)return clearTimeout(t);if((h===r||!h)&&clearTimeout)return h=clearTimeout,clearTimeout(t);try{return h(t)}catch(e){try{return h.call(null,t)}catch(e){return h.call(this,t)}}}function s(){y&&l&&(y=!1,l.length?d=l.concat(d):m=-1,d.length&&a())}function a(){if(!y){var t=o(s);y=!0;for(var e=d.length;e;){for(l=d,d=[];++m<e;)l&&l[m].run();m=-1,e=d.length}l=null,y=!1,i(t)}}function c(t,e){this.fun=t,this.array=e}function p(){}var u,h,f=t.exports={};!function(){try{u="function"==typeof setTimeout?setTimeout:n}catch(t){u=n}try{h="function"==typeof clearTimeout?clearTimeout:r}catch(t){h=r}}();var l,d=[],y=!1,m=-1;f.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];d.push(new c(t,e)),1!==d.length||y||o(a)},c.prototype.run=function(){this.fun.apply(null,this.array)},f.title="browser",f.browser=!0,f.env={},f.argv=[],f.version="",f.versions={},f.on=p,f.addListener=p,f.once=p,f.off=p,f.removeListener=p,f.removeAllListeners=p,f.emit=p,f.prependListener=p,f.prependOnceListener=p,f.listeners=function(t){return[]},f.binding=function(t){throw new Error("process.binding is not supported")},f.cwd=function(){return"/"},f.chdir=function(t){throw new Error("process.chdir is not supported")},f.umask=function(){return 0}},function(t,e,n){function r(t){var n,r=0;for(n in t)r=(r<<5)-r+t.charCodeAt(n),r|=0;return e.colors[Math.abs(r)%e.colors.length]}function o(t){function n(){if(n.enabled){var t=n,r=+new Date,i=r-(o||r);t.diff=i,t.prev=o,t.curr=r,o=r;for(var s=new Array(arguments.length),a=0;a<s.length;a++)s[a]=arguments[a];s[0]=e.coerce(s[0]),"string"!=typeof s[0]&&s.unshift("%O");var c=0;s[0]=s[0].replace(/%([a-zA-Z%])/g,function(n,r){if("%%"===n)return n;c++;var o=e.formatters[r];if("function"==typeof o){var i=s[c];n=o.call(t,i),s.splice(c,1),c--}return n}),e.formatArgs.call(t,s);var p=n.log||e.log||console.log.bind(console);p.apply(t,s)}}var o;return n.namespace=t,n.enabled=e.enabled(t),n.useColors=e.useColors(),n.color=r(t),n.destroy=i,"function"==typeof e.init&&e.init(n),e.instances.push(n),n}function i(){var t=e.instances.indexOf(this);return t!==-1&&(e.instances.splice(t,1),!0)}function s(t){e.save(t),e.names=[],e.skips=[];var n,r=("string"==typeof t?t:"").split(/[\s,]+/),o=r.length;for(n=0;n<o;n++)r[n]&&(t=r[n].replace(/\*/g,".*?"),"-"===t[0]?e.skips.push(new RegExp("^"+t.substr(1)+"$")):e.names.push(new RegExp("^"+t+"$")));for(n=0;n<e.instances.length;n++){var i=e.instances[n];i.enabled=e.enabled(i.namespace)}}function a(){e.enable("")}function c(t){if("*"===t[t.length-1])return!0;var n,r;for(n=0,r=e.skips.length;n<r;n++)if(e.skips[n].test(t))return!1;for(n=0,r=e.names.length;n<r;n++)if(e.names[n].test(t))return!0;return!1}function p(t){return t instanceof Error?t.stack||t.message:t}e=t.exports=o.debug=o["default"]=o,e.coerce=p,e.disable=a,e.enable=s,e.enabled=c,e.humanize=n(6),e.instances=[],e.names=[],e.skips=[],e.formatters={}},function(t,e){function n(t){if(t=String(t),!(t.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t);if(e){var n=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return n*u;case"days":case"day":case"d":return n*p;case"hours":case"hour":case"hrs":case"hr":case"h":return n*c;case"minutes":case"minute":case"mins":case"min":case"m":return n*a;case"seconds":case"second":case"secs":case"sec":case"s":return n*s;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return n;default:return}}}}function r(t){return t>=p?Math.round(t/p)+"d":t>=c?Math.round(t/c)+"h":t>=a?Math.round(t/a)+"m":t>=s?Math.round(t/s)+"s":t+"ms"}function o(t){return i(t,p,"day")||i(t,c,"hour")||i(t,a,"minute")||i(t,s,"second")||t+" ms"}function i(t,e,n){if(!(t<e))return t<1.5*e?Math.floor(t/e)+" "+n:Math.ceil(t/e)+" "+n+"s"}var s=1e3,a=60*s,c=60*a,p=24*c,u=365.25*p;t.exports=function(t,e){e=e||{};var i=typeof t;if("string"===i&&t.length>0)return n(t);if("number"===i&&isNaN(t)===!1)return e["long"]?o(t):r(t);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(t))}},function(t,e,n){function r(){}function o(t){var n=""+t.type;if(e.BINARY_EVENT!==t.type&&e.BINARY_ACK!==t.type||(n+=t.attachments+"-"),t.nsp&&"/"!==t.nsp&&(n+=t.nsp+","),null!=t.id&&(n+=t.id),null!=t.data){var r=i(t.data);if(r===!1)return g;n+=r}return f("encoded %j as %s",t,n),n}function i(t){try{return JSON.stringify(t)}catch(e){return!1}}function s(t,e){function n(t){var n=d.deconstructPacket(t),r=o(n.packet),i=n.buffers;i.unshift(r),e(i)}d.removeBlobs(t,n)}function a(){this.reconstructor=null}function c(t){var n=0,r={type:Number(t.charAt(0))};if(null==e.types[r.type])return h("unknown packet type "+r.type);if(e.BINARY_EVENT===r.type||e.BINARY_ACK===r.type){for(var o="";"-"!==t.charAt(++n)&&(o+=t.charAt(n),n!=t.length););if(o!=Number(o)||"-"!==t.charAt(n))throw new Error("Illegal attachments");r.attachments=Number(o)}if("/"===t.charAt(n+1))for(r.nsp="";++n;){var i=t.charAt(n);if(","===i)break;if(r.nsp+=i,n===t.length)break}else r.nsp="/";var s=t.charAt(n+1);if(""!==s&&Number(s)==s){for(r.id="";++n;){var i=t.charAt(n);if(null==i||Number(i)!=i){--n;break}if(r.id+=t.charAt(n),n===t.length)break}r.id=Number(r.id)}if(t.charAt(++n)){var a=p(t.substr(n)),c=a!==!1&&(r.type===e.ERROR||y(a));if(!c)return h("invalid payload");r.data=a}return f("decoded %s as %j",t,r),r}function p(t){try{return JSON.parse(t)}catch(e){return!1}}function u(t){this.reconPack=t,this.buffers=[]}function h(t){return{type:e.ERROR,data:"parser error: "+t}}var f=n(3)("socket.io-parser"),l=n(8),d=n(9),y=n(10),m=n(11);e.protocol=4,e.types=["CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK"],e.CONNECT=0,e.DISCONNECT=1,e.EVENT=2,e.ACK=3,e.ERROR=4,e.BINARY_EVENT=5,e.BINARY_ACK=6,e.Encoder=r,e.Decoder=a;var g=e.ERROR+'"encode error"';r.prototype.encode=function(t,n){if(f("encoding packet %j",t),e.BINARY_EVENT===t.type||e.BINARY_ACK===t.type)s(t,n);else{var r=o(t);n([r])}},l(a.prototype),a.prototype.add=function(t){var n;if("string"==typeof t)n=c(t),e.BINARY_EVENT===n.type||e.BINARY_ACK===n.type?(this.reconstructor=new u(n),0===this.reconstructor.reconPack.attachments&&this.emit("decoded",n)):this.emit("decoded",n);else{if(!m(t)&&!t.base64)throw new Error("Unknown type: "+t);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");n=this.reconstructor.takeBinaryData(t),n&&(this.reconstructor=null,this.emit("decoded",n))}},a.prototype.destroy=function(){this.reconstructor&&this.reconstructor.finishedReconstruction()},u.prototype.takeBinaryData=function(t){if(this.buffers.push(t),this.buffers.length===this.reconPack.attachments){var e=d.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null},u.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]}},function(t,e,n){function r(t){if(t)return o(t)}function o(t){for(var e in r.prototype)t[e]=r.prototype[e];return t}t.exports=r,r.prototype.on=r.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},r.prototype.once=function(t,e){function n(){this.off(t,n),e.apply(this,arguments)}return n.fn=e,this.on(t,n),this},r.prototype.off=r.prototype.removeListener=r.prototype.removeAllListeners=r.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n=this._callbacks["$"+t];if(!n)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var r,o=0;o<n.length;o++)if(r=n[o],r===e||r.fn===e){n.splice(o,1);break}return this},r.prototype.emit=function(t){this._callbacks=this._callbacks||{};var e=[].slice.call(arguments,1),n=this._callbacks["$"+t];if(n){n=n.slice(0);for(var r=0,o=n.length;r<o;++r)n[r].apply(this,e)}return this},r.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},r.prototype.hasListeners=function(t){return!!this.listeners(t).length}},function(t,e,n){function r(t,e){if(!t)return t;if(s(t)){var n={_placeholder:!0,num:e.length};return e.push(t),n}if(i(t)){for(var o=new Array(t.length),a=0;a<t.length;a++)o[a]=r(t[a],e);return o}if("object"==typeof t&&!(t instanceof Date)){var o={};for(var c in t)o[c]=r(t[c],e);return o}return t}function o(t,e){if(!t)return t;if(t&&t._placeholder)return e[t.num];if(i(t))for(var n=0;n<t.length;n++)t[n]=o(t[n],e);else if("object"==typeof t)for(var r in t)t[r]=o(t[r],e);return t}var i=n(10),s=n(11),a=Object.prototype.toString,c="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===a.call(Blob),p="function"==typeof File||"undefined"!=typeof File&&"[object FileConstructor]"===a.call(File);e.deconstructPacket=function(t){var e=[],n=t.data,o=t;return o.data=r(n,e),o.attachments=e.length,{packet:o,buffers:e}},e.reconstructPacket=function(t,e){return t.data=o(t.data,e),t.attachments=void 0,t},e.removeBlobs=function(t,e){function n(t,a,u){if(!t)return t;if(c&&t instanceof Blob||p&&t instanceof File){r++;var h=new FileReader;h.onload=function(){u?u[a]=this.result:o=this.result,--r||e(o)},h.readAsArrayBuffer(t)}else if(i(t))for(var f=0;f<t.length;f++)n(t[f],f,t);else if("object"==typeof t&&!s(t))for(var l in t)n(t[l],l,t)}var r=0,o=t;n(o),r||e(o)}},function(t,e){var n={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==n.call(t)}},function(t,e){function n(t){return r&&Buffer.isBuffer(t)||o&&(t instanceof ArrayBuffer||i(t))}t.exports=n;var r="function"==typeof Buffer&&"function"==typeof Buffer.isBuffer,o="function"==typeof ArrayBuffer,i=function(t){return"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(t):t.buffer instanceof ArrayBuffer}},function(t,e,n){"use strict";function r(t,e){if(!(this instanceof r))return new r(t,e);t&&"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{},e.path=e.path||"/socket.io",this.nsps={},this.subs=[],this.opts=e,this.reconnection(e.reconnection!==!1),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new l({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==e.timeout?2e4:e.timeout),this.readyState="closed",this.uri=t,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[];var n=e.parser||c;this.encoder=new n.Encoder,this.decoder=new n.Decoder,this.autoConnect=e.autoConnect!==!1,this.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=n(13),s=n(36),a=n(8),c=n(7),p=n(38),u=n(39),h=n(3)("socket.io-client:manager"),f=n(35),l=n(40),d=Object.prototype.hasOwnProperty;t.exports=r,r.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var t in this.nsps)d.call(this.nsps,t)&&this.nsps[t].emit.apply(this.nsps[t],arguments)},r.prototype.updateSocketIds=function(){for(var t in this.nsps)d.call(this.nsps,t)&&(this.nsps[t].id=this.generateId(t))},r.prototype.generateId=function(t){return("/"===t?"":t+"#")+this.engine.id},a(r.prototype),r.prototype.reconnection=function(t){return arguments.length?(this._reconnection=!!t,this):this._reconnection},r.prototype.reconnectionAttempts=function(t){return arguments.length?(this._reconnectionAttempts=t,this):this._reconnectionAttempts},r.prototype.reconnectionDelay=function(t){return arguments.length?(this._reconnectionDelay=t,this.backoff&&this.backoff.setMin(t),this):this._reconnectionDelay},r.prototype.randomizationFactor=function(t){return arguments.length?(this._randomizationFactor=t,this.backoff&&this.backoff.setJitter(t),this):this._randomizationFactor},r.prototype.reconnectionDelayMax=function(t){return arguments.length?(this._reconnectionDelayMax=t,this.backoff&&this.backoff.setMax(t),this):this._reconnectionDelayMax},r.prototype.timeout=function(t){return arguments.length?(this._timeout=t,this):this._timeout},r.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()},r.prototype.open=r.prototype.connect=function(t,e){if(h("readyState %s",this.readyState),~this.readyState.indexOf("open"))return this;h("opening %s",this.uri),this.engine=i(this.uri,this.opts);var n=this.engine,r=this;this.readyState="opening",this.skipReconnect=!1;var o=p(n,"open",function(){r.onopen(),t&&t()}),s=p(n,"error",function(e){if(h("connect_error"),r.cleanup(),r.readyState="closed",r.emitAll("connect_error",e),t){var n=new Error("Connection error");n.data=e,t(n)}else r.maybeReconnectOnOpen()});if(!1!==this._timeout){var a=this._timeout;h("connect attempt will timeout after %d",a);var c=setTimeout(function(){h("connect attempt timed out after %d",a),o.destroy(),n.close(),n.emit("error","timeout"),r.emitAll("connect_timeout",a)},a);this.subs.push({destroy:function(){clearTimeout(c)}})}return this.subs.push(o),this.subs.push(s),this},r.prototype.onopen=function(){h("open"),this.cleanup(),this.readyState="open",this.emit("open");var t=this.engine;this.subs.push(p(t,"data",u(this,"ondata"))),this.subs.push(p(t,"ping",u(this,"onping"))),this.subs.push(p(t,"pong",u(this,"onpong"))),this.subs.push(p(t,"error",u(this,"onerror"))),this.subs.push(p(t,"close",u(this,"onclose"))),this.subs.push(p(this.decoder,"decoded",u(this,"ondecoded")))},r.prototype.onping=function(){this.lastPing=new Date,this.emitAll("ping")},r.prototype.onpong=function(){this.emitAll("pong",new Date-this.lastPing)},r.prototype.ondata=function(t){this.decoder.add(t)},r.prototype.ondecoded=function(t){this.emit("packet",t)},r.prototype.onerror=function(t){h("error",t),this.emitAll("error",t)},r.prototype.socket=function(t,e){function n(){~f(o.connecting,r)||o.connecting.push(r)}var r=this.nsps[t];if(!r){r=new s(this,t,e),this.nsps[t]=r;var o=this;r.on("connecting",n),r.on("connect",function(){r.id=o.generateId(t)}),this.autoConnect&&n()}return r},r.prototype.destroy=function(t){var e=f(this.connecting,t);~e&&this.connecting.splice(e,1),this.connecting.length||this.close()},r.prototype.packet=function(t){h("writing packet %j",t);var e=this;t.query&&0===t.type&&(t.nsp+="?"+t.query),e.encoding?e.packetBuffer.push(t):(e.encoding=!0,this.encoder.encode(t,function(n){for(var r=0;r<n.length;r++)e.engine.write(n[r],t.options);e.encoding=!1,e.processPacketQueue()}))},r.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var t=this.packetBuffer.shift();this.packet(t)}},r.prototype.cleanup=function(){h("cleanup");for(var t=this.subs.length,e=0;e<t;e++){var n=this.subs.shift();n.destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()},r.prototype.close=r.prototype.disconnect=function(){h("disconnect"),this.skipReconnect=!0,this.reconnecting=!1,"opening"===this.readyState&&this.cleanup(),this.backoff.reset(),this.readyState="closed",this.engine&&this.engine.close()},r.prototype.onclose=function(t){h("onclose"),this.cleanup(),this.backoff.reset(),this.readyState="closed",this.emit("close",t),this._reconnection&&!this.skipReconnect&&this.reconnect()},r.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var t=this;if(this.backoff.attempts>=this._reconnectionAttempts)h("reconnect failed"),this.backoff.reset(),this.emitAll("reconnect_failed"),this.reconnecting=!1;else{var e=this.backoff.duration();h("will wait %dms before reconnect attempt",e),this.reconnecting=!0;var n=setTimeout(function(){t.skipReconnect||(h("attempting reconnect"),t.emitAll("reconnect_attempt",t.backoff.attempts),t.emitAll("reconnecting",t.backoff.attempts),t.skipReconnect||t.open(function(e){e?(h("reconnect attempt error"),t.reconnecting=!1,t.reconnect(),t.emitAll("reconnect_error",e.data)):(h("reconnect success"),t.onreconnect())}))},e);this.subs.push({destroy:function(){clearTimeout(n)}})}},r.prototype.onreconnect=function(){var t=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll("reconnect",t)}},function(t,e,n){t.exports=n(14),t.exports.parser=n(21)},function(t,e,n){function r(t,e){return this instanceof r?(e=e||{},t&&"object"==typeof t&&(e=t,t=null),t?(t=u(t),e.hostname=t.host,e.secure="https"===t.protocol||"wss"===t.protocol,e.port=t.port,t.query&&(e.query=t.query)):e.host&&(e.hostname=u(e.host).host),this.secure=null!=e.secure?e.secure:"undefined"!=typeof location&&"https:"===location.protocol,e.hostname&&!e.port&&(e.port=this.secure?"443":"80"),this.agent=e.agent||!1,this.hostname=e.hostname||("undefined"!=typeof location?location.hostname:"localhost"),this.port=e.port||("undefined"!=typeof location&&location.port?location.port:this.secure?443:80),this.query=e.query||{},"string"==typeof this.query&&(this.query=h.decode(this.query)),this.upgrade=!1!==e.upgrade,this.path=(e.path||"/engine.io").replace(/\/$/,"")+"/",this.forceJSONP=!!e.forceJSONP,this.jsonp=!1!==e.jsonp,this.forceBase64=!!e.forceBase64,this.enablesXDR=!!e.enablesXDR,this.timestampParam=e.timestampParam||"t",this.timestampRequests=e.timestampRequests,this.transports=e.transports||["polling","websocket"],this.transportOptions=e.transportOptions||{},this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=e.policyPort||843,this.rememberUpgrade=e.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=e.onlyBinaryUpgrades,this.perMessageDeflate=!1!==e.perMessageDeflate&&(e.perMessageDeflate||{}),!0===this.perMessageDeflate&&(this.perMessageDeflate={}),this.perMessageDeflate&&null==this.perMessageDeflate.threshold&&(this.perMessageDeflate.threshold=1024),this.pfx=e.pfx||null,this.key=e.key||null,this.passphrase=e.passphrase||null,this.cert=e.cert||null,this.ca=e.ca||null,this.ciphers=e.ciphers||null,this.rejectUnauthorized=void 0===e.rejectUnauthorized||e.rejectUnauthorized,this.forceNode=!!e.forceNode,this.isReactNative="undefined"!=typeof navigator&&"string"==typeof navigator.product&&"reactnative"===navigator.product.toLowerCase(),("undefined"==typeof self||this.isReactNative)&&(e.extraHeaders&&Object.keys(e.extraHeaders).length>0&&(this.extraHeaders=e.extraHeaders),e.localAddress&&(this.localAddress=e.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,void this.open()):new r(t,e)}function o(t){var e={};for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);return e}var i=n(15),s=n(8),a=n(3)("engine.io-client:socket"),c=n(35),p=n(21),u=n(2),h=n(29);t.exports=r,r.priorWebsocketSuccess=!1,s(r.prototype),r.protocol=p.protocol,r.Socket=r,r.Transport=n(20),r.transports=n(15),r.parser=n(21),r.prototype.createTransport=function(t){a('creating transport "%s"',t);var e=o(this.query);e.EIO=p.protocol,e.transport=t;var n=this.transportOptions[t]||{};this.id&&(e.sid=this.id);var r=new i[t]({query:e,socket:this,agent:n.agent||this.agent,hostname:n.hostname||this.hostname,port:n.port||this.port,secure:n.secure||this.secure,path:n.path||this.path,forceJSONP:n.forceJSONP||this.forceJSONP,jsonp:n.jsonp||this.jsonp,forceBase64:n.forceBase64||this.forceBase64,enablesXDR:n.enablesXDR||this.enablesXDR,timestampRequests:n.timestampRequests||this.timestampRequests,timestampParam:n.timestampParam||this.timestampParam,policyPort:n.policyPort||this.policyPort,pfx:n.pfx||this.pfx,key:n.key||this.key,passphrase:n.passphrase||this.passphrase,cert:n.cert||this.cert,ca:n.ca||this.ca,ciphers:n.ciphers||this.ciphers,rejectUnauthorized:n.rejectUnauthorized||this.rejectUnauthorized,perMessageDeflate:n.perMessageDeflate||this.perMessageDeflate,extraHeaders:n.extraHeaders||this.extraHeaders,forceNode:n.forceNode||this.forceNode,localAddress:n.localAddress||this.localAddress,requestTimeout:n.requestTimeout||this.requestTimeout,protocols:n.protocols||void 0,isReactNative:this.isReactNative});return r},r.prototype.open=function(){var t;if(this.rememberUpgrade&&r.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1)t="websocket";else{if(0===this.transports.length){var e=this;return void setTimeout(function(){e.emit("error","No transports available")},0)}t=this.transports[0]}this.readyState="opening";try{t=this.createTransport(t)}catch(n){return this.transports.shift(),void this.open()}t.open(),this.setTransport(t)},r.prototype.setTransport=function(t){a("setting transport %s",t.name);var e=this;this.transport&&(a("clearing existing transport %s",this.transport.name),this.transport.removeAllListeners()),this.transport=t,t.on("drain",function(){e.onDrain()}).on("packet",function(t){e.onPacket(t)}).on("error",function(t){e.onError(t)}).on("close",function(){e.onClose("transport close")})},r.prototype.probe=function(t){function e(){if(f.onlyBinaryUpgrades){var e=!this.supportsBinary&&f.transport.supportsBinary;h=h||e}h||(a('probe transport "%s" opened',t),u.send([{type:"ping",data:"probe"}]),u.once("packet",function(e){if(!h)if("pong"===e.type&&"probe"===e.data){if(a('probe transport "%s" pong',t),f.upgrading=!0,f.emit("upgrading",u),!u)return;r.priorWebsocketSuccess="websocket"===u.name,a('pausing current transport "%s"',f.transport.name),f.transport.pause(function(){h||"closed"!==f.readyState&&(a("changing transport and sending upgrade packet"),p(),f.setTransport(u),u.send([{type:"upgrade"}]),f.emit("upgrade",u),u=null,f.upgrading=!1,f.flush())})}else{a('probe transport "%s" failed',t);var n=new Error("probe error");n.transport=u.name,f.emit("upgradeError",n)}}))}function n(){h||(h=!0,p(),u.close(),u=null)}function o(e){var r=new Error("probe error: "+e);r.transport=u.name,n(),a('probe transport "%s" failed because of error: %s',t,e),f.emit("upgradeError",r)}function i(){o("transport closed")}function s(){o("socket closed")}function c(t){u&&t.name!==u.name&&(a('"%s" works - aborting "%s"',t.name,u.name),n())}function p(){u.removeListener("open",e),u.removeListener("error",o),u.removeListener("close",i),f.removeListener("close",s),f.removeListener("upgrading",c)}a('probing transport "%s"',t);var u=this.createTransport(t,{probe:1}),h=!1,f=this;r.priorWebsocketSuccess=!1,u.once("open",e),u.once("error",o),u.once("close",i),this.once("close",s),this.once("upgrading",c),u.open()},r.prototype.onOpen=function(){if(a("socket open"),this.readyState="open",r.priorWebsocketSuccess="websocket"===this.transport.name,this.emit("open"),this.flush(),"open"===this.readyState&&this.upgrade&&this.transport.pause){a("starting upgrade probes");for(var t=0,e=this.upgrades.length;t<e;t++)this.probe(this.upgrades[t])}},r.prototype.onPacket=function(t){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(a('socket receive: type "%s", data "%s"',t.type,t.data),this.emit("packet",t),this.emit("heartbeat"),t.type){case"open":this.onHandshake(JSON.parse(t.data));break;case"pong":this.setPing(),this.emit("pong");break;case"error":var e=new Error("server error");e.code=t.data,this.onError(e);break;case"message":this.emit("data",t.data),this.emit("message",t.data)}else a('packet received with socket readyState "%s"',this.readyState)},r.prototype.onHandshake=function(t){this.emit("handshake",t),this.id=t.sid,this.transport.query.sid=t.sid,this.upgrades=this.filterUpgrades(t.upgrades),this.pingInterval=t.pingInterval,this.pingTimeout=t.pingTimeout,this.onOpen(),"closed"!==this.readyState&&(this.setPing(),this.removeListener("heartbeat",this.onHeartbeat),this.on("heartbeat",this.onHeartbeat))},r.prototype.onHeartbeat=function(t){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout(function(){"closed"!==e.readyState&&e.onClose("ping timeout")},t||e.pingInterval+e.pingTimeout)},r.prototype.setPing=function(){var t=this;clearTimeout(t.pingIntervalTimer),t.pingIntervalTimer=setTimeout(function(){a("writing ping packet - expecting pong within %sms",t.pingTimeout),t.ping(),t.onHeartbeat(t.pingTimeout)},t.pingInterval)},r.prototype.ping=function(){var t=this;this.sendPacket("ping",function(){t.emit("ping")})},r.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emit("drain"):this.flush()},r.prototype.flush=function(){"closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(a("flushing %d packets in socket",this.writeBuffer.length),this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit("flush"))},r.prototype.write=r.prototype.send=function(t,e,n){return this.sendPacket("message",t,e,n),this},r.prototype.sendPacket=function(t,e,n,r){if("function"==typeof e&&(r=e,e=void 0),"function"==typeof n&&(r=n,n=null),"closing"!==this.readyState&&"closed"!==this.readyState){n=n||{},n.compress=!1!==n.compress;var o={type:t,data:e,options:n};this.emit("packetCreate",o),this.writeBuffer.push(o),r&&this.once("flush",r),this.flush()}},r.prototype.close=function(){function t(){r.onClose("forced close"),a("socket closing - telling transport to close"),r.transport.close()}function e(){r.removeListener("upgrade",e),r.removeListener("upgradeError",e),t()}function n(){r.once("upgrade",e),r.once("upgradeError",e)}if("opening"===this.readyState||"open"===this.readyState){this.readyState="closing";var r=this;this.writeBuffer.length?this.once("drain",function(){this.upgrading?n():t()}):this.upgrading?n():t()}return this},r.prototype.onError=function(t){a("socket error %j",t),r.priorWebsocketSuccess=!1,this.emit("error",t),this.onClose("transport error",t)},r.prototype.onClose=function(t,e){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState){a('socket close with reason: "%s"',t);var n=this;clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),this.readyState="closed",this.id=null,this.emit("close",t,e),n.writeBuffer=[],n.prevBufferLen=0}},r.prototype.filterUpgrades=function(t){for(var e=[],n=0,r=t.length;n<r;n++)~c(this.transports,t[n])&&e.push(t[n]);return e}},function(t,e,n){function r(t){var e,n=!1,r=!1,a=!1!==t.jsonp;
if("undefined"!=typeof location){var c="https:"===location.protocol,p=location.port;p||(p=c?443:80),n=t.hostname!==location.hostname||p!==t.port,r=t.secure!==c}if(t.xdomain=n,t.xscheme=r,e=new o(t),"open"in e&&!t.forceJSONP)return new i(t);if(!a)throw new Error("JSONP disabled");return new s(t)}var o=n(16),i=n(18),s=n(32),a=n(33);e.polling=r,e.websocket=a},function(t,e,n){var r=n(17);t.exports=function(t){var e=t.xdomain,n=t.xscheme,o=t.enablesXDR;try{if("undefined"!=typeof XMLHttpRequest&&(!e||r))return new XMLHttpRequest}catch(i){}try{if("undefined"!=typeof XDomainRequest&&!n&&o)return new XDomainRequest}catch(i){}if(!e)try{return new(self[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(i){}}},function(t,e){try{t.exports="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(n){t.exports=!1}},function(t,e,n){function r(){}function o(t){if(c.call(this,t),this.requestTimeout=t.requestTimeout,this.extraHeaders=t.extraHeaders,"undefined"!=typeof location){var e="https:"===location.protocol,n=location.port;n||(n=e?443:80),this.xd="undefined"!=typeof location&&t.hostname!==location.hostname||n!==t.port,this.xs=t.secure!==e}}function i(t){this.method=t.method||"GET",this.uri=t.uri,this.xd=!!t.xd,this.xs=!!t.xs,this.async=!1!==t.async,this.data=void 0!==t.data?t.data:null,this.agent=t.agent,this.isBinary=t.isBinary,this.supportsBinary=t.supportsBinary,this.enablesXDR=t.enablesXDR,this.requestTimeout=t.requestTimeout,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.extraHeaders=t.extraHeaders,this.create()}function s(){for(var t in i.requests)i.requests.hasOwnProperty(t)&&i.requests[t].abort()}var a=n(16),c=n(19),p=n(8),u=n(30),h=n(3)("engine.io-client:polling-xhr");if(t.exports=o,t.exports.Request=i,u(o,c),o.prototype.supportsBinary=!0,o.prototype.request=function(t){return t=t||{},t.uri=this.uri(),t.xd=this.xd,t.xs=this.xs,t.agent=this.agent||!1,t.supportsBinary=this.supportsBinary,t.enablesXDR=this.enablesXDR,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized,t.requestTimeout=this.requestTimeout,t.extraHeaders=this.extraHeaders,new i(t)},o.prototype.doWrite=function(t,e){var n="string"!=typeof t&&void 0!==t,r=this.request({method:"POST",data:t,isBinary:n}),o=this;r.on("success",e),r.on("error",function(t){o.onError("xhr post error",t)}),this.sendXhr=r},o.prototype.doPoll=function(){h("xhr poll");var t=this.request(),e=this;t.on("data",function(t){e.onData(t)}),t.on("error",function(t){e.onError("xhr poll error",t)}),this.pollXhr=t},p(i.prototype),i.prototype.create=function(){var t={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized;var e=this.xhr=new a(t),n=this;try{h("xhr open %s: %s",this.method,this.uri),e.open(this.method,this.uri,this.async);try{if(this.extraHeaders){e.setDisableHeaderCheck&&e.setDisableHeaderCheck(!0);for(var r in this.extraHeaders)this.extraHeaders.hasOwnProperty(r)&&e.setRequestHeader(r,this.extraHeaders[r])}}catch(o){}if("POST"===this.method)try{this.isBinary?e.setRequestHeader("Content-type","application/octet-stream"):e.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(o){}try{e.setRequestHeader("Accept","*/*")}catch(o){}"withCredentials"in e&&(e.withCredentials=!0),this.requestTimeout&&(e.timeout=this.requestTimeout),this.hasXDR()?(e.onload=function(){n.onLoad()},e.onerror=function(){n.onError(e.responseText)}):e.onreadystatechange=function(){if(2===e.readyState)try{var t=e.getResponseHeader("Content-Type");n.supportsBinary&&"application/octet-stream"===t&&(e.responseType="arraybuffer")}catch(r){}4===e.readyState&&(200===e.status||1223===e.status?n.onLoad():setTimeout(function(){n.onError(e.status)},0))},h("xhr data %s",this.data),e.send(this.data)}catch(o){return void setTimeout(function(){n.onError(o)},0)}"undefined"!=typeof document&&(this.index=i.requestsCount++,i.requests[this.index]=this)},i.prototype.onSuccess=function(){this.emit("success"),this.cleanup()},i.prototype.onData=function(t){this.emit("data",t),this.onSuccess()},i.prototype.onError=function(t){this.emit("error",t),this.cleanup(!0)},i.prototype.cleanup=function(t){if("undefined"!=typeof this.xhr&&null!==this.xhr){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=r:this.xhr.onreadystatechange=r,t)try{this.xhr.abort()}catch(e){}"undefined"!=typeof document&&delete i.requests[this.index],this.xhr=null}},i.prototype.onLoad=function(){var t;try{var e;try{e=this.xhr.getResponseHeader("Content-Type")}catch(n){}t="application/octet-stream"===e?this.xhr.response||this.xhr.responseText:this.xhr.responseText}catch(n){this.onError(n)}null!=t&&this.onData(t)},i.prototype.hasXDR=function(){return"undefined"!=typeof XDomainRequest&&!this.xs&&this.enablesXDR},i.prototype.abort=function(){this.cleanup()},i.requestsCount=0,i.requests={},"undefined"!=typeof document)if("function"==typeof attachEvent)attachEvent("onunload",s);else if("function"==typeof addEventListener){var f="onpagehide"in self?"pagehide":"unload";addEventListener(f,s,!1)}},function(t,e,n){function r(t){var e=t&&t.forceBase64;u&&!e||(this.supportsBinary=!1),o.call(this,t)}var o=n(20),i=n(29),s=n(21),a=n(30),c=n(31),p=n(3)("engine.io-client:polling");t.exports=r;var u=function(){var t=n(16),e=new t({xdomain:!1});return null!=e.responseType}();a(r,o),r.prototype.name="polling",r.prototype.doOpen=function(){this.poll()},r.prototype.pause=function(t){function e(){p("paused"),n.readyState="paused",t()}var n=this;if(this.readyState="pausing",this.polling||!this.writable){var r=0;this.polling&&(p("we are currently polling - waiting to pause"),r++,this.once("pollComplete",function(){p("pre-pause polling complete"),--r||e()})),this.writable||(p("we are currently writing - waiting to pause"),r++,this.once("drain",function(){p("pre-pause writing complete"),--r||e()}))}else e()},r.prototype.poll=function(){p("polling"),this.polling=!0,this.doPoll(),this.emit("poll")},r.prototype.onData=function(t){var e=this;p("polling got data %s",t);var n=function(t,n,r){return"opening"===e.readyState&&e.onOpen(),"close"===t.type?(e.onClose(),!1):void e.onPacket(t)};s.decodePayload(t,this.socket.binaryType,n),"closed"!==this.readyState&&(this.polling=!1,this.emit("pollComplete"),"open"===this.readyState?this.poll():p('ignoring poll - transport state "%s"',this.readyState))},r.prototype.doClose=function(){function t(){p("writing close packet"),e.write([{type:"close"}])}var e=this;"open"===this.readyState?(p("transport open - closing"),t()):(p("transport not open - deferring close"),this.once("open",t))},r.prototype.write=function(t){var e=this;this.writable=!1;var n=function(){e.writable=!0,e.emit("drain")};s.encodePayload(t,this.supportsBinary,function(t){e.doWrite(t,n)})},r.prototype.uri=function(){var t=this.query||{},e=this.secure?"https":"http",n="";!1!==this.timestampRequests&&(t[this.timestampParam]=c()),this.supportsBinary||t.sid||(t.b64=1),t=i.encode(t),this.port&&("https"===e&&443!==Number(this.port)||"http"===e&&80!==Number(this.port))&&(n=":"+this.port),t.length&&(t="?"+t);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+n+this.path+t}},function(t,e,n){function r(t){this.path=t.path,this.hostname=t.hostname,this.port=t.port,this.secure=t.secure,this.query=t.query,this.timestampParam=t.timestampParam,this.timestampRequests=t.timestampRequests,this.readyState="",this.agent=t.agent||!1,this.socket=t.socket,this.enablesXDR=t.enablesXDR,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.forceNode=t.forceNode,this.isReactNative=t.isReactNative,this.extraHeaders=t.extraHeaders,this.localAddress=t.localAddress}var o=n(21),i=n(8);t.exports=r,i(r.prototype),r.prototype.onError=function(t,e){var n=new Error(t);return n.type="TransportError",n.description=e,this.emit("error",n),this},r.prototype.open=function(){return"closed"!==this.readyState&&""!==this.readyState||(this.readyState="opening",this.doOpen()),this},r.prototype.close=function(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this},r.prototype.send=function(t){if("open"!==this.readyState)throw new Error("Transport not open");this.write(t)},r.prototype.onOpen=function(){this.readyState="open",this.writable=!0,this.emit("open")},r.prototype.onData=function(t){var e=o.decodePacket(t,this.socket.binaryType);this.onPacket(e)},r.prototype.onPacket=function(t){this.emit("packet",t)},r.prototype.onClose=function(){this.readyState="closed",this.emit("close")}},function(t,e,n){function r(t,n){var r="b"+e.packets[t.type]+t.data.data;return n(r)}function o(t,n,r){if(!n)return e.encodeBase64Packet(t,r);var o=t.data,i=new Uint8Array(o),s=new Uint8Array(1+o.byteLength);s[0]=v[t.type];for(var a=0;a<i.length;a++)s[a+1]=i[a];return r(s.buffer)}function i(t,n,r){if(!n)return e.encodeBase64Packet(t,r);var o=new FileReader;return o.onload=function(){e.encodePacket({type:t.type,data:o.result},n,!0,r)},o.readAsArrayBuffer(t.data)}function s(t,n,r){if(!n)return e.encodeBase64Packet(t,r);if(g)return i(t,n,r);var o=new Uint8Array(1);o[0]=v[t.type];var s=new k([o.buffer,t.data]);return r(s)}function a(t){try{t=d.decode(t,{strict:!1})}catch(e){return!1}return t}function c(t,e,n){for(var r=new Array(t.length),o=l(t.length,n),i=function(t,n,o){e(n,function(e,n){r[t]=n,o(e,r)})},s=0;s<t.length;s++)i(s,t[s],o)}var p,u=n(22),h=n(23),f=n(24),l=n(25),d=n(26);"undefined"!=typeof ArrayBuffer&&(p=n(27));var y="undefined"!=typeof navigator&&/Android/i.test(navigator.userAgent),m="undefined"!=typeof navigator&&/PhantomJS/i.test(navigator.userAgent),g=y||m;e.protocol=3;var v=e.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},b=u(v),w={type:"error",data:"parser error"},k=n(28);e.encodePacket=function(t,e,n,i){"function"==typeof e&&(i=e,e=!1),"function"==typeof n&&(i=n,n=null);var a=void 0===t.data?void 0:t.data.buffer||t.data;if("undefined"!=typeof ArrayBuffer&&a instanceof ArrayBuffer)return o(t,e,i);if("undefined"!=typeof k&&a instanceof k)return s(t,e,i);if(a&&a.base64)return r(t,i);var c=v[t.type];return void 0!==t.data&&(c+=n?d.encode(String(t.data),{strict:!1}):String(t.data)),i(""+c)},e.encodeBase64Packet=function(t,n){var r="b"+e.packets[t.type];if("undefined"!=typeof k&&t.data instanceof k){var o=new FileReader;return o.onload=function(){var t=o.result.split(",")[1];n(r+t)},o.readAsDataURL(t.data)}var i;try{i=String.fromCharCode.apply(null,new Uint8Array(t.data))}catch(s){for(var a=new Uint8Array(t.data),c=new Array(a.length),p=0;p<a.length;p++)c[p]=a[p];i=String.fromCharCode.apply(null,c)}return r+=btoa(i),n(r)},e.decodePacket=function(t,n,r){if(void 0===t)return w;if("string"==typeof t){if("b"===t.charAt(0))return e.decodeBase64Packet(t.substr(1),n);if(r&&(t=a(t),t===!1))return w;var o=t.charAt(0);return Number(o)==o&&b[o]?t.length>1?{type:b[o],data:t.substring(1)}:{type:b[o]}:w}var i=new Uint8Array(t),o=i[0],s=f(t,1);return k&&"blob"===n&&(s=new k([s])),{type:b[o],data:s}},e.decodeBase64Packet=function(t,e){var n=b[t.charAt(0)];if(!p)return{type:n,data:{base64:!0,data:t.substr(1)}};var r=p.decode(t.substr(1));return"blob"===e&&k&&(r=new k([r])),{type:n,data:r}},e.encodePayload=function(t,n,r){function o(t){return t.length+":"+t}function i(t,r){e.encodePacket(t,!!s&&n,!1,function(t){r(null,o(t))})}"function"==typeof n&&(r=n,n=null);var s=h(t);return n&&s?k&&!g?e.encodePayloadAsBlob(t,r):e.encodePayloadAsArrayBuffer(t,r):t.length?void c(t,i,function(t,e){return r(e.join(""))}):r("0:")},e.decodePayload=function(t,n,r){if("string"!=typeof t)return e.decodePayloadAsBinary(t,n,r);"function"==typeof n&&(r=n,n=null);var o;if(""===t)return r(w,0,1);for(var i,s,a="",c=0,p=t.length;c<p;c++){var u=t.charAt(c);if(":"===u){if(""===a||a!=(i=Number(a)))return r(w,0,1);if(s=t.substr(c+1,i),a!=s.length)return r(w,0,1);if(s.length){if(o=e.decodePacket(s,n,!1),w.type===o.type&&w.data===o.data)return r(w,0,1);var h=r(o,c+i,p);if(!1===h)return}c+=i,a=""}else a+=u}return""!==a?r(w,0,1):void 0},e.encodePayloadAsArrayBuffer=function(t,n){function r(t,n){e.encodePacket(t,!0,!0,function(t){return n(null,t)})}return t.length?void c(t,r,function(t,e){var r=e.reduce(function(t,e){var n;return n="string"==typeof e?e.length:e.byteLength,t+n.toString().length+n+2},0),o=new Uint8Array(r),i=0;return e.forEach(function(t){var e="string"==typeof t,n=t;if(e){for(var r=new Uint8Array(t.length),s=0;s<t.length;s++)r[s]=t.charCodeAt(s);n=r.buffer}e?o[i++]=0:o[i++]=1;for(var a=n.byteLength.toString(),s=0;s<a.length;s++)o[i++]=parseInt(a[s]);o[i++]=255;for(var r=new Uint8Array(n),s=0;s<r.length;s++)o[i++]=r[s]}),n(o.buffer)}):n(new ArrayBuffer(0))},e.encodePayloadAsBlob=function(t,n){function r(t,n){e.encodePacket(t,!0,!0,function(t){var e=new Uint8Array(1);if(e[0]=1,"string"==typeof t){for(var r=new Uint8Array(t.length),o=0;o<t.length;o++)r[o]=t.charCodeAt(o);t=r.buffer,e[0]=0}for(var i=t instanceof ArrayBuffer?t.byteLength:t.size,s=i.toString(),a=new Uint8Array(s.length+1),o=0;o<s.length;o++)a[o]=parseInt(s[o]);if(a[s.length]=255,k){var c=new k([e.buffer,a.buffer,t]);n(null,c)}})}c(t,r,function(t,e){return n(new k(e))})},e.decodePayloadAsBinary=function(t,n,r){"function"==typeof n&&(r=n,n=null);for(var o=t,i=[];o.byteLength>0;){for(var s=new Uint8Array(o),a=0===s[0],c="",p=1;255!==s[p];p++){if(c.length>310)return r(w,0,1);c+=s[p]}o=f(o,2+c.length),c=parseInt(c);var u=f(o,0,c);if(a)try{u=String.fromCharCode.apply(null,new Uint8Array(u))}catch(h){var l=new Uint8Array(u);u="";for(var p=0;p<l.length;p++)u+=String.fromCharCode(l[p])}i.push(u),o=f(o,c)}var d=i.length;i.forEach(function(t,o){r(e.decodePacket(t,n,!0),o,d)})}},function(t,e){t.exports=Object.keys||function(t){var e=[],n=Object.prototype.hasOwnProperty;for(var r in t)n.call(t,r)&&e.push(r);return e}},function(t,e,n){function r(t){if(!t||"object"!=typeof t)return!1;if(o(t)){for(var e=0,n=t.length;e<n;e++)if(r(t[e]))return!0;return!1}if("function"==typeof Buffer&&Buffer.isBuffer&&Buffer.isBuffer(t)||"function"==typeof ArrayBuffer&&t instanceof ArrayBuffer||s&&t instanceof Blob||a&&t instanceof File)return!0;if(t.toJSON&&"function"==typeof t.toJSON&&1===arguments.length)return r(t.toJSON(),!0);for(var i in t)if(Object.prototype.hasOwnProperty.call(t,i)&&r(t[i]))return!0;return!1}var o=n(10),i=Object.prototype.toString,s="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===i.call(Blob),a="function"==typeof File||"undefined"!=typeof File&&"[object FileConstructor]"===i.call(File);t.exports=r},function(t,e){t.exports=function(t,e,n){var r=t.byteLength;if(e=e||0,n=n||r,t.slice)return t.slice(e,n);if(e<0&&(e+=r),n<0&&(n+=r),n>r&&(n=r),e>=r||e>=n||0===r)return new ArrayBuffer(0);for(var o=new Uint8Array(t),i=new Uint8Array(n-e),s=e,a=0;s<n;s++,a++)i[a]=o[s];return i.buffer}},function(t,e){function n(t,e,n){function o(t,r){if(o.count<=0)throw new Error("after called too many times");--o.count,t?(i=!0,e(t),e=n):0!==o.count||i||e(null,r)}var i=!1;return n=n||r,o.count=t,0===t?e():o}function r(){}t.exports=n},function(t,e){function n(t){for(var e,n,r=[],o=0,i=t.length;o<i;)e=t.charCodeAt(o++),e>=55296&&e<=56319&&o<i?(n=t.charCodeAt(o++),56320==(64512&n)?r.push(((1023&e)<<10)+(1023&n)+65536):(r.push(e),o--)):r.push(e);return r}function r(t){for(var e,n=t.length,r=-1,o="";++r<n;)e=t[r],e>65535&&(e-=65536,o+=d(e>>>10&1023|55296),e=56320|1023&e),o+=d(e);return o}function o(t,e){if(t>=55296&&t<=57343){if(e)throw Error("Lone surrogate U+"+t.toString(16).toUpperCase()+" is not a scalar value");return!1}return!0}function i(t,e){return d(t>>e&63|128)}function s(t,e){if(0==(4294967168&t))return d(t);var n="";return 0==(4294965248&t)?n=d(t>>6&31|192):0==(4294901760&t)?(o(t,e)||(t=65533),n=d(t>>12&15|224),n+=i(t,6)):0==(4292870144&t)&&(n=d(t>>18&7|240),n+=i(t,12),n+=i(t,6)),n+=d(63&t|128)}function a(t,e){e=e||{};for(var r,o=!1!==e.strict,i=n(t),a=i.length,c=-1,p="";++c<a;)r=i[c],p+=s(r,o);return p}function c(){if(l>=f)throw Error("Invalid byte index");var t=255&h[l];if(l++,128==(192&t))return 63&t;throw Error("Invalid continuation byte")}function p(t){var e,n,r,i,s;if(l>f)throw Error("Invalid byte index");if(l==f)return!1;if(e=255&h[l],l++,0==(128&e))return e;if(192==(224&e)){if(n=c(),s=(31&e)<<6|n,s>=128)return s;throw Error("Invalid continuation byte")}if(224==(240&e)){if(n=c(),r=c(),s=(15&e)<<12|n<<6|r,s>=2048)return o(s,t)?s:65533;throw Error("Invalid continuation byte")}if(240==(248&e)&&(n=c(),r=c(),i=c(),s=(7&e)<<18|n<<12|r<<6|i,s>=65536&&s<=1114111))return s;throw Error("Invalid UTF-8 detected")}function u(t,e){e=e||{};var o=!1!==e.strict;h=n(t),f=h.length,l=0;for(var i,s=[];(i=p(o))!==!1;)s.push(i);return r(s)}/*! https://mths.be/utf8js v2.1.2 by @mathias */
var h,f,l,d=String.fromCharCode;t.exports={version:"2.1.2",encode:a,decode:u}},function(t,e){!function(){"use strict";for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n=new Uint8Array(256),r=0;r<t.length;r++)n[t.charCodeAt(r)]=r;e.encode=function(e){var n,r=new Uint8Array(e),o=r.length,i="";for(n=0;n<o;n+=3)i+=t[r[n]>>2],i+=t[(3&r[n])<<4|r[n+1]>>4],i+=t[(15&r[n+1])<<2|r[n+2]>>6],i+=t[63&r[n+2]];return o%3===2?i=i.substring(0,i.length-1)+"=":o%3===1&&(i=i.substring(0,i.length-2)+"=="),i},e.decode=function(t){var e,r,o,i,s,a=.75*t.length,c=t.length,p=0;"="===t[t.length-1]&&(a--,"="===t[t.length-2]&&a--);var u=new ArrayBuffer(a),h=new Uint8Array(u);for(e=0;e<c;e+=4)r=n[t.charCodeAt(e)],o=n[t.charCodeAt(e+1)],i=n[t.charCodeAt(e+2)],s=n[t.charCodeAt(e+3)],h[p++]=r<<2|o>>4,h[p++]=(15&o)<<4|i>>2,h[p++]=(3&i)<<6|63&s;return u}}()},function(t,e){function n(t){return t.map(function(t){if(t.buffer instanceof ArrayBuffer){var e=t.buffer;if(t.byteLength!==e.byteLength){var n=new Uint8Array(t.byteLength);n.set(new Uint8Array(e,t.byteOffset,t.byteLength)),e=n.buffer}return e}return t})}function r(t,e){e=e||{};var r=new i;return n(t).forEach(function(t){r.append(t)}),e.type?r.getBlob(e.type):r.getBlob()}function o(t,e){return new Blob(n(t),e||{})}var i="undefined"!=typeof i?i:"undefined"!=typeof WebKitBlobBuilder?WebKitBlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"undefined"!=typeof MozBlobBuilder&&MozBlobBuilder,s=function(){try{var t=new Blob(["hi"]);return 2===t.size}catch(e){return!1}}(),a=s&&function(){try{var t=new Blob([new Uint8Array([1,2])]);return 2===t.size}catch(e){return!1}}(),c=i&&i.prototype.append&&i.prototype.getBlob;"undefined"!=typeof Blob&&(r.prototype=Blob.prototype,o.prototype=Blob.prototype),t.exports=function(){return s?a?Blob:o:c?r:void 0}()},function(t,e){e.encode=function(t){var e="";for(var n in t)t.hasOwnProperty(n)&&(e.length&&(e+="&"),e+=encodeURIComponent(n)+"="+encodeURIComponent(t[n]));return e},e.decode=function(t){for(var e={},n=t.split("&"),r=0,o=n.length;r<o;r++){var i=n[r].split("=");e[decodeURIComponent(i[0])]=decodeURIComponent(i[1])}return e}},function(t,e){t.exports=function(t,e){var n=function(){};n.prototype=e.prototype,t.prototype=new n,t.prototype.constructor=t}},function(t,e){"use strict";function n(t){var e="";do e=s[t%a]+e,t=Math.floor(t/a);while(t>0);return e}function r(t){var e=0;for(u=0;u<t.length;u++)e=e*a+c[t.charAt(u)];return e}function o(){var t=n(+new Date);return t!==i?(p=0,i=t):t+"."+n(p++)}for(var i,s="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),a=64,c={},p=0,u=0;u<a;u++)c[s[u]]=u;o.encode=n,o.decode=r,t.exports=o},function(t,e,n){(function(e){function r(){}function o(){return"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof e?e:{}}function i(t){if(s.call(this,t),this.query=this.query||{},!c){var e=o();c=e.___eio=e.___eio||[]}this.index=c.length;var n=this;c.push(function(t){n.onData(t)}),this.query.j=this.index,"function"==typeof addEventListener&&addEventListener("beforeunload",function(){n.script&&(n.script.onerror=r)},!1)}var s=n(19),a=n(30);t.exports=i;var c,p=/\n/g,u=/\\n/g;a(i,s),i.prototype.supportsBinary=!1,i.prototype.doClose=function(){this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),this.form&&(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),s.prototype.doClose.call(this)},i.prototype.doPoll=function(){var t=this,e=document.createElement("script");this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(e){t.onError("jsonp poll error",e)};var n=document.getElementsByTagName("script")[0];n?n.parentNode.insertBefore(e,n):(document.head||document.body).appendChild(e),this.script=e;var r="undefined"!=typeof navigator&&/gecko/i.test(navigator.userAgent);r&&setTimeout(function(){var t=document.createElement("iframe");document.body.appendChild(t),document.body.removeChild(t)},100)},i.prototype.doWrite=function(t,e){function n(){r(),e()}function r(){if(o.iframe)try{o.form.removeChild(o.iframe)}catch(t){o.onError("jsonp polling iframe removal error",t)}try{var e='<iframe src="javascript:0" name="'+o.iframeId+'">';i=document.createElement(e)}catch(t){i=document.createElement("iframe"),i.name=o.iframeId,i.src="javascript:0"}i.id=o.iframeId,o.form.appendChild(i),o.iframe=i}var o=this;if(!this.form){var i,s=document.createElement("form"),a=document.createElement("textarea"),c=this.iframeId="eio_iframe_"+this.index;s.className="socketio",s.style.position="absolute",s.style.top="-1000px",s.style.left="-1000px",s.target=c,s.method="POST",s.setAttribute("accept-charset","utf-8"),a.name="d",s.appendChild(a),document.body.appendChild(s),this.form=s,this.area=a}this.form.action=this.uri(),r(),t=t.replace(u,"\\\n"),this.area.value=t.replace(p,"\\n");try{this.form.submit()}catch(h){}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){"complete"===o.iframe.readyState&&n()}:this.iframe.onload=n}}).call(e,function(){return this}())},function(t,e,n){function r(t){var e=t&&t.forceBase64;e&&(this.supportsBinary=!1),this.perMessageDeflate=t.perMessageDeflate,this.usingBrowserWebSocket=o&&!t.forceNode,this.protocols=t.protocols,this.usingBrowserWebSocket||(l=i),s.call(this,t)}var o,i,s=n(20),a=n(21),c=n(29),p=n(30),u=n(31),h=n(3)("engine.io-client:websocket");if("undefined"==typeof self)try{i=n(34)}catch(f){}else o=self.WebSocket||self.MozWebSocket;var l=o||i;t.exports=r,p(r,s),r.prototype.name="websocket",r.prototype.supportsBinary=!0,r.prototype.doOpen=function(){if(this.check()){var t=this.uri(),e=this.protocols,n={agent:this.agent,perMessageDeflate:this.perMessageDeflate};n.pfx=this.pfx,n.key=this.key,n.passphrase=this.passphrase,n.cert=this.cert,n.ca=this.ca,n.ciphers=this.ciphers,n.rejectUnauthorized=this.rejectUnauthorized,this.extraHeaders&&(n.headers=this.extraHeaders),this.localAddress&&(n.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket&&!this.isReactNative?e?new l(t,e):new l(t):new l(t,e,n)}catch(r){return this.emit("error",r)}void 0===this.ws.binaryType&&(this.supportsBinary=!1),this.ws.supports&&this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType="nodebuffer"):this.ws.binaryType="arraybuffer",this.addEventListeners()}},r.prototype.addEventListeners=function(){var t=this;this.ws.onopen=function(){t.onOpen()},this.ws.onclose=function(){t.onClose()},this.ws.onmessage=function(e){t.onData(e.data)},this.ws.onerror=function(e){t.onError("websocket error",e)}},r.prototype.write=function(t){function e(){n.emit("flush"),setTimeout(function(){n.writable=!0,n.emit("drain")},0)}var n=this;this.writable=!1;for(var r=t.length,o=0,i=r;o<i;o++)!function(t){a.encodePacket(t,n.supportsBinary,function(o){if(!n.usingBrowserWebSocket){var i={};if(t.options&&(i.compress=t.options.compress),n.perMessageDeflate){var s="string"==typeof o?Buffer.byteLength(o):o.length;s<n.perMessageDeflate.threshold&&(i.compress=!1)}}try{n.usingBrowserWebSocket?n.ws.send(o):n.ws.send(o,i)}catch(a){h("websocket closed before onclose event")}--r||e()})}(t[o])},r.prototype.onClose=function(){s.prototype.onClose.call(this)},r.prototype.doClose=function(){"undefined"!=typeof this.ws&&this.ws.close()},r.prototype.uri=function(){var t=this.query||{},e=this.secure?"wss":"ws",n="";this.port&&("wss"===e&&443!==Number(this.port)||"ws"===e&&80!==Number(this.port))&&(n=":"+this.port),this.timestampRequests&&(t[this.timestampParam]=u()),this.supportsBinary||(t.b64=1),t=c.encode(t),t.length&&(t="?"+t);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+n+this.path+t},r.prototype.check=function(){return!(!l||"__initialize"in l&&this.name===r.prototype.name)}},function(t,e){},function(t,e){var n=[].indexOf;t.exports=function(t,e){if(n)return t.indexOf(e);for(var r=0;r<t.length;++r)if(t[r]===e)return r;return-1}},function(t,e,n){"use strict";function r(t,e,n){this.io=t,this.nsp=e,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,this.flags={},n&&n.query&&(this.query=n.query),this.io.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=n(7),s=n(8),a=n(37),c=n(38),p=n(39),u=n(3)("socket.io-client:socket"),h=n(29),f=n(23);t.exports=e=r;var l={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},d=s.prototype.emit;s(r.prototype),r.prototype.subEvents=function(){if(!this.subs){var t=this.io;this.subs=[c(t,"open",p(this,"onopen")),c(t,"packet",p(this,"onpacket")),c(t,"close",p(this,"onclose"))]}},r.prototype.open=r.prototype.connect=function(){return this.connected?this:(this.subEvents(),this.io.open(),"open"===this.io.readyState&&this.onopen(),this.emit("connecting"),this)},r.prototype.send=function(){var t=a(arguments);return t.unshift("message"),this.emit.apply(this,t),this},r.prototype.emit=function(t){if(l.hasOwnProperty(t))return d.apply(this,arguments),this;var e=a(arguments),n={type:(void 0!==this.flags.binary?this.flags.binary:f(e))?i.BINARY_EVENT:i.EVENT,data:e};return n.options={},n.options.compress=!this.flags||!1!==this.flags.compress,"function"==typeof e[e.length-1]&&(u("emitting packet with ack id %d",this.ids),this.acks[this.ids]=e.pop(),n.id=this.ids++),this.connected?this.packet(n):this.sendBuffer.push(n),this.flags={},this},r.prototype.packet=function(t){t.nsp=this.nsp,this.io.packet(t)},r.prototype.onopen=function(){if(u("transport is open - connecting"),"/"!==this.nsp)if(this.query){var t="object"===o(this.query)?h.encode(this.query):this.query;u("sending connect packet with query %s",t),this.packet({type:i.CONNECT,query:t})}else this.packet({type:i.CONNECT})},r.prototype.onclose=function(t){u("close (%s)",t),this.connected=!1,this.disconnected=!0,delete this.id,this.emit("disconnect",t)},r.prototype.onpacket=function(t){var e=t.nsp===this.nsp,n=t.type===i.ERROR&&"/"===t.nsp;if(e||n)switch(t.type){case i.CONNECT:this.onconnect();break;case i.EVENT:this.onevent(t);break;case i.BINARY_EVENT:this.onevent(t);break;case i.ACK:this.onack(t);break;case i.BINARY_ACK:this.onack(t);break;case i.DISCONNECT:this.ondisconnect();break;case i.ERROR:this.emit("error",t.data)}},r.prototype.onevent=function(t){var e=t.data||[];u("emitting event %j",e),null!=t.id&&(u("attaching ack callback to event"),e.push(this.ack(t.id))),this.connected?d.apply(this,e):this.receiveBuffer.push(e)},r.prototype.ack=function(t){var e=this,n=!1;return function(){if(!n){n=!0;var r=a(arguments);u("sending ack %j",r),e.packet({type:f(r)?i.BINARY_ACK:i.ACK,id:t,data:r})}}},r.prototype.onack=function(t){var e=this.acks[t.id];"function"==typeof e?(u("calling ack %s with %j",t.id,t.data),e.apply(this,t.data),delete this.acks[t.id]):u("bad ack %s",t.id)},r.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emit("connect"),this.emitBuffered()},r.prototype.emitBuffered=function(){var t;for(t=0;t<this.receiveBuffer.length;t++)d.apply(this,this.receiveBuffer[t]);for(this.receiveBuffer=[],t=0;t<this.sendBuffer.length;t++)this.packet(this.sendBuffer[t]);this.sendBuffer=[]},r.prototype.ondisconnect=function(){u("server disconnect (%s)",this.nsp),this.destroy(),this.onclose("io server disconnect")},r.prototype.destroy=function(){if(this.subs){for(var t=0;t<this.subs.length;t++)this.subs[t].destroy();this.subs=null}this.io.destroy(this)},r.prototype.close=r.prototype.disconnect=function(){return this.connected&&(u("performing disconnect (%s)",this.nsp),this.packet({type:i.DISCONNECT})),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},r.prototype.compress=function(t){return this.flags.compress=t,this},r.prototype.binary=function(t){return this.flags.binary=t,this}},function(t,e){function n(t,e){var n=[];e=e||0;for(var r=e||0;r<t.length;r++)n[r-e]=t[r];return n}t.exports=n},function(t,e){"use strict";function n(t,e,n){return t.on(e,n),{destroy:function(){t.removeListener(e,n)}}}t.exports=n},function(t,e){var n=[].slice;t.exports=function(t,e){if("string"==typeof e&&(e=t[e]),"function"!=typeof e)throw new Error("bind() requires a function");var r=n.call(arguments,2);return function(){return e.apply(t,r.concat(n.call(arguments)))}}},function(t,e){function n(t){t=t||{},this.ms=t.min||100,this.max=t.max||1e4,this.factor=t.factor||2,this.jitter=t.jitter>0&&t.jitter<=1?t.jitter:0,this.attempts=0}t.exports=n,n.prototype.duration=function(){var t=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),n=Math.floor(e*this.jitter*t);t=0==(1&Math.floor(10*e))?t-n:t+n}return 0|Math.min(t,this.max)},n.prototype.reset=function(){this.attempts=0},n.prototype.setMin=function(t){this.ms=t},n.prototype.setMax=function(t){this.max=t},n.prototype.setJitter=function(t){this.jitter=t}}])});
//# sourceMappingURL=socket.io.js.map
/* eslint-disable */
!function(A){function I(A){"use strict";var I;void 0===(I=A)&&(I={});var e=I;"object"!=typeof e.sodium&&("object"==typeof global?e=global:"object"==typeof window&&(e=window)),"object"==typeof e.sodium&&"number"==typeof e.sodium.totalMemory&&(I.TOTAL_MEMORY=e.sodium.totalMemory);var g=I;return I.ready=new Promise(function(A,I){function e(A){X("NO_DYNAMIC_EXECUTION=1 was set, cannot eval")}function i(A,I){A||X("Assertion failed: "+I)}function B(A){var I=K["_"+A];return I||X("NO_DYNAMIC_EXECUTION=1 was set, cannot eval"),i(I,"Cannot call unknown function "+A+" (perhaps LLVM optimizations or closure removed it?)"),I}function t(A,I,e,g){switch("*"===(e=e||"i8").charAt(e.length-1)&&(e="i32"),e){case"i1":case"i8":aA[A>>0]=I;break;case"i16":CA[A>>1]=I;break;case"i32":cA[A>>2]=I;break;case"i64":tempI64=[I>>>0,(tempDouble=I,+HA(tempDouble)>=1?tempDouble>0?(0|RA(+SA(tempDouble/4294967296),4294967295))>>>0:~~+YA((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],cA[A>>2]=tempI64[0],cA[A+4>>2]=tempI64[1];break;case"float":EA[A>>2]=I;break;case"double":sA[A>>3]=I;break;default:X("invalid type for setValue: "+e)}}function r(A,I,e){switch("*"===(I=I||"i8").charAt(I.length-1)&&(I="i32"),I){case"i1":case"i8":return aA[A>>0];case"i16":return CA[A>>1];case"i32":case"i64":return cA[A>>2];case"float":return EA[A>>2];case"double":return sA[A>>3];default:X("invalid type for getValue: "+I)}return null}function a(A,I,e,g){var B,r;"number"==typeof A?(B=!0,r=A):(B=!1,r=A.length);var a,n="string"==typeof I?I:null;if(a=e==BA?g:["function"==typeof ZA?ZA:$.staticAlloc,$.stackAlloc,$.staticAlloc,$.dynamicAlloc][void 0===e?iA:e](Math.max(r,n?1:I.length)),B){var C;for(g=a,i(0==(3&a)),C=a+(-4&r);g<C;g+=4)cA[g>>2]=0;for(C=a+r;g<C;)aA[g++>>0]=0;return a}if("i8"===n)return A.subarray||A.slice?nA.set(A,a):nA.set(new Uint8Array(A),a),a;for(var o,c,Q,E=0;E<r;){var s=A[E];"function"==typeof s&&(s=$.getFunctionIndex(s)),0!==(o=n||I[E])?("i64"==o&&(o="i32"),t(a+E,s,o),Q!==o&&(c=$.getNativeTypeSize(o),Q=o),E+=c):E++}return a}function n(A,I){if(0===I||!A)return"";for(var e,g=0,i=0;e=nA[A+i>>0],g|=e,(0!=e||I)&&(i++,!I||i!=I););I||(I=i);var B="";if(g<128){for(var t;I>0;)t=String.fromCharCode.apply(String,nA.subarray(A,A+Math.min(I,1024))),B=B?B+t:t,A+=1024,I-=1024;return B}return K.UTF8ToString(A)}function C(A,I){for(var e=I;A[e];)++e;if(e-I>16&&A.subarray&&tA)return tA.decode(A.subarray(I,e));for(var g,i,B,t,r,a="";;){if(!(g=A[I++]))return a;if(128&g)if(i=63&A[I++],192!=(224&g))if(B=63&A[I++],224==(240&g)?g=(15&g)<<12|i<<6|B:(t=63&A[I++],240==(248&g)?g=(7&g)<<18|i<<12|B<<6|t:(r=63&A[I++],g=248==(252&g)?(3&g)<<24|i<<18|B<<12|t<<6|r:(1&g)<<30|i<<24|B<<18|t<<12|r<<6|63&A[I++])),g<65536)a+=String.fromCharCode(g);else{var n=g-65536;a+=String.fromCharCode(55296|n>>10,56320|1023&n)}else a+=String.fromCharCode((31&g)<<6|i);else a+=String.fromCharCode(g)}}function o(A,I,e,g){if(!(g>0))return 0;for(var i=e,B=e+g-1,t=0;t<A.length;++t){var r=A.charCodeAt(t);if(r>=55296&&r<=57343&&(r=65536+((1023&r)<<10)|1023&A.charCodeAt(++t)),r<=127){if(e>=B)break;I[e++]=r}else if(r<=2047){if(e+1>=B)break;I[e++]=192|r>>6,I[e++]=128|63&r}else if(r<=65535){if(e+2>=B)break;I[e++]=224|r>>12,I[e++]=128|r>>6&63,I[e++]=128|63&r}else if(r<=2097151){if(e+3>=B)break;I[e++]=240|r>>18,I[e++]=128|r>>12&63,I[e++]=128|r>>6&63,I[e++]=128|63&r}else if(r<=67108863){if(e+4>=B)break;I[e++]=248|r>>24,I[e++]=128|r>>18&63,I[e++]=128|r>>12&63,I[e++]=128|r>>6&63,I[e++]=128|63&r}else{if(e+5>=B)break;I[e++]=252|r>>30,I[e++]=128|r>>24&63,I[e++]=128|r>>18&63,I[e++]=128|r>>12&63,I[e++]=128|r>>6&63,I[e++]=128|63&r}}return I[e]=0,e-i}function c(A,I,e){return o(A,nA,I,e)}function Q(A){for(var I=0,e=0;e<A.length;++e){var g=A.charCodeAt(e);g>=55296&&g<=57343&&(g=65536+((1023&g)<<10)|1023&A.charCodeAt(++e)),g<=127?++I:I+=g<=2047?2:g<=65535?3:g<=2097151?4:g<=67108863?5:6}return I}function E(A){var I=K.___cxa_demangle||K.__cxa_demangle;if(I){try{var e=A.substr(1),g=Q(e)+1,i=ZA(g);c(e,i,g);var B=ZA(4),t=I(i,0,0,B);if(0===r(B,"i32")&&t)return n(t)}catch(A){}finally{i&&jA(i),B&&jA(B),t&&jA(t)}return A}return $.warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling"),A}function s(A){return A.replace(/__Z[\w\d_]+/g,function(A){var I=E(A);return A===I?A:A+" ["+I+"]"})}function h(){var A=new Error;if(!A.stack){try{throw new Error(0)}catch(I){A=I}if(!A.stack)return"(no stack trace available)"}return A.stack.toString()}function y(){var A=h();return K.extraStackTrace&&(A+="\n"+K.extraStackTrace()),s(A)}function f(A,I){return A%I>0&&(A+=I-A%I),A}function _(A){K.buffer=rA=A}function p(){K.HEAP8=aA=new Int8Array(rA),K.HEAP16=CA=new Int16Array(rA),K.HEAP32=cA=new Int32Array(rA),K.HEAPU8=nA=new Uint8Array(rA),K.HEAPU16=oA=new Uint16Array(rA),K.HEAPU32=QA=new Uint32Array(rA),K.HEAPF32=EA=new Float32Array(rA),K.HEAPF64=sA=new Float64Array(rA)}function w(){X("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value "+dA+", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")}function l(){w()}function u(A){for(;A.length>0;){var I=A.shift();if("function"!=typeof I){var e=I.func;"number"==typeof e?void 0===I.arg?K.dynCall_v(e):K.dynCall_vi(e,I.arg):e(void 0===I.arg?null:I.arg)}else I()}}function d(){if(K.preRun)for("function"==typeof K.preRun&&(K.preRun=[K.preRun]);K.preRun.length;)G(K.preRun.shift());u(DA)}function D(){FA||(FA=!0,u(vA))}function v(){u(bA)}function b(){u(kA),mA=!0}function k(){if(K.postRun)for("function"==typeof K.postRun&&(K.postRun=[K.postRun]);K.postRun.length;)F(K.postRun.shift());u(GA)}function G(A){DA.unshift(A)}function F(A){GA.unshift(A)}function m(A,I){aA.set(A,I)}function M(A,I,e){for(var g=0;g<A.length;++g)aA[I++>>0]=A.charCodeAt(g);e||(aA[I>>0]=0)}function H(A){NA++,K.monitorRunDependencies&&K.monitorRunDependencies(NA)}function Y(A){if(NA--,K.monitorRunDependencies&&K.monitorRunDependencies(NA),0==NA&&(null!==UA&&(clearInterval(UA),UA=null),JA)){var I=JA;JA=null,I()}}function S(A){return K.___errno_location&&(cA[K.___errno_location()>>2]=A),A}function R(A,I,e){var g=e>0?e:Q(A)+1,i=new Array(g),B=o(A,i,0,i.length);return I&&(i.length=B),i}function N(A){for(var I=[],e=0;e<A.length;e++){var g=A[e];g>255&&(KA&&i(!1,"Character code "+g+" ("+String.fromCharCode(g)+")  at offset "+e+" not in 0x00-0xFF."),g&=255),I.push(String.fromCharCode(g))}return I.join("")}function U(A){if("boolean"==typeof Z&&Z){var I;try{I=Buffer.from(A,"base64")}catch(e){I=new Buffer(A,"base64")}return new Uint8Array(I.buffer,I.byteOffset,I.byteLength)}try{for(var e=VA(A),g=new Uint8Array(e.length),i=0;i<e.length;++i)g[i]=e.charCodeAt(i);return g}catch(A){throw new Error("Converting base64 string to bytes failed.")}}function J(A){var I="data:application/octet-stream;base64,";if(String.prototype.startsWith?A.startsWith(I):0===A.indexOf(I))return U(A.slice(I.length))}function P(A){this.name="ExitStatus",this.message="Program terminated with exit("+A+")",this.status=A}function L(A){function I(){K.calledRun||(K.calledRun=!0,eA||(D(),v(),K.onRuntimeInitialized&&K.onRuntimeInitialized(),K._main&&BI&&K.callMain(A),k()))}A=A||K.arguments,null===eI&&(eI=Date.now()),NA>0||(d(),NA>0||K.calledRun||(K.setStatus?(K.setStatus("Running..."),setTimeout(function(){setTimeout(function(){K.setStatus("")},1),I()},1)):I()))}function x(A,I){I&&K.noExitRuntime||(K.noExitRuntime||(eA=!0,gA=A,_A=II,b(),K.onExit&&K.onExit(A)),Z&&process.exit(A),K.quit(A,new P(A)))}function X(A){K.onAbort&&K.onAbort(A),void 0!==A?(K.print(A),K.printErr(A),A=JSON.stringify(A)):A="",eA=!0,gA=1;var I="abort("+A+") at "+y()+"\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";throw iI&&iI.forEach(function(e){I=e(I,A)}),I}(K=g).onAbort=I,K.onRuntimeInitialized=A;var K;K||(K=(void 0!==K?K:null)||{});var T,V={};for(T in K)K.hasOwnProperty(T)&&(V[T]=K[T]);var q=!1,j=!1,Z=!1,W=!1;if(K.ENVIRONMENT)if("WEB"===K.ENVIRONMENT)q=!0;else if("WORKER"===K.ENVIRONMENT)j=!0;else if("NODE"===K.ENVIRONMENT)Z=!0;else{if("SHELL"!==K.ENVIRONMENT)throw new Error("The provided Module['ENVIRONMENT'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.");W=!0}else q="object"==typeof window,j="function"==typeof importScripts,Z="object"==typeof process&&"function"==typeof require&&!q&&!j,W=!q&&!Z&&!j;if(Z){K.print||(K.print=console.log),K.printErr||(K.printErr=console.warn);var z,O;K.read=function(A,I){var e;return(e=J(A))||(z||(z=require("fs")),O||(O=require("path")),A=O.normalize(A),e=z.readFileSync(A)),I?e:e.toString()},K.readBinary=function(A){var I=K.read(A,!0);return I.buffer||(I=new Uint8Array(I)),i(I.buffer),I},K.load=function(A){e(read(A))},K.thisProgram||(process.argv.length>1?K.thisProgram=process.argv[1].replace(/\\/g,"/"):K.thisProgram="unknown-program"),K.arguments=process.argv.slice(2),"undefined"!=typeof module&&(module.exports=K),process.on("uncaughtException",function(A){if(!(A instanceof P))throw A}),K.inspect=function(){return"[Emscripten Module object]"}}else if(W)K.print||(K.print=print),"undefined"!=typeof printErr&&(K.printErr=printErr),"undefined"!=typeof read?K.read=function(A){var I=J(A);return I?N(I):read(A)}:K.read=function(){throw"no read() available"},K.readBinary=function(A){var I;return(I=J(A))?I:"function"==typeof readbuffer?new Uint8Array(readbuffer(A)):(I=read(A,"binary"),i("object"==typeof I),I)},"undefined"!=typeof scriptArgs?K.arguments=scriptArgs:void 0!==arguments&&(K.arguments=arguments),"function"==typeof quit&&(K.quit=function(A,I){quit(A)});else{if(!q&&!j)throw new Error("Unknown runtime environment. Where are we?");K.read=function(A){try{var I=new XMLHttpRequest;return I.open("GET",A,!1),I.send(null),I.responseText}catch(I){var e=J(A);if(e)return N(e);throw I}},j&&(K.readBinary=function(A){try{var I=new XMLHttpRequest;return I.open("GET",A,!1),I.responseType="arraybuffer",I.send(null),new Uint8Array(I.response)}catch(I){var e=J(A);if(e)return e;throw I}}),K.readAsync=function(A,I,e){var g=new XMLHttpRequest;g.open("GET",A,!0),g.responseType="arraybuffer",g.onload=function(){if(200==g.status||0==g.status&&g.response)I(g.response);else{var i=J(A);i?I(i.buffer):e()}},g.onerror=e,g.send(null)},void 0!==arguments&&(K.arguments=arguments),"undefined"!=typeof console?(K.print||(K.print=function(A){}),K.printErr||(K.printErr=function(A){})):K.print||(K.print=function(A){}),j&&(K.load=importScripts),void 0===K.setWindowTitle&&(K.setWindowTitle=function(A){document.title=A})}!K.load&&K.read&&(K.load=function(A){e(K.read(A))}),K.print||(K.print=function(){}),K.printErr||(K.printErr=K.print),K.arguments||(K.arguments=[]),K.thisProgram||(K.thisProgram="./this.program"),K.quit||(K.quit=function(A,I){throw I}),K.print=K.print,K.printErr=K.printErr,K.preRun=[],K.postRun=[];for(T in V)V.hasOwnProperty(T)&&(K[T]=V[T]);V=void 0;var $={setTempRet0:function(A){return tempRet0=A,A},getTempRet0:function(){return tempRet0},stackSave:function(){return _A},stackRestore:function(A){_A=A},getNativeTypeSize:function(A){switch(A){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:if("*"===A[A.length-1])return $.QUANTUM_SIZE;if("i"===A[0]){var I=parseInt(A.substr(1));return i(I%8==0),I/8}return 0}},getNativeFieldSize:function(A){return Math.max($.getNativeTypeSize(A),$.QUANTUM_SIZE)},STACK_ALIGN:16,prepVararg:function(A,I){return"double"===I||"i64"===I?7&A&&(i(4==(7&A)),A+=4):i(0==(3&A)),A},getAlignSize:function(A,I,e){return e||"i64"!=A&&"double"!=A?A?Math.min(I||(A?$.getNativeFieldSize(A):0),$.QUANTUM_SIZE):Math.min(I,8):8},dynCall:function(A,I,e){return e&&e.length?K["dynCall_"+A].apply(null,[I].concat(e)):K["dynCall_"+A].call(null,I)},functionPointers:[null,null,null,null,null,null,null,null],addFunction:function(A){for(var I=0;I<$.functionPointers.length;I++)if(!$.functionPointers[I])return $.functionPointers[I]=A,1*(1+I);throw"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS."},removeFunction:function(A){$.functionPointers[(A-1)/1]=null},warnOnce:function(A){$.warnOnce.shown||($.warnOnce.shown={}),$.warnOnce.shown[A]||($.warnOnce.shown[A]=1,K.printErr(A))},funcWrappers:{},getFuncWrapper:function(A,I){if(A){i(I),$.funcWrappers[I]||($.funcWrappers[I]={});var e=$.funcWrappers[I];return e[A]||(1===I.length?e[A]=function(){return $.dynCall(I,A)}:2===I.length?e[A]=function(e){return $.dynCall(I,A,[e])}:e[A]=function(){return $.dynCall(I,A,Array.prototype.slice.call(arguments))}),e[A]}},getCompilerSetting:function(A){throw"You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work"},stackAlloc:function(A){var I=_A;return _A=_A+A|0,_A=_A+15&-16,I},staticAlloc:function(A){var I=yA;return yA=yA+A|0,yA=yA+15&-16,I},dynamicAlloc:function(A){var I=cA[lA>>2],e=-16&(I+A+15|0);return cA[lA>>2]=e,e>=dA&&!l()?(cA[lA>>2]=I,0):I},alignMemory:function(A,I){return A=Math.ceil(A/(I||16))*(I||16)},makeBigInt:function(A,I,e){return e?+(A>>>0)+4294967296*+(I>>>0):+(A>>>0)+4294967296*+(0|I)},GLOBAL_BASE:1024,QUANTUM_SIZE:4,__dummy__:0};K.Runtime=$;var AA,IA,eA=0,gA=0;!function(){var A={stackSave:function(){$.stackSave()},stackRestore:function(){$.stackRestore()},arrayToC:function(A){var I=$.stackAlloc(A.length);return m(A,I),I},stringToC:function(A){var I=0;if(null!==A&&void 0!==A&&0!==A){var e=1+(A.length<<2);c(A,I=$.stackAlloc(e),e)}return I}},I={string:A.stringToC,array:A.arrayToC};IA=function(A,e,g,i,t){var r=B(A),a=[],C=0;if(i)for(var o=0;o<i.length;o++){var c=I[g[o]];c?(0===C&&(C=$.stackSave()),a[o]=c(i[o])):a[o]=i[o]}var Q=r.apply(null,a);return"string"===e&&(Q=n(Q)),0!==C&&$.stackRestore(C),Q},AA=function(A,I,e){return function(){return IA(A,I,e,arguments)}}}(),K.ccall=IA,K.cwrap=AA,K.setValue=t,K.getValue=r;var iA=2,BA=4;K.ALLOC_NORMAL=0,K.ALLOC_STACK=1,K.ALLOC_STATIC=iA,K.ALLOC_DYNAMIC=3,K.ALLOC_NONE=BA,K.allocate=a,K.getMemory=function(A){return fA?FA?ZA(A):$.dynamicAlloc(A):$.staticAlloc(A)},K.Pointer_stringify=n,K.AsciiToString=function(A){for(var I="";;){var e=aA[A++>>0];if(!e)return I;I+=String.fromCharCode(e)}},K.stringToAscii=function(A,I){return M(A,I,!1)};var tA="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;K.UTF8ArrayToString=C,K.UTF8ToString=function(A){return C(nA,A)},K.stringToUTF8Array=o,K.stringToUTF8=c,K.lengthBytesUTF8=Q,"undefined"!=typeof TextDecoder&&new TextDecoder("utf-16le"),K.stackTrace=y;var rA,aA,nA,CA,oA,cA,QA,EA,sA,hA,yA,fA,_A,pA,wA,lA;hA=yA=_A=pA=wA=lA=0,fA=!1;var uA=K.TOTAL_STACK||5242880,dA=K.TOTAL_MEMORY||16777216;if(dA<uA&&K.printErr("TOTAL_MEMORY should be larger than TOTAL_STACK, was "+dA+"! (TOTAL_STACK="+uA+")"),K.buffer?rA=K.buffer:"object"==typeof WebAssembly&&"function"==typeof WebAssembly.Memory?(K.wasmMemory=new WebAssembly.Memory({initial:dA/65536,maximum:dA/65536}),rA=K.wasmMemory.buffer):rA=new ArrayBuffer(dA),p(),cA[0]=1668509029,CA[1]=25459,115!==nA[2]||99!==nA[3])throw"Runtime error: expected the system to be little-endian!";K.HEAP=void 0,K.buffer=rA,K.HEAP8=aA,K.HEAP16=CA,K.HEAP32=cA,K.HEAPU8=nA,K.HEAPU16=oA,K.HEAPU32=QA,K.HEAPF32=EA,K.HEAPF64=sA;var DA=[],vA=[],bA=[],kA=[],GA=[],FA=!1,mA=!1;if(K.addOnPreRun=G,K.addOnInit=function(A){vA.unshift(A)},K.addOnPreMain=function(A){bA.unshift(A)},K.addOnExit=function(A){kA.unshift(A)},K.addOnPostRun=F,K.writeStringToMemory=function(A,I,e){$.warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");var g,i;e&&(i=I+Q(A),g=aA[i]),c(A,I,1/0),e&&(aA[i]=g)},K.writeArrayToMemory=m,K.writeAsciiToMemory=M,Math.imul&&-5===Math.imul(4294967295,5)||(Math.imul=function(A,I){var e=65535&A,g=65535&I;return e*g+((A>>>16)*g+e*(I>>>16)<<16)|0}),Math.imul=Math.imul,!Math.fround){var MA=new Float32Array(1);Math.fround=function(A){return MA[0]=A,MA[0]}}Math.fround=Math.fround,Math.clz32||(Math.clz32=function(A){A>>>=0;for(var I=0;I<32;I++)if(A&1<<31-I)return I;return 32}),Math.clz32=Math.clz32,Math.trunc||(Math.trunc=function(A){return A<0?Math.ceil(A):Math.floor(A)}),Math.trunc=Math.trunc;var HA=Math.abs,YA=(Math.cos,Math.sin,Math.tan,Math.acos,Math.asin,Math.atan,Math.atan2,Math.exp,Math.log,Math.sqrt,Math.ceil),SA=Math.floor,RA=(Math.pow,Math.imul,Math.fround,Math.round,Math.min),NA=(Math.clz32,Math.trunc,0),UA=null,JA=null;K.addRunDependency=H,K.removeRunDependency=Y,K.preloadedImages={},K.preloadedAudios={};var PA=null;!function(){function A(A){var I=K.buffer;A.byteLength<I.byteLength&&K.printErr("the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here");var e=new Int8Array(I),g=new Int8Array(A);PA||e.set(g.subarray(K.STATIC_BASE,K.STATIC_BASE+K.STATIC_BUMP),K.STATIC_BASE),g.set(e),_(A),p()}function I(A){return A}function e(){try{if(K.wasmBinary)return new Uint8Array(K.wasmBinary);var A=J(r);if(A)return A;if(K.readBinary)return K.readBinary(r);throw"on the web, we need the wasm binary to be preloaded and set on Module['wasmBinary']. emcc.py will do that for you when generating HTML (but not JS)"}catch(A){X(A)}}function g(){return K.wasmBinary||!q&&!j||"function"!=typeof fetch?new Promise(function(A,I){A(e())}):fetch(r,{credentials:"same-origin"}).then(function(A){if(!A.ok)throw"failed to load wasm binary file at '"+r+"'";return A.arrayBuffer()}).catch(function(){return e()})}function i(I,e,i){function B(I){(C=I.exports).memory&&A(C.memory),K.asm=C,K.usingWasm=!0,Y("wasm-instantiate")}function t(A){B(A.instance)}function a(A){g().then(function(A){return WebAssembly.instantiate(A,n)}).then(A).catch(function(A){K.printErr("failed to asynchronously prepare wasm: "+A),X(A)})}if("object"!=typeof WebAssembly)return K.printErr("no native wasm support detected"),!1;if(!(K.wasmMemory instanceof WebAssembly.Memory))return K.printErr("no native wasm Memory in use"),!1;if(e.memory=K.wasmMemory,n.global={NaN:NaN,Infinity:1/0},n["global.Math"]=I.Math,n.env=e,H("wasm-instantiate"),K.instantiateWasm)try{return K.instantiateWasm(n,B)}catch(A){return K.printErr("Module.instantiateWasm callback failed with error: "+A),!1}return K.wasmBinary||"function"!=typeof WebAssembly.instantiateStreaming||0===r.indexOf("data:")||"function"!=typeof fetch?a(t):WebAssembly.instantiateStreaming(fetch(r,{credentials:"same-origin"}),n).then(t).catch(function(A){K.printErr("wasm streaming compile failed: "+A),K.printErr("falling back to ArrayBuffer instantiation"),a(t)}),{}}var B=K.wasmJSMethod||"native-wasm";K.wasmJSMethod=B;var t=K.wasmTextFile||"",r=K.wasmBinaryFile||"data:application/octet-stream;base64,AGFzbQEAAAAByQM0YAABf2AEf39/fwBgAX8AYAAAYAF/AX9gA39/fwF/YAJ/fwBgCn9/f39+f35/f38Bf2ACf34AYAl/f39+f35/f38Bf2AJf39/fn9/fn9/AX9gCX9/f39+f35/fwF/YAR/f35/AX9gA39/fgBgBH9/fn8AYAJ/fwF/YAZ/f39+f38Bf2AHf39/fn9/fwF/YAV/f35/fwF/YAZ/f35/f38Bf2ADf39/AGABfwF+YAN/f38BfmAEf39/fwF/YAN/f34Bf2ACfn8BfmAFf39/f38AYAZ/f39/fn8AYAV/f39/fwF/YAJ+fgF+YAx/f39/f39/f39/f38Bf2AHf35/fn9+fwF/YAV/f35+fwF/YAR/fn9/AX9gCH9+f35/fn9/AX9gBn9/fn5/fwF/YAN/fn8Bf2AIf39/f35/fn8Bf2AIf39/f39+f34Bf2AFf39/fn8Bf2AGf39/fn9/AGAFf39/fn8AYAR/fn9/AGAFf39+f38AYAZ/f35/f38AYAZ/f35/fn8AYAR/f39+AGAHf39/f39/fwF/YAh/f39/f39/fwF/YAt/f39/f39/f39/fwF/YAZ/f39/f38Bf2AKf39/f39/f39/fwF/Ar8CEANlbnYORFlOQU1JQ1RPUF9QVFIDfwADZW52CFNUQUNLVE9QA38AA2VudglTVEFDS19NQVgDfwADZW52DWVubGFyZ2VNZW1vcnkAAANlbnYOZ2V0VG90YWxNZW1vcnkAAANlbnYXYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkAAANlbnYOX19fYXNzZXJ0X2ZhaWwAAQNlbnYLX19fc2V0RXJyTm8AAgNlbnYGX2Fib3J0AAMDZW52F19lbXNjcmlwdGVuX2FzbV9jb25zdF9pAAQDZW52Fl9lbXNjcmlwdGVuX21lbWNweV9iaWcABQNlbnYIX3N5c2NvbmYABANlbnYGbWVtb3J5AgGAAoACA2VudgV0YWJsZQFwAAADZW52Cm1lbW9yeUJhc2UDfwADZW52CXRhYmxlQmFzZQN/AAP3AvUCBAACBgYCAAcICQcJCgsKCwAAAAACAAcJCgsADAwGDQYGDgwFDwUQERITEBESEwwUEgAFBQYVFgYGBgYUFBQUAgYEFAYEDwYGBgYGFAEGBgYUFAYCBgIUDxQGFAQGBAQBAgQXBA8GFBQUAAAQFxgFBhUZBgIGAgYGAQ0IGgUbGhAcFw0FGAINAQYVBgYUCA0SEgUPHBwGDQYODAYNDQYGBgYGBgYXBgQGBhQPDwUPFwYGFBQUHQIPHhcBHyAYIR8gGAAAAAAAAAAAAAAAACIgIxgkAA8FBQ8UFAYFDxASEBIFAgUCJQYmAAAMAg4ZAAUPJycnDAQYFwUBBRQGDw8SDCcGKAIpJxQqKywqKi0sBhQuFCsrDwUPAAMEBhQIFy8PAhwEBDAEBBwAAwMCBgUPAgMcFwAAKi0EAgQGBA8ABQQPDwMFBQUEMTExHjExMR4xMTEeHBwwLy8yMC8vMhwyLxcXMjEvMBcXLzIvMjMzHDIyMhccFAYfBn8BIwALfwEjAQt/ASMCC38BQQALfwFBAAt/AUEACwf0LsMBJF9jcnlwdG9fYWVhZF9jaGFjaGEyMHBvbHkxMzA1X2FieXRlcwAcJV9jcnlwdG9fYWVhZF9jaGFjaGEyMHBvbHkxMzA1X2RlY3J5cHQA0AIuX2NyeXB0b19hZWFkX2NoYWNoYTIwcG9seTEzMDVfZGVjcnlwdF9kZXRhY2hlZADRAiVfY3J5cHRvX2FlYWRfY2hhY2hhMjBwb2x5MTMwNV9lbmNyeXB0ANICLl9jcnlwdG9fYWVhZF9jaGFjaGEyMHBvbHkxMzA1X2VuY3J5cHRfZGV0YWNoZWQA0wIpX2NyeXB0b19hZWFkX2NoYWNoYTIwcG9seTEzMDVfaWV0Zl9hYnl0ZXMAHCpfY3J5cHRvX2FlYWRfY2hhY2hhMjBwb2x5MTMwNV9pZXRmX2RlY3J5cHQA1AIzX2NyeXB0b19hZWFkX2NoYWNoYTIwcG9seTEzMDVfaWV0Zl9kZWNyeXB0X2RldGFjaGVkANUCKl9jcnlwdG9fYWVhZF9jaGFjaGEyMHBvbHkxMzA1X2lldGZfZW5jcnlwdADWAjNfY3J5cHRvX2FlYWRfY2hhY2hhMjBwb2x5MTMwNV9pZXRmX2VuY3J5cHRfZGV0YWNoZWQA1wIrX2NyeXB0b19hZWFkX2NoYWNoYTIwcG9seTEzMDVfaWV0Zl9rZXlieXRlcwAZKV9jcnlwdG9fYWVhZF9jaGFjaGEyMHBvbHkxMzA1X2lldGZfa2V5Z2VuAB0sX2NyeXB0b19hZWFkX2NoYWNoYTIwcG9seTEzMDVfaWV0Zl9ucHViYnl0ZXMAGixfY3J5cHRvX2FlYWRfY2hhY2hhMjBwb2x5MTMwNV9pZXRmX25zZWNieXRlcwAbJl9jcnlwdG9fYWVhZF9jaGFjaGEyMHBvbHkxMzA1X2tleWJ5dGVzABkkX2NyeXB0b19hZWFkX2NoYWNoYTIwcG9seTEzMDVfa2V5Z2VuAB0nX2NyeXB0b19hZWFkX2NoYWNoYTIwcG9seTEzMDVfbnB1YmJ5dGVzAB4nX2NyeXB0b19hZWFkX2NoYWNoYTIwcG9seTEzMDVfbnNlY2J5dGVzABsqX2NyeXB0b19hZWFkX3hjaGFjaGEyMHBvbHkxMzA1X2lldGZfYWJ5dGVzABwrX2NyeXB0b19hZWFkX3hjaGFjaGEyMHBvbHkxMzA1X2lldGZfZGVjcnlwdADYAjRfY3J5cHRvX2FlYWRfeGNoYWNoYTIwcG9seTEzMDVfaWV0Zl9kZWNyeXB0X2RldGFjaGVkANkCK19jcnlwdG9fYWVhZF94Y2hhY2hhMjBwb2x5MTMwNV9pZXRmX2VuY3J5cHQA2gI0X2NyeXB0b19hZWFkX3hjaGFjaGEyMHBvbHkxMzA1X2lldGZfZW5jcnlwdF9kZXRhY2hlZADbAixfY3J5cHRvX2FlYWRfeGNoYWNoYTIwcG9seTEzMDVfaWV0Zl9rZXlieXRlcwAZKl9jcnlwdG9fYWVhZF94Y2hhY2hhMjBwb2x5MTMwNV9pZXRmX2tleWdlbgAdLV9jcnlwdG9fYWVhZF94Y2hhY2hhMjBwb2x5MTMwNV9pZXRmX25wdWJieXRlcwAjLV9jcnlwdG9fYWVhZF94Y2hhY2hhMjBwb2x5MTMwNV9pZXRmX25zZWNieXRlcwAbDF9jcnlwdG9fYXV0aADcAhJfY3J5cHRvX2F1dGhfYnl0ZXMAGRVfY3J5cHRvX2F1dGhfa2V5Ynl0ZXMAGRNfY3J5cHRvX2F1dGhfa2V5Z2VuAB0TX2NyeXB0b19hdXRoX3ZlcmlmeQDdAhRfY3J5cHRvX2JveF9iZWZvcmVubQAuGV9jcnlwdG9fYm94X2JlZm9yZW5tYnl0ZXMAGRRfY3J5cHRvX2JveF9kZXRhY2hlZADeAhxfY3J5cHRvX2JveF9kZXRhY2hlZF9hZnRlcm5tAN8CEF9jcnlwdG9fYm94X2Vhc3kA4AIYX2NyeXB0b19ib3hfZWFzeV9hZnRlcm5tAOECE19jcnlwdG9fYm94X2tleXBhaXIALRRfY3J5cHRvX2JveF9tYWNieXRlcwAcFl9jcnlwdG9fYm94X25vbmNlYnl0ZXMAIxlfY3J5cHRvX2JveF9vcGVuX2RldGFjaGVkAOICIV9jcnlwdG9fYm94X29wZW5fZGV0YWNoZWRfYWZ0ZXJubQDjAhVfY3J5cHRvX2JveF9vcGVuX2Vhc3kA5AIdX2NyeXB0b19ib3hfb3Blbl9lYXN5X2FmdGVybm0A5QIaX2NyeXB0b19ib3hfcHVibGlja2V5Ynl0ZXMAGRBfY3J5cHRvX2JveF9zZWFsAOYCFV9jcnlwdG9fYm94X3NlYWxfb3BlbgDnAhVfY3J5cHRvX2JveF9zZWFsYnl0ZXMAOhpfY3J5cHRvX2JveF9zZWNyZXRrZXlieXRlcwAZGF9jcnlwdG9fYm94X3NlZWRfa2V5cGFpcgAsFV9jcnlwdG9fYm94X3NlZWRieXRlcwAZFl9jcnlwdG9fY29yZV9oY2hhY2hhMjAAayFfY3J5cHRvX2NvcmVfaGNoYWNoYTIwX2NvbnN0Ynl0ZXMAHCFfY3J5cHRvX2NvcmVfaGNoYWNoYTIwX2lucHV0Ynl0ZXMAHB9fY3J5cHRvX2NvcmVfaGNoYWNoYTIwX2tleWJ5dGVzABkiX2NyeXB0b19jb3JlX2hjaGFjaGEyMF9vdXRwdXRieXRlcwAZE19jcnlwdG9fZ2VuZXJpY2hhc2gA6AIZX2NyeXB0b19nZW5lcmljaGFzaF9ieXRlcwAZHV9jcnlwdG9fZ2VuZXJpY2hhc2hfYnl0ZXNfbWF4AHIdX2NyeXB0b19nZW5lcmljaGFzaF9ieXRlc19taW4AHBlfY3J5cHRvX2dlbmVyaWNoYXNoX2ZpbmFsAHcYX2NyeXB0b19nZW5lcmljaGFzaF9pbml0AHUcX2NyeXB0b19nZW5lcmljaGFzaF9rZXlieXRlcwAZIF9jcnlwdG9fZ2VuZXJpY2hhc2hfa2V5Ynl0ZXNfbWF4AHIgX2NyeXB0b19nZW5lcmljaGFzaF9rZXlieXRlc19taW4AHBpfY3J5cHRvX2dlbmVyaWNoYXNoX2tleWdlbgAdHl9jcnlwdG9fZ2VuZXJpY2hhc2hfc3RhdGVieXRlcwBzGl9jcnlwdG9fZ2VuZXJpY2hhc2hfdXBkYXRlAOkCDF9jcnlwdG9faGFzaADqAhJfY3J5cHRvX2hhc2hfYnl0ZXMAchVfY3J5cHRvX2tkZl9ieXRlc19tYXgAchVfY3J5cHRvX2tkZl9ieXRlc19taW4AHBhfY3J5cHRvX2tkZl9jb250ZXh0Ynl0ZXMAHhtfY3J5cHRvX2tkZl9kZXJpdmVfZnJvbV9rZXkA6wIUX2NyeXB0b19rZGZfa2V5Ynl0ZXMAGRJfY3J5cHRvX2tkZl9rZXlnZW4AHR5fY3J5cHRvX2t4X2NsaWVudF9zZXNzaW9uX2tleXMAnAESX2NyeXB0b19reF9rZXlwYWlyAJsBGV9jcnlwdG9fa3hfcHVibGlja2V5Ynl0ZXMAGRlfY3J5cHRvX2t4X3NlY3JldGtleWJ5dGVzABkXX2NyeXB0b19reF9zZWVkX2tleXBhaXIAmgEUX2NyeXB0b19reF9zZWVkYnl0ZXMAGR5fY3J5cHRvX2t4X3NlcnZlcl9zZXNzaW9uX2tleXMAnQEaX2NyeXB0b19reF9zZXNzaW9ua2V5Ynl0ZXMAGQ5fY3J5cHRvX3B3aGFzaADsAhxfY3J5cHRvX3B3aGFzaF9hbGdfYXJnb24yaTEzAMoBHV9jcnlwdG9fcHdoYXNoX2FsZ19hcmdvbjJpZDEzAMsBGl9jcnlwdG9fcHdoYXNoX2FsZ19kZWZhdWx0AMsBGF9jcnlwdG9fcHdoYXNoX2J5dGVzX21heADMARhfY3J5cHRvX3B3aGFzaF9ieXRlc19taW4AHCNfY3J5cHRvX3B3aGFzaF9tZW1saW1pdF9pbnRlcmFjdGl2ZQDRARtfY3J5cHRvX3B3aGFzaF9tZW1saW1pdF9tYXgA0AEbX2NyeXB0b19wd2hhc2hfbWVtbGltaXRfbWluAM8BIF9jcnlwdG9fcHdoYXNoX21lbWxpbWl0X21vZGVyYXRlANMBIV9jcnlwdG9fcHdoYXNoX21lbWxpbWl0X3NlbnNpdGl2ZQDVASNfY3J5cHRvX3B3aGFzaF9vcHNsaW1pdF9pbnRlcmFjdGl2ZQDLARtfY3J5cHRvX3B3aGFzaF9vcHNsaW1pdF9tYXgAzAEbX2NyeXB0b19wd2hhc2hfb3BzbGltaXRfbWluAMoBIF9jcnlwdG9fcHdoYXNoX29wc2xpbWl0X21vZGVyYXRlANIBIV9jcnlwdG9fcHdoYXNoX29wc2xpbWl0X3NlbnNpdGl2ZQDUARlfY3J5cHRvX3B3aGFzaF9wYXNzd2RfbWF4AMwBGV9jcnlwdG9fcHdoYXNoX3Bhc3N3ZF9taW4AGxhfY3J5cHRvX3B3aGFzaF9wcmltaXRpdmUA2wEYX2NyeXB0b19wd2hhc2hfc2FsdGJ5dGVzABwSX2NyeXB0b19wd2hhc2hfc3RyAO0CFl9jcnlwdG9fcHdoYXNoX3N0cl9hbGcA7gIfX2NyeXB0b19wd2hhc2hfc3RyX25lZWRzX3JlaGFzaADvAhlfY3J5cHRvX3B3aGFzaF9zdHJfdmVyaWZ5APACF19jcnlwdG9fcHdoYXNoX3N0cmJ5dGVzAM0BGF9jcnlwdG9fcHdoYXNoX3N0cnByZWZpeADOARJfY3J5cHRvX3NjYWxhcm11bHQA3QEXX2NyeXB0b19zY2FsYXJtdWx0X2Jhc2UA3AEYX2NyeXB0b19zY2FsYXJtdWx0X2J5dGVzABkeX2NyeXB0b19zY2FsYXJtdWx0X3NjYWxhcmJ5dGVzABkaX2NyeXB0b19zZWNyZXRib3hfZGV0YWNoZWQA8QIWX2NyeXB0b19zZWNyZXRib3hfZWFzeQDyAhpfY3J5cHRvX3NlY3JldGJveF9rZXlieXRlcwAZGF9jcnlwdG9fc2VjcmV0Ym94X2tleWdlbgAdGl9jcnlwdG9fc2VjcmV0Ym94X21hY2J5dGVzABwcX2NyeXB0b19zZWNyZXRib3hfbm9uY2VieXRlcwAjH19jcnlwdG9fc2VjcmV0Ym94X29wZW5fZGV0YWNoZWQA8wIbX2NyeXB0b19zZWNyZXRib3hfb3Blbl9lYXN5APQCLV9jcnlwdG9fc2VjcmV0c3RyZWFtX3hjaGFjaGEyMHBvbHkxMzA1X2FieXRlcwDxATJfY3J5cHRvX3NlY3JldHN0cmVhbV94Y2hhY2hhMjBwb2x5MTMwNV9oZWFkZXJieXRlcwAjMF9jcnlwdG9fc2VjcmV0c3RyZWFtX3hjaGFjaGEyMHBvbHkxMzA1X2luaXRfcHVsbADrATBfY3J5cHRvX3NlY3JldHN0cmVhbV94Y2hhY2hhMjBwb2x5MTMwNV9pbml0X3B1c2gA6QEvX2NyeXB0b19zZWNyZXRzdHJlYW1feGNoYWNoYTIwcG9seTEzMDVfa2V5Ynl0ZXMAGS1fY3J5cHRvX3NlY3JldHN0cmVhbV94Y2hhY2hhMjBwb2x5MTMwNV9rZXlnZW4AHTdfY3J5cHRvX3NlY3JldHN0cmVhbV94Y2hhY2hhMjBwb2x5MTMwNV9tZXNzYWdlYnl0ZXNfbWF4AMwBK19jcnlwdG9fc2VjcmV0c3RyZWFtX3hjaGFjaGEyMHBvbHkxMzA1X3B1bGwA9QIrX2NyeXB0b19zZWNyZXRzdHJlYW1feGNoYWNoYTIwcG9seTEzMDVfcHVzaAD2AixfY3J5cHRvX3NlY3JldHN0cmVhbV94Y2hhY2hhMjBwb2x5MTMwNV9yZWtleQDsATFfY3J5cHRvX3NlY3JldHN0cmVhbV94Y2hhY2hhMjBwb2x5MTMwNV9zdGF0ZWJ5dGVzAPABMF9jcnlwdG9fc2VjcmV0c3RyZWFtX3hjaGFjaGEyMHBvbHkxMzA1X3RhZ19maW5hbADSATJfY3J5cHRvX3NlY3JldHN0cmVhbV94Y2hhY2hhMjBwb2x5MTMwNV90YWdfbWVzc2FnZQAbL19jcnlwdG9fc2VjcmV0c3RyZWFtX3hjaGFjaGEyMHBvbHkxMzA1X3RhZ19wdXNoAMoBMF9jcnlwdG9fc2VjcmV0c3RyZWFtX3hjaGFjaGEyMHBvbHkxMzA1X3RhZ19yZWtleQDLARFfY3J5cHRvX3Nob3J0aGFzaAD3AhdfY3J5cHRvX3Nob3J0aGFzaF9ieXRlcwAeGl9jcnlwdG9fc2hvcnRoYXNoX2tleWJ5dGVzABwYX2NyeXB0b19zaG9ydGhhc2hfa2V5Z2VuAPMBDF9jcnlwdG9fc2lnbgD4AhJfY3J5cHRvX3NpZ25fYnl0ZXMAchVfY3J5cHRvX3NpZ25fZGV0YWNoZWQA+QIlX2NyeXB0b19zaWduX2VkMjU1MTlfcGtfdG9fY3VydmUyNTUxOQCFAiVfY3J5cHRvX3NpZ25fZWQyNTUxOV9za190b19jdXJ2ZTI1NTE5AIYCGV9jcnlwdG9fc2lnbl9maW5hbF9jcmVhdGUA/wEZX2NyeXB0b19zaWduX2ZpbmFsX3ZlcmlmeQCAAhFfY3J5cHRvX3NpZ25faW5pdAD9ARRfY3J5cHRvX3NpZ25fa2V5cGFpcgD4ARFfY3J5cHRvX3NpZ25fb3BlbgD6AhtfY3J5cHRvX3NpZ25fcHVibGlja2V5Ynl0ZXMAGRtfY3J5cHRvX3NpZ25fc2VjcmV0a2V5Ynl0ZXMAchlfY3J5cHRvX3NpZ25fc2VlZF9rZXlwYWlyAPcBFl9jcnlwdG9fc2lnbl9zZWVkYnl0ZXMAGRdfY3J5cHRvX3NpZ25fc3RhdGVieXRlcwD2ARNfY3J5cHRvX3NpZ25fdXBkYXRlAPsCHF9jcnlwdG9fc2lnbl92ZXJpZnlfZGV0YWNoZWQA/AIVX2NyeXB0b19zdHJlYW1fa2V5Z2VuAB0bX2Vtc2NyaXB0ZW5fZ2V0X2dsb2JhbF9saWJjAMYCBV9mcmVlAMECB19tYWxsb2MAwAIHX21lbWNweQDMAghfbWVtbW92ZQDNAgdfbWVtc2V0AM4CDF9yYW5kb21ieXRlcwD9AhBfcmFuZG9tYnl0ZXNfYnVmAKMCHl9yYW5kb21ieXRlc19idWZfZGV0ZXJtaW5pc3RpYwCkAhJfcmFuZG9tYnl0ZXNfY2xvc2UAGxNfcmFuZG9tYnl0ZXNfcmFuZG9tAKACFl9yYW5kb21ieXRlc19zZWVkYnl0ZXMAGRFfcmFuZG9tYnl0ZXNfc3RpcgChAhRfcmFuZG9tYnl0ZXNfdW5pZm9ybQCiAgVfc2JyawDPAhJfc29kaXVtX2Jhc2U2NDJiaW4ArQIaX3NvZGl1bV9iYXNlNjRfZW5jb2RlZF9sZW4AqAISX3NvZGl1bV9iaW4yYmFzZTY0AKoCD19zb2RpdW1fYmluMmhleACmAg9fc29kaXVtX2hleDJiaW4ApwIMX3NvZGl1bV9pbml0ALECF19zb2RpdW1fbGlicmFyeV9taW5pbWFsAMoBHV9zb2RpdW1fbGlicmFyeV92ZXJzaW9uX21ham9yAL0CHV9zb2RpdW1fbGlicmFyeV92ZXJzaW9uX21pbm9yABsLX3NvZGl1bV9wYWQAugINX3NvZGl1bV91bnBhZAC7AhZfc29kaXVtX3ZlcnNpb25fc3RyaW5nALwCE2VzdGFibGlzaFN0YWNrU3BhY2UADAtnZXRUZW1wUmV0MAAPC3J1blBvc3RTZXRzAMsCC3NldFRlbXBSZXQwAA4Ic2V0VGhyZXcADQpzdGFja0FsbG9jAAkMc3RhY2tSZXN0b3JlAAsJc3Rh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A0AgAyACaiIFIAUsAAAgASACaiwAAHM6AAAgAkEBaiICQSBHDQALIAAgA0KAARCPASAAQdABaiICEI4BIANBAWoiAELcuPHixYuXrtwANwAAIABC3Ljx4sWLl67cADcACCAAQty48eLFi5eu3AA3ABAgAELcuPHixYuXrtwANwAYIABC3Ljx4sWLl67cADcAICAAQty48eLFi5eu3AA3ACggAELcuPHixYuXrtwANwAwIABC3Ljx4sWLl67cADcAOCAAQty48eLFi5eu3AA3AEAgAELcuPHixYuXrtwANwBIIABC3Ljx4sWLl67cADcAUCAAQty48eLFi5eu3AA3AFggAELcuPHixYuXrtwANwBgIABC3Ljx4sWLl67cADcAaCAAQty48eLFi5eu3AA3AHAgAEHcuPHiBTYAeCAAQdy4ATsAfCAAQdwAOgB+IAMgASwAAEHcAHM6AABBASEAA0AgAyAAaiIFIAUsAAAgASAAaiwAAHM6AAAgAEEBaiIAQSBHDQALIAIgA0KAARCPASADQYABELUCIAZBwAAQtQIgBCQGCwsAIAAgASACEI8BCzwBAn8jBiECIwZBwABqJAYgACACIgMQkwEgAEHQAWoiACADQsAAEI8BIAAgARCTASADQcAAELUCIAIkBgtEAQF/IwYhAiMGQcAAaiQGIAAgAiIAECggASAAKQAANwAAIAEgACkACDcACCABIAApABA3ABAgASAAKQAYNwAYIAIkBgssAQJ/IwYhBCMGQaADaiQGIAQiBSADECYgBSIDIAEgAhAnIAUgABApIAQkBgs8AQJ/IwYhBSMGQSBqJAYgBSIEIAEgAiADECpBfyAAIAQQnwIgBCAARhsgBCAAQSAQtgJyIQAgBSQGIAALCgAgACABIAIQOwsQACABQSAQowIgACABEOQBCwoAIAAgASACEDwLFAAgACABIAIgAyAEIAUQ5QEaQQALPwECfyMGIQcjBkEgaiQGIAciCCAFIAYQLgR/QX8FIAAgASACIAMgBCAIEC8aIAhBIBC1AkEACyEAIAckBiAACykAIAJC7////w9WBEAQsgIFIABBEGogACABIAIgAyAEEC8aQQAPC0EACygAIAJC7////w9WBEAQsgIFIABBEGogACABIAIgAyAEIAUQMA8LQQALEQAgACABIAIgAyAEIAUQ5wELPgECfyMG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fyMGIQYjBkE/akFAcSQGIwYhAiMGQeANaiQGIAJB4ANqIgUgARBRIAJBwAJqIgMgARBXIAIiASADEFAgAyABIAUQRSACQaABaiIEIAMQUCAFQaABaiICIAQQUSADIAEgAhBFIAQgAxBQIAVBwAJqIgIgBBBRIAMgASACEEUgBCADEFAgBUHgA2oiAiAEEFEgAyABIAIQRSAEIAMQUCAFQYAFaiICIAQQUSADIAEgAhBFIAQgAxBQIAVBoAZqIgIgBBBRIAMgASACEEUgBCADEFAgBUHAB2oiAiAEEFEgAyABIAIQRSAEIAMQUCAFQeAIaiAEEFEgABBeQfwBIQEDQCADIAAQVyABQcyJAmosAAAiAkEASgRAIAQgAxBQIAMgBCAFIAJB/wFxQQF2QaABbGoQRQUgAkEASARAIAQgAxBQIAMgBCAFIAJBfm1BGHRBGHVBoAFsahBUCwsgACADEFAgAUF/aiECIAFBAEoEQCACIQEMAQsLIAYkBgtQAQJ/IAAsAB9B/wBxQf8AcyEBQR4hAgNAIAEgACACaiwAAEF/c3IhASACQX9qIgINAAtB7AEgAC0AAGsgAUH/AXFB/wNqcUEIdkEBcUEBcwueAQEHfyAALAAAIQdBACECA0ACQEEAIQVBACEDIAJBBXRBgAhqLAAAIQQgByEBA0AgBCABc0H/AXEgA3IhAyAAIAVBAWoiAWosAAAhBiACQQV0QYAIaiABaiwAACEEIAFBH0cEQCABIQUgBiEBDAELCyAGQf8AcSAEc0H/AXEgA3JFBEBBASEADAELIAJBAWoiAkEHSQ0BQQAhAAsLIAALsiACAX84fiABLAAAIAEsAAEgAUECaiIELAAAED9C////AIMhByAEED5CBYhC////AIMhBiABLAAFIAEsAAYgAUEHaiIELAAAED9CAohC////AIMhBSAEED5CB4hC////AIMhESABQQpqED5CBIhC////AIMhCCABLAANIAEsAA4gAUEPaiIELAAAED9CAYhC////AIMhDiAEED5CBohC////AIMhCiABLAASIAEsABMgASwAFBA/QgOIQv///wCDIQsgASwAFSABLAAWIAFBF2oiBCwAABA/Qv///wCDIRIgBBA+QgWIQv///wCDIQwgASwAGiABLAAbIAFBHGoiASwAABA/QgKIQv///wCDIQkgARA+QgeIIQ8gAiwAACACLAABIAJBAmoiASwAABA/Qv///wCDIRkgARA+QgWIQv///wCDIRogAiwABSACLAAGIAJBB2oiASwAABA/QgKIQv///wCDIRsgARA+QgeIQv///wCDIRwgAkEKahA+QgSIQv///wCDIRMgAiwADSACLAAOIAJBD2oiASwAABA/QgGIQv///wCDIRYgARA+QgaIQv///wCDIRcgAiwAEiACLAATIAIsABQQP0IDiEL///8AgyEYIAIsABUgAiwAFiACQRdqIgEsAAAQP0L///8AgyEUIAEQPkIFiEL///8AgyEVIAIsABogAiwAGyACQRxqIgEsAAAQP0ICiEL///8AgyEQIAEQPkIHiCENIAMsAAAgAywAASADQQJqIgEsAAAQP0L///8AgyEfIAEQPkIFiEL///8AgyEgIAMsAAUgAywABiADQQdqIgEsAAAQP0ICiEL///8AgyEqIAEQPkIHiEL///8AgyErIANBCmoQPkIEiEL///8AgyEsIAMsAA0gAywADiADQQ9qIgEsAAAQP0IBiEL///8AgyEtIAEQPkIGiEL///8AgyEuIAMsABIgAywAEyADLAAUED9CA4hC////AIMhLyADLAAVIAMsABYgA0EXaiIBLAAAED9C////AIMhJiABED5CBYhC////AIMhJyAaIAx+IBkgCX58IBsgEn58IBwgC358IBMgCn58IBYgDn58IBcgCH58IBQgBX58IBggEX58IBUgBn58IBAgB358IAMsABogAywAGyADQRxqIgEsAAAQP0ICiEL///8Ag3wiMEKAgMAAfEIVhyEjIBUgCX4gFCAPfnwgECAMfnwgDSASfnwgGCAPfiAUIAl+fCAVIAx+fCAQIBJ+fCANIAt+fCIhQoCAwAB8QhWHIh18ISIgGiAHfiAZIAZ+fCAgfCAfIBkgB358IjFCgIDAAHxCFYgiMnwiM0KAgMAAfEIViCEpIBQgDH4gFyAPfnwgGCAJfnwgFSASfnwgECALfnwgDSAKfnwgFyAJfiAWIA9+fCAUIBJ+fCAYIAx+fCAVIAt+fCAQIAp+fCANIA5+fCIgQoCAwAB8QhWHIh58IjRCgIDAAHxCFYciNSAhIB1CFYZ9fCEfICAgDSAPfiIhQoCAwAB8QhWHIiBCg6FWfnwgHkIVhn0gFiAJfiATIA9+fCAXIAx+fCAU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fCIjNwMAIAsgJyAjhUE/EHo3AwAgLSABKQMAIiQgKHwgGikDAHwiKIVBIBB6IScgISAoICQgBikDACAnfCIkhUEYEHoiKHwgGSkDAHwiJTcDACAOICcgJYVBEBB6Iic3AwAgBiAkICd8Iic3AwAgASAoICeFQT8QejcDACAAICYgACkDAIUgI4U3AwBBASEBA0AgACABQQN0aiICICIgAikDAIUgAyABQQhqQQN0aikDAIU3AwAgAUEBaiIBQQhHBEAgAyABQQN0aikDACEiDAELCyAeJAYLBwAgACkAAAsTACAAQcAAIAFrrYYgACABrYiECz4CAn8BfiAAEHxBACECA0AgASACQQN0ahB5IQQgACACQQN0aiIDIAMpAwAgBIU3AwAgAkEBaiICQQhHDQALC2kAIABB4AkpAwA3AwAgAEHoCSkDADcDCCAAQfAJKQMANwMQIABB+AkpAwA3AxggAEGACikDADcDICAAQYgKKQMANwMoIABBkAopAwA3AzAgAEGYCikDADcDOCAAQcAAakEAQaUCEM4CGgucAQECfyMGIQMjBkE/akFAcSQGIwYhAiMGQcAAaiQGIAFBf2pBGHRBGHVB/wFxQT9KBEAQsgIFIAIgAToAACACQQA6AAEgAkEBOgACIAJBAToAAyACQQRqEH4gAkEIakIAEBEgAkEQaiIBQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCAAIAIQeyADJAYLCwkAIABBADYAAAsdAQF/IABBIGoiAiABKQAANwAAIAIgASkACDcACAsdAQF/IABBMGoiAiABKQAANwAAIAIgASkACDcACAuBAgEDfyMGIQYjBkE/akFAcSQGIwYhBSMGQcABaiQGIAFBf2pBGHRBGHVB/wFxQT9KBEAQsgILIAVBgAFqIQQgA0F/akEYdEEYdUH/AXFBP0ogAkVyBEAQsgIFIAQgAToAACAEIAM6AAEgBEEBOgACIARBAToAAyAEQQRqEH4gBEEIakIAEBEgBEEQaiIBQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCAAIAQQeyAFIANB/wFxIgFqQQBBAEGAASABayADQRh0QRh1QQBIGxDOAhogBSACIAEQzAIaIAAgBUKAARCCASAFQYABELUCIAYkBgsL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AhAhCyAAQRRqIg0oAgAhBCAAQRhqIg4oAgAhAyAAQRxqIg8oAgAhBSAAQSBqIhAoAgAhBiAAQSRqIhEoAgAhByACQg9WBEAgACgCAK0hEyALQQVsrSEUIApBBWytIRsgCUEFbK0hHSAIQQVsrSEfIAitIRUgCa0hHCAKrSEeIAutISAgAyEAIAEhAwNAIAMQbEH///8fcSAEaiEBIANBA2oQbEECdkH///8fcSAAaq0iFiAUfiABrSIXIBN+fCADQQZqEGxBBHZB////H3EgBWqtIhggG358IANBCWoQbEEGdiAGaq0iGSAdfnwgA0EMahBsQQh2IAxyIAdqrSIaIB9+fCISpyEEIBYgFX4gFyAcfnwgGCATfnwgGSAUfnwgGiAbfnwgFiATfiAXIBV+fCAYIBR+fCAZIBt+fCAaIB1+fCASQhqIQv////8Pg3wiIUIaiEL/////D4N8IhKnQf///x9xIQUgFiAcfiAXIB5+fCAYIBV+fCAZIBN+fCAaIBR+fCASQhqIQv////8Pg3wiEqdB////H3EhBiAWIB5+IBcgIH58IBggHH58IBkgFX58IBogE358IBJCGohC/////w+DfCISp0H///8fcSEHIBJCGoinQQVsIgAgBGpB////H3EhASAAIARB////H3FqQRp2ICGnQf///x9xaiEAIANBEGohAyACQnB8IgJCD1YEQCABIQQMAQsLBSAEIQEgAyEACyANIAE2AgAgDiAANgIAIA8gBTYCACAQIAY2AgAgESAHNgIAC5YCAgF/A34CQAJAIABBOGoiAykDACIEQgBRDQAgAkIQIAR9IgUgBSACVhsiBkIAUgRAQgAhBQNAIABBwABqIAQgBXynaiABIAWnaiwAADoAACADKQMAIQQgBUIBfCIFIAZUDQALCyADIAQgBnwiBDcDACAEQhBaBEAgACAAQcAAakIQEKQBIANCADcDACABIAanaiEBIAIgBn0hAgwBCwwBCyACQnCDIQQgAkIPVgR+IAAgASAEEKQBIAEgBKdqIQEgAiAEfQUgAgsiBUIAUgRAQgAhAiADKQMAIQQDQCAAQcAAaiAEIAJ8p2ogASACp2osAAA6AAAgAykDACEEIAJCAXwiAiAFVA0ACyADIAQgBXw3AwALCwu+AQEBfyAAIAEQbEH///8fcTYCACAAIAFBA2oQbEECdkGD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AzYCHCAAIAM2AiAgACADNgIkIAAgAzYCKCAAIAM2AiwgACADNgIwIAAgAzYCNCAAIAM2AjggACADNgI8IABBwABqIQAMAQsLA0AgACAFSARAIAAgAzYCACAAQQRqIQAMAQsLCwNAIAAgBEgEQCAAIAE6AAAgAEEBaiEADAELCyAEIAJrC1sBAn8jBSgCACICIABBD2pBcHEiAGohASAAQQBKIAEgAkhxIAFBAEhyBEAQAhpBDBAEQX8PCyMFIAE2AgAgARABSgRAEABFBEAjBSACNgIAQQwQBEF/DwsLIAILJgAgACABIAIgAyAErSAFrUIghoQgBiAHrSAIrUIghoQgCSAKEBYLJgAgACABIAIgA60gBK1CIIaEIAUgBiAHrSAIrUIghoQgCSAKEBULJgAgACABIAIgA60gBK1CIIaEIAUgBq0gB61CIIaEIAggCSAKEBILKAAgACABIAIgAyAErSAFrUIghoQgBiAHrSAIrUIghoQgCSAKIAsQEAsmACAAIAEgAiADIAStIAWtQiCGhCAGIAetIAitQiCGhCAJIAoQGAsmACAAIAEgAiADrSAErUIghoQgBSAGIAetIAitQiCGhCAJIAoQFwsmACAAIAEgAiADrSAErUIghoQgBSAGrSAHrUIghoQgCCAJIAoQFAsoACAAIAEgAiADIAStIAWtQiCGhCAGIAetIAitQiCGhCAJIAogCxATCyYAIAAgASACIAMgBK0gBa1CIIaEIAYgB60gCK1CIIaEIAkgChAiCyYAIAAgASACIAOtIAStQiCGhCAFIAYgB60gCK1CIIaEIAkgChAhCyYAIAAgASACIAOtIAStQiCGhCAFIAatIAetQiCGhCAIIAkgChAgCygAIAAgASACIAMgBK0gBa1CIIaEIAYgB60gCK1CIIaEIAkgCiALEB8LFAAgACABIAKtIAOtQiCGhCAEECQLFAAgACABIAKtIAOtQiCGhCAEECULGgAgACABIAIgA60gBK1CIIaEIAUgBiAHEDALGAAgACABIAIgA60gBK1CIIaEIAUgBhAvCxgAIAAgASACrSADrUIghoQgBCAFIAYQMgsWACAAIAEgAq0gA61CIIaEIAQgBRAxCxoAIAAgASACIAOtIAStQiCGhCAFIAYgBxA0CxgAIAAgASACIAOtIAStQiCGhCAFIAYQMwsYACAAIAEgAq0gA61CIIaEIAQgBSAGEDYLFgAgACABIAKtIAOtQiCGhCAEIAUQNQsUACAAIAEgAq0gA61CIIaEIAQQNwsWACAAIAEgAq0gA61CIIaEIAQgBRA5CxgAIAAgASACIAOtIAStQiCGhCAFIAYQdAsSACAAIAEgAq0gA61CIIaEEHYLEwAgACABIAKtIAOtQiCGhBCNAQsXACAAIAEgAq0gA61CIIaEIAQgBRCZAQstACAAIAGtIAKtQiCGhCADIAStIAWtQiCGhCAGIAetIAitQiCGhCAJIAoQ1gELHwAgACABIAKtIAOtQiCGhCAErSAFrUIghoQgBhDXAQshACAAIAEgAq0gA61CIIaEIAStIAWtQiCGhCAGIAcQ2AELEwAgACABrSACrUIghoQgAxDaAQsTACAAIAEgAq0gA61CIIaEENkBCxkAIAAgASACIAOtIAStQiCGhCAFIAYQ5QELFwAgACABIAKtIAOtQiCGhCAEIAUQ5gELGQAgACABIAIgA60gBK1CIIaEIAUgBhDnAQsXACAAIAEgAq0gA61CIIaEIAQgBRDoAQslACAAIAEgAiADIAQgBa0gBq1CIIaEIAcgCK0gCa1CIIaEEO8BCyUAIAAgASACIAMgBK0gBa1CIIaEIAYgB60gCK1CIIaEIAkQ7QELFQAgACABIAKtIAOtQiCGhCAEEPIBCxcAIAAgASACIAOtIAStQiCGhCAFEPkBCxcAIAAgASACIAOtIAStQiCGhCAFEPsBCxcAIAAgASACIAOtIAStQiCGhCAFEPoBCxMAIAAgASACrSADrUIghoQQ/gELFQAgACABIAKtIAOtQiCGhCAEEPwBCxEAIAAgAa0gAq1CIIaEEKUCCwvyigIIAEGgCAsBAQBBwAgLl/8BJuiVj8KyJ7BFw/SJ8u+Y8NXfrAXTxjM5sTgCiG1T/AXHF2pwPU3YT7o8C3YNEGcPKiBT+iw5zMZOx/13kqwDeuz///////////////////////////////////////9/7f///////////////////////////////////////3/u////////////////////////////////////////fwjJvPNn5glqO6fKhIWuZ7sr+JT+cvNuPPE2HV869U+l0YLmrX9SDlEfbD4rjGgFm2u9Qfur2YMfeSF+ExnN4Fsi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Qsj+ETTkAHXcj/7L+HsAOBKu/7qXpP8z6NABoOQr//kdGQFEvj8AQZSJAgsCsI0AQcyJAgszDQAAAAD/AAAAAPUAAAAAAAD7AAAAAAAA/QAAAADzAAAAAAcAAAAAAAMAAAAA8wAAAAAFAEGHigILQAsAAAAAAAsAAAAA8wAAAAAAAP0AAAAAAP8AAAAAAwAAAAD1AAAAAAAAAA8AAAAAAP8AAAAA/wAAAAAHAAAAAAUAQciLAgsRAe3T9VwaYxJY1pz3ot753hQAQeiLAguqAhBTLT5idWZsZW4gPD0gQkxBS0UyQl9CTE9DS0JZVEVTAGNyeXB0b19nZW5lcmljaGFzaC9ibGFrZTJiL3JlZi9ibGFrZTJiLXJlZi5jAGNyeXB0b19nZW5lcmljaGFzaF9ibGFrZTJiX19maW5hbABvdXRsZW4gPD0gVUlOVDhfTUFYAGNyeXB0b19nZW5lcmljaGFzaC9ibGFrZTJiL3JlZi9nZW5lcmljaGFzaF9ibGFrZTJiLmMAY3J5cHRvX2dlbmVyaWNoYXNoX2JsYWtlMmIAa2V5bGVuIDw9IFVJTlQ4X01BWABjcnlwdG9fZ2VuZXJpY2hhc2hfYmxha2UyYl9pbml0AGNyeXB0b19nZW5lcmljaGFzaF9ibGFrZTJiX2ZpbmFsAIAAQZGPAgvvByRhcmdvbjJpZAAkYXJnb24yaQAkdj0AJG09ACx0PQAscD0AJGFyZ29uMmlkJHY9ACRhcmdvbjJpJHY9ACRhcmdvbjJpZCQAJGFyZ29uMmkkAGFyZ29uMmkAU2lnRWQyNTUxOSBubyBFZDI1NTE5IGNvbGxpc2lvbnMBAHsgcmV0dXJuIE1vZHVsZS5nZXRSYW5kb21WYWx1ZSgpOyB9AHsgaWYgKE1vZHVsZS5nZXRSYW5kb21WYWx1ZSA9PT0gdW5kZWZpbmVkKSB7IHRyeSB7IHZhciB3aW5kb3dfID0gJ29iamVjdCcgPT09IHR5cGVvZiB3aW5kb3cgPyB3aW5kb3cgOiBzZWxmOyB2YXIgY3J5cHRvXyA9IHR5cGVvZiB3aW5kb3dfLmNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3dfLmNyeXB0byA6IHdpbmRvd18ubXNDcnlwdG87IHZhciByYW5kb21WYWx1ZXNTdGFuZGFyZCA9IGZ1bmN0aW9uKCkgeyB2YXIgYnVmID0gbmV3IFVpbnQzMkFycmF5KDEpOyBjcnlwdG9fLmdldFJhbmRvbVZhbHVlcyhidWYpOyByZXR1cm4gYnVmWzBdID4+PiAwOyB9OyByYW5kb21WYWx1ZXNTdGFuZGFyZCgpOyBNb2R1bGUuZ2V0UmFuZG9tVmFsdWUgPSByYW5kb21WYWx1ZXNTdGFuZGFyZDsgfSBjYXRjaCAoZSkgeyB0cnkgeyB2YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7IHZhciByYW5kb21WYWx1ZU5vZGVKUyA9IGZ1bmN0aW9uKCkgeyB2YXIgYnVmID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDQpOyByZXR1cm4gKGJ1ZlswXSA8PCAyNCB8IGJ1ZlsxXSA8PCAxNiB8IGJ1ZlsyXSA8PCA4IHwgYnVmWzNdKSA+Pj4gMDsgfTsgcmFuZG9tVmFsdWVOb2RlSlMoKTsgTW9kdWxlLmdldFJhbmRvbVZhbHVlID0gcmFuZG9tVmFsdWVOb2RlSlM7IH0gY2F0Y2ggKGUpIHsgdGhyb3cgJ05vIHNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBmb3VuZCc7IH0gfSB9IH0ATGlic29kaXVtRFJHYnVmX2xlbiA8PSBTSVpFX01BWAByYW5kb21ieXRlcy9yYW5kb21ieXRlcy5jAHJhbmRvbWJ5dGVzAGI2NF9wb3MgPD0gYjY0X2xlbgBzb2RpdW0vY29kZWNzLmMAc29kaXVtX2JpbjJiYXNlNjQAMS4wLjE1",a=K.asmjsCodeFile||"";"function"==typeof K.locateFile&&(t=K.locateFile(t),r=K.locateFile(r),a=K.locateFile(a));var n={global:null,env:null,asm2wasm:{"f64-rem":function(A,I){return A%I},"f64-to-int":function(A){return 0|A},"i32s-div":function(A,I){return(0|A)/(0|I)|0},"i32u-div":function(A,I){return(A>>>0)/(I>>>0)>>>0},"i32s-rem":function(A,I){return(0|A)%(0|I)|0},"i32u-rem":function(A,I){return(A>>>0)%(I>>>0)>>>0},debugger:function(){}},parent:K},C=null;K.asmPreload=K.asm;var o=K.reallocBuffer,c=function(A){A=f(A,K.usingWasm?65536:16777216);var I=K.buffer,e=I.byteLength;if(!K.usingWasm)return C.__growWasmMemory((A-e)/65536),K.buffer!==I?K.buffer:null;try{return-1!==K.wasmMemory.grow((A-e)/65536)?K.buffer=K.wasmMemory.buffer:null}catch(A){return null}};K.reallocBuffer=function(A){return"asmjs"===Q?o(A):c(A)};var Q="";K.asm=function(A,e,g){if(A=I(A),!(e=I(e)).table){var B=K.wasmTableSize;void 0===B&&(B=1024);var t=K.wasmMaxTableSize;"object"==typeof WebAssembly&&"function"==typeof WebAssembly.Table?e.table=void 0!==t?new WebAssembly.Table({initial:B,maximum:t,element:"anyfunc"}):new WebAssembly.Table({initial:B,element:"anyfunc"}):e.table=new Array(B),K.wasmTable=e.table}e.memoryBase||(e.memoryBase=K.STATIC_BASE),e.tableBase||(e.tableBase=0);var r;return(r=i(A,e))||X("no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/WebAssembly#binaryen-methods"),r},K.asm}();var LA=[function(){return K.getRandomValue()},function(){if(void 0===K.getRandomValue)try{var A="object"==typeof window?window:self,I=void 0!==A.crypto?A.crypto:A.msCrypto,e=function(){var A=new Uint32Array(1);return I.getRandomValues(A),A[0]>>>0};e(),K.getRandomValue=e}catch(A){try{var g=require("crypto"),i=function(){var A=g.randomBytes(4);return(A[0]<<24|A[1]<<16|A[2]<<8|A[3])>>>0};i(),K.getRandomValue=i}catch(A){throw"No secure random number generator found"}}}];hA=$.GLOBAL_BASE,yA=hA+36368,vA.push(),PA=null,K.STATIC_BASE=hA,K.STATIC_BUMP=36368;var xA=yA;yA+=16;var XA={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};lA=a(1,"i32",iA),pA=(_A=$.alignMemory(yA))+uA,wA=$.alignMemory(pA),cA[lA>>2]=wA,fA=!0;var KA=!1;K.intArrayFromString=R,K.intArrayToString=N;var TA="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",VA="function"==typeof atob?atob:function(A){var I,e,g,i,B,t,r="",a=0;A=A.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{I=TA.indexOf(A.charAt(a++))<<2|(i=TA.indexOf(A.charAt(a++)))>>4,e=(15&i)<<4|(B=TA.indexOf(A.charAt(a++)))>>2,g=(3&B)<<6|(t=TA.indexOf(A.charAt(a++))),r+=String.fromCharCode(I),64!==B&&(r+=String.fromCharCode(e)),64!==t&&(r+=String.fromCharCode(g))}while(a<A.length);return r};K.wasmTableSize=0,K.wasmMaxTableSize=0,K.asmGlobalArg={Math:Math,Int8Array:Int8Array,Int16Array:Int16Array,Int32Array:Int32Array,Uint8Array:Uint8Array,Uint16Array:Uint16Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,NaN:NaN,Infinity:1/0},K.asmLibraryArg={abort:X,assert:i,enlargeMemory:l,getTotalMemory:function(){return dA},abortOnCannotGrowMemory:w,___assert_fail:function(A,I,e,g){throw eA=!0,"Assertion failed: "+n(A)+", at: "+[I?n(I):"unknown filename",e,g?n(g):"unknown function"]+" at "+y()},___setErrNo:S,_abort:function(){K.abort()},_emscripten_asm_const_i:function(A){return LA[A]()},_emscripten_memcpy_big:function(A,I,e){return nA.set(nA.subarray(I,I+e),A),A},_sysconf:function(A){switch(A){case 30:return 16384;case 85:return nA.length/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 80:case 81:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 79:return 0;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return"object"==typeof navigator?navigator.hardwareConcurrency||1:1}return S(XA.EINVAL),-1},DYNAMICTOP_PTR:lA,tempDoublePtr:xA,ABORT:eA,STACKTOP:_A,STACK_MAX:pA};var qA=K.asm(K.asmGlobalArg,K.asmLibraryArg,rA);K.asm=qA,K._crypto_aead_chacha20poly1305_abytes=function(){return K.asm._crypto_aead_chacha20poly1305_abytes.apply(null,arguments)},K._crypto_aead_chacha20poly1305_decrypt=function(){return K.asm._crypto_aead_chacha20poly1305_decrypt.apply(null,arguments)},K._crypto_aead_chacha20poly1305_decrypt_detached=function(){return K.asm._crypto_aead_chacha20poly1305_decrypt_detached.apply(null,arguments)},K._crypto_aead_chacha20poly1305_encrypt=function(){return K.asm._crypto_aead_chacha20poly1305_encrypt.apply(null,arguments)},K._crypto_aead_chacha20poly1305_encrypt_detached=function(){return K.asm._crypto_aead_chacha20poly1305_encrypt_detached.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_abytes=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_abytes.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_decrypt=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_decrypt.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_decrypt_detached=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_decrypt_detached.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_encrypt=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_encrypt.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_encrypt_detached=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_encrypt_detached.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_keybytes=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_keybytes.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_keygen=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_keygen.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_npubbytes=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_npubbytes.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_nsecbytes=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_nsecbytes.apply(null,arguments)},K._crypto_aead_chacha20poly1305_keybytes=function(){return K.asm._crypto_aead_chacha20poly1305_keybytes.apply(null,arguments)},K._crypto_aead_chacha20poly1305_keygen=function(){return K.asm._crypto_aead_chacha20poly1305_keygen.apply(null,arguments)},K._crypto_aead_chacha20poly1305_npubbytes=function(){return K.asm._crypto_aead_chacha20poly1305_npubbytes.apply(null,arguments)},K._crypto_aead_chacha20poly1305_nsecbytes=function(){return K.asm._crypto_aead_chacha20poly1305_nsecbytes.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_abytes=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_abytes.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_decrypt=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_decrypt.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_decrypt_detached=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_decrypt_detached.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_encrypt=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_encrypt.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_encrypt_detached=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_encrypt_detached.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_keybytes=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_keybytes.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_keygen=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_keygen.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_npubbytes=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_npubbytes.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_nsecbytes=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_nsecbytes.apply(null,arguments)},K._crypto_auth=function(){return K.asm._crypto_auth.apply(null,arguments)},K._crypto_auth_bytes=function(){return K.asm._crypto_auth_bytes.apply(null,arguments)},K._crypto_auth_keybytes=function(){return K.asm._crypto_auth_keybytes.apply(null,arguments)},K._crypto_auth_keygen=function(){return K.asm._crypto_auth_keygen.apply(null,arguments)},K._crypto_auth_verify=function(){return K.asm._crypto_auth_verify.apply(null,arguments)},K._crypto_box_beforenm=function(){return K.asm._crypto_box_beforenm.apply(null,arguments)},K._crypto_box_beforenmbytes=function(){return K.asm._crypto_box_beforenmbytes.apply(null,arguments)},K._crypto_box_detached=function(){return K.asm._crypto_box_detached.apply(null,arguments)},K._crypto_box_detached_afternm=function(){return K.asm._crypto_box_detached_afternm.apply(null,arguments)},K._crypto_box_easy=function(){return K.asm._crypto_box_easy.apply(null,arguments)},K._crypto_box_easy_afternm=function(){return K.asm._crypto_box_easy_afternm.apply(null,arguments)},K._crypto_box_keypair=function(){return K.asm._crypto_box_keypair.apply(null,arguments)},K._crypto_box_macbytes=function(){return K.asm._crypto_box_macbytes.apply(null,arguments)},K._crypto_box_noncebytes=function(){return K.asm._crypto_box_noncebytes.apply(null,arguments)},K._crypto_box_open_detached=function(){return K.asm._crypto_box_open_detached.apply(null,arguments)},K._crypto_box_open_detached_afternm=function(){return K.asm._crypto_box_open_detached_afternm.apply(null,arguments)},K._crypto_box_open_easy=function(){return K.asm._crypto_box_open_easy.apply(null,arguments)},K._crypto_box_open_easy_afternm=function(){return K.asm._crypto_box_open_easy_afternm.apply(null,arguments)},K._crypto_box_publickeybytes=function(){return K.asm._crypto_box_publickeybytes.apply(null,arguments)},K._crypto_box_seal=function(){return K.asm._crypto_box_seal.apply(null,arguments)},K._crypto_box_seal_open=function(){return K.asm._crypto_box_seal_open.apply(null,arguments)},K._crypto_box_sealbytes=function(){return K.asm._crypto_box_sealbytes.apply(null,arguments)},K._crypto_box_secretkeybytes=function(){return K.asm._crypto_box_secretkeybytes.apply(null,arguments)},K._crypto_box_seed_keypair=function(){return K.asm._crypto_box_seed_keypair.apply(null,arguments)},K._crypto_box_seedbytes=function(){return K.asm._crypto_box_seedbytes.apply(null,arguments)},K._crypto_core_hchacha20=function(){return K.asm._crypto_core_hchacha20.apply(null,arguments)},K._crypto_core_hchacha20_constbytes=function(){return K.asm._crypto_core_hchacha20_constbytes.apply(null,arguments)},K._crypto_core_hchacha20_inputbytes=function(){return K.asm._crypto_core_hchacha20_inputbytes.apply(null,arguments)},K._crypto_core_hchacha20_keybytes=function(){return K.asm._crypto_core_hchacha20_keybytes.apply(null,arguments)},K._crypto_core_hchacha20_outputbytes=function(){return K.asm._crypto_core_hchacha20_outputbytes.apply(null,arguments)},K._crypto_generichash=function(){return K.asm._crypto_generichash.apply(null,arguments)},K._crypto_generichash_bytes=function(){return K.asm._crypto_generichash_bytes.apply(null,arguments)},K._crypto_generichash_bytes_max=function(){return K.asm._crypto_generichash_bytes_max.apply(null,arguments)},K._crypto_generichash_bytes_min=function(){return K.asm._crypto_generichash_bytes_min.apply(null,arguments)},K._crypto_generichash_final=function(){return K.asm._crypto_generichash_final.apply(null,arguments)},K._crypto_generichash_init=function(){return K.asm._crypto_generichash_init.apply(null,arguments)},K._crypto_generichash_keybytes=function(){return K.asm._crypto_generichash_keybytes.apply(null,arguments)},K._crypto_generichash_keybytes_max=function(){return K.asm._crypto_generichash_keybytes_max.apply(null,arguments)},K._crypto_generichash_keybytes_min=function(){return K.asm._crypto_generichash_keybytes_min.apply(null,arguments)},K._crypto_generichash_keygen=function(){return K.asm._crypto_generichash_keygen.apply(null,arguments)},K._crypto_generichash_statebytes=function(){return K.asm._crypto_generichash_statebytes.apply(null,arguments)},K._crypto_generichash_update=function(){return K.asm._crypto_generichash_update.apply(null,arguments)},K._crypto_hash=function(){return K.asm._crypto_hash.apply(null,arguments)},K._crypto_hash_bytes=function(){return K.asm._crypto_hash_bytes.apply(null,arguments)},K._crypto_kdf_bytes_max=function(){return K.asm._crypto_kdf_bytes_max.apply(null,arguments)},K._crypto_kdf_bytes_min=function(){return K.asm._crypto_kdf_bytes_min.apply(null,arguments)},K._crypto_kdf_contextbytes=function(){return K.asm._crypto_kdf_contextbytes.apply(null,arguments)},K._crypto_kdf_derive_from_key=function(){return K.asm._crypto_kdf_derive_from_key.apply(null,arguments)},K._crypto_kdf_keybytes=function(){return K.asm._crypto_kdf_keybytes.apply(null,arguments)},K._crypto_kdf_keygen=function(){return K.asm._crypto_kdf_keygen.apply(null,arguments)},K._crypto_kx_client_session_keys=function(){return K.asm._crypto_kx_client_session_keys.apply(null,arguments)},K._crypto_kx_keypair=function(){return K.asm._crypto_kx_keypair.apply(null,arguments)},K._crypto_kx_publickeybytes=function(){return K.asm._crypto_kx_publickeybytes.apply(null,arguments)},K._crypto_kx_secretkeybytes=function(){return K.asm._crypto_kx_secretkeybytes.apply(null,arguments)},K._crypto_kx_seed_keypair=function(){return K.asm._crypto_kx_seed_keypair.apply(null,arguments)},K._crypto_kx_seedbytes=function(){return K.asm._crypto_kx_seedbytes.apply(null,arguments)},K._crypto_kx_server_session_keys=function(){return K.asm._crypto_kx_server_session_keys.apply(null,arguments)},K._crypto_kx_sessionkeybytes=function(){return K.asm._crypto_kx_sessionkeybytes.apply(null,arguments)},K._crypto_pwhash=function(){return K.asm._crypto_pwhash.apply(null,arguments)},K._crypto_pwhash_alg_argon2i13=function(){return K.asm._crypto_pwhash_alg_argon2i13.apply(null,arguments)},K._crypto_pwhash_alg_argon2id13=function(){return K.asm._crypto_pwhash_alg_argon2id13.apply(null,arguments)},K._crypto_pwhash_alg_default=function(){return K.asm._crypto_pwhash_alg_default.apply(null,arguments)},K._crypto_pwhash_bytes_max=function(){return K.asm._crypto_pwhash_bytes_max.apply(null,arguments)},K._crypto_pwhash_bytes_min=function(){return K.asm._crypto_pwhash_bytes_min.apply(null,arguments)},K._crypto_pwhash_memlimit_interactive=function(){return K.asm._crypto_pwhash_memlimit_interactive.apply(null,arguments)},K._crypto_pwhash_memlimit_max=function(){return K.asm._crypto_pwhash_memlimit_max.apply(null,arguments)},K._crypto_pwhash_memlimit_min=function(){return K.asm._crypto_pwhash_memlimit_min.apply(null,arguments)},K._crypto_pwhash_memlimit_moderate=function(){return K.asm._crypto_pwhash_memlimit_moderate.apply(null,arguments)},K._crypto_pwhash_memlimit_sensitive=function(){return K.asm._crypto_pwhash_memlimit_sensitive.apply(null,arguments)},K._crypto_pwhash_opslimit_interactive=function(){return K.asm._crypto_pwhash_opslimit_interactive.apply(null,arguments)},K._crypto_pwhash_opslimit_max=function(){return K.asm._crypto_pwhash_opslimit_max.apply(null,arguments)},K._crypto_pwhash_opslimit_min=function(){return K.asm._crypto_pwhash_opslimit_min.apply(null,arguments)},K._crypto_pwhash_opslimit_moderate=function(){return K.asm._crypto_pwhash_opslimit_moderate.apply(null,arguments)},K._crypto_pwhash_opslimit_sensitive=function(){return K.asm._crypto_pwhash_opslimit_sensitive.apply(null,arguments)},K._crypto_pwhash_passwd_max=function(){return K.asm._crypto_pwhash_passwd_max.apply(null,arguments)},K._crypto_pwhash_passwd_min=function(){return K.asm._crypto_pwhash_passwd_min.apply(null,arguments)},K._crypto_pwhash_primitive=function(){return K.asm._crypto_pwhash_primitive.apply(null,arguments)},K._crypto_pwhash_saltbytes=function(){return K.asm._crypto_pwhash_saltbytes.apply(null,arguments)},K._crypto_pwhash_str=function(){return K.asm._crypto_pwhash_str.apply(null,arguments)},K._crypto_pwhash_str_alg=function(){return K.asm._crypto_pwhash_str_alg.apply(null,arguments)},K._crypto_pwhash_str_needs_rehash=function(){return K.asm._crypto_pwhash_str_needs_rehash.apply(null,arguments)},K._crypto_pwhash_str_verify=function(){return K.asm._crypto_pwhash_str_verify.apply(null,arguments)},K._crypto_pwhash_strbytes=function(){return K.asm._crypto_pwhash_strbytes.apply(null,arguments)},K._crypto_pwhash_strprefix=function(){return K.asm._crypto_pwhash_strprefix.apply(null,arguments)},K._crypto_scalarmult=function(){return K.asm._crypto_scalarmult.apply(null,arguments)},K._crypto_scalarmult_base=function(){return K.asm._crypto_scalarmult_base.apply(null,arguments)},K._crypto_scalarmult_bytes=function(){return K.asm._crypto_scalarmult_bytes.apply(null,arguments)},K._crypto_scalarmult_scalarbytes=function(){return K.asm._crypto_scalarmult_scalarbytes.apply(null,arguments)},K._crypto_secretbox_detached=function(){return K.asm._crypto_secretbox_detached.apply(null,arguments)},K._crypto_secretbox_easy=function(){return K.asm._crypto_secretbox_easy.apply(null,arguments)},K._crypto_secretbox_keybytes=function(){return K.asm._crypto_secretbox_keybytes.apply(null,arguments)},K._crypto_secretbox_keygen=function(){return K.asm._crypto_secretbox_keygen.apply(null,arguments)},K._crypto_secretbox_macbytes=function(){return K.asm._crypto_secretbox_macbytes.apply(null,arguments)},K._crypto_secretbox_noncebytes=function(){return K.asm._crypto_secretbox_noncebytes.apply(null,arguments)},K._crypto_secretbox_open_detached=function(){return K.asm._crypto_secretbox_open_detached.apply(null,arguments)},K._crypto_secretbox_open_easy=function(){return K.asm._crypto_secretbox_open_easy.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_abytes=function(){return K.asm._crypto_secretstream_xchacha20poly1305_abytes.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_headerbytes=function(){return K.asm._crypto_secretstream_xchacha20poly1305_headerbytes.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_init_pull=function(){return K.asm._crypto_secretstream_xchacha20poly1305_init_pull.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_init_push=function(){return K.asm._crypto_secretstream_xchacha20poly1305_init_push.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_keybytes=function(){return K.asm._crypto_secretstream_xchacha20poly1305_keybytes.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_keygen=function(){return K.asm._crypto_secretstream_xchacha20poly1305_keygen.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_messagebytes_max=function(){return K.asm._crypto_secretstream_xchacha20poly1305_messagebytes_max.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_pull=function(){return K.asm._crypto_secretstream_xchacha20poly1305_pull.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_push=function(){return K.asm._crypto_secretstream_xchacha20poly1305_push.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_rekey=function(){return K.asm._crypto_secretstream_xchacha20poly1305_rekey.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_statebytes=function(){return K.asm._crypto_secretstream_xchacha20poly1305_statebytes.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_tag_final=function(){return K.asm._crypto_secretstream_xchacha20poly1305_tag_final.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_tag_message=function(){return K.asm._crypto_secretstream_xchacha20poly1305_tag_message.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_tag_push=function(){return K.asm._crypto_secretstream_xchacha20poly1305_tag_push.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_tag_rekey=function(){return K.asm._crypto_secretstream_xchacha20poly1305_tag_rekey.apply(null,arguments)},K._crypto_shorthash=function(){return K.asm._crypto_shorthash.apply(null,arguments)},K._crypto_shorthash_bytes=function(){return K.asm._crypto_shorthash_bytes.apply(null,arguments)},K._crypto_shorthash_keybytes=function(){return K.asm._crypto_shorthash_keybytes.apply(null,arguments)},K._crypto_shorthash_keygen=function(){return K.asm._crypto_shorthash_keygen.apply(null,arguments)},K._crypto_sign=function(){return K.asm._crypto_sign.apply(null,arguments)},K._crypto_sign_bytes=function(){return K.asm._crypto_sign_bytes.apply(null,arguments)},K._crypto_sign_detached=function(){return K.asm._crypto_sign_detached.apply(null,arguments)},K._crypto_sign_ed25519_pk_to_curve25519=function(){return K.asm._crypto_sign_ed25519_pk_to_curve25519.apply(null,arguments)},K._crypto_sign_ed25519_sk_to_curve25519=function(){return K.asm._crypto_sign_ed25519_sk_to_curve25519.apply(null,arguments)},K._crypto_sign_final_create=function(){return K.asm._crypto_sign_final_create.apply(null,arguments)},K._crypto_sign_final_verify=function(){return K.asm._crypto_sign_final_verify.apply(null,arguments)},K._crypto_sign_init=function(){return K.asm._crypto_sign_init.apply(null,arguments)},K._crypto_sign_keypair=function(){return K.asm._crypto_sign_keypair.apply(null,arguments)},K._crypto_sign_open=function(){return K.asm._crypto_sign_open.apply(null,arguments)},K._crypto_sign_publickeybytes=function(){return K.asm._crypto_sign_publickeybytes.apply(null,arguments)},K._crypto_sign_secretkeybytes=function(){return K.asm._crypto_sign_secretkeybytes.apply(null,arguments)},K._crypto_sign_seed_keypair=function(){return K.asm._crypto_sign_seed_keypair.apply(null,arguments)},K._crypto_sign_seedbytes=function(){return K.asm._crypto_sign_seedbytes.apply(null,arguments)},K._crypto_sign_statebytes=function(){return K.asm._crypto_sign_statebytes.apply(null,arguments)},K._crypto_sign_update=function(){return K.asm._crypto_sign_update.apply(null,arguments)},K._crypto_sign_verify_detached=function(){return K.asm._crypto_sign_verify_detached.apply(null,arguments)},K._crypto_stream_keygen=function(){return K.asm._crypto_stream_keygen.apply(null,arguments)},K._emscripten_get_global_libc=function(){return K.asm._emscripten_get_global_libc.apply(null,arguments)};var jA=K._free=function(){return K.asm._free.apply(null,arguments)},ZA=K._malloc=function(){return K.asm._malloc.apply(null,arguments)};if(K._memcpy=function(){return K.asm._memcpy.apply(null,arguments)},K._memmove=function(){return K.asm._memmove.apply(null,arguments)},K._memset=function(){return K.asm._memset.apply(null,arguments)},K._randombytes=function(){return K.asm._randombytes.apply(null,arguments)},K._randombytes_buf=function(){return K.asm._randombytes_buf.apply(null,arguments)},K._randombytes_buf_deterministic=function(){return K.asm._randombytes_buf_deterministic.apply(null,arguments)},K._randombytes_close=function(){return K.asm._randombytes_close.apply(null,arguments)},K._randombytes_random=function(){return K.asm._randombytes_random.apply(null,arguments)},K._randombytes_seedbytes=function(){return K.asm._randombytes_seedbytes.apply(null,arguments)},K._randombytes_stir=function(){return K.asm._randombytes_stir.apply(null,arguments)},K._randombytes_uniform=function(){return K.asm._randombytes_uniform.apply(null,arguments)},K._sbrk=function(){return K.asm._sbrk.apply(null,arguments)},K._sodium_base642bin=function(){return K.asm._sodium_base642bin.apply(null,arguments)},K._sodium_base64_encoded_len=function(){return K.asm._sodium_base64_encoded_len.apply(null,arguments)},K._sodium_bin2base64=function(){return K.asm._sodium_bin2base64.apply(null,arguments)},K._sodium_bin2hex=function(){return K.asm._sodium_bin2hex.apply(null,arguments)},K._sodium_hex2bin=function(){return K.asm._sodium_hex2bin.apply(null,arguments)},K._sodium_init=function(){return K.asm._sodium_init.apply(null,arguments)},K._sodium_library_minimal=function(){return K.asm._sodium_library_minimal.apply(null,arguments)},K._sodium_library_version_major=function(){return K.asm._sodium_library_version_major.apply(null,arguments)},K._sodium_library_version_minor=function(){return K.asm._sodium_library_version_minor.apply(null,arguments)},K._sodium_pad=function(){return K.asm._sodium_pad.apply(null,arguments)},K._sodium_unpad=function(){return K.asm._sodium_unpad.apply(null,arguments)},K._sodium_version_string=function(){return K.asm._sodium_version_string.apply(null,arguments)},K.establishStackSpace=function(){return K.asm.establishStackSpace.apply(null,arguments)},K.getTempRet0=function(){return K.asm.getTempRet0.apply(null,arguments)},K.runPostSets=function(){return K.asm.runPostSets.apply(null,arguments)},K.setTempRet0=function(){return K.asm.setTempRet0.apply(null,arguments)},K.setThrew=function(){return K.asm.setThrew.apply(null,arguments)},K.stackAlloc=function(){return K.asm.stackAlloc.apply(null,arguments)},K.stackRestore=function(){return K.asm.stackRestore.apply(null,arguments)},K.stackSave=function(){return K.asm.stackSave.apply(null,arguments)},$.stackAlloc=K.stackAlloc,$.stackSave=K.stackSave,$.stackRestore=K.stackRestore,$.establishStackSpace=K.establishStackSpace,$.setTempRet0=K.setTempRet0,$.getTempRet0=K.getTempRet0,K.asm=qA,PA)if("function"==typeof K.locateFile?PA=K.locateFile(PA):K.memoryInitializerPrefixURL&&(PA=K.memoryInitializerPrefixURL+PA),Z||W){var WA=K.readBinary(PA);nA.set(WA,$.GLOBAL_BASE)}else{H("memory initializer");var zA=function(A){A.byteLength&&(A=new Uint8Array(A)),nA.set(A,$.GLOBAL_BASE),K.memoryInitializerRequest&&delete K.memoryInitializerRequest.response,Y("memory initializer")};function OA(){K.readAsync(PA,zA,function(){throw"could not load memory initializer "+PA})}var $A=J(PA);if($A)zA($A.buffer);else if(K.memoryInitializerRequest){function AI(){var A=K.memoryInitializerRequest,I=A.response;if(200!==A.status&&0!==A.status){var e=J(K.memoryInitializerRequestURL);if(!e)return void OA();I=e.buffer}zA(I)}K.memoryInitializerRequest.response?setTimeout(AI,0):K.memoryInitializerRequest.addEventListener("load",AI)}else OA()}P.prototype=new Error,P.prototype.constructor=P;var II,eI=null,gI=!1;JA=function A(){K.calledRun||L(),K.calledRun||(JA=A)},K.callMain=K.callMain=function(A){function I(){for(var A=0;A<3;A++)g.push(0)}A=A||[],D();var e=A.length+1,g=[a(R(K.thisProgram),"i8",0)];I();for(var i=0;i<e-1;i+=1)g.push(a(R(A[i]),"i8",0)),I();g.push(0),g=a(g,"i32",0);try{x(K._main(e,g,0),!0)}catch(A){if(A instanceof P)return;if("SimulateInfiniteLoop"==A)return void(K.noExitRuntime=!0);var B=A;A&&"object"==typeof A&&A.stack&&(B=[A,A.stack]),K.printErr("exception thrown: "+B),K.quit(1,A)}finally{gI=!0}},K.run=K.run=L,K.exit=K.exit=x;var iI=[];if(K.abort=K.abort=X,K.preInit)for("function"==typeof K.preInit&&(K.preInit=[K.preInit]);K.preInit.length>0;)K.preInit.pop()();var BI=!0;K.noInitialRun&&(BI=!1),L()}).catch(function(){function A(A){U("NO_DYNAMIC_EXECUTION=1 was set, cannot eval")}function I(A,I){A||U("Assertion failed: "+I)}function e(A){var e=J["_"+A];return e||U("NO_DYNAMIC_EXECUTION=1 was set, cannot eval"),I(e,"Cannot call unknown function "+A+" (perhaps LLVM optimizations or closure removed it?)"),e}function i(A,I,e,g){switch("*"===(e=e||"i8").charAt(e.length-1)&&(e="i32"),e){case"i1":case"i8":gA[A>>0]=I;break;case"i16":BA[A>>1]=I;break;case"i32":rA[A>>2]=I;break;case"i64":tempI64=[I>>>0,(tempDouble=I,+bA(tempDouble)>=1?tempDouble>0?(0|FA(+GA(tempDouble/4294967296),4294967295))>>>0:~~+kA((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],rA[A>>2]=tempI64[0],rA[A+4>>2]=tempI64[1];break;case"float":nA[A>>2]=I;break;case"double":CA[A>>3]=I;break;default:U("invalid type for setValue: "+e)}}function B(A,I,e){switch("*"===(I=I||"i8").charAt(I.length-1)&&(I="i32"),I){case"i1":case"i8":return gA[A>>0];case"i16":return BA[A>>1];case"i32":case"i64":return rA[A>>2];case"float":return nA[A>>2];case"double":return CA[A>>3];default:U("invalid type for getValue: "+I)}return null}function t(A,e,g,B){var t,r;"number"==typeof A?(t=!0,r=A):(t=!1,r=A.length);var a,n="string"==typeof e?e:null;if(a=g==AA?B:["function"==typeof KA?KA:j.staticAlloc,j.stackAlloc,j.staticAlloc,j.dynamicAlloc][void 0===g?$:g](Math.max(r,n?1:e.length)),t){var C;for(B=a,I(0==(3&a)),C=a+(-4&r);B<C;B+=4)rA[B>>2]=0;for(C=a+r;B<C;)gA[B++>>0]=0;return a}if("i8"===n)return A.subarray||A.slice?iA.set(A,a):iA.set(new Uint8Array(A),a),a;for(var o,c,Q,E=0;E<r;){var s=A[E];"function"==typeof s&&(s=j.getFunctionIndex(s)),0!==(o=n||e[E])?("i64"==o&&(o="i32"),i(a+E,s,o),Q!==o&&(c=j.getNativeTypeSize(o),Q=o),E+=c):E++}return a}function r(A,I){if(0===I||!A)return"";for(var e,g=0,i=0;e=iA[A+i>>0],g|=e,(0!=e||I)&&(i++,!I||i!=I););I||(I=i);var B="";if(g<128){for(var t;I>0;)t=String.fromCharCode.apply(String,iA.subarray(A,A+Math.min(I,1024))),B=B?B+t:t,A+=1024,I-=1024;return B}return J.UTF8ToString(A)}function a(A,I){for(var e=I;A[e];)++e;if(e-I>16&&A.subarray&&IA)return IA.decode(A.subarray(I,e));for(var g,i,B,t,r,a="";;){if(!(g=A[I++]))return a;if(128&g)if(i=63&A[I++],192!=(224&g))if(B=63&A[I++],224==(240&g)?g=(15&g)<<12|i<<6|B:(t=63&A[I++],240==(248&g)?g=(7&g)<<18|i<<12|B<<6|t:(r=63&A[I++],g=248==(252&g)?(3&g)<<24|i<<18|B<<12|t<<6|r:(1&g)<<30|i<<24|B<<18|t<<12|r<<6|63&A[I++])),g<65536)a+=String.fromCharCode(g);else{var n=g-65536;a+=String.fromCharCode(55296|n>>10,56320|1023&n)}else a+=String.fromCharCode((31&g)<<6|i);else a+=String.fromCharCode(g)}}function n(A,I,e,g){if(!(g>0))return 0;for(var i=e,B=e+g-1,t=0;t<A.length;++t){var r=A.charCodeAt(t);if(r>=55296&&r<=57343&&(r=65536+((1023&r)<<10)|1023&A.charCodeAt(++t)),r<=127){if(e>=B)break;I[e++]=r}else if(r<=2047){if(e+1>=B)break;I[e++]=192|r>>6,I[e++]=128|63&r}else if(r<=65535){if(e+2>=B)break;I[e++]=224|r>>12,I[e++]=128|r>>6&63,I[e++]=128|63&r}else if(r<=2097151){if(e+3>=B)break;I[e++]=240|r>>18,I[e++]=128|r>>12&63,I[e++]=128|r>>6&63,I[e++]=128|63&r}else if(r<=67108863){if(e+4>=B)break;I[e++]=248|r>>24,I[e++]=128|r>>18&63,I[e++]=128|r>>12&63,I[e++]=128|r>>6&63,I[e++]=128|63&r}else{if(e+5>=B)break;I[e++]=252|r>>30,I[e++]=128|r>>24&63,I[e++]=128|r>>18&63,I[e++]=128|r>>12&63,I[e++]=128|r>>6&63,I[e++]=128|63&r}}return I[e]=0,e-i}function C(A,I,e){return n(A,iA,I,e)}function o(A){for(var I=0,e=0;e<A.length;++e){var g=A.charCodeAt(e);g>=55296&&g<=57343&&(g=65536+((1023&g)<<10)|1023&A.charCodeAt(++e)),g<=127?++I:I+=g<=2047?2:g<=65535?3:g<=2097151?4:g<=67108863?5:6}return I}function c(A){var I=J.___cxa_demangle||J.__cxa_demangle;if(I){try{var e=A.substr(1),g=o(e)+1,i=KA(g);C(e,i,g);var t=KA(4),a=I(i,0,0,t);if(0===B(t,"i32")&&a)return r(a)}catch(A){}finally{i&&XA(i),t&&XA(t),a&&XA(a)}return A}return j.warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling"),A}function Q(A){return A.replace(/__Z[\w\d_]+/g,function(A){var I=c(A);return A===I?A:A+" ["+I+"]"})}function E(){var A=new Error;if(!A.stack){try{throw new Error(0)}catch(I){A=I}if(!A.stack)return"(no stack trace available)"}return A.stack.toString()}function s(){var A=E();return J.extraStackTrace&&(A+="\n"+J.extraStackTrace()),Q(A)}function h(){U("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value "+_A+", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or (4) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")}function y(){h()}function f(A){for(;A.length>0;){var I=A.shift();if("function"!=typeof I){var e=I.func;"number"==typeof e?void 0===I.arg?J.dynCall_v(e):J.dynCall_vi(e,I.arg):e(void 0===I.arg?null:I.arg)}else I()}}function _(){if(J.preRun)for("function"==typeof J.preRun&&(J.preRun=[J.preRun]);J.preRun.length;)d(J.preRun.shift());f(pA)}function p(){DA||(DA=!0,f(wA))}function w(){f(lA)}function l(){f(uA),vA=!0}function u(){if(J.postRun)for("function"==typeof J.postRun&&(J.postRun=[J.postRun]);J.postRun.length;)D(J.postRun.shift());f(dA)}function d(A){pA.unshift(A)}function D(A){dA.unshift(A)}function v(A,I){gA.set(A,I)}function b(A,I,e){for(var g=0;g<A.length;++g)gA[I++>>0]=A.charCodeAt(g);e||(gA[I>>0]=0)}function k(A){mA++,J.monitorRunDependencies&&J.monitorRunDependencies(mA)}function G(A){if(mA--,J.monitorRunDependencies&&J.monitorRunDependencies(mA),0==mA&&(null!==MA&&(clearInterval(MA),MA=null),HA)){var I=HA;HA=null,I()}}function F(A){return J.___errno_location&&(rA[J.___errno_location()>>2]=A),A}function m(A,I,e){var g=e>0?e:o(A)+1,i=new Array(g),B=n(A,i,0,i.length);return I&&(i.length=B),i}function M(A){for(var e=[],g=0;g<A.length;g++){var i=A[g];i>255&&(JA&&I(!1,"Character code "+i+" ("+String.fromCharCode(i)+")  at offset "+g+" not in 0x00-0xFF."),i&=255),e.push(String.fromCharCode(i))}return e.join("")}function H(A){if("boolean"==typeof K&&K){var I;try{I=Buffer.from(A,"base64")}catch(e){I=new Buffer(A,"base64")}return new Uint8Array(I.buffer,I.byteOffset,I.byteLength)}try{for(var e=LA(A),g=new Uint8Array(e.length),i=0;i<e.length;++i)g[i]=e.charCodeAt(i);return g}catch(A){throw new Error("Converting base64 string to bytes failed.")}}function Y(A){var I="data:application/octet-stream;base64,";if(String.prototype.startsWith?A.startsWith(I):0===A.indexOf(I))return H(A.slice(I.length))}function S(A){this.name="ExitStatus",this.message="Program terminated with exit("+A+")",this.status=A}function R(A){function I(){J.calledRun||(J.calledRun=!0,z||(p(),w(),J.onRuntimeInitialized&&J.onRuntimeInitialized(),J._main&&AI&&J.callMain(A),u()))}A=A||J.arguments,null===zA&&(zA=Date.now()),mA>0||(_(),mA>0||J.calledRun||(J.setStatus?(J.setStatus("Running..."),setTimeout(function(){setTimeout(function(){J.setStatus("")},1),I()},1)):I()))}function N(A,I){I&&J.noExitRuntime||(J.noExitRuntime||(z=!0,O=A,EA=WA,l(),J.onExit&&J.onExit(A)),K&&process.exit(A),J.quit(A,new S(A)))}function U(A){J.onAbort&&J.onAbort(A),void 0!==A?(J.print(A),J.printErr(A),A=JSON.stringify(A)):A="",z=!0,O=1;var I="abort("+A+") at "+s()+"\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";throw $A&&$A.forEach(function(e){I=e(I,A)}),I}(J=g).onAbort=void 0,J.onRuntimeInitialized=void 0;var J;J||(J=(void 0!==J?J:null)||{});var P,L={};for(P in J)J.hasOwnProperty(P)&&(L[P]=J[P]);var x=!1,X=!1,K=!1,T=!1;if(J.ENVIRONMENT)if("WEB"===J.ENVIRONMENT)x=!0;else if("WORKER"===J.ENVIRONMENT)X=!0;else if("NODE"===J.ENVIRONMENT)K=!0;else{if("SHELL"!==J.ENVIRONMENT)throw new Error("The provided Module['ENVIRONMENT'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.");T=!0}else x="object"==typeof window,X="function"==typeof importScripts,K="object"==typeof process&&"function"==typeof require&&!x&&!X,T=!x&&!K&&!X;if(K){J.print||(J.print=console.log),J.printErr||(J.printErr=console.warn);var V,q;J.read=function(A,I){var e;return(e=Y(A))||(V||(V=require("fs")),q||(q=require("path")),A=q.normalize(A),e=V.readFileSync(A)),I?e:e.toString()},J.readBinary=function(A){var e=J.read(A,!0);return e.buffer||(e=new Uint8Array(e)),I(e.buffer),e},J.load=function(I){A(read(I))},J.thisProgram||(process.argv.length>1?J.thisProgram=process.argv[1].replace(/\\/g,"/"):J.thisProgram="unknown-program"),J.arguments=process.argv.slice(2),"undefined"!=typeof module&&(module.exports=J),process.on("uncaughtException",function(A){if(!(A instanceof S))throw A}),J.inspect=function(){return"[Emscripten Module object]"}}else if(T)J.print||(J.print=print),"undefined"!=typeof printErr&&(J.printErr=printErr),"undefined"!=typeof read?J.read=function(A){var I=Y(A);return I?M(I):read(A)}:J.read=function(){throw"no read() available"},J.readBinary=function(A){var e;return(e=Y(A))?e:"function"==typeof readbuffer?new Uint8Array(readbuffer(A)):(e=read(A,"binary"),I("object"==typeof e),e)},"undefined"!=typeof scriptArgs?J.arguments=scriptArgs:void 0!==arguments&&(J.arguments=arguments),"function"==typeof quit&&(J.quit=function(A,I){quit(A)});else{if(!x&&!X)throw new Error("Unknown runtime environment. Where are we?");J.read=function(A){try{var I=new XMLHttpRequest;return I.open("GET",A,!1),I.send(null),I.responseText}catch(I){var e=Y(A);if(e)return M(e);throw I}},X&&(J.readBinary=function(A){try{var I=new XMLHttpRequest;return I.open("GET",A,!1),I.responseType="arraybuffer",I.send(null),new Uint8Array(I.response)}catch(I){var e=Y(A);if(e)return e;throw I}}),J.readAsync=function(A,I,e){var g=new XMLHttpRequest;g.open("GET",A,!0),g.responseType="arraybuffer",g.onload=function(){if(200==g.status||0==g.status&&g.response)I(g.response);else{var i=Y(A);i?I(i.buffer):e()}},g.onerror=e,g.send(null)},void 0!==arguments&&(J.arguments=arguments),"undefined"!=typeof console?(J.print||(J.print=function(A){}),J.printErr||(J.printErr=function(A){})):J.print||(J.print=function(A){}),X&&(J.load=importScripts),void 0===J.setWindowTitle&&(J.setWindowTitle=function(A){document.title=A})}!J.load&&J.read&&(J.load=function(I){A(J.read(I))}),J.print||(J.print=function(){}),J.printErr||(J.printErr=J.print),J.arguments||(J.arguments=[]),J.thisProgram||(J.thisProgram="./this.program"),J.quit||(J.quit=function(A,I){throw I}),J.print=J.print,J.printErr=J.printErr,J.preRun=[],J.postRun=[];for(P in L)L.hasOwnProperty(P)&&(J[P]=L[P]);L=void 0;var j={setTempRet0:function(A){return tempRet0=A,A},getTempRet0:function(){return tempRet0},stackSave:function(){return EA},stackRestore:function(A){EA=A},getNativeTypeSize:function(A){switch(A){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:if("*"===A[A.length-1])return j.QUANTUM_SIZE;if("i"===A[0]){var e=parseInt(A.substr(1));return I(e%8==0),e/8}return 0}},getNativeFieldSize:function(A){return Math.max(j.getNativeTypeSize(A),j.QUANTUM_SIZE)},STACK_ALIGN:16,prepVararg:function(A,e){return"double"===e||"i64"===e?7&A&&(I(4==(7&A)),A+=4):I(0==(3&A)),A},getAlignSize:function(A,I,e){return e||"i64"!=A&&"double"!=A?A?Math.min(I||(A?j.getNativeFieldSize(A):0),j.QUANTUM_SIZE):Math.min(I,8):8},dynCall:function(A,I,e){return e&&e.length?J["dynCall_"+A].apply(null,[I].concat(e)):J["dynCall_"+A].call(null,I)},functionPointers:[null,null,null,null,null,null,null,null],addFunction:function(A){for(var I=0;I<j.functionPointers.length;I++)if(!j.functionPointers[I])return j.functionPointers[I]=A,1*(1+I);throw"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS."},removeFunction:function(A){j.functionPointers[(A-1)/1]=null},warnOnce:function(A){j.warnOnce.shown||(j.warnOnce.shown={}),j.warnOnce.shown[A]||(j.warnOnce.shown[A]=1,J.printErr(A))},funcWrappers:{},getFuncWrapper:function(A,e){if(A){I(e),j.funcWrappers[e]||(j.funcWrappers[e]={});var g=j.funcWrappers[e];return g[A]||(1===e.length?g[A]=function(){return j.dynCall(e,A)}:2===e.length?g[A]=function(I){return j.dynCall(e,A,[I])}:g[A]=function(){return j.dynCall(e,A,Array.prototype.slice.call(arguments))}),g[A]}},getCompilerSetting:function(A){throw"You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work"},stackAlloc:function(A){var I=EA;return EA=EA+A|0,EA=EA+15&-16,I},staticAlloc:function(A){var I=cA;return cA=cA+A|0,cA=cA+15&-16,I},dynamicAlloc:function(A){var I=rA[yA>>2],e=-16&(I+A+15|0);return rA[yA>>2]=e,e>=_A&&!y()?(rA[yA>>2]=I,0):I},alignMemory:function(A,I){return A=Math.ceil(A/(I||16))*(I||16)},makeBigInt:function(A,I,e){return e?+(A>>>0)+4294967296*+(I>>>0):+(A>>>0)+4294967296*+(0|I)},GLOBAL_BASE:8,QUANTUM_SIZE:4,__dummy__:0};J.Runtime=j;var Z,W,z=0,O=0;!function(){var A={stackSave:function(){j.stackSave()},stackRestore:function(){j.stackRestore()},arrayToC:function(A){var I=j.stackAlloc(A.length);return v(A,I),I},stringToC:function(A){var I=0;if(null!==A&&void 0!==A&&0!==A){var e=1+(A.length<<2);C(A,I=j.stackAlloc(e),e)}return I}},I={string:A.stringToC,array:A.arrayToC};W=function(A,g,i,B,t){var a=e(A),n=[],C=0;if(B)for(var o=0;o<B.length;o++){var c=I[i[o]];c?(0===C&&(C=j.stackSave()),n[o]=c(B[o])):n[o]=B[o]}var Q=a.apply(null,n);return"string"===g&&(Q=r(Q)),0!==C&&j.stackRestore(C),Q},Z=function(A,I,e){return function(){return W(A,I,e,arguments)}}}(),J.ccall=W,J.cwrap=Z,J.setValue=i,J.getValue=B;var $=2,AA=4;J.ALLOC_NORMAL=0,J.ALLOC_STACK=1,J.ALLOC_STATIC=$,J.ALLOC_DYNAMIC=3,J.ALLOC_NONE=AA,J.allocate=t,J.getMemory=function(A){return QA?DA?KA(A):j.dynamicAlloc(A):j.staticAlloc(A)},J.Pointer_stringify=r,J.AsciiToString=function(A){for(var I="";;){var e=gA[A++>>0];if(!e)return I;I+=String.fromCharCode(e)}},J.stringToAscii=function(A,I){return b(A,I,!1)};var IA="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;J.UTF8ArrayToString=a,J.UTF8ToString=function(A){return a(iA,A)},J.stringToUTF8Array=n,J.stringToUTF8=C,J.lengthBytesUTF8=o,"undefined"!=typeof TextDecoder&&new TextDecoder("utf-16le"),J.stackTrace=s;var eA,gA,iA,BA,tA,rA,aA,nA,CA,oA,cA,QA,EA,sA,hA,yA;oA=cA=EA=sA=hA=yA=0,QA=!1;var fA=J.TOTAL_STACK||5242880,_A=J.TOTAL_MEMORY||16777216;if(_A<fA&&J.printErr("TOTAL_MEMORY should be larger than TOTAL_STACK, was "+_A+"! (TOTAL_STACK="+fA+")"),eA=J.buffer?J.buffer:new ArrayBuffer(_A),J.HEAP8=gA=new Int8Array(eA),J.HEAP16=BA=new Int16Array(eA),J.HEAP32=rA=new Int32Array(eA),J.HEAPU8=iA=new Uint8Array(eA),J.HEAPU16=tA=new Uint16Array(eA),J.HEAPU32=aA=new Uint32Array(eA),J.HEAPF32=nA=new Float32Array(eA),J.HEAPF64=CA=new Float64Array(eA),rA[0]=1668509029,BA[1]=25459,115!==iA[2]||99!==iA[3])throw"Runtime error: expected the system to be little-endian!";J.HEAP=void 0,J.buffer=eA,J.HEAP8=gA,J.HEAP16=BA,J.HEAP32=rA,J.HEAPU8=iA,J.HEAPU16=tA,J.HEAPU32=aA,J.HEAPF32=nA,J.HEAPF64=CA;var pA=[],wA=[],lA=[],uA=[],dA=[],DA=!1,vA=!1;J.addOnPreRun=d,J.addOnInit=function(A){wA.unshift(A)},J.addOnPreMain=function(A){lA.unshift(A)},J.addOnExit=function(A){uA.unshift(A)},J.addOnPostRun=D,J.writeStringToMemory=function(A,I,e){j.warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");var g,i;e&&(i=I+o(A),g=gA[i]),C(A,I,1/0),e&&(gA[i]=g)},J.writeArrayToMemory=v,J.writeAsciiToMemory=b,Math.imul&&-5===Math.imul(4294967295,5)||(Math.imul=function(A,I){var e=65535&A,g=65535&I;return e*g+((A>>>16)*g+e*(I>>>16)<<16)|0}),Math.imul=Math.imul,Math.clz32||(Math.clz32=function(A){A>>>=0;for(var I=0;I<32;I++)if(A&1<<31-I)return I;return 32}),Math.clz32=Math.clz32,Math.trunc||(Math.trunc=function(A){return A<0?Math.ceil(A):Math.floor(A)}),Math.trunc=Math.trunc;var bA=Math.abs,kA=(Math.cos,Math.sin,Math.tan,Math.acos,Math.asin,Math.atan,Math.atan2,Math.exp,Math.log,Math.sqrt,Math.ceil),GA=Math.floor,FA=(Math.pow,Math.imul,Math.fround,Math.round,Math.min),mA=(Math.clz32,Math.trunc,0),MA=null,HA=null;J.addRunDependency=k,J.removeRunDependency=G,J.preloadedImages={},J.preloadedAudios={};var YA=null,SA=[function(){return J.getRandomValue()},function(){if(void 0===J.getRandomValue)try{var A="object"==typeof window?window:self,I=void 0!==A.crypto?A.crypto:A.msCrypto,e=function(){var A=new Uint32Array(1);return I.getRandomValues(A),A[0]>>>0};e(),J.getRandomValue=e}catch(A){try{var g=require("crypto"),i=function(){var A=g.randomBytes(4);return(A[0]<<24|A[1]<<16|A[2]<<8|A[3])>>>0};i(),J.getRandomValue=i}catch(A){throw"No secure random number generator found"}}}];oA=j.GLOBAL_BASE,cA=oA+35360,wA.push(),YA="data:application/octet-stream;base64,AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJuiVj8KyJ7BFw/SJ8u+Y8NXfrAXTxjM5sTgCiG1T/AXHF2pwPU3YT7o8C3YNEGcPKiBT+iw5zMZOx/13kqwDeuz///////////////////////////////////////9/7f///////////////////////////////////////3/u////////////////////////////////////////fwjJvPNn5glqO6fKhIWuZ7sr+JT+cvNuPPE2HV869U+l0YLmrX9SDlEfbD4rjGgFm2u9Qfur2YMfeSF+ExnN4FsirijXmC+KQs1l7yORRDdxLztN7M/7wLW824mBpdu16Ti1SPNbwlY5GdAFtvER8VmbTxmvpII/khiBbdrVXhyrQgIDo5iqB9i+b3BFAVuDEoyy5E6+hTEk4rT/1cN9DFVviXvydF2+crGWFjv+sd6ANRLHJacG3JuUJmnPdPGbwdJK8Z7BaZvk4yVPOIZHvu+11YyLxp3BD2WcrHfMoQwkdQIrWW8s6S2D5KZuqoR0StT7Qb3cqbBctVMRg9qI+Xar32buUlE+mBAytC1txjGoPyH7mMgnA7DkDu++x39Zv8KPqD3zC+DGJacKk0eRp9VvggPgUWPKBnBuDgpnKSkU/C/SRoUKtycmySZcOCEbLu0qxFr8bSxN37OVnRMNOFPeY6+LVHMKZaiydzy7Cmp25q7tRy7JwoE7NYIUhSxykmQD8Uyh6L+iATBCvEtmGqiRl/jQcItLwjC+VAajUWzHGFLv1hnoktEQqWVVJAaZ1iogcVeFNQ70uNG7MnCgahDI0NK4FsGkGVOrQVEIbDcemeuO30x3SCeoSJvhtbywNGNaycWzDBw5y4pB40qq2E5z42N3T8qcW6O4stbzby5o/LLvXe6Cj3RgLxdDb2OleHKr8KEUeMiE7DlkGggCx4woHmMj+v++kOm9gt7rbFCkFXnGsvej+b4rU3Lj8nhxxpxhJurOPifKB8LAIce4htEe6+DN1n3a6njRbu5/T331um8Xcqpn8AammMiixX1jCq4N+b4EmD8RG0ccEzULcRuEfQQj9XfbKJMkx0B7q8oyvL7JFQq+njxMDRCcxGcdQ7ZCPsu+1MVMKn5l/Jwpf1ns+tY6q2/LXxdYR0qMGURstnhZ/4Vy0wC9bhX/DwpqACnAAQCY6Hn/vDyg/5lxzv8At+L+tA1I/7CgDv7TyYb/nhiPAH9pNQBgDL0Ap9f7/59MgP5qZeH/HvwEAJIMrgBZ8bL+CuWm/3vdKv4eFNQAUoADADDR8wB3eUD/MuOc/wBuxQFnG5AAhTuMAb3xJP/4JcMBYNw3ALdMPv/DQj0AMkykAeGkTP9MPaP/dT4fAFGRQP92QQ4AonPW/waKLgB85vT/CoqPADQawgC49EwAgY8pAb70E/97qnr/YoFEAHnVkwBWZR7/oWebAIxZQ//v5b4BQwu1AMbwif7uRbz/Q5fuABMqbP/lVXEBMkSH/xFqCQAyZwH/UAGoASOYHv8QqLkBOFno/2XS/AAp+kcAzKpP/w4u7/9QTe8AvdZL/xGN+QAmUEz/vlV1AFbkqgCc2NABw8+k/5ZCTP+v4RD/jVBiAUzb8gDGonIALtqYAJsr8f6boGj/M7ulAAIRrwBCVKAB9zoeACNBNf5F7L8ALYb1AaN73QAgbhT/NBelALrWRwDpsGAA8u82ATlZigBTAFT/iKBkAFyOeP5ofL4AtbE+//opVQCYgioBYPz2AJeXP/7vhT4AIDicAC2nvf+OhbMBg1bTALuzlv76qg7/0qNOACU0lwBjTRoA7pzV/9XA0QFJLlQAFEEpATbOTwDJg5L+qm8Y/7EhMv6rJsv/Tvd0ANHdmQCFgLIBOiwZAMknOwG9E/wAMeXSAXW7dQC1s7gBAHLbADBekwD1KTgAfQ3M/vStdwAs3SD+VOoUAPmgxgHsfur/L2Oo/qrimf9ms9gA4o16/3pCmf629YYA4+QZAdY56//YrTj/tefSAHeAnf+BX4j/bn4zAAKpt/8HgmL+RbBe/3QE4wHZ8pH/yq0fAWkBJ/8ur0UA5C86/9fgRf7POEX/EP6L/xfP1P/KFH7/X9Vg/wmwIQDIBc//8SqA/iMhwP/45cQBgRF4APtnl/8HNHD/jDhC/yji9f/ZRiX+rNYJ/0hDhgGSwNb/LCZwAES4S//OWvsAleuNALWqOgB09O8AXJ0CAGatYgDpiWABfzHLAAWblAAXlAn/03oMACKGGv/bzIgAhggp/+BTK/5VGfcAbX8A/qmIMADud9v/563VAM4S/v4Iugf/fgkHAW8qSABvNOz+YD+NAJO/f/7NTsD/DmrtAbvbTACv87v+aVmtAFUZWQGi85QAAnbR/iGeCQCLoy7/XUYoAGwqjv5v/I7/m9+QADPlp/9J/Jv/XnQM/5ig2v+c7iX/s+rP/8UAs/+apI0A4cRoAAojGf7R1PL/Yf3e/rhl5QDeEn8BpIiH/x7PjP6SYfMAgcAa/slUIf9vCk7/k1Gy/wQEGACh7tf/Bo0hADXXDv8ptdD/54udALPL3f//uXEAveKs/3FC1v/KPi3/ZkAI/06uEP6FdUT/hTuMAb3xJP/4JcMBYNw3ALdMPv/DQj0AMkykAeGkTP9MPaP/dT4fAFGRQP92QQ4AonPW/waKLgB85vT/CoqPADQawgC49EwAgY8pAb70E/97qnr/YoFEAHnVkwBWZR7/oWebAIxZQ//v5b4BQwu1AMbwif7uRbz/6nE8/yX/Of9Fsrb+gNCzAHYaff4DB9b/8TJN/1XLxf/Th/r/GTBk/7vVtP4RWGkAU9GeAQVzYgAErjz+qzdu/9m1Ef8UvKoAkpxm/lfWrv9yepsB6SyqAH8I7wHW7OoArwXbADFqPf8GQtD/Ampu/1HqE//Xa8D/Q5fuABMqbP/lVXEBMkSH/xFqCQAyZwH/UAGoASOYHv8QqLkBOFno/2XS/AAp+kcAzKpP/w4u7/9QTe8AvdZL/xGN+QAmUEz/vlV1AFbkqgCc2NABw8+k/5ZCTP+v4RD/jVBiAUzb8gDGonIALtqYAJsr8f6boGj/sgn8/mRu1AAOBacA6e+j/xyXnQFlkgr//p5G/kf55ABYHjIARDqg/78YaAGBQoH/wDJV/wiziv8m+skAc1CgAIPmcQB9WJMAWkTHAP1MngAc/3YAcfr+AEJLLgDm2isA5Xi6AZREKwCIfO4Bu2vF/1Q19v8zdP7/M7ulAAIRrwBCVKAB9zoeACNBNf5F7L8ALYb1AaN73QAgbhT/NBelALrWRwDpsGAA8u82ATlZigBTAFT/iKBkAFyOeP5ofL4AtbE+//opVQCYgioBYPz2AJeXP/7vhT4AIDicAC2nvf+OhbMBg1bTALuzlv76qg7/RHEV/966O/9CB/EBRQZIAFacbP43p1kAbTTb/g2wF//ELGr/75VH/6SMff+frQEAMynnAJE+IQCKb10BuVNFAJBzLgBhlxD/GOQaADHZ4gBxS+r+wZkM/7YwYP8ODRoAgMP5/kXBOwCEJVH+fWo8ANbwqQGk40IA0qNOACU0lwBjTRoA7pzV/9XA0QFJLlQAFEEpATbOTwDJg5L+qm8Y/7EhMv6rJsv/Tvd0ANHdmQCFgLIBOiwZAMknOwG9E/wAMeXSAXW7dQC1s7gBAHLbADBekwD1KTgAfQ3M/vStdwAs3SD+VOoUAPmgxgHsfur/jz7dAIFZ1v83iwX+RBS//w7MsgEjw9kALzPOASb2pQDOGwb+nlckANk0kv99e9f/VTwf/6sNBwDa9Vj+/CM8ADfWoP+FZTgA4CAT/pNA6gAakaIBcnZ9APj8+gBlXsT/xo3i/jMqtgCHDAn+bazS/8XswgHxQZoAMJwv/5lDN//apSL+SrSzANpCRwFYemMA1LXb/1wq5//vAJoA9U23/15RqgES1dgAq11HADRe+AASl6H+xdFC/670D/6iMLcAMT3w/rZdwwDH5AYByAUR/4kt7f9slAQAWk/t/yc/Tf81Us8BjhZ2/2XoEgFcGkMABchY/yGoiv+V4UgAAtEb/yz1qAHc7RH/HtNp/o3u3QCAUPX+b/4OAN5fvgHfCfEAkkzU/2zNaP8/dZkAkEUwACPkbwDAIcH/cNa+/nOYlwAXZlgAM0r4AOLHj/7MomX/0GG9AfVoEgDm9h7/F5RFAG5YNP7itVn/0C9a/nKhUP8hdPgAs5hX/0WQsQFY7hr/OiBxAQFNRQA7eTT/mO5TADQIwQDnJ+n/xyKKAN5ErQBbOfL+3NJ//8AH9v6XI7sAw+ylAG9dzgDU94UBmoXR/5vnCgBATiYAevlkAR4TYf8+W/kB+IVNAMU/qP50ClIAuOxx/tTLwv89ZPz+JAXK/3dbmf+BTx0AZ2er/u3Xb//YNUUA7/AXAMKV3f8m4d4A6P+0/nZShf850bEBi+iFAJ6wLv7Ccy4AWPflARxnvwDd3q/+lessAJfkGf7aaWcAjlXSAJWBvv/VQV7+dYbg/1LGdQCd3dwAo2UkAMVyJQBorKb+C7YAAFFIvP9hvBD/RQYKAMeTkf8ICXMBQdav/9mt0QBQf6YA9+UE/qe3fP9aHMz+rzvw/wsp+AFsKDP/kLHD/pb6fgCKW0EBeDze//XB7wAd1r3/gAIZAFCaogBN3GsB6s1K/zamZ/90SAkA5F4v/x7IGf8j1ln/PbCM/1Pio/9LgqwAgCYRAF+JmP/XfJ8BT10AAJRSnf7Dgvv/KMpM//t+4ACdYz7+zwfh/2BEwwCMup3/gxPn/yqA/gA02z3+ZstIAI0HC/+6pNUAH3p3AIXykQDQ/Oj/W9W2/48E+v7510oApR5vAasJ3wDleyIBXIIa/02bLQHDixz/O+BOAIgR9wBseSAAT/q9/2Dj/P4m8T4APq59/5tvXf8K5s4BYcUo/wAxOf5B+g0AEvuW/9xt0v8Frqb+LIG9AOsjk/8l943/SI0E/2dr/wD3WgQANSwqAAIe8AAEOz8AWE4kAHGntAC+R8H/x56k/zoIrABNIQwAQT8DAJlNIf+s/mYB5N0E/1ce/gGSKVb/iszv/myNEf+78ocA0tB/AEQtDv5JYD4AUTwY/6oGJP8D+RoAI9VtABaBNv8VI+H/6j04/zrZBgCPfFgA7H5CANEmt/8i7gb/rpFmAF8W0wDED5n+LlTo/3UikgHn+kr/G4ZkAVy7w/+qxnAAeBwqANFGQwAdUR8AHahkAamtoABrI3UAPmA7/1EMRQGH777/3PwSAKPcOv+Jibz/U2ZtAGAGTADq3tL/ua7NATye1f8N8dYArIGMAF1o8gDAnPsAK3UeAOFRngB/6NoA4hzLAOkbl/91KwX/8g4v/yEUBgCJ+yz+Gx/1/7fWff4oeZUAup7V/1kI4wBFWAD+y4fhAMmuywCTR7gAEnkp/l4FTgDg1vD+JAW0APuH5wGjitQA0vl0/liBuwATCDH+Pg6Q/59M0wDWM1IAbXXk/mffy/9L/A8Bmkfc/xcNWwGNqGD/tbaFAPozNwDq6tT+rz+eACfwNAGevST/1ShVASC09/8TZhoBVBhh/0UV3gCUi3r/3NXrAejL/wB5OZMA4weaADUWkwFIAeEAUoYw/lM8nf+RSKkAImfvAMbpLwB0EwT/uGoJ/7eBUwAksOYBImdIANuihgD1Kp4AIJVg/qUskADK70j+15YFACpCJAGE168AVq5W/xrFnP8x6If+Z7ZSAP2AsAGZsnoA9foKAOwYsgCJaoQAKB0pADIemP98aSYA5r9LAI8rqgAsgxT/LA0X/+3/mwGfbWT/cLUY/2jcbAA304MAYwzV/5iXkf/uBZ8AYZsIACFsUQABA2cAPm0i//qbtAAgR8P/JkaRAZ9f9QBF5WUBiBzwAE/gGQBObnn/+Kh8ALuA9wACk+v+TwuEAEY6DAG1CKP/T4mF/yWqC/+N81X/sOfX/8yWpP/v1yf/Llec/gijWP+sIugAQixm/xs2Kf7sY1f/KXupATRyKwB1higAm4YaAOfPW/4jhCb/E2Z9/iTjhf92A3H/HQ18AJhgSgFYks7/p7/c/qISWP+2ZBcAH3U0AFEuagEMAgcARVDJAdH2rAAMMI0B4NNYAHTinwB6YoIAQezqAeHiCf/P4nsBWdY7AHCHWAFa9Mv/MQsmAYFsugBZcA8BZS7M/3/MLf5P/93/M0kS/38qZf/xFcoAoOMHAGky7ABPNMX/aMrQAbQPEABlxU7/Yk3LACm58QEjwXwAI5sX/881wAALfaMB+Z65/wSDMAAVXW//PXnnAUXIJP+5MLn/b+4V/ycyGf9j16P/V9Qe/6STBf+ABiMBbN9u/8JMsgBKZbQA8y8wAK4ZK/9Srf0BNnLA/yg3WwDXbLD/CzgHAODpTADRYsr+8hl9ACzBXf7LCLEAh7ATAHBH1f/OO7ABBEMaAA6P1f4qN9D/PEN4AMEVowBjpHMAChR2AJzU3v6gB9n/cvVMAXU7ewCwwlb+1Q+wAE7Oz/7VgTsA6fsWAWA3mP/s/w//xVlU/12VhQCuoHEA6mOp/5h0WACQpFP/Xx3G/yIvD/9jeIb/BezBAPn3fv+Tux4AMuZ1/2zZ2/+jUab/SBmp/pt5T/8cm1n+B34RAJNBIQEv6v0AGjMSAGlTx/+jxOYAcfikAOL+2gC90cv/pPfe/v8jpQAEvPMBf7NHACXt/v9kuvAABTlH/mdISf/0ElH+5dKE/+4GtP8L5a7/493AARExHACj18T+CXYE/zPwRwBxgW3/TPDnALyxfwB9RywBGq/zAF6pGf4b5h0AD4t3Aaiquv+sxUz//Eu8AIl8xABIFmD/LZf5AdyRZABAwJ//eO/iAIGykgAAwH0A64rqALedkgBTx8D/uKxI/0nhgABNBvr/ukFDAGj2zwC8IIr/2hjyAEOKUf7tgXn/FM+WASnHEP8GFIAAn3YFALUQj//cJg8AF0CT/kkaDQBX5DkBzHyAACsY3wDbY8cAFksU/xMbfgCdPtcAbh3mALOn/wE2/L4A3cy2/rOeQf9RnQMAwtqfAKrfAADgCyD/JsViAKikJQAXWAcBpLpuAGAkhgDq8uUA+nkTAPL+cP8DL14BCe8G/1GGmf7W/aj/Q3zgAPVfSgAcHiz+AW3c/7JZWQD8JEwAGMYu/0xNbwCG6oj/J14dALlI6v9GRIf/52YH/k3njACnLzoBlGF2/xAb4QGmzo//brLW/7SDogCPjeEBDdpO/3KZIQFiaMwAr3J1AafOSwDKxFMBOkBDAIovbwHE94D/ieDg/p5wzwCaZP8BhiVrAMaAT/9/0Zv/o/65/jwO8wAf23D+HdlBAMgNdP57PMT/4Du4/vJZxAB7EEv+lRDOAEX+MAHndN//0aBBAchQYgAlwrj+lD8iAIvwQf/ZkIT/OCYt/sd40gBssab/oN4EANx+d/6la6D/Utz4AfGviACQjRf/qYpUAKCJTv/idlD/NBuE/z9gi/+Y+icAvJsPAOgzlv4oD+j/8OUJ/4mvG/9LSWEB2tQLAIcFogFrudUAAvlr/yjyRgDbyBkAGZ0NAENSUP/E+Rf/kRSVADJIkgBeTJQBGPtBAB/AFwC41Mn/e+miAfetSACiV9v+foZZAJ8LDP6maR0ASRvkAXF4t/9Co20B1I8L/5/nqAH/gFoAOQ46/lk0Cv/9CKMBAJHS/wqBVQEutRsAZ4ig/n680f8iI28A19sY/9QL1v5lBXYA6MWF/9+nbf/tUFb/RoteAJ7BvwGbDzP/D75zAE6Hz//5ChsBtX3pAF+sDf6q1aH/J+yK/19dV/++gF8AfQ/OAKaWnwDjD57/zp54/yqNgABlsngBnG2DANoOLP73qM7/1HAcAHAR5P9aECUBxd5sAP7PU/8JWvP/8/SsABpYc//NdHoAv+bBALRkCwHZJWD/mk6cAOvqH//OsrL/lcD7ALb6hwD2FmkAfMFt/wLSlf+pEaoAAGBu/3UJCAEyeyj/wb1jACLjoAAwUEb+0zPsAC169f4srggArSXp/55BqwB6Rdf/WlAC/4NqYP7jcocAzTF3/rA+QP9SMxH/8RTz/4INCP6A2fP/ohsB/lp28QD2xvb/NxB2/8ifnQCjEQEAjGt5AFWhdv8mAJUAnC/uAAmmpgFLYrX/MkoZAEIPLwCL4Z8ATAOO/w7uuAALzzX/t8C6Aasgrv+/TN0B96rbABmsMv7ZCekAy35E/7dcMAB/p7cBQTH+ABA/fwH+Far/O+B//hYwP/8bToL+KMMdAPqEcP4jy5AAaKmoAM/9Hv9oKCb+XuRYAM4QgP/UN3r/3xbqAN/FfwD9tbUBkWZ2AOyZJP/U2Uj/FCYY/oo+PgCYjAQA5txj/wEV1P+UyecA9HsJ/gCr0gAzOiX/Af8O//S3kf4A8qYAFkqEAHnYKQBfw3L+hRiX/5zi5//3BU3/9pRz/uFcUf/eUPb+qntZ/0rHjQAdFAj/iohG/11LXADdkzH+NH7iAOV8FwAuCbUAzUA0AYP+HACXntQAg0BOAM4ZqwAA5osAv/1u/mf3pwBAKCgBKqXx/ztL5P58873/xFyy/4KMVv+NWTgBk8YF/8v4nv6Qoo0AC6ziAIIqFf8Bp4//kCQk/zBYpP6oqtwAYkfWAFvQTwCfTMkBpirW/0X/AP8GgH3/vgGMAJJT2v/X7kgBen81AL10pf9UCEL/1gPQ/9VuhQDDqCwBnudFAKJAyP5bOmgAtjq7/vnkiADLhkz+Y93pAEv+1v5QRZoAQJj4/uyIyv+daZn+la8UABYjE/98eekAuvrG/oTliwCJUK7/pX1EAJDKlP7r7/gAh7h2AGVeEf96SEb+RYKSAH/e+AFFf3b/HlLX/rxKE//lp8L+dRlC/0HqOP7VFpwAlztd/i0cG/+6fqT/IAbvAH9yYwHbNAL/Y2Cm/j6+fv9s3qgBS+KuAObixwA8ddr//PgUAda8zAAfwob+e0XA/6mtJP43YlsA3ypm/okBZgCdWhkA73pA//wG6QAHNhT/UnSuAIclNv8Pun0A43Cv/2S04f8q7fT/9K3i/vgSIQCrY5b/Susy/3VSIP5qqO0Az23QAeQJugCHPKn+s1yPAPSqaP/rLXz/RmO6AHWJtwDgH9cAKAlkABoQXwFE2VcACJcU/xpkOv+wpcsBNHZGAAcg/v70/vX/p5DC/31xF/+webUAiFTRAIoGHv9ZMBwAIZsO/xnwmgCNzW0BRnM+/xQoa/6Kmsf/Xt/i/52rJgCjsRn+LXYD/w7eFwHRvlH/dnvoAQ3VZf97N3v+G/alADJjTP+M1iD/YUFD/xgMHACuVk4BQPdgAKCHQwBCN/P/k8xg/xoGIf9iM1MBmdXQ/wK4Nv8Z2gsAMUP2/hKVSP8NGUgAKk/WACoEJgEbi5D/lbsXABKkhAD1VLj+eMZo/37aYAA4der/DR3W/kQvCv+nmoT+mCbGAEKyWf/ILqv/DWNT/9K7/f+qLSoBitF8ANaijQAM5pwAZiRw/gOTQwA013v/6as2/2KJPgD32if/59rsAPe/fwDDklQApbBc/xPUXv8RSuMAWCiZAcaTAf/OQ/X+8APa/z2N1f9ht2oAw+jr/l9WmgDRMM3+dtHx//B43wHVHZ8Ao3+T/w3aXQBVGET+RhRQ/70FjAFSYf7/Y2O//4RUhf9r2nT/cHouAGkRIADCoD//RN4nAdj9XACxac3/lcnDACrhC/8oonMACQdRAKXa2wC0FgD+HZL8/5LP4QG0h2AAH6NwALEL2/+FDMH+K04yAEFxeQE72Qb/bl4YAXCsbwAHD2AAJFV7AEeWFf/QSbwAwAunAdX1IgAJ5lwAoo4n/9daGwBiYVkAXk/TAFqd8ABf3H4BZrDiACQe4P4jH38A5+hzAVVTggDSSfX/L49y/0RBxQA7SD7/t4Wt/l15dv87sVH/6kWt/82AsQDc9DMAGvTRAUneTf+jCGD+lpXTAJ7+ywE2f4sAoeA7AARtFv/eKi3/0JJm/+yOuwAyzfX/CkpZ/jBPjgDeTIL/HqY/AOwMDf8xuPQAu3FmANpl/QCZObb+IJYqABnGkgHt8TgAjEQFAFukrP9Okbr+QzTNANvPgQFtcxEANo86ARX4eP+z/x4AwexC/wH/B//9wDD/E0XZAQPWAP9AZZIB330j/+tJs//5p+IA4a8KAWGiOgBqcKsBVKwF/4WMsv+G9Y4AYVp9/7rLuf/fTRf/wFxqAA/Gc//ZmPgAq7J4/+SGNQCwNsEB+vs1ANUKZAEix2oAlx/0/qzgV/8O7Rf//VUa/38ndP+saGQA+w5G/9TQiv/90/oAsDGlAA9Me/8l2qD/XIcQAQp+cv9GBeD/9/mNAEQUPAHx0r3/w9m7AZcDcQCXXK4A5z6y/9u34QAXFyH/zbVQADm4+P9DtAH/Wntd/ycAov9g+DT/VEKMACJ/5P/CigcBpm68ABURmwGavsb/1lA7/xIHjwBIHeIBx9n5AOihRwGVvskA2a9f/nGTQ/+Kj8f/f8wBAB22UwHO5pv/usw8AAp9Vf/oYBn//1n3/9X+rwHowVEAHCuc/gxFCACTGPgAEsYxAIY8IwB29hL/MVj+/uQVuv+2QXAB2xYB/xZ+NP+9NTH/cBmPACZ/N//iZaP+0IU9/4lFrgG+dpH/PGLb/9kN9f/6iAoAVP7iAMkffQHwM/v/H4OC/wKKMv/X17EB3wzu//yVOP98W0T/SH6q/nf/ZACCh+j/Dk+yAPqDxQCKxtAAediL/ncSJP8dwXoAECot/9Xw6wHmvqn/xiPk/m6tSADW3fH/OJSHAMB1Tv6NXc//j0GVABUSYv9fLPQBar9NAP5VCP7WbrD/Sa0T/qDEx//tWpAAwaxx/8ibiP7kWt0AiTFKAaTd1//RvQX/aew3/yofgQHB/+wALtk8AIpYu//iUuz/UUWX/46+EAENhggAf3ow/1FAnACr84sA7SP2AHqPwf7UepIAXyn/AVeETQAE1B8AER9OACctrf4Yjtn/XwkG/+NTBgBiO4L+Ph4hAAhz0wGiYYD/B7gX/nQcqP/4ipf/YvTwALp2ggBy+Ov/aa3IAaB8R/9eJKQBr0GS/+7xqv7KxsUA5EeK/i32bf/CNJ4AhbuwAFP8mv5Zvd3/qkn8AJQ6fQAkRDP+KkWx/6hMVv8mZMz/JjUjAK8TYQDh7v3/UVGHANIb//7rSWsACM9zAFJ/iABUYxX+zxOIAGSkZQBQ0E3/hM/t/w8DD/8hpm4AnF9V/yW5bwGWaiP/ppdMAHJXh/+fwkAADHof/+gHZf6td2IAmkfc/r85Nf+o6KD/4CBj/9qcpQCXmaMA2Q2UAcVxWQCVHKH+zxceAGmE4/825l7/ha3M/1y3nf9YkPz+ZiFaAJ9hAwC12pv/8HJ3AGrWNf+lvnMBmFvh/1hqLP/QPXEAlzR8AL8bnP9uNuwBDh6m/yd/zwHlxxwAvOS8/mSd6wD22rcBaxbB/86gXwBM75MAz6F1ADOmAv80dQr+STjj/5jB4QCEXoj/Zb/RACBr5f/GK7QBZNJ2AHJDmf8XWBr/WZpcAdx4jP+Qcs///HP6/yLOSACKhX//CLJ8AVdLYQAP5Vz+8EOD/3Z74/6SeGj/kdX/AYG7Rv/bdzYAAROtAC2WlAH4U0gAy+mpAY5rOAD3+SYBLfJQ/x7pZwBgUkYAF8lvAFEnHv+ht07/wuoh/0TjjP7YznQARhvr/2iQTwCk5l3+1oecAJq78v68FIP/JG2uAJ9w8QAFbpUBJKXaAKYdEwGyLkkAXSsg/vi97QBmm40AyV3D//GL/f8Pb2L/bEGj/ptPvv9JrsH+9igw/2tYC/7KYVX//cwS/3HyQgBuoML+0BK6AFEVPAC8aKf/fKZh/tKFjgA48on+KW+CAG+XOgFv1Y3/t6zx/yYGxP+5B3v/Lgv2APVpdwEPAqH/CM4t/xLKSv9TfHMB1I2dAFMI0f6LD+j/rDat/jL3hADWvdUAkLhpAN/++AD/k/D/F7xIAAczNgC8GbT+3LQA/1OgFACjvfP/OtHC/1dJPABqGDEA9fncABatpwB2C8P/E37tAG6fJf87Ui8AtLtWALyU0AFkJYX/B3DBAIG8nP9UaoH/heHKAA7sb/8oFGUArKwx/jM2Sv/7ubj/XZvg/7T54AHmspIASDk2/rI+uAB3zUgAue/9/z0P2gDEQzj/6iCrAS7b5ADQbOr/FD/o/6U1xwGF5AX/NM1rAErujP+WnNv+76yy//u93/4gjtP/2g+KAfHEUAAcJGL+FurHAD3t3P/2OSUAjhGO/50+GgAr7l/+A9kG/9UZ8AEn3K7/ms0w/hMNwP/0Ijb+jBCbAPC1Bf6bwTwApoAE/ySROP+W8NsAeDORAFKZKgGM7JIAa1z4Ab0KAwA/iPIA0ycYABPKoQGtG7r/0szv/inRov+2/p//rHQ0AMNn3v7NRTsANRYpAdowwgBQ0vIA0rzPALuhof7YEQEAiOFxAPq4PwDfHmL+TaiiADs1rwATyQr/i+DCAJPBmv/UvQz+Aciu/zKFcQFes1oArbaHAF6xcQArWdf/iPxq/3uGU/4F9UL/UjEnAdwC4ABhgbEATTtZAD0dmwHLq9z/XE6LAJEhtf+pGI0BN5azAIs8UP/aJ2EAApNr/zz4SACt5i8BBlO2/xBpov6J1FH/tLiGASfepP/dafsB73B9AD8HYQA/aOP/lDoMAFo84P9U1PwAT9eoAPjdxwFzeQEAJKx4ACCiu/85azH/kyoVAGrGKwE5SlcAfstR/4GHwwCMH7EA3YvCAAPe1wCDROcAsVay/nyXtAC4fCYBRqMRAPn7tQEqN+MA4qEsABfsbgAzlY4BXQXsANq3av5DGE0AKPXR/955mQClOR4AU308AEYmUgHlBrwAbd6d/zd2P//Nl7oA4yGV//6w9gHjseMAImqj/rArTwBqX04BufF6/7kOPQAkAcoADbKi//cLhACh5lwBQQG5/9QypQGNkkD/nvLaABWkfQDVi3oBQ0dXAMuesgGXXCsAmG8F/ycD7//Z//r/sD9H/0r1TQH6rhL/IjHj//Yu+/+aIzABfZ09/2okTv9h7JkAiLt4/3GGq/8T1dn+2F7R//wFPQBeA8oAAxq3/0C/K/8eFxUAgY1N/2Z4BwHCTIwAvK80/xFRlADoVjcB4TCsAIYqKv/uMi8AqRL+ABSTV/8Ow+//RfcXAO7lgP+xMXAAqGL7/3lH+ADzCJH+9uOZ/9upsf77i6X/DKO5/6Qoq/+Znxv+821b/94YcAES1ucAa521/sOTAP/CY2j/WYy+/7FCfv5quUIAMdofAPyungC8T+YB7ingANTqCAGIC7UApnVT/0TDXgAuhMkA8JhYAKQ5Rf6g4Cr/O9dD/3fDjf8ktHn+zy8I/67S3wBlxUT//1KNAfqJ6QBhVoUBEFBFAISDnwB0XWQALY2LAJisnf9aK1sAR5kuACcQcP/ZiGH/3MYZ/rE1MQDeWIb/gA88AM/Aqf/AdNH/ak7TAcjVt/8HDHr+3ss8/yFux/77anUA5OEEAXg6B//dwVT+cIUbAL3Iyf+Lh5YA6jew/z0yQQCYbKn/3FUB/3CH4wCiGroAz2C5/vSIawBdmTIBxmGXAG4LVv+Pda7/c9TIAAXKtwDtpAr+ue8+AOx4Ev5ie2P/qMnC/i7q1gC/hTH/Y6l3AL67IwFzFS3/+YNIAHAGe//WMbX+pukiAFzFZv795M3/AzvJASpiLgDbJSP/qcMmAF58wQGcK98AX0iF/njOvwB6xe//sbtP//4uAgH6p74AVIETAMtxpv/5H73+SJ3K/9BHSf/PGEgAChASAdJRTP9Y0MD/fvNr/+6NeP/Heer/iQw7/yTce/+Uszz+8AwdAEIAYQEkHib/cwFd/2Bn5//FnjsBwKTwAMrKOf8YrjAAWU2bASpM1wD0l+kAFzBRAO9/NP7jgiX/+HRdAXyEdgCt/sABButT/26v5wH7HLYAgfld/lS4gABMtT4Ar4C6AGQ1iP5tHeIA3ek6ARRjSgAAFqAAhg0VAAk0N/8RWYwAryI7AFSld//g4ur/B0im/3tz/wES1vYA+gdHAdncuQDUI0z/Jn2vAL1h0gBy7iz/Kbyp/i26mgBRXBYAhKDBAHnQYv8NUSz/y5xSAEc6Ff/Qcr/+MiaTAJrYwwBlGRIAPPrX/+mE6/9nr44BEA5cAI0fbv7u8S3/mdnvAWGoL//5VRABHK8+/zn+NgDe534Api11/hK9YP/kTDIAyPReAMaYeAFEIkX/DEGg/mUTWgCnxXj/RDa5/ynavABxqDAAWGm9ARpSIP+5XaQB5PDt/0K2NQCrxVz/awnpAcd4kP9OMQr/bapp/1oEH/8c9HH/SjoLAD7c9v95msj+kNKy/345gQEr+g7/ZW8cAS9W8f89Rpb/NUkF/x4angDRGlYAiu1KAKRfvACOPB3+onT4/7uvoACXEhAA0W9B/suGJ/9YbDH/gxpH/90b1/5oaV3/H+wf/ocA0/+Pf24B1EnlAOlDp/7DAdD/hBHd/zPZWgBD6zL/39KPALM1ggHpasYA2a3c/3DlGP+vml3+R8v2/zBChf8DiOb/F91x/utv1QCqeF/++90CAC2Cnv5pXtn/8jS0/tVELf9oJhwA9J5MAKHIYP/PNQ3/u0OUAKo2+AB3orL/UxQLACoqwAGSn6P/t+hvAE3lFf9HNY8AG0wiAPaIL//bJ7b/XODJAROODv9FtvH/o3b1AAltagGqtff/Ti/u/1TSsP/Va4sAJyYLAEgVlgBIgkUAzU2b/o6FFQBHb6z+4io7/7MA1wEhgPEA6vwNAbhPCABuHkn/9o29AKrP2gFKmkX/ivYx/5sgZAB9Smn/WlU9/yPlsf8+fcH/mVa8AUl41ADRe/b+h9Em/5c6LAFcRdb/DgxY//yZpv/9z3D/PE5T/+N8bgC0YPz/NXUh/qTcUv8pARv/JqSm/6Rjqf49kEb/wKYSAGv6QgDFQTIAAbMS//9oAf8rmSP/UG+oAG6vqAApaS3/2w7N/6TpjP4rAXYA6UPDALJSn/+KV3r/1O5a/5AjfP4ZjKQA+9cs/oVGa/9l41D+XKk3ANcqMQBytFX/IegbAazVGQA+sHv+IIUY/+G/PgBdRpkAtSpoARa/4P/IyIz/+eolAJU5jQDDOND//oJG/yCt8P8d3McAbmRz/4Tl+QDk6d//JdjR/rKx0f+3LaX+4GFyAIlhqP/h3qwApQ0xAdLrzP/8BBz+RqCXAOi+NP5T+F3/PtdNAa+vs/+gMkIAeTDQAD+p0f8A0sgA4LssAUmiUgAJsI//E0zB/x07pwEYK5oAHL6+AI28gQDo68v/6gBt/zZBnwA8WOj/ef2W/vzpg//GbikBU01H/8gWO/5q/fL/FQzP/+1CvQBaxsoB4ax/ADUWygA45oQAAVa3AG2+KgDzRK4BbeSaAMixegEjoLf/sTBV/1raqf/4mE4Ayv5uAAY0KwCOYkH/P5EWAEZqXQDoimsBbrM9/9OB2gHy0VwAI1rZAbaPav90Zdn/cvrd/63MBgA8lqMASaws/+9uUP/tTJn+oYz5AJXo5QCFHyj/rqR3AHEz1gCB5AL+QCLzAGvj9P+uasj/VJlGATIjEAD6Stj+7L1C/5n5DQDmsgT/3SnuAHbjef9eV4z+/ndcAEnv9v51V4AAE9OR/7Eu/ADlW/YBRYD3/8pNNgEICwn/mWCmANnWrf+GwAIBAM8AAL2uawGMhmQAnsHzAbZmqwDrmjMAjgV7/zyoWQHZDlz/E9YFAdOn/gAsBsr+eBLs/w9xuP+434sAKLF3/rZ7Wv+wpbAA903CABvqeADnANb/OyceAH1jkf+WREQBjd74AJl70v9uf5j/5SHWAYfdxQCJYQIADI/M/1EpvABzT4L/XgOEAJivu/98jQr/fsCz/wtnxgCVBi0A21W7AeYSsv9ItpgAA8a4/4Bw4AFhoeYA/mMm/zqfxQCXQtsAO0WP/7lw+QB3iC//e4KEAKhHX/9xsCgB6LmtAM9ddQFEnWz/ZgWT/jFhIQBZQW/+9x6j/3zZ3QFm+tgAxq5L/jk3EgDjBewB5dWtAMlt2gEx6e8AHjeeARmyagCbb7wBXn6MANcf7gFN8BAA1fIZASZHqADNul3+MdOM/9sAtP+GdqUAoJOG/266I//G8yoA85J3AIbrowEE8Yf/wS7B/me0T//hBLj+8naCAJKHsAHqbx4ARULV/ilgewB5Xir/sr/D/y6CKgB1VAj/6THW/u56bQAGR1kB7NN7APQNMP53lA4AchxW/0vtGf+R5RD+gWQ1/4aWeP6onTIAF0ho/+AxDgD/exb/l7mX/6pQuAGGthQAKWRlAZkhEABMmm8BVs7q/8CgpP6le13/Adik/kMRr/+pCzv/nik9/0m8Dv/DBon/FpMd/xRnA//2guP/eiiAAOIvGP4jJCAAmLq3/0XKFADDhcMA3jP3AKmrXgG3AKD/QM0SAZxTD//FOvn++1lu/zIKWP4zK9gAYvLGAfWXcQCr7MIBxR/H/+VRJgEpOxQA/WjmAJhdDv/28pL+1qnw//BmbP6gp+wAmtq8AJbpyv8bE/oBAkeF/68MPwGRt8YAaHhz/4L79wAR1Kf/PnuE//dkvQCb35gAj8UhAJs7LP+WXfABfwNX/19HzwGnVQH/vJh0/woXFwCJw10BNmJhAPAAqP+UvH8AhmuXAEz9qwBahMAAkhY2AOBCNv7muuX/J7bEAJT7gv9Bg2z+gAGgAKkxp/7H/pT/+waDALv+gf9VUj4Ashc6//6EBQCk1ScAhvyS/iU1Uf+bhlIAzafu/14ttP+EKKEA/m9wATZL2QCz5t0B616//xfzMAHKkcv/J3Yq/3WN/QD+AN4AK/syADap6gFQRNAAlMvz/pEHhwAG/gAA/Ll/AGIIgf8mI0j/0yTcASgaWQCoQMX+A97v/wJT1/60n2kAOnPCALp0av/l99v/gXbBAMqutwGmoUgAyWuT/u2ISgDp5moBaW+oAEDgHgEB5QMAZpev/8Lu5P/++tQAu+15AEP7YAHFHgsAt1/MAM1ZigBA3SUB/98e/7Iw0//xyFr/p9Fg/zmC3QAucsj/PbhCADe2GP5utiEAq77o/3JeHwAS3QgAL+f+AP9wUwB2D9f/rRko/sDBH//uFZL/q8F2/2XqNf6D1HAAWcBrAQjQGwC12Q//55XoAIzsfgCQCcf/DE+1/pO2yv8Tbbb/MdThAEqjywCv6ZQAGnAzAMHBCf8Ph/kAluOCAMwA2wEY8s0A7tB1/xb0cAAa5SIAJVC8/yYtzv7wWuH/HQMv/yrgTAC686cAIIQP/wUzfQCLhxgABvHbAKzlhf/21jIA5wvP/79+UwG0o6r/9TgYAbKk0/8DEMoBYjl2/42DWf4hMxgA85Vb//00DgAjqUP+MR5Y/7MbJP+ljLcAOr2XAFgfAABLqUIAQmXH/xjYxwF5xBr/Dk/L/vDiUf9eHAr/U8Hw/8zBg/9eD1YA2iidADPB0QAA8rEAZrn3AJ5tdAAmh1sA36+VANxCAf9WPOgAGWAl/+F6ogHXu6j/np0uADirogDo8GUBehYJADMJFf81Ge7/2R7o/n2plAAN6GYAlAklAKVhjQHkgykA3g/z//4SEQAGPO0BagNxADuEvQBccB4AadDVADBUs/+7eef+G9ht/6Lda/5J78P/+h85/5WHWf+5F3MBA6Od/xJw+gAZObv/oWCkAC8Q8wAMjfv+Q+q4/ykSoQCvBmD/oKw0/hiwt//GwVUBfHmJ/5cycv/cyzz/z+8FAQAma/837l7+RpheANXcTQF4EUX/VaS+/8vqUQAmMSX+PZB8AIlOMf6o9zAAX6T8AGmphwD95IYAQKZLAFFJFP/P0goA6mqW/14iWv/+nzn+3IVjAIuTtP4YF7kAKTke/71hTABBu9//4Kwl/yI+XwHnkPAATWp+/kCYWwAdYpsA4vs1/+rTBf+Qy97/pLDd/gXnGACzes0AJAGG/31Gl/5h5PwArIEX/jBa0f+W4FIBVIYeAPHELgBncer/LmV5/ih8+v+HLfL+Cfmo/4xsg/+Po6sAMq3H/1jejv/IX54AjsCj/wd1hwBvfBYA7AxB/kQmQf/jrv4A9PUmAPAy0P+hP/oAPNHvAHojEwAOIeb+Ap9xAGoUf//kzWAAidKu/rTUkP9ZYpoBIliLAKeicAFBbsUA8SWpAEI4g/8KyVP+hf27/7FwLf7E+wAAxPqX/+7o1v+W0c0AHPB2AEdMUwHsY1sAKvqDAWASQP923iMAcdbL/3p3uP9CEyQAzED5AJJZiwCGPocBaOllALxUGgAx+YEA0NZL/8+CTf9zr+sAqwKJ/6+RugE39Yf/mla1AWQ69v9txzz/UsyG/9cx5gGM5cD/3sH7/1GID/+zlaL/Fycd/wdfS/6/Ud4A8VFa/2sxyf/0050A3oyV/0HbOP699lr/sjudATDbNABiItcAHBG7/6+pGABcT6H/7MjCAZOP6gDl4QcBxagOAOszNQH9eK4AxQao/8p1qwCjFc4AclVa/w8pCv/CE2MAQTfY/qKSdAAyztT/QJId/56egwFkpYL/rBeB/301Cf8PwRIBGjEL/7WuyQGHyQ7/ZBOVANtiTwAqY4/+YAAw/8X5U/5olU//626I/lKALP9BKST+WNMKALt5uwBihscAq7yz/tIL7v9Ce4L+NOo9ADBxF/4GVnj/d7L1AFeByQDyjdEAynJVAJQWoQBnwzAAGTGr/4pDggC2SXr+lBiCANPlmgAgm54AVGk9ALHCCf+mWVYBNlO7APkodf9tA9f/NZIsAT8vswDC2AP+DlSIAIixDf9I87r/dRF9/9M60/9dT98AWlj1/4vRb/9G3i8ACvZP/8bZsgDj4QsBTn6z/z4rfgBnlCMAgQil/vXwlAA9M44AUdCGAA+Jc//Td+z/n/X4/wKGiP/mizoBoKT+AHJVjf8xprb/kEZUAVW2BwAuNV0ACaah/zeisv8tuLwAkhws/qlaMQB4svEBDnt//wfxxwG9QjL/xo9l/r3zh/+NGBj+S2FXAHb7mgHtNpwAq5LP/4PE9v+IQHEBl+g5APDacwAxPRv/QIFJAfypG/8ohAoBWsnB//x58AG6zikAK8ZhAJFktwDM2FD+rJZBAPnlxP5oe0n/TWhg/oK0CABoezkA3Mrl/2b50wBWDuj/tk7RAO/hpABqDSD/eEkR/4ZD6QBT/rUAt+xwATBAg//x2PP/QcHiAM7xZP5khqb/7crFADcNUQAgfGb/KOSxAHa1HwHnoIb/d7vKAACOPP+AJr3/psmWAM94GgE2uKwADPLM/oVC5gAiJh8BuHBQACAzpf6/8zcAOkmS/punzf9kaJj/xf7P/60T9wDuCsoA75fyAF47J//wHWb/Clya/+VU2/+hgVAA0FrMAfDbrv+eZpEBNbJM/zRsqAFT3msA0yRtAHY6OAAIHRYA7aDHAKrRnQCJRy8Aj1YgAMbyAgDUMIgBXKy6AOaXaQFgv+UAilC//vDYgv9iKwb+qMQxAP0SWwGQSXkAPZInAT9oGP+4pXD+futiAFDVYv97PFf/Uoz1Ad94rf8PxoYBzjzvAOfqXP8h7hP/pXGOAbB3JgCgK6b+71tpAGs9wgEZBEQAD4szAKSEav8idC7+qF/FAInUFwBInDoAiXBF/pZpmv/syZ0AF9Sa/4hS4/7iO93/X5XAAFF2NP8hK9cBDpNL/1mcef4OEk8Ak9CLAZfaPv+cWAgB0rhi/xSve/9mU+UA3EF0AZb6BP9cjtz/IvdC/8zhs/6XUZcARyjs/4o/PgAGT/D/t7m1AHYyGwA/48AAe2M6ATLgm/8R4d/+3OBN/w4sewGNgK8A+NTIAJY7t/+TYR0Alsy1AP0lRwCRVXcAmsi6AAKA+f9TGHwADlePAKgz9QF8l+f/0PDFAXy+uQAwOvYAFOnoAH0SYv8N/h//9bGC/2yOIwCrffL+jAwi/6WhogDOzWUA9xkiAWSROQAnRjkAdszL//IAogCl9B4AxnTiAIBvmf+MNrYBPHoP/5s6OQE2MsYAq9Md/2uKp/+ta8f/baHBAFlI8v/Oc1n/+v6O/rHKXv9RWTIAB2lC/xn+//7LQBf/T95s/yf5SwDxfDIA75iFAN3xaQCTl2IA1aF5/vIxiQDpJfn+KrcbALh35v/ZIKP/0PvkAYk+g/9PQAn+XjBxABGKMv7B/xYA9xLFAUM3aAAQzV//MCVCADecPwFAUkr/yDVH/u9DfQAa4N4A34ld/x7gyv8J3IQAxibrAWaNVgA8K1EBiBwaAOkkCP7P8pQApKI/ADMu4P9yME//Ca/iAN4Dwf8voOj//11p/g4q5gAailIB0Cv0ABsnJv9i0H//QJW2/wX60QC7PBz+MRna/6l0zf93EngAnHST/4Q1bf8NCsoAblOnAJ3bif8GA4L/Mqce/zyfL/+BgJ3+XgO9AAOmRABT39cAllrCAQ+oQQDjUzP/zatC/za7PAGYZi3/d5rhAPD3iABkxbL/i0ff/8xSEAEpzir/nMDd/9h79P/a2rn/u7rv//ysoP/DNBYAkK61/rtkc//TTrD/GwfBAJPVaP9ayQr/UHtCARYhugABB2P+Hs4KAOXqBQA1HtIAigjc/kc3pwBI4VYBdr68AP7BZQGr+az/Xp63/l0CbP+wXUz/SWNP/0pAgf72LkEAY/F//vaXZv8sNdD+O2bqAJqvpP9Y8iAAbyYBAP+2vv9zsA/+qTyBAHrt8QBaTD8APkp4/3rDbgB3BLIA3vLSAIIhLv6cKCkAp5JwATGjb/95sOsATM8O/wMZxgEp69UAVSTWATFcbf/IGB7+qOzDAJEnfAHsw5UAWiS4/0NVqv8mIxr+g3xE/++bI/82yaQAxBZ1/zEPzQAY4B0BfnGQAHUVtgDLn40A34dNALDmsP++5df/YyW1/zMViv8ZvVn/MTCl/pgt9wCqbN4AUMoFABtFZ/7MFoH/tPw+/tIBW/+Sbv7/26IcAN/81QE7CCEAzhD0AIHTMABroNAAcDvRAG1N2P4iFbn/9mM4/7OLE/+5HTL/VFkTAEr6Yv/hKsj/wNnN/9IQpwBjhF8BK+Y5AP4Ly/9jvD//d8H7/lBpNgDotb0Bt0Vw/9Crpf8vbbT/e1OlAJKiNP+aCwT/l+Na/5KJYf496Sn/Xio3/2yk7ACYRP4ACoyD/wpqT/7znokAQ7JC/rF7xv8PPiIAxVgq/5Vfsf+YAMb/lf5x/+Fao/992fcAEhHgAIBCeP7AGQn/Mt3NADHURgDp/6QAAtEJAN002/6s4PT/XjjOAfKzAv8fW6QB5i6K/73m3AA5Lz3/bwudALFbmAAc5mIAYVd+AMZZkf+nT2sA+U2gAR3p5v+WFVb+PAvBAJclJP65lvP/5NRTAayXtADJqZsA9DzqAI7rBAFD2jwAwHFLAXTzz/9BrJsAUR6c/1BIIf4S523/jmsV/n0ahP+wEDv/lsk6AM6pyQDQeeIAKKwO/5Y9Xv84OZz/jTyR/y1slf/ukZv/0VUf/sAM0gBjYl3+mBCXAOG53ACN6yz/oKwV/kcaH/8NQF3+HDjGALE++AG2CPEApmWU/05Rhf+B3tcBvKmB/+gHYQAxcDz/2eX7AHdsigAnE3v+gzHrAIRUkQCC5pT/GUq7AAX1Nv+52/EBEsLk//HKZgBpccoAm+tPABUJsv+cAe8AyJQ9AHP30v8x3YcAOr0IASMuCQBRQQX/NJ65/310Lv9KjA3/0lys/pMXRwDZ4P3+c2y0/5E6MP7bsRj/nP88AZqT8gD9hlcANUvlADDD3v8frzL/nNJ4/9Aj3v8S+LMBAgpl/53C+P+ezGX/aP7F/08+BACyrGUBYJL7/0EKnAACiaX/dATnAPLXAQATIx3/K6FPADuV9gH7QrAAyCED/1Bujv/DoREB5DhC/3svkf6EBKQAQ66sABn9cgBXYVcB+txUAGBbyP8lfTsAE0F2AKE08f/trAb/sL///wFBgv7fvuYAZf3n/5IjbQD6HU0BMQATAHtamwEWViD/2tVBAG9dfwA8Xan/CH+2ABG6Dv79ifb/1Rkw/kzuAP/4XEb/Y+CLALgJ/wEHpNAAzYPGAVfWxwCC1l8A3ZXeABcmq/7FbtUAK3OM/texdgBgNEIBdZ7tAA5Atv8uP67/nl++/+HNsf8rBY7/rGPU//S7kwAdM5n/5HQY/h5lzwAT9pb/hucFAH2G4gFNQWIA7IIh/wVuPgBFbH//B3EWAJEUU/7Coef/g7U8ANnRsf/llNT+A4O4AHWxuwEcDh//sGZQADJUl/99Hzb/FZ2F/xOziwHg6BoAInWq/6f8q/9Jjc7+gfojAEhP7AHc5RT/Kcqt/2NM7v/GFuD/bMbD/ySNYAHsnjv/amRXAG7iAgDj6t4Aml13/0pwpP9DWwL/FZEh/2bWif+v5mf+o/amAF33dP6n4Bz/3AI5AavOVAB75BH/G3h3AHcLkwG0L+H/aMi5/qUCcgBNTtQALZqx/xjEef5SnbYAWhC+AQyTxQBf75j/C+tHAFaSd/+shtYAPIPEAKHhgQAfgnj+X8gzAGnn0v86CZT/K6jd/3ztjgDG0zL+LvVnAKT4VACYRtD/tHWxAEZPuQDzSiAAlZzPAMXEoQH1Ne8AD132/ovwMf/EWCT/oiZ7AIDInQGuTGf/raki/tgBq/9yMxEAiOTCAG6WOP5q9p8AE7hP/5ZN8P+bUKIAADWp/x2XVgBEXhAAXAdu/mJ1lf/5Teb//QqMANZ8XP4jdusAWTA5ARY1pgC4kD3/s//CANb4Pf47bvYAeRVR/qYD5ABqQBr/ReiG//LcNf4u3FUAcZX3/2GzZ/++fwsAh9G2AF80gQGqkM7/esjM/6hkkgA8kJX+RjwoAHo0sf/202X/ru0IAAczeAATH60Afu+c/4+9ywDEgFj/6YXi/x59rf/JbDIAe2Q7//6jAwHdlLX/1og5/t60if/PWDb/HCH7/0PWNAHS0GQAUapeAJEoNQDgb+f+Ixz0/+LHw/7uEeYA2dmk/qmd3QDaLqIBx8+j/2xzogEOYLv/djxMALifmADR50f+KqS6/7qZM/7dq7b/oo6tAOsvwQAHixABX6RA/xDdpgDbxRAAhB0s/2RFdf8861j+KFGtAEe+Pf+7WJ0A5wsXAO11pADhqN//mnJ0/6OY8gEYIKoAfWJx/qgTTAARndz+mzQFABNvof9HWvz/rW7wAArGef/9//D/QnvSAN3C1/55oxH/4QdjAL4xtgBzCYUB6BqK/9VEhAAsd3r/s2IzAJVaagBHMub/Cpl2/7FGGQClV80AN4rqAO4eYQBxm88AYpl/ACJr2/51cqz/TLT//vI5s//dIqz+OKIx/1MD//9x3b3/vBnk/hBYWf9HHMb+FhGV//N5/v9rymP/Cc4OAdwvmQBriScBYTHC/5Uzxf66Ogv/ayvoAcgGDv+1hUH+3eSr/3s+5wHj6rP/Ir3U/vS7+QC+DVABglkBAN+FrQAJ3sb/Qn9KAKfYXf+bqMYBQpEAAERmLgGsWpoA2IBL/6AoMwCeERsBfPAxAOzKsP+XfMD/JsG+AF+2PQCjk3z//6Uz/xwoEf7XYE4AVpHa/h8kyv9WCQUAbynI/+1sYQA5PiwAdbgPAS3xdACYAdz/naW8APoPgwE8LH3/Qdz7/0syuAA1WoD/51DC/4iBfwEVErv/LTqh/0eTIgCu+Qv+I40dAO9Esf9zbjoA7r6xAVf1pv++Mff/klO4/60OJ/+S12gAjt94AJXIm//Uz5EBELXZAK0gV///I7UAd9+hAcjfXv9GBrr/wENV/zKpmACQGnv/OPOz/hREiAAnjLz+/dAF/8hzhwErrOX/nGi7AJf7pwA0hxcAl5lIAJPFa/6UngX/7o/OAH6Zif9YmMX+B0SnAPyfpf/vTjb/GD83/ybeXgDttwz/zszSABMn9v4eSucAh2wdAbNzAAB1dnQBhAb8/5GBoQFpQ40AUiXi/+7i5P/M1oH+ontk/7l56gAtbOcAQgg4/4SIgACs4EL+r528AObf4v7y20UAuA53AVKiOAByexQAomdV/zHvY/6ch9cAb/+n/ifE1gCQJk8B+ah9AJthnP8XNNv/lhaQACyVpf8of7cAxE3p/3aB0v+qh+b/1nfGAOnwIwD9NAf/dWYw/xXMmv+ziLH/FwIDAZWCWf/8EZ8BRjwaAJBrEQC0vjz/OLY7/25HNv/GEoH/leBX/98VmP+KFrb/+pzNAOwt0P9PlPIBZUbRAGdOrgBlkKz/mIjtAb/CiABxUH0BmASNAJuWNf/EdPUA73JJ/hNSEf98fer/KDS/ACrSnv+bhKUAsgUqAUBcKP8kVU3/suR2AIlCYP5z4kIAbvBF/pdvUACnruz/42xr/7zyQf+3Uf8AOc61/y8itf/V8J4BR0tfAJwoGP9m0lEAq8fk/5oiKQDjr0sAFe/DAIrlXwFMwDEAdXtXAePhggB9Pj//AsarAP4kDf6Rus4AlP/0/yMApgAeltsBXOTUAFzGPP4+hcj/ySk7AH3ubf+0o+4BjHpSAAkWWP/FnS//mV45AFgetgBUoVUAspJ8AKamB/8V0N8AnLbyAJt5uQBTnK7+mhB2/7pT6AHfOnn/HRdYACN9f/+qBZX+pAyC/5vEHQChYIgAByMdAaIl+wADLvL/ANm8ADmu4gHO6QIAObuI/nu9Cf/JdX//uiTMAOcZ2ABQTmkAE4aB/5TLRACNUX3++KXI/9aQhwCXN6b/JutbABUumgDf/pb/I5m0/32wHQErYh7/2Hrm/+mgDAA5uQz+8HEH/wUJEP4aW2wAbcbLAAiTKACBhuT/fLoo/3JihP6mhBcAY0UsAAny7v+4NTsAhIFm/zQg8/6T38j/e1Oz/oeQyf+NJTgBlzzj/1pJnAHLrLsAUJcv/16J5/8kvzv/4dG1/0rX1f4GdrP/mTbBATIA5wBonUgBjOOa/7biEP5g4Vz/cxSq/gb6TgD4S63/NVkG/wC0dgBIrQEAQAjOAa6F3wC5PoX/1gtiAMUf0ACrp/T/Fue1AZbauQD3qWEBpYv3/y94lQFn+DMAPEUc/hmzxAB8B9r+OmtRALjpnP/8SiQAdrxDAI1fNf/eXqX+Lj01AM47c/8v7Pr/SgUgAYGa7v9qIOIAebs9/wOm8f5Dqqz/Hdiy/xfJ/AD9bvMAyH05AG3AYP80c+4AJnnz/8k4IQDCdoIAS2AZ/6oe5v4nP/0AJC36//sB7wCg1FwBLdHtAPMhV/7tVMn/1BKd/tRjf//ZYhD+i6zvAKjJgv+Pwan/7pfBAddoKQDvPaX+AgPyABbLsf6xzBYAlYHV/h8LKf8An3n+oBly/6JQyACdlwsAmoZOAdg2/AAwZ4UAadzFAP2oTf41sxcAGHnwAf8uYP9rPIf+Ys35/z/5d/94O9P/crQ3/ltV7QCV1E0BOEkxAFbGlgBd0aAARc22//RaKwAUJLAAenTdADOnJwHnAT//DcWGAAPRIv+HO8oAp2ROAC/fTAC5PD4AsqZ7AYQMof89risAw0WQAH8vvwEiLE4AOeo0Af8WKP/2XpIAU+SAADxO4P8AYNL/ma/sAJ8VSQC0c8T+g+FqAP+nhgCfCHD/eETC/7DExv92MKj/XakBAHDIZgFKGP4AE40E/o4+PwCDs7v/TZyb/3dWpACq0JL/0IWa/5SbOv+ieOj+/NWbAPENKgBeMoMAs6pwAIxTl/83d1QBjCPv/5ktQwHsrycANpdn/54qQf/E74f+VjXLAJVhL/7YIxH/RgNGAWckWv8oGq0AuDANAKPb2f9RBgH/3aps/unQXQBkyfn+ViQj/9GaHgHjyfv/Ar2n/mQ5AwANgCkAxWRLAJbM6/+RrjsAePiV/1U34QBy0jX+x8x3AA73SgE/+4EAQ2iXAYeCUABPWTf/dead/xlgjwDVkQUARfF4AZXzX/9yKhQAg0gCAJo1FP9JPm0AxGaYACkMzP96JgsB+gqRAM99lAD29N7/KSBVAXDVfgCi+VYBR8Z//1EJFQFiJwT/zEctAUtviQDqO+cAIDBf/8wfcgEdxLX/M/Gn/l1tjgBokC0A6wy1/zRwpABM/sr/rg6iAD3rk/8rQLn+6X3ZAPNYp/5KMQgAnMxCAHzWewAm3XYBknDsAHJisQCXWccAV8VwALmVoQAsYKUA+LMU/7zb2P4oPg0A846NAOXjzv+syiP/dbDh/1JuJgEq9Q7/FFNhADGrCgDyd3gAGeg9ANTwk/8Eczj/kRHv/soR+//5EvX/Y3XvALgEs//27TP/Je+J/6Zwpv9RvCH/ufqO/za7rQDQcMkA9ivkAWi4WP/UNMT/M3Vs//51mwAuWw//Vw6Q/1fjzABTGlMBn0zjAJ8b1QEYl2wAdZCz/onRUgAmnwoAc4XJAN+2nAFuxF3/OTzpAAWnaf+axaQAYCK6/5OFJQHcY74AAadU/xSRqwDCxfv+X06F//z48//hXYP/u4bE/9iZqgAUdp7+jAF2AFaeDwEt0yn/kwFk/nF0TP/Tf2wBZw8wAMEQZgFFM1//a4CdAImr6QBafJABaqG2AK9M7AHIjaz/ozpoAOm0NP/w/Q7/onH+/ybviv40LqYA8WUh/oO6nABv0D7/fF6g/x+s/gBwrjj/vGMb/0OK+wB9OoABnJiu/7IM9//8VJ4AUsUO/qzIU/8lJy4Bas+nABi9IgCDspAAztUEAKHi0gBIM2n/YS27/0643/+wHfsAT6BW/3QlsgBSTdUBUlSN/+Jl1AGvWMf/9V73Aax2bf+mub4Ag7V4AFf+Xf+G8En/IPWP/4uiZ/+zYhL+2cxwAJPfeP81CvMApoyWAH1QyP8Obdv/W9oB//z8L/5tnHT/czF/AcxX0/+Uytn/GlX5/w71hgFMWan/8i3mADtirP9ySYT+Tpsx/55+VAAxryv/ELZU/51nIwBowW3/Q92aAMmsAf4IolgApQEd/32b5f8emtwBZ+9cANwBbf/KxgEAXgKOASQ2LADr4p7/qvvW/7lNCQBhSvIA26OV//Ajdv/fclj+wMcDAGolGP/JoXb/YVljAeA6Z/9lx5P+3jxjAOoZOwE0hxsAZgNb/qjY6wDl6IgAaDyBAC6o7gAnv0MAS6MvAI9hYv842KgBqOn8/yNvFv9cVCsAGshXAVv9mADKOEYAjghNAFAKrwH8x0wAFm5S/4EBwgALgD0BVw6R//3evgEPSK4AVaNW/jpjLP8tGLz+Gs0PABPl0v74Q8MAY0e4AJrHJf+X83n/JjNL/8lVgv4sQfoAOZPz/pIrO/9ZHDUAIVQY/7MzEv69RlMAC5yzAWKGdwCeb28Ad5pJ/8g/jP4tDQ3/msAC/lFIKgAuoLn+LHAGAJLXlQEasGgARBxXAewymf+zgPr+zsG//6Zcif41KO8A0gHM/qitIwCN8y0BJDJt/w/ywv/jn3r/sK/K/kY5SAAo3zgA0KI6/7diXQAPbwwAHghM/4R/9v8t8mcARbUP/wrRHgADs3kA8ejaAXvHWP8C0soBvIJR/15l0AFnJC0ATMEYAV8a8f+lorsAJHKMAMpCBf8lOJMAmAvzAX9V6P/6h9QBubFxAFrcS/9F+JIAMm8yAFwWUAD0JHP+o2RS/xnBBgF/PSQA/UMe/kHsqv+hEdf+P6+MADd/BABPcOkAbaAoAI9TB/9BGu7/2amM/05evf8Ak77/k0e6/mpNf//pnekBh1ft/9AN7AGbbST/tGTaALSjEgC+bgkBET97/7OItP+le3v/kLxR/kfwbP8ZcAv/49oz/6cy6v9yT2z/HxNz/7fwYwDjV4//SNn4/2apXwGBlZUA7oUMAePMIwDQcxoBZgjqAHBYjwGQ+Q4A8J6s/mRwdwDCjZn+KDhT/3mwLgAqNUz/nr+aAFvRXACtDRABBUji/8z+lQBQuM8AZAl6/nZlq//8ywD+oM82ADhI+QE4jA3/CkBr/ltlNP/htfgBi/+EAOaREQDpOBcAdwHx/9Wpl/9jYwn+uQ+//61nbQGuDfv/slgH/hs7RP8KIQL/+GE7ABoekgGwkwoAX3nPAbxYGAC5Xv7+czfJABgyRgB4NQYAjkKSAOTi+f9owN4BrUTbAKK4JP+PZon/nQsXAH0tYgDrXeH+OHCg/0Z08wGZ+Tf/gScRAfFQ9ABXRRUBXuRJ/05CQf/C4+cAPZJX/62bF/9wdNv+2CYL/4O6hQBe1LsAZC9bAMz+r//eEtf+rURs/+PkT/8m3dUAo+OW/h++EgCgswsBClpe/9yuWACj0+X/x4g0AIJf3f+MvOf+i3GA/3Wr7P4x3BT/OxSr/+RtvAAU4SD+wxCuAOP+iAGHJ2kAlk3O/9Lu4gA31IT+7zl8AKrCXf/5EPf/GJc+/wqXCgBPi7L/ePLKABrb1QA+fSP/kAJs/+YhU/9RLdgB4D4RANbZfQBimZn/s7Bq/oNdiv9tPiT/snkg/3j8RgDc+CUAzFhnAYDc+//s4wcBajHG/zw4awBjcu4A3MxeAUm7AQBZmiIATtml/w7D+f8J5v3/zYf1ABr8B/9UzRsBhgJwACWeIADnW+3/v6rM/5gH3gBtwDEAwaaS/+gTtf9pjjT/ZxAbAf3IpQDD2QT/NL2Q/3uboP5Xgjb/Tng9/w44KQAZKX3/V6j1ANalRgDUqQb/29PC/khdpP/FIWf/K46NAIPhrAD0aRwAREThAIhUDf+COSj+i004AFSWNQA2X50AkA2x/l9zugB1F3b/9Kbx/wu6hwCyasv/YdpdACv9LQCkmAQAi3bvAGABGP7rmdP/qG4U/zLvsAByKegAwfo1AP6gb/6Iein/YWxDANeYF/+M0dQAKr2jAMoqMv9qar3/vkTZ/+k6dQDl3PMBxQMEACV4Nv4EnIb/JD2r/qWIZP/U6A4AWq4KANjGQf8MA0AAdHFz//hnCADnfRL/oBzFAB64IwHfSfn/exQu/oc4Jf+tDeUBd6Ei//U9SQDNfXAAiWiGANn2Hv/tjo8AQZ9m/2ykvgDbda3/IiV4/shFUAAffNr+Shug/7qax/9Hx/wAaFGfARHIJwDTPcABGu5bAJTZDAA7W9X/C1G3/4Hmev9yy5EBd7RC/0iKtADglWoAd1Jo/9CMKwBiCbb/zWWG/xJlJgBfxab/y/GTAD7Qkf+F9vsAAqkOAA33uACOB/4AJMgX/1jN3wBbgTT/FboeAI/k0gH36vj/5kUf/rC6h//uzTQBi08rABGw2f4g80MA8m/pACwjCf/jclEBBEcM/yZpvwAHdTL/UU8QAD9EQf+dJG7/TfED/+It+wGOGc4AeHvRARz+7v8FgH7/W97X/6IPvwBW8EkAh7lR/izxowDU29L/cKKbAM9ldgCoSDj/xAU0AEis8v9+Fp3/kmA7/6J5mP6MEF8Aw/7I/lKWogB3K5H+zKxO/6bgnwBoE+3/9X7Q/+I71QB12cUAmEjtANwfF/4OWuf/vNRAATxl9v9VGFYAAbFtAJJTIAFLtsAAd/HgALntG/+4ZVIB6yVN//2GEwDo9noAPGqzAMMLDABtQusBfXE7AD0opACvaPAAAi+7/zIMjQDCi7X/h/poAGFc3v/Zlcn/y/F2/0+XQwB6jtr/lfXvAIoqyP5QJWH/fHCn/ySKV/+CHZP/8VdO/8xhEwGx0Rb/9+N//mN3U//UGcYBELOzAJFNrP5ZmQ7/2r2nAGvpO/8jIfP+LHBw/6F/TwHMrwoAKBWK/mh05ADHX4n/hb6o/5Kl6gG3YycAt9w2/v/ehQCi23n+P+8GAOFmNv/7EvYABCKBAYckgwDOMjsBD2G3AKvYh/9lmCv/lvtbACaRXwAizCb+soxT/xmB8/9MkCUAaiQa/naQrP9EuuX/a6HV/y6jRP+Vqv0AuxEPANqgpf+rI/YBYA0TAKXLdQDWa8D/9HuxAWQDaACy8mH/+0yC/9NNKgH6T0b/P/RQAWll9gA9iDoB7lvVAA47Yv+nVE0AEYQu/jmvxf+5PrgATEDPAKyv0P6vSiUAihvT/pR9wgAKWVEAqMtl/yvV0QHr9TYAHiPi/wl+RgDifV7+nHUU/zn4cAHmMED/pFymAeDW5v8keI8ANwgr//sB9QFqYqUASmtq/jUENv9aspYBA3h7//QFWQFy+j3//plSAU0PEQA57loBX9/mAOw0L/5nlKT/ec8kARIQuf9LFEoAuwtlAC4wgf8W79L/TeyB/29NzP89SGH/x9n7/yrXzACFkcn/OeaSAetkxgCSSSP+bMYU/7ZP0v9SZ4gA9mywACIRPP8TSnL+qKpO/53vFP+VKagAOnkcAE+zhv/neYf/rtFi//N6vgCrps0A1HQwAB1sQv+i3rYBDncVANUn+f/+3+T/t6XGAIW+MAB80G3/d69V/wnReQEwq73/w0eGAYjbM/+2W43+MZ9IACN29f9wuuP/O4kfAIksowByZzz+CNWWAKIKcf/CaEgA3IN0/7JPXADL+tX+XcG9/4L/Iv7UvJcAiBEU/xRlU//UzqYA5e5J/5dKA/+oV9cAm7yF/6aBSQDwT4X/stNR/8tIo/7BqKUADqTH/h7/zABBSFsBpkpm/8gqAP/CceP/QhfQAOXYZP8Y7xoACuk+/3sKsgEaJK7/d9vHAS2jvgAQqCoApjnG/xwaGgB+pecA+2xk/z3lef86dooATM8RAA0icP5ZEKgAJdBp/yPJ1/8oamX+Bu9yAChn4v72f27/P6c6AITwjgAFnlj/gUme/15ZkgDmNpIACC2tAE+pAQBzuvcAVECDAEPg/f/PvUAAmhxRAS24Nv9X1OD/AGBJ/4Eh6wE0QlD/+66b/wSzJQDqpF3+Xa/9AMZFV//gai4AYx3SAD68cv8s6ggAqa/3/xdtif/lticAwKVe/vVl2QC/WGAAxF5j/2ruC/41fvMAXgFl/y6TAgDJfHz/jQzaAA2mnQEw++3/m/p8/2qUkv+2DcoAHD2nANmYCP7cgi3/yOb/ATdBV/9dv2H+cvsOACBpXAEaz40AGM8N/hUyMP+6lHT/0yvhACUiov6k0ir/RBdg/7bWCP/1dYn/QsMyAEsMU/5QjKQACaUkAeRu4wDxEVoBGTTUAAbfDP+L8zkADHFLAfa3v//Vv0X/5g+OAAHDxP+Kqy//QD9qARCp1v/PrjgBWEmF/7aFjACxDhn/k7g1/wrjof942PT/SU3pAJ3uiwE7QekARvvYASm4mf8gy3AAkpP9AFdlbQEsUoX/9JY1/16Y6P87XSf/WJPc/05RDQEgL/z/oBNy/11rJ/92ENMBuXfR/+Pbf/5Yaez/om4X/ySmbv9b7N3/Qup0AG8T9P4K6RoAILcG/gK/8gDanDX+KTxG/6jsbwB5uX7/7o7P/zd+NADcgdD+UMyk/0MXkP7aKGz/f8qkAMshA/8CngAAJWC8/8AxSgBtBAAAb6cK/lvah//LQq3/lsLiAMn9Bv+uZnkAzb9uADXCBABRKC3+I2aP/wxsxv8QG+j//Ee6AbBucgCOA3UBcU2OABOcxQFcL/wANegWATYS6wAuI73/7NSBAAJg0P7I7sf/O6+k/5Ir5wDC2TT/A98MAIo2sv5V688A6M8iADE0Mv+mcVn/Ci3Y/z6tHABvpfYAdnNb/4BUPACnkMsAVw3zABYe5AGxcZL/garm/vyZgf+R4SsARucF/3ppfv5W9pT/biWa/tEDWwBEkT4A5BCl/zfd+f6y0lsAU5Li/kWSugBd0mj+EBmtAOe6JgC9eoz/+w1w/2luXQD7SKoAwBff/xgDygHhXeQAmZPH/m2qFgD4Zfb/snwM/7L+Zv43BEEAfda0ALdgkwAtdRf+hL/5AI+wy/6Itzb/kuqxAJJlVv8se48BIdGYAMBaKf5TD33/1axSANepkAAQDSIAINFk/1QS+QHFEez/2brmADGgsP9vdmH/7WjrAE87XP5F+Qv/I6xKARN2RADefKX/tEIj/1au9gArSm//fpBW/+TqWwDy1Rj+RSzr/9y0IwAI+Af/Zi9c//DNZv9x5qsBH7nJ/8L2Rv96EbsAhkbH/5UDlv91P2cAQWh7/9Q2EwEGjVgAU4bz/4g1ZwCpG7QAsTEYAG82pwDDPdf/HwFsATwqRgC5A6L/wpUo//Z/Jv6+dyb/PXcIAWCh2/8qy90BsfKk//WfCgB0xAAABV3N/oB/swB97fb/laLZ/1clFP6M7sAACQnBAGEB4gAdJgoAAIg//+VI0v4mhlz/TtrQAWgkVP8MBcH/8q89/7+pLgGzk5P/cb6L/n2sHwADS/z+1yQPAMEbGAH/RZX/boF2AMtd+QCKiUD+JkYGAJl03gChSnsAwWNP/3Y7Xv89DCsBkrGdAC6TvwAQ/yYACzMfATw6Yv9vwk0Bmlv0AIwokAGtCvsAy9Ey/myCTgDktFoArgf6AB+uPAApqx4AdGNS/3bBi/+7rcb+2m84ALl72AD5njQANLRd/8kJW/84Lab+hJvL/zrobgA001n//QCiAQlXtwCRiCwBXnr1AFW8qwGTXMYAAAhoAB5frgDd5jQB9/fr/4muNf8jFcz/R+PWAehSwgALMOP/qkm4/8b7/P4scCIAg2WD/0iouwCEh33/imhh/+64qP/zaFT/h9ji/4uQ7QC8iZYBUDiM/1app//CThn/3BG0/xENwQB1idT/jeCXADH0rwDBY6//E2OaAf9BPv+c0jf/8vQD//oOlQCeWNn/nc+G/vvoHAAunPv/qzi4/+8z6gCOioP/Gf7zAQrJwgA/YUsA0u+iAMDIHwF11vMAGEfe/jYo6P9Mt2/+kA5X/9ZPiP/YxNQAhBuM/oMF/QB8bBP/HNdLAEzeN/7ptj8ARKu//jRv3v8KaU3/UKrrAI8YWP8t53kAlIHgAT32VAD9Ltv/70whADGUEv7mJUUAQ4YW/o6bXgAfndP+1Soe/wTk9/78sA3/JwAf/vH0//+qLQr+/d75AN5yhAD/Lwb/tKOzAVRel/9Z0VL+5TSp/9XsAAHWOOT/h3eX/3DJwQBToDX+BpdCABKiEQDpYVsAgwVOAbV4Nf91Xz//7XW5AL9+iP+Qd+kAtzlhAS/Ju/+npXcBLWR+ABViBv6Rll//eDaYANFiaACPbx7+uJT5AOvYLgD4ypT/OV8WAPLhowDp9+j/R6sT/2f0Mf9UZ13/RHn0AVLgDQApTyv/+c6n/9c0Ff7AIBb/9288AGVKJv8WW1T+HRwN/8bn1/70msgA34ntANOEDgBfQM7/ET73/+mDeQFdF00Azcw0/lG9iAC024oBjxJeAMwrjP68r9sAb2KP/5c/ov/TMkf+E5I1AJItU/6yUu7/EIVU/+LGXf/JYRT/eHYj/3Iy5/+i5Zz/0xoMAHInc//O1IYAxdmg/3SBXv7H19v/S9/5Af10tf/o12j/5IL2/7l1VgAOBQgA7x09Ae1Xhf99kon+zKjfAC6o9QCaaRYA3NSh/2tFGP+J2rX/8VTG/4J60/+NCJn/vrF2AGBZsgD/EDD+emBp/3U26P8ifmn/zEOmAOg0iv/TkwwAGTYHACwP1/4z7C0AvkSBAWqT4QAcXS3+7I0P/xE9oQDcc8AA7JEY/m+oqQDgOj//f6S8AFLqSwHgnoYA0URuAdmm2QBG4aYBu8GP/xAHWP8KzYwAdcCcARE4JgAbfGwBq9c3/1/91ACbh6j/9rKZ/ppESgDoPWD+aYQ7ACFMxwG9sIL/CWgZ/kvGZv/pAXAAbNwU/3LmRgCMwoX/OZ6k/pIGUP+pxGEBVbeCAEae3gE77er/YBka/+ivYf8Lefj+WCPCANu0/P5KCOMAw+NJAbhuof8x6aQBgDUvAFIOef/BvjoAMK51/4QXIAAoCoYBFjMZ//ALsP9uOZIAdY/vAZ1ldv82VEwAzbgS/y8ESP9OcFX/wTJCAV0QNP8IaYYADG1I/zqc+wCQI8wALKB1/jJrwgABRKX/b26iAJ5TKP5M1uoAOtjN/6tgk/8o43IBsOPxAEb5twGIVIv/PHr3/o8Jdf+xron+SfePAOy5fv8+Gff/LUA4/6H0BgAiOTgBacpTAICT0AAGZwr/SopB/2FQZP/WriH/MoZK/26Xgv5vVKwAVMdL/vg7cP8I2LIBCbdfAO4bCP6qzdwAw+WHAGJM7f/iWxoBUtsn/+G+xwHZyHn/UbMI/4xBzgCyz1f++vwu/2hZbgH9vZ7/kNae/6D1Nv81t1wBFcjC/5IhcQHRAf8A62or/6c06ACd5d0AMx4ZAPrdGwFBk1f/T3vEAEHE3/9MLBEBVfFEAMq3+f9B1NT/CSGaAUc7UACvwjv/jUgJAGSg9ADm0DgAOxlL/lDCwgASA8j+oJ9zAISP9wFvXTn/Ou0LAYbeh/96o2wBeyu+//u9zv5Qtkj/0PbgARE8CQChzyYAjW1bANgP0/+ITm4AYqNo/xVQef+tsrcBf48EAGg8Uv7WEA3/YO4hAZ6U5v9/gT7/M//S/z6N7P6dN+D/cif0AMC8+v/kTDUAYlRR/63LPf6TMjf/zOu/ADTF9ABYK9P+G793ALznmgBCUaEAXMGgAfrjeAB7N+IAuBFIAIWoCv4Wh5z/KRln/zDKOgC6lVH/vIbvAOu1vf7Zi7z/SjBSAC7a5QC9/fsAMuUM/9ONvwGA9Bn/qed6/lYvvf+Etxf/JbKW/zOJ/QDITh8AFmkyAII8AACEo1v+F+e7AMBP7wCdZqT/wFIUARi1Z//wCeoAAXuk/4XpAP/K8vIAPLr1APEQx//gdJ7+v31b/+BWzwB5Jef/4wnG/w+Z7/956Nn+S3BSAF8MOf4z1mn/lNxhAcdiJACc0Qz+CtQ0ANm0N/7Uquj/2BRU/536hwCdY3/+Ac4pAJUkRgE2xMn/V3QA/uurlgAbo+oAyoe0ANBfAP57nF0Atz5LAInrtgDM4f//1ovS/wJzCP8dDG8ANJwBAP0V+/8lpR/+DILTAGoSNf4qY5oADtk9/tgLXP/IxXD+kybHACT8eP5rqU0AAXuf/89LZgCjr8QALAHwAHi6sP4NYkz/7Xzx/+iSvP/IYOAAzB8pANDIDQAV4WD/r5zEAPfQfgA+uPT+AqtRAFVzngA2QC3/E4pyAIdHzQDjL5MB2udCAP3RHAD0D63/Bg92/hCW0P+5FjL/VnDP/0tx1wE/kiv/BOET/uMXPv8O/9b+LQjN/1fFl/7SUtf/9fj3/4D4RgDh91cAWnhGANX1XAANheIAL7UFAVyjaf8GHoX+6LI9/+aVGP8SMZ4A5GQ9/nTz+/9NS1wBUduT/0yj/v6N1fYA6CWY/mEsZADJJTIB1PQ5AK6rt//5SnAAppweAN7dYf/zXUn++2Vk/9jZXf/+irv/jr40/zvLsf/IXjQAc3Ke/6WYaAF+Y+L/dp30AWvIEADBWuUAeQZYAJwgXf598dP/Du2d/6WaFf+44Bb/+hiY/3FNHwD3qxf/7bHM/zSJkf/CtnIA4OqVAApvZwHJgQQA7o5OADQGKP9u1aX+PM/9AD7XRQBgYQD/MS3KAHh5Fv/rizABxi0i/7YyGwGD0lv/LjaAAK97af/GjU7+Q/Tv//U2Z/5OJvL/Alz5/vuuV/+LP5AAGGwb/yJmEgEiFpgAQuV2/jKPYwCQqZUBdh6YALIIeQEInxIAWmXm/4EddwBEJAsB6Lc3ABf/YP+hKcH/P4veAA+z8wD/ZA//UjWHAIk5lQFj8Kr/Fubk/jG0Uv89UisAbvXZAMd9PQAu/TQAjcXbANOfwQA3eWn+txSBAKl3qv/Lsov/hyi2/6wNyv9BspQACM8rAHo1fwFKoTAA49aA/lYL8/9kVgcB9USG/z0rFQGYVF7/vjz6/u926P/WiCUBcUxr/11oZAGQzhf/bpaaAeRnuQDaMTL+h02L/7kBTgAAoZT/YR3p/8+Ulf+gqAAAW4Cr/wYcE/4Lb/cAJ7uW/4rolQB1PkT/P9i8/+vqIP4dOaD/GQzxAak8vwAgg43/7Z97/17FXv50/gP/XLNh/nlhXP+qcA4AFZX4APjjAwBQYG0AS8BKAQxa4v+hakQB0HJ//3Iq//5KGkr/97OW/nmMPACTRsj/1iih/6G8yf+NQYf/8nP8AD4vygC0lf/+gjftAKURuv8KqcIAnG3a/3CMe/9ogN/+sY5s/3kl2/+ATRL/b2wXAVvASwCu9Rb/BOw+/ytAmQHjrf4A7XqEAX9Zuv+OUoD+/FSuAFqzsQHz1lf/Zzyi/9CCDv8LgosAzoHb/17Znf/v5ub/dHOf/qRrXwAz2gIB2H3G/4zKgP4LX0T/Nwld/q6ZBv/MrGAARaBuANUmMf4bUNUAdn1yAEZGQ/8Pjkn/g3q5//MUMv6C7SgA0p+MAcWXQf9UmUIAw35aABDu7AF2u2b/AxiF/7tF5gA4xVwB1UVe/1CK5QHOB+YA3m/mAVvpd/8JWQcBAmIBAJRKhf8z9rT/5LFwATq9bP/Cy+3+FdHDAJMKIwFWneIAH6OL/jgHS/8+WnQAtTypAIqi1P5Rpx8AzVpw/yFw4wBTl3UBseBJ/66Q2f/mzE//Fk3o/3JO6gDgOX7+CTGNAPKTpQFotoz/p4QMAXtEfwDhVycB+2wIAMbBjwF5h8//rBZGADJEdP9lryj/+GnpAKbLBwBuxdoA1/4a/qji/QAfj2AAC2cpALeBy/5k90r/1X6EANKTLADH6hsBlC+1AJtbngE2aa//Ak6R/maaXwCAz3/+NHzs/4JURwDd89MAmKrPAN5qxwC3VF7+XMg4/4q2cwGOYJIAhYjkAGESlgA3+0IAjGYEAMpnlwAeE/j/M7jPAMrGWQA3xeH+qV/5/0JBRP+86n4Apt9kAXDv9ACQF8IAOie2APQsGP6vRLP/mHaaAbCiggDZcsz+rX5O/yHeHv8kAlv/Ao/zAAnr1wADq5cBGNf1/6gvpP7xks8ARYG0AETzcQCQNUj++y0OABduqABERE//bkZf/q5bkP8hzl//iSkH/xO7mf4j/3D/CZG5/jKdJQALcDEBZgi+/+rzqQE8VRcASie9AHQx7wCt1dIALqFs/5+WJQDEeLn/ImIG/5nDPv9h5kf/Zj1MABrU7P+kYRAAxjuSAKMXxAA4GD0AtWLBAPuT5f9ivRj/LjbO/+pS9gC3ZyYBbT7MAArw4ACSFnX/jpp4AEXUIwDQY3YBef8D/0gGwgB1EcX/fQ8XAJpPmQDWXsX/uTeT/z7+Tv5/UpkAbmY//2xSof9pu9QBUIonADz/Xf9IDLoA0vsfAb6nkP/kLBP+gEPoANb5a/6IkVb/hC6wAL274//QFowA2dN0ADJRuv6L+h8AHkDGAYebZACgzhf+u6LT/xC8PwD+0DEAVVS/APHA8v+ZfpEB6qKi/+Zh2AFAh34AvpTfATQAK/8cJ70BQIjuAK/EuQBi4tX/f5/0AeKvPACg6Y4BtPPP/0WYWQEfZRUAkBmk/ou/0QBbGXkAIJMFACe6e/8/c+b/XafG/4/V3P+znBP/GUJ6ANag2f8CLT7/ak+S/jOJY/9XZOf/r5Ho/2W4Af+uCX0AUiWhASRyjf8w3o7/9bqaAAWu3f4/cpv/hzegAVAfhwB++rMB7NotABQckQEQk0kA+b2EARG9wP/fjsb/SBQP//o17f4PCxIAG9Nx/tVrOP+uk5L/YH4wABfBbQElol4Ax535/hiAu//NMbL+XaQq/yt36wFYt+3/2tIB/2v+KgDmCmP/ogDiANvtWwCBsssA0DJf/s7QX//3v1n+bupP/6U98wAUenD/9va5/mcEewDpY+YB21v8/8feFv+z9en/0/HqAG/6wP9VVIgAZToy/4OtnP53LTP/dukQ/vJa1gBen9sBAwPq/2JMXP5QNuYABeTn/jUY3/9xOHYBFIQB/6vS7AA48Z7/unMT/wjlrgAwLAABcnKm/wZJ4v/NWfQAieNLAfitOABKePb+dwML/1F4xv+IemL/kvHdAW3CTv/f8UYB1sip/2G+L/8vZ67/Y1xI/nbptP/BI+n+GuUg/978xgDMK0f/x1SsAIZmvgBv7mH+5ijmAOPNQP7IDOEAphneAHFFM/+PnxgAp7hKAB3gdP6e0OkAwXR+/9QLhf8WOowBzCQz/+geKwDrRrX/QDiS/qkSVP/iAQ3/yDKw/zTV9f6o0WEAv0c3ACJOnADokDoBuUq9ALqOlf5ARX//ocuT/7CXvwCI58v+o7aJAKF++/7pIEIARM9CAB4cJQBdcmAB/lz3/yyrRQDKdwv/vHYyAf9TiP9HUhoARuMCACDreQG1KZoAR4bl/sr/JAApmAUAmj9J/yK2fAB53Zb/GszVASmsVwBanZL/bYIUAEdryP/zZr0AAcOR/i5YdQAIzuMAv279/22AFP6GVTP/ibFwAdgiFv+DEND/eZWqAHITFwGmUB//cfB6AOiz+gBEbrT+0qp3AN9spP/PT+n/G+Xi/tFiUf9PRAcAg7lkAKodov8Romv/ORULAWTItf9/QaYBpYbMAGinqAABpE8Akoc7AUYygP9mdw3+4waHAKKOs/+gZN4AG+DbAZ5dw//qjYkAEBh9/+7OL/9hEWL/dG4M/2BzTQBb4+j/+P5P/1zlBv5YxosAzkuBAPpNzv+N9HsBikXcACCXBgGDpxb/7USn/se9lgCjq4r/M7wG/18dif6U4rMAtWvQ/4YfUv+XZS3/gcrhAOBIkwAwipf/w0DO/u3angBqHYn+/b3p/2cPEf/CYf8Asi2p/sbhmwAnMHX/h2pzAGEmtQCWL0H/U4Ll/vYmgQBc75r+W2N/AKFvIf/u2fL/g7nD/9W/nv8pltoAhKmDAFlU/AGrRoD/o/jL/gEytP98TFUB+29QAGNC7/+a7bb/3X6F/krMY/9Bk3f/Yzin/0/4lf90m+T/7SsO/kWJC/8W+vEBW3qP/8358wDUGjz/MLawATAXv//LeZj+LUrV/z5aEv71o+b/uWp0/1MjnwAMIQL/UCI+ABBXrv+tZVUAyiRR/qBFzP9A4bsAOs5eAFaQLwDlVvUAP5G+ASUFJwBt+xoAiZPqAKJ5kf+QdM7/xei5/7e+jP9JDP7/ixTy/6pa7/9hQrv/9bWH/t6INAD1BTP+yy9OAJhl2ABJF30A/mAhAevSSf8r0VgBB4FtAHpo5P6q8ssA8syH/8oc6f9BBn8An5BHAGSMXwBOlg0A+2t2AbY6ff8BJmz/jb3R/wibfQFxo1v/eU++/4bvbP9ML/gAo+TvABFvCgBYlUv/1+vvAKefGP8vl2z/a9G8AOnnY/4cypT/riOK/24YRP8CRbUAa2ZSAGbtBwBcJO3/3aJTATfKBv+H6of/GPreAEFeqP71+NL/p2zJ/v+hbwDNCP4AiA10AGSwhP8r137/sYWC/55PlABD4CUBDM4V/z4ibgHtaK//UIRv/46uSABU5bT+abOMAED4D//pihAA9UN7/tp51P8/X9oB1YWJ/4+2Uv8wHAsA9HKNAdGvTP+dtZb/uuUD/6SdbwHnvYsAd8q+/9pqQP9E6z/+YBqs/7svCwHXEvv/UVRZAEQ6gABecQUBXIHQ/2EPU/4JHLwA7wmkADzNmADAo2L/uBI8ANm2iwBtO3j/BMD7AKnS8P8lrFz+lNP1/7NBNAD9DXMAua7OAXK8lf/tWq0AK8fA/1hscQA0I0wAQhmU/90EB/+X8XL/vtHoAGIyxwCXltX/EkokATUoBwATh0H/GqxFAK7tVQBjXykAAzgQACegsf/Iatr+uURU/1u6Pf5Dj43/DfSm/2NyxgDHbqP/wRK6AHzv9gFuRBYAAusuAdQ8awBpKmkBDuaYAAcFgwCNaJr/1QMGAIPkov+zZBwB53tV/84O3wH9YOYAJpiVAWKJegDWzQP/4piz/waFiQCeRYz/caKa/7TzrP8bvXP/jy7c/9WG4f9+HUUAvCuJAfJGCQBazP//56qTABc4E/44fZ3/MLPa/0+2/f8m1L8BKet8AGCXHACHlL4Azfkn/jRgiP/ULIj/Q9GD//yCF//bgBT/xoF2AGxlCwCyBZIBPgdk/7XsXv4cGqQATBZw/3hmTwDKwOUByLDXAClA9P/OuE4Apy0/AaAjAP87DI7/zAmQ/9te5QF6G3AAvWlt/0DQSv/7fzcBAuLGACxM0QCXmE3/0hcuAcmrRf8s0+cAviXg//XEPv+ptd7/ItMRAHfxxf/lI5gBFUUo/7LioQCUs8EA28L+ASjOM//nXPoBQ5mqABWU8QCqRVL/eRLn/1xyAwC4PuYA4clX/5Jgov+18twArbvdAeI+qv84ftkBdQ3j/7Ms7wCdjZv/kN1TAOvR0AAqEaUB+1GFAHz1yf5h0xj/U9amAJokCf/4L38AWtuM/6HZJv7Ukz//QlSUAc8DAQDmhlkBf056/+CbAf9SiEoAspzQ/7oZMf/eA9IB5Za+/1WiNP8pVI3/SXtU/l0RlgB3ExwBIBbX/xwXzP+O8TT/5DR9AB1MzwDXp/r+r6TmADfPaQFtu/X/oSzcASllgP+nEF4AXdZr/3ZIAP5QPer/ea99AIup+wBhJ5P++sQx/6Wzbv7fRrv/Fo59AZqziv92sCoBCq6ZAJxcZgCoDaH/jxAgAPrFtP/LoywBVyAkAKGZFP97/A8AGeNQADxYjgARFskBms1N/yc/LwAIeo0AgBe2/swnE/8EcB3/FySM/9LqdP41Mj//eato/6DbXgBXUg7+5yoFAKWLf/5WTiYAgjxC/sseLf8uxHoB+TWi/4iPZ/7X0nIA5weg/qmYKv9vLfYAjoOH/4NHzP8k4gsAABzy/+GK1f/3Ltj+9QO3AGz8SgHOGjD/zTb2/9PGJP95IzIANNjK/yaLgf7ySZQAQ+eN/yovzABOdBkBBOG//waT5AA6WLEAeqXl//xTyf/gp2ABsbie//JpswH4xvAAhULLAf4kLwAtGHP/dz7+AMThuv57jawAGlUp/+JvtwDV55cABDsH/+6KlABCkyH/H/aN/9GNdP9ocB8AWKGsAFPX5v4vb5cALSY0AYQtzACKgG3+6XWG//O+rf7x7PAAUn/s/ijfof9utuH/e67vAIfykQEz0ZoAlgNz/tmk/P83nEUBVF7//+hJLQEUE9T/YMU7/mD7IQAmx0kBQKz3/3V0OP/kERIAPopnAfblpP/0dsn+ViCf/20iiQFV07oACsHB/nrCsQB67mb/otqrAGzZoQGeqiIAsC+bAbXkC/8InAAAEEtdAM5i/wE6miMADPO4/kN1Qv/m5XsAySpuAIbksv66bHb/OhOa/1KpPv9yj3MB78Qy/60wwf+TAlT/loaT/l/oSQBt4zT+v4kKACjMHv5MNGH/pOt+AP58vABKthUBeR0j//EeB/5V2tb/B1SW/lEbdf+gn5j+Qhjd/+MKPAGNh2YA0L2WAXWzXACEFoj/eMccABWBT/62CUEA2qOpAPaTxv9rJpABTq/N/9YF+v4vWB3/pC/M/ys3Bv+Dhs/+dGTWAGCMSwFq3JAAwyAcAaxRBf/HszT/JVTLAKpwrgALBFsARfQbAXWDXAAhmK//jJlr//uHK/5XigT/xuqT/nmYVP/NZZsBnQkZAEhqEf5smQD/veW6AMEIsP+uldEA7oIdAOnWfgE94mYAOaMEAcZvM/8tT04Bc9IK/9oJGf+ei8b/01K7/lCFUwCdgeYB84WG/yiIEABNa0//t1VcAbHMygCjR5P/mEW+AKwzvAH60qz/0/JxAVlZGv9AQm/+dJgqAKEnG/82UP4AatFzAWd8YQDd5mL/H+cGALLAeP4P2cv/fJ5PAHCR9wBc+jABo7XB/yUvjv6QvaX/LpLwAAZLgAApncj+V3nVAAFx7AAFLfoAkAxSAB9s5wDh73f/pwe9/7vkhP9uvSIAXizMAaI0xQBOvPH+ORSNAPSSLwHOZDMAfWuU/hvDTQCY/VoBB4+Q/zMlHwAidyb/B8V2AJm80wCXFHT+9UE0/7T9bgEvsdEAoWMR/3beygB9s/wBezZ+/5E5vwA3unkACvOKAM3T5f99nPH+lJy5/+MTvP98KSD/HyLO/hE5UwDMFiX/KmBiAHdmuAEDvhwAblLa/8jMwP/JkXYAdcySAIQgYgHAwnkAaqH4Ae1YfAAX1BoAzata//gw2AGNJeb/fMsA/p6oHv/W+BUAcLsH/0uF7/9K4/P/+pNGANZ4ogCnCbP/Fp4SANpN0QFhbVH/9CGz/zk0Of9BrNL/+UfR/46p7gCevZn/rv5n/mIhDgCNTOb/cYs0/w861ACo18n/+MzXAd9EoP85mrf+L+d5AGqmiQBRiIoApSszAOeLPQA5Xzv+dmIZ/5c/7AFevvr/qblyAQX6Ov9LaWEB19+GAHFjowGAPnAAY2qTAKPDCgAhzbYA1g6u/4Em5/81tt8AYiqf//cNKAC80rEBBhUA//89lP6JLYH/WRp0/n4mcgD7MvL+eYaA/8z5p/6l69cAyrHzAIWNPgDwgr4Bbq//AAAUkgEl0nn/ByeCAI76VP+NyM8ACV9o/wv0rgCG6H4ApwF7/hDBlf/o6e8B1UZw//x0oP7y3tz/zVXjAAe5OgB29z8BdE2x/z71yP4/EiX/azXo/jLd0wCi2wf+Al4rALY+tv6gTsj/h4yqAOu45ACvNYr+UDpN/5jJAgE/xCIABR64AKuwmgB5O84AJmMnAKxQTf4AhpcAuiHx/l793/8scvwAbH45/8koDf8n5Rv/J+8XAZd5M/+ZlvgACuqu/3b2BP7I9SYARaHyARCylgBxOIIAqx9pABpYbP8xKmoA+6lCAEVdlQAUOf4ApBlvAFq8Wv/MBMUAKNUyAdRghP9YirT+5JJ8/7j29wBBdVb//WbS/v55JACJcwP/PBjYAIYSHQA74mEAsI5HAAfRoQC9VDP+m/pIANVU6/8t3uAA7pSP/6oqNf9Op3UAugAo/32xZ/9F4UIA4wdYAUusBgCpLeMBECRG/zICCf+LwRYAj7fn/tpFMgDsOKEB1YMqAIqRLP6I5Sj/MT8j/z2R9f9lwAL+6KdxAJhoJgF5udoAeYvT/nfwIwBBvdn+u7Oi/6C75gA++A7/PE5hAP/3o//hO1v/a0c6//EvIQEydewA27E//vRaswAjwtf/vUMy/xeHgQBovSX/uTnCACM+5//c+GwADOeyAI9QWwGDXWX/kCcCAf/6sgAFEez+iyAuAMy8Jv71czT/v3FJ/r9sRf8WRfUBF8uyAKpjqgBB+G8AJWyZ/0AlRQAAWD7+WZSQ/79E4AHxJzUAKcvt/5F+wv/dKv3/GWOXAGH93wFKczH/Bq9I/zuwywB8t/kB5ORjAIEMz/6owMP/zLAQ/pjqqwBNJVX/IXiH/47C4wEf1joA1bt9/+guPP++dCr+l7IT/zM+7f7M7MEAwug8AKwinf+9ELj+ZwNf/43pJP4pGQv/FcOmAHb1LQBD1ZX/nwwS/7uk4wGgGQUADE7DASvF4QAwjin+xJs8/9/HEgGRiJwA/HWp/pHi7gDvF2sAbbW8/+ZwMf5Jqu3/57fj/1DcFADCa38Bf81lAC40xQHSqyT/WANa/ziXjQBgu///Kk7IAP5GRgH0fagAzESKAXzXRgBmQsj+ETTkAHXcj/7L+HsAOBKu/7qXpP8z6NABoOQr//kdGQFEvj8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAiQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAA/wAAAAD1AAAAAAAA+wAAAAAAAP0AAAAA8wAAAAAHAAAAAAADAAAAAPMAAAAABQAAAAAAAAAACwAAAAAACwAAAADzAAAAAAAA/QAAAAAA/wAAAAADAAAAAPUAAAAAAAAADwAAAAAA/wAAAAD/AAAAAAcAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHt0/VcGmMSWNac96Le+d4UAAAAAAAAAAAAAAAAAAAAEFMtPmJ1ZmxlbiA8PSBCTEFLRTJCX0JMT0NLQllURVMAY3J5cHRvX2dlbmVyaWNoYXNoL2JsYWtlMmIvcmVmL2JsYWtlMmItcmVmLmMAY3J5cHRvX2dlbmVyaWNoYXNoX2JsYWtlMmJfX2ZpbmFsAG91dGxlbiA8PSBVSU5UOF9NQVgAY3J5cHRvX2dlbmVyaWNoYXNoL2JsYWtlMmIvcmVmL2dlbmVyaWNoYXNoX2JsYWtlMmIuYwBjcnlwdG9fZ2VuZXJpY2hhc2hfYmxha2UyYgBrZXlsZW4gPD0gVUlOVDhfTUFYAGNyeXB0b19nZW5lcmljaGFzaF9ibGFrZTJiX2luaXQAY3J5cHRvX2dlbmVyaWNoYXNoX2JsYWtlMmJfZmluYWwAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkYXJnb24yaWQAJGFyZ29uMmkAJHY9ACRtPQAsdD0ALHA9ACRhcmdvbjJpZCR2PQAkYXJnb24yaSR2PQAkYXJnb24yaWQkACRhcmdvbjJpJABhcmdvbjJpAFNpZ0VkMjU1MTkgbm8gRWQyNTUxOSBjb2xsaXNpb25zAQB7IHJldHVybiBNb2R1bGUuZ2V0UmFuZG9tVmFsdWUoKTsgfQB7IGlmIChNb2R1bGUuZ2V0UmFuZG9tVmFsdWUgPT09IHVuZGVmaW5lZCkgeyB0cnkgeyB2YXIgd2luZG93XyA9ICdvYmplY3QnID09PSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDogc2VsZjsgdmFyIGNyeXB0b18gPSB0eXBlb2Ygd2luZG93Xy5jcnlwdG8gIT09ICd1bmRlZmluZWQnID8gd2luZG93Xy5jcnlwdG8gOiB3aW5kb3dfLm1zQ3J5cHRvOyB2YXIgcmFuZG9tVmFsdWVzU3RhbmRhcmQgPSBmdW5jdGlvbigpIHsgdmFyIGJ1ZiA9IG5ldyBVaW50MzJBcnJheSgxKTsgY3J5cHRvXy5nZXRSYW5kb21WYWx1ZXMoYnVmKTsgcmV0dXJuIGJ1ZlswXSA+Pj4gMDsgfTsgcmFuZG9tVmFsdWVzU3RhbmRhcmQoKTsgTW9kdWxlLmdldFJhbmRvbVZhbHVlID0gcmFuZG9tVmFsdWVzU3RhbmRhcmQ7IH0gY2F0Y2ggKGUpIHsgdHJ5IHsgdmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpOyB2YXIgcmFuZG9tVmFsdWVOb2RlSlMgPSBmdW5jdGlvbigpIHsgdmFyIGJ1ZiA9IGNyeXB0by5yYW5kb21CeXRlcyg0KTsgcmV0dXJuIChidWZbMF0gPDwgMjQgfCBidWZbMV0gPDwgMTYgfCBidWZbMl0gPDwgOCB8IGJ1ZlszXSkgPj4+IDA7IH07IHJhbmRvbVZhbHVlTm9kZUpTKCk7IE1vZHVsZS5nZXRSYW5kb21WYWx1ZSA9IHJhbmRvbVZhbHVlTm9kZUpTOyB9IGNhdGNoIChlKSB7IHRocm93ICdObyBzZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgZm91bmQnOyB9IH0gfSB9AExpYnNvZGl1bURSR2J1Zl9sZW4gPD0gU0laRV9NQVgAcmFuZG9tYnl0ZXMvcmFuZG9tYnl0ZXMuYwByYW5kb21ieXRlcwBiNjRfcG9zIDw9IGI2NF9sZW4Ac29kaXVtL2NvZGVjcy5jAHNvZGl1bV9iaW4yYmFzZTY0ADEuMC4xNQ==";var RA=cA;cA+=16;var NA=t([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0],"i8",$),UA={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};yA=t(1,"i32",$),sA=(EA=j.alignMemory(cA))+fA,hA=j.alignMemory(sA),rA[yA>>2]=hA,QA=!0;var JA=!1;J.intArrayFromString=m,J.intArrayToString=M;var PA="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",LA="function"==typeof atob?atob:function(A){var I,e,g,i,B,t,r="",a=0;A=A.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{I=PA.indexOf(A.charAt(a++))<<2|(i=PA.indexOf(A.charAt(a++)))>>4,e=(15&i)<<4|(B=PA.indexOf(A.charAt(a++)))>>2,g=(3&B)<<6|(t=PA.indexOf(A.charAt(a++))),r+=String.fromCharCode(I),64!==B&&(r+=String.fromCharCode(e)),64!==t&&(r+=String.fromCharCode(g))}while(a<A.length);return r};J.asmGlobalArg={Math:Math,Int8Array:Int8Array,Int16Array:Int16Array,Int32Array:Int32Array,Uint8Array:Uint8Array,Uint16Array:Uint16Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,NaN:NaN,Infinity:1/0},J.asmLibraryArg={abort:U,assert:I,enlargeMemory:y,getTotalMemory:function(){return _A},abortOnCannotGrowMemory:h,___assert_fail:function(A,I,e,g){throw z=!0,"Assertion failed: "+r(A)+", at: "+[I?r(I):"unknown filename",e,g?r(g):"unknown function"]+" at "+s()},___setErrNo:F,_abort:function(){J.abort()},_emscripten_asm_const_i:function(A){return SA[A]()},_emscripten_memcpy_big:function(A,I,e){return iA.set(iA.subarray(I,I+e),A),A},_sysconf:function(A){switch(A){case 30:return 16384;case 85:return iA.length/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 80:case 81:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 79:return 0;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return"object"==typeof navigator?navigator.hardwareConcurrency||1:1}return F(UA.EINVAL),-1},DYNAMICTOP_PTR:yA,tempDoublePtr:RA,ABORT:z,STACKTOP:EA,STACK_MAX:sA,cttz_i8:NA};var xA=function(A,I,e){"";function g(A,I){A|=0,I|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0,P=0,L=0,x=0,X=0,K=0,T=0,V=0,q=0,j=0,Z=0,W=0,z=0,O=0,$=0,AA=0,IA=0,eA=0,gA=0,iA=0,BA=0;i=wi,B=wi=wi+63&-64,wi=wi+256|0,e=0;do{t=0|oe(I+(e<<3)|0),fi[(g=B+128+(e<<3)|0)>>2]=t,fi[g+4>>2]=vi,e=e+1|0}while(16!=(0|e));I=A,g=(e=B)+64|0;do{fi[e>>2]=fi[I>>2],e=e+4|0,I=I+4|0}while((0|e)<(0|g));for(fi[B+88>>2]=1595750129,fi[B+88+4>>2]=-1521486534,$=-1377402159^fi[A+64>>2],s=1359893119^fi[A+64+4>>2],t=725511199^fi[A+72>>2],p=-1694144372^fi[A+72+4>>2],o=-79577749^fi[A+80>>2],h=528734635^fi[A+80+4>>2],H=327033209^fi[A+88>>2],O=1541459225^fi[A+88+4>>2],fi[B+120>>2]=H,fi[B+120+4>>2]=O,e=0|Ig(0|(e=0|Ig(0|(R=0|Ig(0|(R=0|Ig(0|(f=0|fi[B+32>>2]),0|(g=0|fi[B+32+4>>2]),0|fi[B>>2],0|fi[B+4>>2])),0|vi,0|fi[B+128>>2],0|fi[B+128+4>>2])),0|(e=vi),0|(g=0|Ee(f^(K=0|Ig(0|(s=0|Ee($^R,s^e,32)),0|($=vi),-205731576,1779033703)),g^(N=vi),24)),0|(f=vi))),0|vi,0|fi[(R=B+128+8|0)>>2],0|fi[R+4>>2]),P=vi,fi[B>>2]=e,fi[B+4>>2]=P,$=0|Ee(s^e,$^P,16),s=vi,fi[B+96>>2]=$,fi[B+96+4>>2]=s,s=0|Ig(0|K,0|N,0|$,0|s),$=vi,fi[B+64>>2]=s,fi[B+64+4>>2]=$,$=0|Ee(g^s,f^$,63),fi[B+32>>2]=$,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(s=0|Ig(0|(s=0|Ig(0|($=0|fi[B+40>>2]),0|(f=0|fi[B+40+4>>2]),0|fi[B+8>>2],0|fi[B+8+4>>2])),0|vi,0|fi[(g=B+128+16|0)>>2],0|fi[g+4>>2])),p^(N=vi),32))^(N=0|Ig(0|(N=0|Ig(0|s,0|N,0|(f=0|Ee($^(K=0|Ig(0|p,0|(t=vi),-2067093701,-1150833019)),f^(v=vi),24)),0|($=vi))),0|vi,0|fi[(s=B+128+24|0)>>2],0|fi[s+4>>2])),t^(w=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,v=0|Ig(0|K,0|v,0|t,0|p),K=vi,fi[B+72>>2]=v,fi[B+72+4>>2]=K,K=0|Ee(f^v,$^K,63),$=vi,o=0|Ee((h=0|Ee(o^(y=0|Ig(0|(y=0|Ig(0|(v=0|fi[B+48>>2]),0|(f=0|fi[B+48+4>>2]),0|fi[B+16>>2],0|fi[B+16+4>>2])),0|vi,0|fi[(V=B+128+32|0)>>2],0|fi[V+4>>2])),h^(r=vi),32))^(r=0|Ig(0|(r=0|Ig(0|y,0|r,0|(f=0|Ee(v^(D=0|Ig(0|h,0|(o=vi),-23791573,1013904242)),f^(I=vi),24)),0|(v=vi))),0|vi,0|fi[(y=B+128+40|0)>>2],0|fi[y+4>>2])),o^(U=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,v=0|Ee(f^(I=0|Ig(0|D,0|I,0|o,0|h)),v^(D=vi),63),f=vi,O=0|Ee(H^(_=0|Ig(0|(_=0|Ig(0|(C=0|fi[B+56>>2]),0|(c=0|fi[B+56+4>>2]),0|fi[B+24>>2],0|fi[B+24+4>>2])),0|vi,0|fi[(E=B+128+48|0)>>2],0|fi[E+4>>2])),O^(z=vi),32),H=vi,C=0|Ee((c=0|Ee(C^(d=0|Ig(0|fi[B+88>>2],0|fi[B+88+4>>2],0|O,0|H)),c^(k=vi),24))^(k=0|Ig(0|d,0|k,0|(H=0|Ee(O^(z=0|Ig(0|(z=0|Ig(0|_,0|z,0|c,0|(C=vi))),0|vi,0|fi[(_=B+128+56|0)>>2],0|fi[_+4>>2])),H^(l=vi),16)),0|(O=vi))),C^(d=vi),63),c=vi,H=0|Ee((O=0|Ee(H^(P=0|Ig(0|(P=0|Ig(0|K,0|$,0|e,0|P)),0|vi,0|fi[(e=B+128+64|0)>>2],0|fi[e+4>>2])),O^(L=vi),32))^(L=0|Ig(0|(L=0|Ig(0|P,0|L,0|($=0|Ee(K^(D=0|Ig(0|I,0|D,0|O,0|(H=vi))),$^(I=vi),24)),0|(K=vi))),0|vi,0|fi[(P=B+128+72|0)>>2],0|fi[P+4>>2])),H^(W=vi),16),O=vi,fi[B+120>>2]=H,fi[B+120+4>>2]=O,O=0|Ig(0|D,0|I,0|H,0|O),H=vi,fi[B+80>>2]=O,fi[B+80+4>>2]=H,H=0|Ee($^O,K^H,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,w=0|Ig(0|v,0|f,0|N,0|w),O=0|fi[(N=B+128+80|0)>>2],$=0|fi[N+4>>2],w=0|Ig(0|w,0|vi,0|O,0|$),I=vi,k=0|Ig(0|(d=0|Ig(0|k,0|d,0|(D=0|Ee(fi[B+96>>2]^w,fi[B+96+4>>2]^I,32)),0|(u=vi))),0|(k=vi),0|(u=0|Ee(D^(I=0|Ig(0|(I=0|Ig(0|w,0|I,0|(f=0|Ee(v^d,f^k,24)),0|(v=vi))),0|vi,0|fi[(w=B+128+88|0)>>2],0|fi[w+4>>2])),u^(S=vi),16)),0|(D=vi)),d=vi,fi[B+88>>2]=k,fi[B+88+4>>2]=d,d=0|Ee(f^k,v^d,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,p=0|Ee(t^(U=0|Ig(0|(U=0|Ig(0|C,0|c,0|r,0|U)),0|vi,0|fi[(r=B+128+96|0)>>2],0|fi[r+4>>2])),p^(k=vi),32),t=vi,k=0|Ig(0|U,0|k,0|(c=0|Ee(C^(f=0|Ig(0|fi[B+64>>2],0|fi[B+64+4>>2],0|p,0|t)),c^(Q=vi),24)),0|(C=vi)),AA=0|fi[(U=B+128+104|0)>>2],Z=0|fi[U+4>>2],C=0|Ee(c^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(k=0|Ig(0|k,0|vi,0|AA,0|Z)),t^(b=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,l=0|Ig(0|(n=0|fi[B+32>>2]),0|(gA=0|fi[B+32+4>>2]),0|z,0|l),x=0|fi[(z=B+128+112|0)>>2],a=0|fi[z+4>>2],h=0|Ee(o^(l=0|Ig(0|l,0|vi,0|x,0|a)),h^(BA=vi),32),o=vi,BA=0|Ig(0|l,0|BA,0|(gA=0|Ee(n^(m=0|Ig(0|fi[B+72>>2],0|fi[B+72+4>>2],0|h,0|o)),gA^(X=vi),24)),0|(n=vi)),F=0|fi[(l=B+128+120|0)>>2],eA=0|fi[l+4>>2],u=0|Ee((D=0|Ee(u^(a=0|Ig(0|(W=0|Ig(0|L,0|W,0|(n=0|Ee(gA^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(BA=0|Ig(0|BA,0|vi,0|F,0|eA)),o^(J=vi),16)),0|(h=vi))),n^(m=vi),63)),0|(gA=vi))),0|vi,0|x,0|a)),D^(x=vi),32))^($=0|Ig(0|(x=0|Ig(0|a,0|x,0|(gA=0|Ee(n^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),gA^(Q=vi),24)),0|(n=vi))),0|vi,0|O,0|$)),u^(O=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,n=0|Ee(gA^Q,n^f,63),fi[B+32>>2]=n,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(S=0|Ig(0|(S=0|Ig(0|H,0|K,0|I,0|S)),0|vi,0|fi[V>>2],0|fi[V+4>>2])),p^(I=vi),32))^(I=0|Ig(0|(I=0|Ig(0|S,0|I,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|fi[e>>2],0|fi[e+4>>2])),t^(S=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,h=0|Ee(o^(b=0|Ig(0|(b=0|Ig(0|d,0|v,0|k,0|b)),0|vi,0|fi[P>>2],0|fi[P+4>>2])),h^(k=vi),32),o=vi,o=0|Ee(h^(eA=0|Ig(0|(k=0|Ig(0|b,0|k,0|(v=0|Ee(d^(n=0|Ig(0|fi[B+80>>2],0|fi[B+80+4>>2],0|h,0|o)),v^(gA=vi),24)),0|(d=vi))),0|vi,0|F,0|eA)),o^(F=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(gA=0|Ig(0|n,0|gA,0|o,0|h)),d^(n=vi),63),v=vi,Z=0|Ig(0|(J=0|Ig(0|C,0|c,0|BA,0|J)),0|vi,0|AA,0|Z),AA=vi,J=0|Ee(fi[B+120>>2]^Z,fi[B+120+4>>2]^AA,32),BA=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|fi[B+88>>2],0|fi[B+88+4>>2],0|J,0|BA)),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(BA=0|Ee(J^(AA=0|Ig(0|(AA=0|Ig(0|Z,0|AA,0|c,0|(C=vi))),0|vi,0|fi[E>>2],0|fi[E+4>>2])),BA^(Z=vi),16)),0|(J=vi))),C^(k=vi),63),c=vi,$=0|Ig(0|(O=0|Ig(0|(O=0|Ig(0|H,0|K,0|$,0|O)),0|vi,0|fi[R>>2],0|fi[R+4>>2])),0|($=vi),0|(K=0|Ee(H^(n=0|Ig(0|gA,0|n,0|(J=0|Ee(BA^O,J^$,32)),0|(BA=vi))),K^(gA=vi),24)),0|(H=vi)),O=0|fi[r>>2],x=0|fi[r+4>>2],BA=0|Ee(J^($=0|Ig(0|$,0|vi,0|O,0|x)),BA^(a=vi),16),J=vi,fi[B+120>>2]=BA,fi[B+120+4>>2]=J,J=0|Ig(0|n,0|gA,0|BA,0|J),BA=vi,fi[B+80>>2]=J,fi[B+80+4>>2]=BA,H=0|Ee(K^J,H^BA,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,S=0|Ig(0|d,0|v,0|I,0|S),I=0|fi[B+128>>2],gA=0|fi[B+128+4>>2],n=0|Ig(0|(S=0|Ig(0|S,0|vi,0|I,0|gA)),0|(n=vi),0|(v=0|Ee(d^(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^S,D^n,32)),0|(u=vi))),v^(b=vi),24)),0|(d=vi)),S=0|fi[g>>2],W=0|fi[g+4>>2],b=0|Ig(0|k,0|b,0|(u=0|Ee(D^(n=0|Ig(0|n,0|vi,0|S,0|W)),u^(L=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,F=0|Ig(0|C,0|c,0|eA,0|F),eA=0|fi[w>>2],iA=0|fi[w+4>>2],C=0|Ee((c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^(F=0|Ig(0|F,0|vi,0|eA,0|iA)),p^(Y=vi),32)),0|(t=vi))),c^(Q=vi),24))^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(Y=0|Ig(0|(Y=0|Ig(0|F,0|Y,0|c,0|(C=vi))),0|vi,0|fi[_>>2],0|fi[_+4>>2])),t^(F=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,Z=0|Ig(0|(j=0|fi[B+32>>2]),0|(T=0|fi[B+32+4>>2]),0|AA,0|Z),AA=0|fi[y>>2],G=0|fi[y+4>>2],IA=0|Ig(0|(Z=0|Ig(0|Z,0|vi,0|AA,0|G)),0|(IA=vi),0|(T=0|Ee(j^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^Z,h^IA,32)),0|(o=vi))),T^(X=vi),24)),0|(j=vi)),Z=0|fi[s>>2],M=0|fi[s+4>>2],u=0|Ee((D=0|Ee(u^(iA=0|Ig(0|(a=0|Ig(0|$,0|a,0|(j=0|Ee(T^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(IA=0|Ig(0|IA,0|vi,0|Z,0|M)),o^(q=vi),16)),0|(h=vi))),j^(m=vi),63)),0|(T=vi))),0|vi,0|eA,0|iA)),D^(eA=vi),32))^(eA=0|Ig(0|(eA=0|Ig(0|iA,0|eA,0|(T=0|Ee(j^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),T^(Q=vi),24)),0|(j=vi))),0|vi,0|fi[e>>2],0|fi[e+4>>2])),u^(iA=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,j=0|Ee(T^Q,j^f,63),fi[B+32>>2]=j,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(x=0|Ig(0|(L=0|Ig(0|H,0|K,0|n,0|L)),0|vi,0|O,0|x)),p^(O=vi),32))^(gA=0|Ig(0|(O=0|Ig(0|x,0|O,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|I,0|gA)),t^(I=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,o=0|Ee((h=0|Ee(o^(G=0|Ig(0|(F=0|Ig(0|d,0|v,0|Y,0|F)),0|vi,0|AA,0|G)),h^(AA=vi),32))^(W=0|Ig(0|(AA=0|Ig(0|G,0|AA,0|(v=0|Ee(d^(BA=0|Ig(0|J,0|BA,0|h,0|(o=vi))),v^(J=vi),24)),0|(d=vi))),0|vi,0|S,0|W)),o^(S=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(J=0|Ig(0|BA,0|J,0|o,0|h)),d^(BA=vi),63),v=vi,q=0|Ig(0|(q=0|Ig(0|C,0|c,0|IA,0|q)),0|vi,0|fi[l>>2],0|fi[l+4>>2]),IA=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(AA=0|Ee(fi[B+120>>2]^q,fi[B+120+4>>2]^IA,32)),0|(G=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(G=0|Ee(AA^(IA=0|Ig(0|(IA=0|Ig(0|q,0|IA,0|c,0|(C=vi))),0|vi,0|fi[U>>2],0|fi[U+4>>2])),G^(q=vi),16)),0|(AA=vi))),C^(k=vi),63),c=vi,G=0|Ee((AA=0|Ee(G^(iA=0|Ig(0|(iA=0|Ig(0|H,0|K,0|eA,0|iA)),0|vi,0|fi[N>>2],0|fi[N+4>>2])),AA^(eA=vi),32))^(eA=0|Ig(0|(eA=0|Ig(0|iA,0|eA,0|(K=0|Ee(H^(BA=0|Ig(0|J,0|BA,0|AA,0|(G=vi))),K^(J=vi),24)),0|(H=vi))),0|vi,0|fi[z>>2],0|fi[z+4>>2])),G^(iA=vi),16),AA=vi,fi[B+120>>2]=G,fi[B+120+4>>2]=AA,AA=0|Ig(0|BA,0|J,0|G,0|AA),G=vi,fi[B+80>>2]=AA,fi[B+80+4>>2]=G,H=0|Ee(K^AA,H^G,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,b=0|Ig(0|(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^(M=0|Ig(0|(I=0|Ig(0|d,0|v,0|gA,0|I)),0|vi,0|Z,0|M)),D^(Z=vi),32)),0|(u=vi))),0|(b=vi),0|(u=0|Ee(D^(Z=0|Ig(0|(Z=0|Ig(0|M,0|Z,0|(v=0|Ee(d^k,v^b,24)),0|(d=vi))),0|vi,0|fi[E>>2],0|fi[E+4>>2])),u^(M=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,S=0|Ig(0|C,0|c,0|W,0|S),W=0|fi[_>>2],I=0|fi[_+4>>2],gA=0|Ig(0|(S=0|Ig(0|S,0|vi,0|W,0|I)),0|(gA=vi),0|(c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^S,p^gA,32)),0|(t=vi))),c^(Q=vi),24)),0|(C=vi)),S=0|fi[R>>2],J=0|fi[R+4>>2],C=0|Ee(c^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(gA=0|Ig(0|gA,0|vi,0|S,0|J)),t^(BA=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,q=0|Ig(0|(F=0|fi[B+32>>2]),0|(Y=0|fi[B+32+4>>2]),0|IA,0|q),IA=0|fi[P>>2],O=0|fi[P+4>>2],u=0|Ee((D=0|Ee(u^(I=0|Ig(0|(iA=0|Ig(0|eA,0|iA,0|(F=0|Ee((Y=0|Ee(F^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^(q=0|Ig(0|q,0|vi,0|IA,0|O)),h^(x=vi),32)),0|(o=vi))),Y^(X=vi),24))^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(x=0|Ig(0|(x=0|Ig(0|q,0|x,0|Y,0|(F=vi))),0|vi,0|fi[V>>2],0|fi[V+4>>2])),o^(q=vi),16)),0|(h=vi))),F^(m=vi),63)),0|(Y=vi))),0|vi,0|W,0|I)),D^(W=vi),32))^(O=0|Ig(0|(W=0|Ig(0|I,0|W,0|(Y=0|Ee(F^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),Y^(Q=vi),24)),0|(F=vi))),0|vi,0|IA,0|O)),u^(IA=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,F=0|Ee(Y^Q,F^f,63),fi[B+32>>2]=F,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(M=0|Ig(0|(M=0|Ig(0|H,0|K,0|Z,0|M)),0|vi,0|fi[s>>2],0|fi[s+4>>2])),p^(Z=vi),32))^(J=0|Ig(0|(Z=0|Ig(0|M,0|Z,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|S,0|J)),t^(S=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,o=0|Ee((h=0|Ee(o^(BA=0|Ig(0|(BA=0|Ig(0|d,0|v,0|gA,0|BA)),0|vi,0|fi[U>>2],0|fi[U+4>>2])),h^(gA=vi),32))^(gA=0|Ig(0|(gA=0|Ig(0|BA,0|gA,0|(v=0|Ee(d^(G=0|Ig(0|AA,0|G,0|h,0|(o=vi))),v^(AA=vi),24)),0|(d=vi))),0|vi,0|fi[r>>2],0|fi[r+4>>2])),o^(BA=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(AA=0|Ig(0|G,0|AA,0|o,0|h)),d^(G=vi),63),v=vi,q=0|Ig(0|(q=0|Ig(0|C,0|c,0|x,0|q)),0|vi,0|fi[w>>2],0|fi[w+4>>2]),x=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(Z=0|Ee(fi[B+120>>2]^q,fi[B+120+4>>2]^x,32)),0|(M=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(M=0|Ee(Z^(x=0|Ig(0|(x=0|Ig(0|q,0|x,0|c,0|(C=vi))),0|vi,0|fi[z>>2],0|fi[z+4>>2])),M^(q=vi),16)),0|(Z=vi))),C^(k=vi),63),c=vi,M=0|Ee((Z=0|Ee(M^(IA=0|Ig(0|(IA=0|Ig(0|H,0|K,0|O,0|IA)),0|vi,0|fi[g>>2],0|fi[g+4>>2])),Z^(O=vi),32))^(O=0|Ig(0|(O=0|Ig(0|IA,0|O,0|(K=0|Ee(H^(G=0|Ig(0|AA,0|G,0|Z,0|(M=vi))),K^(AA=vi),24)),0|(H=vi))),0|vi,0|fi[E>>2],0|fi[E+4>>2])),M^(IA=vi),16),Z=vi,fi[B+120>>2]=M,fi[B+120+4>>2]=Z,Z=0|Ig(0|G,0|AA,0|M,0|Z),M=vi,fi[B+80>>2]=Z,fi[B+80+4>>2]=M,H=0|Ee(K^Z,H^M,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,S=0|Ig(0|d,0|v,0|J,0|S),J=0|fi[y>>2],AA=0|fi[y+4>>2],G=0|Ig(0|(S=0|Ig(0|S,0|vi,0|J,0|AA)),0|(G=vi),0|(v=0|Ee(d^(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^S,D^G,32)),0|(u=vi))),v^(b=vi),24)),0|(d=vi)),S=0|fi[N>>2],F=0|fi[N+4>>2],b=0|Ig(0|k,0|b,0|(u=0|Ee(D^(G=0|Ig(0|G,0|vi,0|S,0|F)),u^(Y=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,BA=0|Ig(0|C,0|c,0|gA,0|BA),gA=0|fi[V>>2],W=0|fi[V+4>>2],I=0|Ig(0|(BA=0|Ig(0|BA,0|vi,0|gA,0|W)),0|(I=vi),0|(c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^BA,p^I,32)),0|(t=vi))),c^(Q=vi),24)),0|(C=vi)),BA=0|fi[B+128>>2],iA=0|fi[B+128+4>>2],C=0|Ee(c^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(I=0|Ig(0|I,0|vi,0|BA,0|iA)),t^(eA=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,q=0|Ig(0|(L=0|fi[B+32>>2]),0|(n=0|fi[B+32+4>>2]),0|x,0|q),x=0|fi[l>>2],j=0|fi[l+4>>2],u=0|Ee((D=0|Ee(u^(IA=0|Ig(0|(IA=0|Ig(0|O,0|IA,0|(L=0|Ee((n=0|Ee(L^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^(q=0|Ig(0|q,0|vi,0|x,0|j)),h^(T=vi),32)),0|(o=vi))),n^(X=vi),24))^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(T=0|Ig(0|(T=0|Ig(0|q,0|T,0|n,0|(L=vi))),0|vi,0|fi[e>>2],0|fi[e+4>>2])),o^(q=vi),16)),0|(h=vi))),L^(m=vi),63)),0|(n=vi))),0|vi,0|fi[P>>2],0|fi[P+4>>2])),D^(O=vi),32))^(iA=0|Ig(0|(O=0|Ig(0|IA,0|O,0|(n=0|Ee(L^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),n^(Q=vi),24)),0|(L=vi))),0|vi,0|BA,0|iA)),u^(BA=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,L=0|Ee(n^Q,L^f,63),fi[B+32>>2]=L,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(AA=0|Ig(0|(Y=0|Ig(0|H,0|K,0|G,0|Y)),0|vi,0|J,0|AA)),p^(J=vi),32))^(J=0|Ig(0|(J=0|Ig(0|AA,0|J,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|fi[_>>2],0|fi[_+4>>2])),t^(AA=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,o=0|Ee((h=0|Ee(o^(eA=0|Ig(0|(eA=0|Ig(0|d,0|v,0|I,0|eA)),0|vi,0|fi[g>>2],0|fi[g+4>>2])),h^(I=vi),32))^(W=0|Ig(0|(I=0|Ig(0|eA,0|I,0|(v=0|Ee(d^(M=0|Ig(0|Z,0|M,0|h,0|(o=vi))),v^(Z=vi),24)),0|(d=vi))),0|vi,0|gA,0|W)),o^(gA=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(Z=0|Ig(0|M,0|Z,0|o,0|h)),d^(M=vi),63),v=vi,F=0|Ig(0|(q=0|Ig(0|C,0|c,0|T,0|q)),0|vi,0|S,0|F),S=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(q=0|Ee(fi[B+120>>2]^F,fi[B+120+4>>2]^S,32)),0|(T=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(T=0|Ee(q^(j=0|Ig(0|(S=0|Ig(0|F,0|S,0|c,0|(C=vi))),0|vi,0|x,0|j)),T^(x=vi),16)),0|(q=vi))),C^(k=vi),63),c=vi,T=0|Ee((q=0|Ee(T^(BA=0|Ig(0|(BA=0|Ig(0|H,0|K,0|iA,0|BA)),0|vi,0|fi[z>>2],0|fi[z+4>>2])),q^(iA=vi),32))^(iA=0|Ig(0|(iA=0|Ig(0|BA,0|iA,0|(K=0|Ee(H^(M=0|Ig(0|Z,0|M,0|q,0|(T=vi))),K^(Z=vi),24)),0|(H=vi))),0|vi,0|fi[R>>2],0|fi[R+4>>2])),T^(BA=vi),16),q=vi,fi[B+120>>2]=T,fi[B+120+4>>2]=q,q=0|Ig(0|M,0|Z,0|T,0|q),T=vi,fi[B+80>>2]=q,fi[B+80+4>>2]=T,H=0|Ee(K^q,H^T,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,AA=0|Ig(0|d,0|v,0|J,0|AA),J=0|fi[w>>2],Z=0|fi[w+4>>2],M=0|Ig(0|(AA=0|Ig(0|AA,0|vi,0|J,0|Z)),0|(M=vi),0|(v=0|Ee(d^(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^AA,D^M,32)),0|(u=vi))),v^(b=vi),24)),0|(d=vi)),AA=0|fi[r>>2],S=0|fi[r+4>>2],b=0|Ig(0|k,0|b,0|(u=0|Ee(D^(M=0|Ig(0|M,0|vi,0|AA,0|S)),u^(F=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,gA=0|Ig(0|C,0|c,0|W,0|gA),W=0|fi[E>>2],I=0|fi[E+4>>2],eA=0|Ig(0|(gA=0|Ig(0|gA,0|vi,0|W,0|I)),0|(eA=vi),0|(c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^gA,p^eA,32)),0|(t=vi))),c^(Q=vi),24)),0|(C=vi)),gA=0|fi[e>>2],Y=0|fi[e+4>>2],C=0|Ee(c^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(eA=0|Ig(0|eA,0|vi,0|gA,0|Y)),t^(G=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,x=0|Ig(0|(L=0|fi[B+32>>2]),0|(n=0|fi[B+32+4>>2]),0|j,0|x),j=0|fi[s>>2],O=0|fi[s+4>>2],IA=0|Ig(0|(x=0|Ig(0|x,0|vi,0|j,0|O)),0|(IA=vi),0|(n=0|Ee(L^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^x,h^IA,32)),0|(o=vi))),n^(X=vi),24)),0|(L=vi)),x=0|fi[U>>2],a=0|fi[U+4>>2],u=0|Ee((D=0|Ee(u^(BA=0|Ig(0|(BA=0|Ig(0|iA,0|BA,0|(L=0|Ee(n^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(IA=0|Ig(0|IA,0|vi,0|x,0|a)),o^($=vi),16)),0|(h=vi))),L^(m=vi),63)),0|(n=vi))),0|vi,0|fi[g>>2],0|fi[g+4>>2])),D^(iA=vi),32))^(S=0|Ig(0|(iA=0|Ig(0|BA,0|iA,0|(n=0|Ee(L^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),n^(Q=vi),24)),0|(L=vi))),0|vi,0|AA,0|S)),u^(AA=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,L=0|Ee(n^Q,L^f,63),fi[B+32>>2]=L,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(I=0|Ig(0|(F=0|Ig(0|H,0|K,0|M,0|F)),0|vi,0|W,0|I)),p^(W=vi),32))^(W=0|Ig(0|(W=0|Ig(0|I,0|W,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|fi[N>>2],0|fi[N+4>>2])),t^(I=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,o=0|Ee((h=0|Ee(o^(G=0|Ig(0|(G=0|Ig(0|d,0|v,0|eA,0|G)),0|vi,0|fi[B+128>>2],0|fi[B+128+4>>2])),h^(eA=vi),32))^(Z=0|Ig(0|(eA=0|Ig(0|G,0|eA,0|(v=0|Ee(d^(T=0|Ig(0|q,0|T,0|h,0|(o=vi))),v^(q=vi),24)),0|(d=vi))),0|vi,0|J,0|Z)),o^(J=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(q=0|Ig(0|T,0|q,0|o,0|h)),d^(T=vi),63),v=vi,Y=0|Ig(0|($=0|Ig(0|C,0|c,0|IA,0|$)),0|vi,0|gA,0|Y),gA=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|($=0|Ee(fi[B+120>>2]^Y,fi[B+120+4>>2]^gA,32)),0|(IA=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(IA=0|Ee($^(O=0|Ig(0|(gA=0|Ig(0|Y,0|gA,0|c,0|(C=vi))),0|vi,0|j,0|O)),IA^(j=vi),16)),0|($=vi))),C^(k=vi),63),c=vi,IA=0|Ee(($=0|Ee(IA^(AA=0|Ig(0|(AA=0|Ig(0|H,0|K,0|S,0|AA)),0|vi,0|fi[V>>2],0|fi[V+4>>2])),$^(S=vi),32))^(a=0|Ig(0|(S=0|Ig(0|AA,0|S,0|(K=0|Ee(H^(T=0|Ig(0|q,0|T,0|$,0|(IA=vi))),K^(q=vi),24)),0|(H=vi))),0|vi,0|x,0|a)),IA^(x=vi),16),$=vi,fi[B+120>>2]=IA,fi[B+120+4>>2]=$,$=0|Ig(0|T,0|q,0|IA,0|$),IA=vi,fi[B+80>>2]=$,fi[B+80+4>>2]=IA,H=0|Ee(K^$,H^IA,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,W=0|Ig(0|(I=0|Ig(0|(I=0|Ig(0|d,0|v,0|W,0|I)),0|vi,0|fi[_>>2],0|fi[_+4>>2])),0|(W=vi),0|(v=0|Ee(d^(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^I,D^W,32)),0|(u=vi))),v^(b=vi),24)),0|(d=vi)),I=0|fi[y>>2],q=0|fi[y+4>>2],b=0|Ig(0|k,0|b,0|(u=0|Ee(D^(W=0|Ig(0|W,0|vi,0|I,0|q)),u^(T=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,J=0|Ig(0|C,0|c,0|Z,0|J),Z=0|fi[l>>2],S=0|fi[l+4>>2],AA=0|Ig(0|(J=0|Ig(0|J,0|vi,0|Z,0|S)),0|(AA=vi),0|(c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^J,p^AA,32)),0|(t=vi))),c^(Q=vi),24)),0|(C=vi)),J=0|fi[z>>2],gA=0|fi[z+4>>2],C=0|Ee(c^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(AA=0|Ig(0|AA,0|vi,0|J,0|gA)),t^(Y=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,j=0|Ig(0|(eA=0|fi[B+32>>2]),0|(G=0|fi[B+32+4>>2]),0|O,0|j),O=0|fi[R>>2],F=0|fi[R+4>>2],u=0|Ee((D=0|Ee(u^(x=0|Ig(0|(x=0|Ig(0|a,0|x,0|(eA=0|Ee((G=0|Ee(eA^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^(j=0|Ig(0|j,0|vi,0|O,0|F)),h^(M=vi),32)),0|(o=vi))),G^(X=vi),24))^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(M=0|Ig(0|(M=0|Ig(0|j,0|M,0|G,0|(eA=vi))),0|vi,0|fi[P>>2],0|fi[P+4>>2])),o^(j=vi),16)),0|(h=vi))),eA^(m=vi),63)),0|(G=vi))),0|vi,0|fi[r>>2],0|fi[r+4>>2])),D^(a=vi),32))^(q=0|Ig(0|(a=0|Ig(0|x,0|a,0|(G=0|Ee(eA^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),G^(Q=vi),24)),0|(eA=vi))),0|vi,0|I,0|q)),u^(I=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,eA=0|Ee(G^Q,eA^f,63),fi[B+32>>2]=eA,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(F=0|Ig(0|(T=0|Ig(0|H,0|K,0|W,0|T)),0|vi,0|O,0|F)),p^(O=vi),32))^(S=0|Ig(0|(O=0|Ig(0|F,0|O,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|Z,0|S)),t^(Z=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,J=0|Ig(0|(gA=0|Ig(0|(Y=0|Ig(0|d,0|v,0|AA,0|Y)),0|vi,0|J,0|gA)),0|(J=vi),0|(v=0|Ee(d^(IA=0|Ig(0|$,0|IA,0|(h=0|Ee(o^gA,h^J,32)),0|(o=vi))),v^($=vi),24)),0|(d=vi)),gA=0|fi[U>>2],Y=0|fi[U+4>>2],o=0|Ee(h^(J=0|Ig(0|J,0|vi,0|gA,0|Y)),o^(AA=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^($=0|Ig(0|IA,0|$,0|o,0|h)),d^(IA=vi),63),v=vi,j=0|Ig(0|(j=0|Ig(0|C,0|c,0|M,0|j)),0|vi,0|fi[V>>2],0|fi[V+4>>2]),M=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(O=0|Ee(fi[B+120>>2]^j,fi[B+120+4>>2]^M,32)),0|(F=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(F=0|Ee(O^(M=0|Ig(0|(M=0|Ig(0|j,0|M,0|c,0|(C=vi))),0|vi,0|fi[N>>2],0|fi[N+4>>2])),F^(j=vi),16)),0|(O=vi))),C^(k=vi),63),c=vi,q=0|Ig(0|(I=0|Ig(0|(I=0|Ig(0|H,0|K,0|q,0|I)),0|vi,0|fi[B+128>>2],0|fi[B+128+4>>2])),0|(q=vi),0|(K=0|Ee(H^(IA=0|Ig(0|$,0|IA,0|(O=0|Ee(F^I,O^q,32)),0|(F=vi))),K^($=vi),24)),0|(H=vi)),I=0|fi[_>>2],T=0|fi[_+4>>2],F=0|Ee(O^(q=0|Ig(0|q,0|vi,0|I,0|T)),F^(W=vi),16),O=vi,fi[B+120>>2]=F,fi[B+120+4>>2]=O,O=0|Ig(0|IA,0|$,0|F,0|O),F=vi,fi[B+80>>2]=O,fi[B+80+4>>2]=F,H=0|Ee(K^O,H^F,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,S=0|Ig(0|(Z=0|Ig(0|(Z=0|Ig(0|d,0|v,0|S,0|Z)),0|vi,0|fi[E>>2],0|fi[E+4>>2])),0|(S=vi),0|(v=0|Ee(d^(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^Z,D^S,32)),0|(u=vi))),v^(b=vi),24)),0|(d=vi)),Z=0|fi[s>>2],$=0|fi[s+4>>2],b=0|Ig(0|k,0|b,0|(u=0|Ee(D^(S=0|Ig(0|S,0|vi,0|Z,0|$)),u^(IA=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,AA=0|Ig(0|C,0|c,0|J,0|AA),J=0|fi[P>>2],eA=0|fi[P+4>>2],C=0|Ee((c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^(AA=0|Ig(0|AA,0|vi,0|J,0|eA)),p^(G=vi),32)),0|(t=vi))),c^(Q=vi),24))^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(G=0|Ig(0|(G=0|Ig(0|AA,0|G,0|c,0|(C=vi))),0|vi,0|fi[g>>2],0|fi[g+4>>2])),t^(AA=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,M=0|Ig(0|(j=0|Ig(0|(j=0|Ig(0|(a=0|fi[B+32>>2]),0|(x=0|fi[B+32+4>>2]),0|M,0|j)),0|vi,0|fi[e>>2],0|fi[e+4>>2])),0|(M=vi),0|(x=0|Ee(a^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^j,h^M,32)),0|(o=vi))),x^(X=vi),24)),0|(a=vi)),j=0|fi[w>>2],L=0|fi[w+4>>2],u=0|Ee((D=0|Ee(u^(Y=0|Ig(0|(W=0|Ig(0|q,0|W,0|(a=0|Ee(x^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(M=0|Ig(0|M,0|vi,0|j,0|L)),o^(n=vi),16)),0|(h=vi))),a^(m=vi),63)),0|(x=vi))),0|vi,0|gA,0|Y)),D^(gA=vi),32))^(L=0|Ig(0|(gA=0|Ig(0|Y,0|gA,0|(x=0|Ee(a^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),x^(Q=vi),24)),0|(a=vi))),0|vi,0|j,0|L)),u^(j=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,a=0|Ee(x^Q,a^f,63),fi[B+32>>2]=a,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(T=0|Ig(0|(IA=0|Ig(0|H,0|K,0|S,0|IA)),0|vi,0|I,0|T)),p^(I=vi),32))^(I=0|Ig(0|(I=0|Ig(0|T,0|I,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|fi[z>>2],0|fi[z+4>>2])),t^(T=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,o=0|Ee((h=0|Ee(o^(AA=0|Ig(0|(AA=0|Ig(0|d,0|v,0|G,0|AA)),0|vi,0|fi[r>>2],0|fi[r+4>>2])),h^(G=vi),32))^(G=0|Ig(0|(G=0|Ig(0|AA,0|G,0|(v=0|Ee(d^(F=0|Ig(0|O,0|F,0|h,0|(o=vi))),v^(O=vi),24)),0|(d=vi))),0|vi,0|fi[R>>2],0|fi[R+4>>2])),o^(AA=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(O=0|Ig(0|F,0|O,0|o,0|h)),d^(F=vi),63),v=vi,$=0|Ig(0|(n=0|Ig(0|C,0|c,0|M,0|n)),0|vi,0|Z,0|$),Z=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(n=0|Ee(fi[B+120>>2]^$,fi[B+120+4>>2]^Z,32)),0|(M=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(M=0|Ee(n^(eA=0|Ig(0|(Z=0|Ig(0|$,0|Z,0|c,0|(C=vi))),0|vi,0|J,0|eA)),M^(J=vi),16)),0|(n=vi))),C^(k=vi),63),c=vi,M=0|Ee((n=0|Ee(M^(j=0|Ig(0|(j=0|Ig(0|H,0|K,0|L,0|j)),0|vi,0|fi[y>>2],0|fi[y+4>>2])),n^(L=vi),32))^(L=0|Ig(0|(L=0|Ig(0|j,0|L,0|(K=0|Ee(H^(F=0|Ig(0|O,0|F,0|n,0|(M=vi))),K^(O=vi),24)),0|(H=vi))),0|vi,0|fi[B+128>>2],0|fi[B+128+4>>2])),M^(j=vi),16),n=vi,fi[B+120>>2]=M,fi[B+120+4>>2]=n,n=0|Ig(0|F,0|O,0|M,0|n),M=vi,fi[B+80>>2]=n,fi[B+80+4>>2]=M,H=0|Ee(K^n,H^M,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,T=0|Ig(0|d,0|v,0|I,0|T),I=0|fi[l>>2],O=0|fi[l+4>>2],b=0|Ig(0|(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^(T=0|Ig(0|T,0|vi,0|I,0|O)),D^(F=vi),32)),0|(u=vi))),0|(b=vi),0|(u=0|Ee(D^(F=0|Ig(0|(F=0|Ig(0|T,0|F,0|(v=0|Ee(d^k,v^b,24)),0|(d=vi))),0|vi,0|fi[V>>2],0|fi[V+4>>2])),u^(T=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,AA=0|Ig(0|C,0|c,0|G,0|AA),G=0|fi[e>>2],Z=0|fi[e+4>>2],$=0|Ig(0|(AA=0|Ig(0|AA,0|vi,0|G,0|Z)),0|($=vi),0|(c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^AA,p^$,32)),0|(t=vi))),c^(Q=vi),24)),0|(C=vi)),AA=0|fi[E>>2],IA=0|fi[E+4>>2],C=0|Ee(c^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^($=0|Ig(0|$,0|vi,0|AA,0|IA)),t^(S=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,J=0|Ig(0|(a=0|fi[B+32>>2]),0|(x=0|fi[B+32+4>>2]),0|eA,0|J),eA=0|fi[g>>2],gA=0|fi[g+4>>2],u=0|Ee((D=0|Ee(u^(IA=0|Ig(0|(j=0|Ig(0|L,0|j,0|(a=0|Ee((x=0|Ee(a^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^(J=0|Ig(0|J,0|vi,0|eA,0|gA)),h^(Y=vi),32)),0|(o=vi))),x^(X=vi),24))^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(Y=0|Ig(0|(Y=0|Ig(0|J,0|Y,0|x,0|(a=vi))),0|vi,0|fi[N>>2],0|fi[N+4>>2])),o^(J=vi),16)),0|(h=vi))),a^(m=vi),63)),0|(x=vi))),0|vi,0|AA,0|IA)),D^(AA=vi),32))^(O=0|Ig(0|(AA=0|Ig(0|IA,0|AA,0|(x=0|Ee(a^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),x^(Q=vi),24)),0|(a=vi))),0|vi,0|I,0|O)),u^(I=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,a=0|Ee(x^Q,a^f,63),fi[B+32>>2]=a,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(T=0|Ig(0|(T=0|Ig(0|H,0|K,0|F,0|T)),0|vi,0|fi[z>>2],0|fi[z+4>>2])),p^(F=vi),32))^(F=0|Ig(0|(F=0|Ig(0|T,0|F,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|fi[P>>2],0|fi[P+4>>2])),t^(T=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,o=0|Ee((h=0|Ee(o^(S=0|Ig(0|(S=0|Ig(0|d,0|v,0|$,0|S)),0|vi,0|fi[w>>2],0|fi[w+4>>2])),h^($=vi),32))^($=0|Ig(0|($=0|Ig(0|S,0|$,0|(v=0|Ee(d^(M=0|Ig(0|n,0|M,0|h,0|(o=vi))),v^(n=vi),24)),0|(d=vi))),0|vi,0|fi[s>>2],0|fi[s+4>>2])),o^(S=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(n=0|Ig(0|M,0|n,0|o,0|h)),d^(M=vi),63),v=vi,J=0|Ig(0|(J=0|Ig(0|C,0|c,0|Y,0|J)),0|vi,0|fi[B+128>>2],0|fi[B+128+4>>2]),Y=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(a=0|Ee(fi[B+120>>2]^J,fi[B+120+4>>2]^Y,32)),0|(x=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(x=0|Ee(a^(Z=0|Ig(0|(Y=0|Ig(0|J,0|Y,0|c,0|(C=vi))),0|vi,0|G,0|Z)),x^(G=vi),16)),0|(a=vi))),C^(k=vi),63),c=vi,x=0|Ee((a=0|Ee(x^(I=0|Ig(0|(I=0|Ig(0|H,0|K,0|O,0|I)),0|vi,0|fi[r>>2],0|fi[r+4>>2])),a^(O=vi),32))^(gA=0|Ig(0|(O=0|Ig(0|I,0|O,0|(K=0|Ee(H^(M=0|Ig(0|n,0|M,0|a,0|(x=vi))),K^(n=vi),24)),0|(H=vi))),0|vi,0|eA,0|gA)),x^(eA=vi),16),a=vi,fi[B+120>>2]=x,fi[B+120+4>>2]=a,a=0|Ig(0|M,0|n,0|x,0|a),x=vi,fi[B+80>>2]=a,fi[B+80+4>>2]=x,H=0|Ee(K^a,H^x,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,F=0|Ig(0|(T=0|Ig(0|(T=0|Ig(0|d,0|v,0|F,0|T)),0|vi,0|fi[U>>2],0|fi[U+4>>2])),0|(F=vi),0|(v=0|Ee(d^(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^T,D^F,32)),0|(u=vi))),v^(b=vi),24)),0|(d=vi)),T=0|fi[_>>2],n=0|fi[_+4>>2],b=0|Ig(0|k,0|b,0|(u=0|Ee(D^(F=0|Ig(0|F,0|vi,0|T,0|n)),u^(M=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,S=0|Ig(0|C,0|c,0|$,0|S),$=0|fi[R>>2],O=0|fi[R+4>>2],I=0|Ig(0|(S=0|Ig(0|S,0|vi,0|$,0|O)),0|(I=vi),0|(c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^S,p^I,32)),0|(t=vi))),c^(Q=vi),24)),0|(C=vi)),S=0|fi[V>>2],Y=0|fi[V+4>>2],C=0|Ee(c^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(I=0|Ig(0|I,0|vi,0|S,0|Y)),t^(J=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,G=0|Ig(0|(AA=0|fi[B+32>>2]),0|(IA=0|fi[B+32+4>>2]),0|Z,0|G),Z=0|fi[N>>2],j=0|fi[N+4>>2],L=0|Ig(0|(G=0|Ig(0|G,0|vi,0|Z,0|j)),0|(L=vi),0|(IA=0|Ee(AA^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^G,h^L,32)),0|(o=vi))),IA^(X=vi),24)),0|(AA=vi)),G=0|fi[y>>2],W=0|fi[y+4>>2],u=0|Ee((D=0|Ee(u^(j=0|Ig(0|(eA=0|Ig(0|gA,0|eA,0|(AA=0|Ee(IA^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(L=0|Ig(0|L,0|vi,0|G,0|W)),o^(q=vi),16)),0|(h=vi))),AA^(m=vi),63)),0|(IA=vi))),0|vi,0|Z,0|j)),D^(Z=vi),32))^(Z=0|Ig(0|(Z=0|Ig(0|j,0|Z,0|(IA=0|Ee(AA^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),IA^(Q=vi),24)),0|(AA=vi))),0|vi,0|fi[g>>2],0|fi[g+4>>2])),u^(j=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,AA=0|Ee(IA^Q,AA^f,63),fi[B+32>>2]=AA,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(M=0|Ig(0|(M=0|Ig(0|H,0|K,0|F,0|M)),0|vi,0|fi[e>>2],0|fi[e+4>>2])),p^(F=vi),32))^(Y=0|Ig(0|(F=0|Ig(0|M,0|F,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|S,0|Y)),t^(S=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,o=0|Ee((h=0|Ee(o^(n=0|Ig(0|(J=0|Ig(0|d,0|v,0|I,0|J)),0|vi,0|T,0|n)),h^(T=vi),32))^(T=0|Ig(0|(T=0|Ig(0|n,0|T,0|(v=0|Ee(d^(x=0|Ig(0|a,0|x,0|h,0|(o=vi))),v^(a=vi),24)),0|(d=vi))),0|vi,0|fi[E>>2],0|fi[E+4>>2])),o^(n=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(a=0|Ig(0|x,0|a,0|o,0|h)),d^(x=vi),63),v=vi,O=0|Ig(0|(q=0|Ig(0|C,0|c,0|L,0|q)),0|vi,0|$,0|O),$=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(q=0|Ee(fi[B+120>>2]^O,fi[B+120+4>>2]^$,32)),0|(L=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(L=0|Ee(q^(W=0|Ig(0|($=0|Ig(0|O,0|$,0|c,0|(C=vi))),0|vi,0|G,0|W)),L^(G=vi),16)),0|(q=vi))),C^(k=vi),63),c=vi,L=0|Ee((q=0|Ee(L^(j=0|Ig(0|(j=0|Ig(0|H,0|K,0|Z,0|j)),0|vi,0|fi[l>>2],0|fi[l+4>>2])),q^(Z=vi),32))^(Z=0|Ig(0|(Z=0|Ig(0|j,0|Z,0|(K=0|Ee(H^(x=0|Ig(0|a,0|x,0|q,0|(L=vi))),K^(a=vi),24)),0|(H=vi))),0|vi,0|fi[w>>2],0|fi[w+4>>2])),L^(j=vi),16),q=vi,fi[B+120>>2]=L,fi[B+120+4>>2]=q,q=0|Ig(0|x,0|a,0|L,0|q),L=vi,fi[B+80>>2]=q,fi[B+80+4>>2]=L,H=0|Ee(K^q,H^L,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,b=0|Ig(0|(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^(S=0|Ig(0|(S=0|Ig(0|d,0|v,0|Y,0|S)),0|vi,0|fi[P>>2],0|fi[P+4>>2])),D^(Y=vi),32)),0|(u=vi))),0|(b=vi),0|(u=0|Ee(D^(Y=0|Ig(0|(Y=0|Ig(0|S,0|Y,0|(v=0|Ee(d^k,v^b,24)),0|(d=vi))),0|vi,0|fi[z>>2],0|fi[z+4>>2])),u^(S=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,n=0|Ig(0|C,0|c,0|T,0|n),T=0|fi[s>>2],a=0|fi[s+4>>2],C=0|Ee((c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^(n=0|Ig(0|n,0|vi,0|T,0|a)),p^(x=vi),32)),0|(t=vi))),c^(Q=vi),24))^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(x=0|Ig(0|(x=0|Ig(0|n,0|x,0|c,0|(C=vi))),0|vi,0|fi[r>>2],0|fi[r+4>>2])),t^(n=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,W=0|Ig(0|(G=0|Ig(0|(G=0|Ig(0|($=0|fi[B+32>>2]),0|(O=0|fi[B+32+4>>2]),0|W,0|G)),0|vi,0|fi[U>>2],0|fi[U+4>>2])),0|(W=vi),0|(O=0|Ee($^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^G,h^W,32)),0|(o=vi))),O^(X=vi),24)),0|($=vi)),G=0|fi[B+128>>2],J=0|fi[B+128+4>>2],u=0|Ee((D=0|Ee(u^(J=0|Ig(0|(j=0|Ig(0|Z,0|j,0|($=0|Ee(O^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(W=0|Ig(0|W,0|vi,0|G,0|J)),o^(I=vi),16)),0|(h=vi))),$^(m=vi),63)),0|(O=vi))),0|vi,0|G,0|J)),D^(G=vi),32))^(G=0|Ig(0|(G=0|Ig(0|J,0|G,0|(O=0|Ee($^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),O^(Q=vi),24)),0|($=vi))),0|vi,0|fi[R>>2],0|fi[R+4>>2])),u^(J=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,$=0|Ee(O^Q,$^f,63),fi[B+32>>2]=$,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(S=0|Ig(0|(S=0|Ig(0|H,0|K,0|Y,0|S)),0|vi,0|fi[g>>2],0|fi[g+4>>2])),p^(Y=vi),32))^(a=0|Ig(0|(Y=0|Ig(0|S,0|Y,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|T,0|a)),t^(T=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,o=0|Ee((h=0|Ee(o^(n=0|Ig(0|(n=0|Ig(0|d,0|v,0|x,0|n)),0|vi,0|fi[V>>2],0|fi[V+4>>2])),h^(x=vi),32))^(x=0|Ig(0|(x=0|Ig(0|n,0|x,0|(v=0|Ee(d^(L=0|Ig(0|q,0|L,0|h,0|(o=vi))),v^(q=vi),24)),0|(d=vi))),0|vi,0|fi[y>>2],0|fi[y+4>>2])),o^(n=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(q=0|Ig(0|L,0|q,0|o,0|h)),d^(L=vi),63),v=vi,I=0|Ig(0|(I=0|Ig(0|C,0|c,0|W,0|I)),0|vi,0|fi[E>>2],0|fi[E+4>>2]),W=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(Y=0|Ee(fi[B+120>>2]^I,fi[B+120+4>>2]^W,32)),0|(S=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(S=0|Ee(Y^(W=0|Ig(0|(W=0|Ig(0|I,0|W,0|c,0|(C=vi))),0|vi,0|fi[_>>2],0|fi[_+4>>2])),S^(I=vi),16)),0|(Y=vi))),C^(k=vi),63),c=vi,J=0|Ig(0|H,0|K,0|G,0|J),G=0|fi[e>>2],e=0|fi[e+4>>2],$=0|Ig(0|(J=0|Ig(0|J,0|vi,0|G,0|e)),0|($=vi),0|(K=0|Ee(H^(L=0|Ig(0|q,0|L,0|(Y=0|Ee(S^J,Y^$,32)),0|(S=vi))),K^(q=vi),24)),0|(H=vi)),J=0|fi[P>>2],P=0|fi[P+4>>2],S=0|Ee(Y^($=0|Ig(0|$,0|vi,0|J,0|P)),S^(O=vi),16),Y=vi,fi[B+120>>2]=S,fi[B+120+4>>2]=Y,Y=0|Ig(0|L,0|q,0|S,0|Y),S=vi,fi[B+80>>2]=Y,fi[B+80+4>>2]=S,H=0|Ee(K^Y,H^S,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,T=0|Ig(0|d,0|v,0|a,0|T),a=0|fi[N>>2],N=0|fi[N+4>>2],b=0|Ig(0|(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^(T=0|Ig(0|T,0|vi,0|a,0|N)),D^(q=vi),32)),0|(u=vi))),0|(b=vi),0|(u=0|Ee(D^(q=0|Ig(0|(q=0|Ig(0|T,0|q,0|(v=0|Ee(d^k,v^b,24)),0|(d=vi))),0|vi,0|fi[w>>2],0|fi[w+4>>2])),u^(T=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,x=0|Ig(0|(n=0|Ig(0|(n=0|Ig(0|C,0|c,0|x,0|n)),0|vi,0|fi[r>>2],0|fi[r+4>>2])),0|(x=vi),0|(c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^n,p^x,32)),0|(t=vi))),c^(Q=vi),24)),0|(C=vi)),n=0|fi[U>>2],U=0|fi[U+4>>2],C=0|Ee(c^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(x=0|Ig(0|x,0|vi,0|n,0|U)),t^(L=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,I=0|Ig(0|(j=0|fi[B+32>>2]),0|(Z=0|fi[B+32+4>>2]),0|W,0|I),W=0|fi[z>>2],z=0|fi[z+4>>2],F=0|Ig(0|(I=0|Ig(0|I,0|vi,0|W,0|z)),0|(F=vi),0|(Z=0|Ee(j^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^I,h^F,32)),0|(o=vi))),Z^(X=vi),24)),0|(j=vi)),I=0|fi[l>>2],l=0|fi[l+4>>2],Q=0|Ig(0|(f=0|Ig(0|Q,0|f,0|(D=0|Ee(u^(z=0|Ig(0|(O=0|Ig(0|$,0|O,0|(j=0|Ee(Z^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(F=0|Ig(0|F,0|vi,0|I,0|l)),o^(M=vi),16)),0|(h=vi))),j^(m=vi),63)),0|(Z=vi))),0|vi,0|W,0|z)),D^(W=vi),32)),0|(u=vi))),0|(Q=vi),0|(u=0|Ee(D^(N=0|Ig(0|(W=0|Ig(0|z,0|W,0|(Z=0|Ee(j^f,Z^Q,24)),0|(j=vi))),0|vi,0|a,0|N)),u^(a=vi),16)),0|(D=vi)),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,j=0|Ee(Z^Q,j^f,63),fi[B+32>>2]=j,fi[B+32+4>>2]=vi,X=0|Ig(0|(m=0|Ig(0|X,0|m,0|(p=0|Ee(t^(V=0|Ig(0|(T=0|Ig(0|H,0|K,0|q,0|T)),0|vi,0|fi[V>>2],0|fi[V+4>>2])),p^(T=vi),32)),0|(t=vi))),0|(X=vi),0|(t=0|Ee(p^(e=0|Ig(0|(T=0|Ig(0|V,0|T,0|(K=0|Ee(H^m,K^X,24)),0|(H=vi))),0|vi,0|G,0|e)),t^(G=vi),16)),0|(p=vi)),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,m=0|Ee(K^X,H^m,63),H=vi,d=0|Ee((v=0|Ee(d^(S=0|Ig(0|Y,0|S,0|(h=0|Ee(o^(P=0|Ig(0|(L=0|Ig(0|d,0|v,0|x,0|L)),0|vi,0|J,0|P)),h^(J=vi),32)),0|(o=vi))),v^(Y=vi),24))^(Y=0|Ig(0|S,0|Y,0|(o=0|Ee(h^(l=0|Ig(0|(J=0|Ig(0|P,0|J,0|v,0|(d=vi))),0|vi,0|I,0|l)),o^(I=vi),16)),0|(h=vi))),d^(S=vi),63),v=vi,U=0|Ig(0|(M=0|Ig(0|C,0|c,0|F,0|M)),0|vi,0|n,0|U),n=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(M=0|Ee(fi[B+120>>2]^U,fi[B+120+4>>2]^n,32)),0|(F=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(F=0|Ee(M^(E=0|Ig(0|(n=0|Ig(0|U,0|n,0|c,0|(C=vi))),0|vi,0|fi[E>>2],0|fi[E+4>>2])),F^(n=vi),16)),0|(M=vi))),C^(k=vi),63),c=vi,r=0|Ig(0|(a=0|Ig(0|(R=0|Ig(0|(a=0|Ig(0|m,0|H,0|N,0|a)),0|vi,0|fi[R>>2],0|fi[R+4>>2])),0|(a=vi),0|(H=0|Ee(m^(S=0|Ig(0|Y,0|S,0|(M=0|Ee(F^R,M^a,32)),0|(F=vi))),H^(Y=vi),24)),0|(m=vi))),0|vi,0|fi[r>>2],0|fi[r+4>>2]),a=vi,fi[B>>2]=r,fi[B+4>>2]=a,F=0|Ee(M^r,F^a,16),M=vi,fi[B+120>>2]=F,fi[B+120+4>>2]=M,M=0|Ig(0|S,0|Y,0|F,0|M),F=vi,fi[B+80>>2]=M,fi[B+80+4>>2]=F,F=0|Ee(H^M,m^F,63),fi[B+40>>2]=F,fi[B+40+4>>2]=vi,g=0|Ig(0|(e=0|Ig(0|(G=0|Ig(0|(G=0|Ig(0|d,0|v,0|e,0|G)),0|vi,0|fi[B+128>>2],0|fi[B+128+4>>2])),0|(e=vi),0|(v=0|Ee(d^(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^G,D^e,32)),0|(u=vi))),v^(b=vi),24)),0|(d=vi))),0|vi,0|fi[g>>2],0|fi[g+4>>2]),e=vi,fi[B+8>>2]=g,fi[B+8+4>>2]=e,u=0|Ee(D^g,u^e,16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,D=0|Ig(0|k,0|b,0|u,0|D),u=vi,fi[B+88>>2]=D,fi[B+88+4>>2]=u,u=0|Ee(v^D,d^u,63),fi[B+48>>2]=u,fi[B+48+4>>2]=vi,_=0|Ig(0|(I=0|Ig(0|(w=0|Ig(0|(I=0|Ig(0|C,0|c,0|l,0|I)),0|vi,0|fi[w>>2],0|fi[w+4>>2])),0|(I=vi),0|(c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^w,p^I,32)),0|(t=vi))),c^(Q=vi),24)),0|(C=vi))),0|vi,0|fi[_>>2],0|fi[_+4>>2]),I=vi,fi[B+16>>2]=_,fi[B+16+4>>2]=I,I=0|Ee(p^_,t^I,16),t=vi,fi[B+104>>2]=I,fi[B+104+4>>2]=t,t=0|Ig(0|f,0|Q,0|I,0|t),I=vi,fi[B+64>>2]=t,fi[B+64+4>>2]=I,C=0|Ee(c^t,C^I,63),fi[B+56>>2]=C,fi[B+56+4>>2]=vi,h=0|Ee(o^(y=0|Ig(0|(n=0|Ig(0|(C=0|fi[B+32>>2]),0|(c=0|fi[B+32+4>>2]),0|E,0|n)),0|vi,0|fi[y>>2],0|fi[y+4>>2])),h^(n=vi),32),o=vi,s=0|Ig(0|(n=0|Ig(0|y,0|n,0|(c=0|Ee(C^(E=0|Ig(0|fi[B+72>>2],0|fi[B+72+4>>2],0|h,0|o)),c^(Q=vi),24)),0|(C=vi))),0|vi,0|fi[s>>2],0|fi[s+4>>2]),n=vi,fi[B+24>>2]=s,fi[B+24+4>>2]=n,n=0|Ee(h^s,o^n,16),o=vi,fi[B+112>>2]=n,fi[B+112+4>>2]=o,o=0|Ig(0|E,0|Q,0|n,0|o),n=vi,fi[B+72>>2]=o,fi[B+72+4>>2]=n,n=0|Ee(c^o,C^n,63),fi[B+32>>2]=n,fi[B+32+4>>2]=vi,I=a^fi[A+4>>2]^I,fi[A>>2]=r^fi[A>>2]^t,fi[A+4>>2]=I,I=1;BA=A+(I<<3)|0,iA=B+(I+8<<3)|0,e=e^fi[BA+4>>2]^fi[iA+4>>2],fi[BA>>2]=g^fi[BA>>2]^fi[iA>>2],fi[BA+4>>2]=e,8!=(0|(e=I+1|0));)I=e,g=0|fi[B+(e<<3)>>2],e=0|fi[B+(e<<3)+4>>2];wi=i}function i(A,I,e,g){A|=0,e|=0,g|=0;var i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0,P=0,L=0,x=0,X=0,K=0,T=0,V=0,q=0,j=0,Z=0,W=0,z=0,O=0,$=0,AA=0,IA=0,eA=0,gA=0,iA=0,BA=0,tA=0,rA=0,aA=0,nA=0,CA=0,oA=0,cA=0,QA=0,EA=0,sA=0,hA=0,yA=0,fA=0,_A=0,pA=0,wA=0,lA=0,uA=0,dA=0,DA=0,vA=0,bA=0,kA=0,GA=0,FA=0,mA=0,MA=0,HA=0,YA=0,SA=0,RA=0,NA=0,UA=0,JA=0,PA=0,LA=0,xA=0,XA=0,KA=0,TA=0,VA=0,qA=0,jA=0,ZA=0,WA=0,zA=0,OA=0,$A=0,AI=0,II=0,eI=0,gI=0,iI=0,BI=0,tI=0,rI=0,aI=0,nI=0,CI=0,oI=0,cI=0,QI=0,EI=0,sI=0,hI=0,yI=0,fI=0,_I=0,pI=0,wI=0,lI=0,uI=0,dI=0,DI=0,vI=0,bI=0,kI=0,GI=0,FI=0,mI=0,MI=0,YI=0,SI=0,RI=0,NI=0,UI=0,JI=0,PI=0,LI=0,xI=0,XI=0,KI=0,TI=0,VI=0,qI=0,jI=0,ZI=0,WI=0,zI=0,OI=0,$I=0,Ae=0,Ie=0,ee=0,ge=0,ie=0,Be=0,te=0,re=0,ae=0,ne=0,Ce=0,oe=0,ce=0,Qe=0,Ee=0,se=0;ZA=0|fe(0|yi[(I|=0)>>0],0|yi[I+1>>0],0|yi[I+2>>0]),oI=0|Ue(0|(oI=0|HI(I+2|0)),0|vi,5),d=0|Ue(0|(d=0|fe(0|yi[I+5>>0],0|yi[I+6>>0],0|yi[I+7>>0])),0|vi,2),aI=0|Ue(0|(aI=0|HI(I+7|0)),0|vi,7),C=0|Ue(0|(C=0|HI(I+10|0)),0|vi,4),H=0|Ue(0|(H=0|fe(0|yi[I+13>>0],0|yi[I+14>>0],0|yi[I+15>>0])),0|vi,1),G=0|Ue(0|(G=0|HI(I+15|0)),0|vi,6),eA=0|Ue(0|(eA=0|fe(0|yi[I+18>>0],0|yi[I+19>>0],0|yi[I+20>>0])),0|vi,3),tI=0|fe(0|yi[I+21>>0],0|yi[I+22>>0],0|yi[I+23>>0]),M=0|Ue(0|(M=0|HI(I+23|0)),0|vi,5),se=0|Ue(0|(se=0|fe(0|yi[I+26>>0],0|yi[I+27>>0],0|yi[I+28>>0])),0|vi,2),c=0|Ue(0|(c=0|HI(I+28|0)),0|vi,7),fA=vi,fI=0|fe(0|yi[e>>0],0|yi[e+1>>0],0|yi[e+2>>0]),MA=0|Ue(0|(MA=0|HI(e+2|0)),0|vi,5),VA=0|Ue(0|(VA=0|fe(0|yi[e+5>>0],0|yi[e+6>>0],0|yi[e+7>>0])),0|vi,2),AA=0|Ue(0|(AA=0|HI(e+7|0)),0|vi,7),J=0|Ue(0|(J=0|HI(e+10|0)),0|vi,4),yA=0|Ue(0|(yA=0|fe(0|yi[e+13>>0],0|yi[e+14>>0],0|yi[e+15>>0])),0|vi,1),wA=0|Ue(0|(wA=0|HI(e+15|0)),0|vi,6),sI=0|Ue(0|(sI=0|fe(0|yi[e+18>>0],0|yi[e+19>>0],0|yi[e+20>>0])),0|vi,3),oA=0|fe(0|yi[e+21>>0],0|yi[e+22>>0],0|yi[e+23>>0]),U=0|Ue(0|(U=0|HI(e+23|0)),0|vi,5),HA=0|Ue(0|(HA=0|fe(0|yi[e+26>>0],0|yi[e+27>>0],0|yi[e+28>>0])),0|vi,2),w=0|Ue(0|(w=0|HI(e+28|0)),0|vi,7),EA=vi,T=0|fe(0|yi[g>>0],0|yi[g+1>>0],0|yi[g+2>>0]),cA=0|Ue(0|(cA=0|HI(g+2|0)),0|vi,5),hA=0|Ue(0|(hA=0|fe(0|yi[g+5>>0],0|yi[g+6>>0],0|yi[g+7>>0])),0|vi,2),NA=0|Ue(0|(NA=0|HI(g+7|0)),0|vi,7),CA=0|Ue(0|(CA=0|HI(g+10|0)),0|vi,4),bA=0|Ue(0|(bA=0|fe(0|yi[g+13>>0],0|yi[g+14>>0],0|yi[g+15>>0])),0|vi,1),gI=0|Ue(0|(gI=0|HI(g+15|0)),0|vi,6),B=0|Ue(0|(B=0|fe(0|yi[g+18>>0],0|yi[g+19>>0],0|yi[g+20>>0])),0|vi,3),LA=0|fe(0|yi[g+21>>0],0|yi[g+22>>0],0|yi[g+23>>0]),k=0|Ue(0|(k=0|HI(g+23|0)),0|vi,5),PA=0|Ue(0|(PA=0|fe(0|yi[g+26>>0],0|yi[g+27>>0],0|yi[g+28>>0])),0|vi,2),I=0|Ue(0|(I=0|HI(g+28|0)),0|vi,7),t=vi,QA=0|Ig(2097151&T|0,0,0|(QA=0|he(2097151&fI|0,0,2097151&ZA|0,0)),0|vi),T=vi,Ee=0|he(2097151&MA|0,0,2097151&ZA|0,0),Qe=vi,ce=0|he(2097151&fI|0,0,2097151&oI|0,0),f=vi,rA=0|he(2097151&VA|0,0,2097151&ZA|0,0),sA=vi,hA=0|Ig(0|(sA=0|Ig(0|(x=0|Ig(0|(aA=0|he(2097151&MA|0,0,2097151&oI|0,0)),0|(re=vi),0|(x=0|he(2097151&fI|0,0,2097151&d|0,0)),0|vi)),0|vi,0|rA,0|sA)),0|vi,2097151&hA|0,0),sA=vi,rA=0|he(2097151&AA|0,0,2097151&ZA|0,0),x=vi,re=0|he(2097151&VA|0,0,2097151&oI|0,0),aA=vi,oe=0|he(2097151&MA|0,0,2097151&d|0,0),Ce=vi,ne=0|he(2097151&fI|0,0,2097151&aI|0,0),ae=vi,vA=0|he(2097151&J|0,0,2097151&ZA|0,0),nA=vi,OI=0|he(2097151&AA|0,0,2097151&oI|0,0),W=vi,Ae=0|he(2097151&VA|0,0,2097151&d|0,0),DA=vi,CA=0|Ig(0|(nA=0|Ig(0|(W=0|Ig(0|(DA=0|Ig(0|($I=0|Ig(0|(Ie=0|he(2097151&MA|0,0,2097151&aI|0,0)),0|(ee=vi),0|($I=0|he(2097151&fI|0,0,2097151&C|0,0)),0|vi)),0|vi,0|Ae,0|DA)),0|vi,0|OI,0|W)),0|vi,0|vA,0|nA)),0|vi,2097151&CA|0,0),nA=vi,vA=0|he(2097151&yA|0,0,2097151&ZA|0,0),W=vi,OI=0|he(2097151&J|0,0,2097151&oI|0,0),DA=vi,Ae=0|he(2097151&AA|0,0,2097151&d|0,0),$I=vi,ee=0|he(2097151&VA|0,0,2097151&aI|0,0),Ie=vi,te=0|he(2097151&MA|0,0,2097151&C|0,0),Be=vi,ie=0|he(2097151&fI|0,0,2097151&H|0,0),ge=vi,j=0|he(2097151&wA|0,0,2097151&ZA|0,0),zA=vi,JI=0|he(2097151&yA|0,0,2097151&oI|0,0),D=vi,LI=0|he(2097151&J|0,0,2097151&d|0,0),q=vi,XI=0|he(2097151&AA|0,0,2097151&aI|0,0),PI=vi,TI=0|he(2097151&VA|0,0,2097151&C|0,0),xI=vi,gI=0|Ig(0|(zA=0|Ig(0|(D=0|Ig(0|(q=0|Ig(0|(PI=0|Ig(0|(xI=0|Ig(0|(KI=0|Ig(0|(VI=0|he(2097151&MA|0,0,2097151&H|0,0)),0|(qI=vi),0|(KI=0|he(2097151&fI|0,0,2097151&G|0,0)),0|vi)),0|vi,0|TI,0|xI)),0|vi,0|XI,0|PI)),0|vi,0|LI,0|q)),0|vi,0|JI,0|D)),0|vi,0|j,0|zA)),0|vi,2097151&gI|0,0),zA=vi,j=0|he(2097151&sI|0,0,2097151&ZA|0,0),D=vi,JI=0|he(2097151&wA|0,0,2097151&oI|0,0),q=vi,LI=0|he(2097151&yA|0,0,2097151&d|0,0),PI=vi,XI=0|he(2097151&J|0,0,2097151&aI|0,0),xI=vi,TI=0|he(2097151&AA|0,0,2097151&C|0,0),KI=vi,qI=0|he(2097151&VA|0,0,2097151&H|0,0),VI=vi,zI=0|he(2097151&MA|0,0,2097151&G|0,0),WI=vi,ZI=0|he(2097151&fI|0,0,2097151&eA|0,0),jI=vi,uI=0|he(2097151&oA|0,0,2097151&ZA|0,0),g=vi,r=0|he(2097151&sI|0,0,2097151&oI|0,0),xA=vi,wI=0|he(2097151&wA|0,0,2097151&d|0,0),lI=vi,DI=0|he(2097151&yA|0,0,2097151&aI|0,0),_A=vi,bI=0|he(2097151&J|0,0,2097151&C|0,0),dI=vi,GI=0|he(2097151&AA|0,0,2097151&H|0,0),vI=vi,mI=0|he(2097151&VA|0,0,2097151&G|0,0),kI=vi,LA=0|Ig(0|(xA=0|Ig(0|(g=0|Ig(0|(lI=0|Ig(0|(_A=0|Ig(0|(dI=0|Ig(0|(vI=0|Ig(0|(kI=0|Ig(0|(FI=0|Ig(0|(MI=0|he(2097151&MA|0,0,2097151&eA|0,0)),0|(YI=vi),0|(FI=0|he(2097151&fI|0,0,2097151&tI|0,0)),0|vi)),0|vi,0|mI,0|kI)),0|vi,0|GI,0|vI)),0|vi,0|bI,0|dI)),0|vi,0|DI,0|_A)),0|vi,0|wI,0|lI)),0|vi,0|uI,0|g)),0|vi,0|r,0|xA)),0|vi,2097151&LA|0,0),xA=vi,r=0|he(2097151&U|0,0,2097151&ZA|0,0),g=vi,uI=0|he(2097151&oA|0,0,2097151&oI|0,0),lI=vi,wI=0|he(2097151&sI|0,0,2097151&d|0,0),_A=vi,DI=0|he(2097151&wA|0,0,2097151&aI|0,0),dI=vi,bI=0|he(2097151&yA|0,0,2097151&C|0,0),vI=vi,GI=0|he(2097151&J|0,0,2097151&H|0,0),kI=vi,mI=0|he(2097151&AA|0,0,2097151&G|0,0),FI=vi,YI=0|he(2097151&VA|0,0,2097151&eA|0,0),MI=vi,UI=0|he(2097151&MA|0,0,2097151&tI|0,0),NI=vi,RI=0|he(2097151&fI|0,0,2097151&M|0,0),SI=vi,WA=0|he(2097151&HA|0,0,2097151&ZA|0,0),JA=vi,OA=0|he(2097151&U|0,0,2097151&oI|0,0),iI=vi,z=0|he(2097151&oA|0,0,2097151&d|0,0),O=vi,K=0|he(2097151&sI|0,0,2097151&aI|0,0),X=vi,CI=0|he(2097151&wA|0,0,2097151&C|0,0),nI=vi,RA=0|he(2097151&yA|0,0,2097151&H|0,0),SA=vi,eI=0|he(2097151&J|0,0,2097151&G|0,0),II=vi,FA=0|he(2097151&AA|0,0,2097151&eA|0,0),GA=vi,KA=0|he(2097151&VA|0,0,2097151&tI|0,0),XA=vi,PA=0|Ig(0|(JA=0|Ig(0|(iI=0|Ig(0|(X=0|Ig(0|(O=0|Ig(0|(nI=0|Ig(0|(SA=0|Ig(0|(II=0|Ig(0|(GA=0|Ig(0|(XA=0|Ig(0|(P=0|Ig(0|(pI=0|he(2097151&MA|0,0,2097151&M|0,0)),0|(S=vi),0|(P=0|he(2097151&fI|0,0,2097151&se|0,0)),0|vi)),0|vi,0|KA,0|XA)),0|vi,0|FA,0|GA)),0|vi,0|eI,0|II)),0|vi,0|RA,0|SA)),0|vi,0|CI,0|nI)),0|vi,0|z,0|O)),0|vi,0|K,0|X)),0|vi,0|OA,0|iI)),0|vi,0|WA,0|JA)),0|vi,2097151&PA|0,0),JA=vi,ZA=0|he(0|w,0|EA,2097151&ZA|0,0),WA=vi,iI=0|he(2097151&HA|0,0,2097151&oI|0,0),OA=vi,X=0|he(2097151&U|0,0,2097151&d|0,0),K=vi,O=0|he(2097151&oA|0,0,2097151&aI|0,0),z=vi,nI=0|he(2097151&sI|0,0,2097151&C|0,0),CI=vi,SA=0|he(2097151&wA|0,0,2097151&H|0,0),RA=vi,II=0|he(2097151&yA|0,0,2097151&G|0,0),eI=vi,GA=0|he(2097151&J|0,0,2097151&eA|0,0),FA=vi,XA=0|he(2097151&AA|0,0,2097151&tI|0,0),KA=vi,P=0|he(2097151&VA|0,0,2097151&M|0,0),S=vi,pI=0|he(2097151&MA|0,0,2097151&se|0,0),_I=vi,fI=0|he(2097151&fI|0,0,0|c,0|fA),yI=vi,oI=0|he(0|w,0|EA,2097151&oI|0,0),cI=vi,$A=0|he(2097151&HA|0,0,2097151&d|0,0),p=vi,R=0|he(2097151&U|0,0,2097151&aI|0,0),AI=vi,QI=0|he(2097151&oA|0,0,2097151&C|0,0),_=vi,E=0|he(2097151&sI|0,0,2097151&H|0,0),BI=vi,s=0|he(2097151&wA|0,0,2097151&G|0,0),EI=vi,BA=0|he(2097151&yA|0,0,2097151&eA|0,0),u=vi,IA=0|he(2097151&J|0,0,2097151&tI|0,0),tA=vi,mA=0|he(2097151&AA|0,0,2097151&M|0,0),L=vi,cI=0|Ig(0|(p=0|Ig(0|(AI=0|Ig(0|(BI=0|Ig(0|(_=0|Ig(0|(EI=0|Ig(0|(u=0|Ig(0|(tA=0|Ig(0|(L=0|Ig(0|(MA=0|Ig(0|(rI=0|he(2097151&VA|0,0,2097151&se|0,0)),0|(TA=vi),0|(MA=0|he(2097151&MA|0,0,0|c,0|fA)),0|vi)),0|vi,0|mA,0|L)),0|vi,0|IA,0|tA)),0|vi,0|BA,0|u)),0|vi,0|s,0|EI)),0|vi,0|QI,0|_)),0|vi,0|E,0|BI)),0|vi,0|R,0|AI)),0|vi,0|$A,0|p)),0|vi,0|oI,0|cI),oI=vi,d=0|he(0|w,0|EA,2097151&d|0,0),p=vi,$A=0|he(2097151&HA|0,0,2097151&aI|0,0),AI=vi,R=0|he(2097151&U|0,0,2097151&C|0,0),BI=vi,E=0|he(2097151&oA|0,0,2097151&H|0,0),_=vi,QI=0|he(2097151&sI|0,0,2097151&G|0,0),EI=vi,s=0|he(2097151&wA|0,0,2097151&eA|0,0),u=vi,BA=0|he(2097151&yA|0,0,2097151&tI|0,0),tA=vi,IA=0|he(2097151&J|0,0,2097151&M|0,0),L=vi,mA=0|he(2097151&AA|0,0,2097151&se|0,0),MA=vi,VA=0|he(2097151&VA|0,0,0|c,0|fA),TA=vi,aI=0|he(0|w,0|EA,2097151&aI|0,0),rI=vi,qA=0|he(2097151&HA|0,0,2097151&C|0,0),a=vi,o=0|he(2097151&U|0,0,2097151&H|0,0),jA=vi,V=0|he(2097151&oA|0,0,2097151&G|0,0),F=vi,Z=0|he(2097151&sI|0,0,2097151&eA|0,0),i=vi,uA=0|he(2097151&wA|0,0,2097151&tI|0,0),h=vi,pA=0|he(2097151&yA|0,0,2097151&M|0,0),n=vi,rI=0|Ig(0|(a=0|Ig(0|(jA=0|Ig(0|(i=0|Ig(0|(F=0|Ig(0|(h=0|Ig(0|(n=0|Ig(0|(AA=0|Ig(0|(hI=0|he(2097151&J|0,0,2097151&se|0,0)),0|(Q=vi),0|(AA=0|he(2097151&AA|0,0,0|c,0|fA)),0|vi)),0|vi,0|pA,0|n)),0|vi,0|uA,0|h)),0|vi,0|V,0|F)),0|vi,0|Z,0|i)),0|vi,0|o,0|jA)),0|vi,0|qA,0|a)),0|vi,0|aI,0|rI),aI=vi,C=0|he(0|w,0|EA,2097151&C|0,0),a=vi,qA=0|he(2097151&HA|0,0,2097151&H|0,0),jA=vi,o=0|he(2097151&U|0,0,2097151&G|0,0),i=vi,Z=0|he(2097151&oA|0,0,2097151&eA|0,0),F=vi,V=0|he(2097151&sI|0,0,2097151&tI|0,0),h=vi,uA=0|he(2097151&wA|0,0,2097151&M|0,0),n=vi,pA=0|he(2097151&yA|0,0,2097151&se|0,0),AA=vi,J=0|he(2097151&J|0,0,0|c,0|fA),Q=vi,H=0|he(0|w,0|EA,2097151&H|0,0),hI=vi,gA=0|he(2097151&HA|0,0,2097151&G|0,0),YA=vi,kA=0|he(2097151&U|0,0,2097151&eA|0,0),v=vi,$=0|he(2097151&oA|0,0,2097151&tI|0,0),y=vi,b=0|he(2097151&sI|0,0,2097151&M|0,0),dA=vi,hI=0|Ig(0|(YA=0|Ig(0|(v=0|Ig(0|(dA=0|Ig(0|(y=0|Ig(0|(e=0|Ig(0|(Y=0|he(2097151&wA|0,0,2097151&se|0,0)),0|(lA=vi),0|(e=0|he(2097151&yA|0,0,0|c,0|fA)),0|vi)),0|vi,0|$,0|y)),0|vi,0|b,0|dA)),0|vi,0|kA,0|v)),0|vi,0|gA,0|YA)),0|vi,0|H,0|hI),H=vi,G=0|he(0|w,0|EA,2097151&G|0,0),YA=vi,gA=0|he(2097151&HA|0,0,2097151&eA|0,0),v=vi,kA=0|he(2097151&U|0,0,2097151&tI|0,0),dA=vi,b=0|he(2097151&oA|0,0,2097151&M|0,0),y=vi,$=0|he(2097151&sI|0,0,2097151&se|0,0),e=vi,wA=0|he(2097151&wA|0,0,0|c,0|fA),lA=vi,eA=0|he(0|w,0|EA,2097151&eA|0,0),Y=vi,yA=0|he(2097151&HA|0,0,2097151&tI|0,0),N=vi,UA=0|he(2097151&U|0,0,2097151&M|0,0),m=vi,l=0|he(2097151&oA|0,0,2097151&se|0,0),iA=vi,Y=0|Ig(0|(N=0|Ig(0|(m=0|Ig(0|(iA=0|Ig(0|(sI=0|he(2097151&sI|0,0,0|c,0|fA)),0|vi,0|l,0|iA)),0|vi,0|UA,0|m)),0|vi,0|yA,0|N)),0|vi,0|eA,0|Y),eA=vi,tI=0|he(0|w,0|EA,2097151&tI|0,0),N=vi,yA=0|he(2097151&HA|0,0,2097151&M|0,0),m=vi,UA=0|he(2097151&U|0,0,2097151&se|0,0),iA=vi,oA=0|he(2097151&oA|0,0,0|c,0|fA),l=vi,M=0|he(0|w,0|EA,2097151&M|0,0),sI=vi,sI=0|Ig(0|(U=0|Ig(0|he(2097151&HA|0,0,2097151&se|0,0),0|vi,0|(U=0|he(2097151&U|0,0,0|c,0|fA)),0|vi)),0|vi,0|M,0|sI),M=vi,HA=0|Ig(0|(se=0|he(0|w,0|EA,2097151&se|0,0)),0|(U=vi),0|(HA=0|he(2097151&HA|0,0,0|c,0|fA)),0|vi),U=vi,fA=0|he(0|w,0|EA,0|c,0|fA),c=vi,EA=0|Ue(0|(EA=0|Ig(0|QA,0|T,1048576,0)),0|vi,21),w=vi,cA=0|Ig(0|(cA=0|Ig(0|(f=0|Ig(0|Ee,0|Qe,0|ce,0|f)),0|vi,2097151&cA|0,0)),0|vi,0|EA,0|w),f=vi,w=0|Ag(0|QA,0|T,0|(w=0|Se(0|EA,0|w,21)),0|vi),T=vi,QA=0|Ue(0|(QA=0|Ig(0|hA,0|sA,1048576,0)),0|vi,21),EA=vi,NA=0|Ig(0|(NA=0|Ig(0|(x=0|Ig(0|(aA=0|Ig(0|(ae=0|Ig(0|oe,0|Ce,0|ne,0|ae)),0|vi,0|re,0|aA)),0|vi,0|rA,0|x)),0|vi,2097151&NA|0,0)),0|vi,0|QA,0|EA),x=vi,EA=0|Se(0|QA,0|EA,21),QA=vi,rA=0|be(0|(rA=0|Ig(0|CA,0|nA,1048576,0)),0|vi,21),aA=vi,bA=0|Ig(0|(bA=0|Ig(0|(W=0|Ig(0|(DA=0|Ig(0|($I=0|Ig(0|(Ie=0|Ig(0|(ge=0|Ig(0|te,0|Be,0|ie,0|ge)),0|vi,0|ee,0|Ie)),0|vi,0|Ae,0|$I)),0|vi,0|OI,0|DA)),0|vi,0|vA,0|W)),0|vi,2097151&bA|0,0)),0|vi,0|rA,0|aA),W=vi,aA=0|Se(0|rA,0|aA,21),rA=vi,vA=0|be(0|(vA=0|Ig(0|gI,0|zA,1048576,0)),0|vi,21),DA=vi,B=0|Ig(0|(B=0|Ig(0|(D=0|Ig(0|(q=0|Ig(0|(PI=0|Ig(0|(xI=0|Ig(0|(KI=0|Ig(0|(VI=0|Ig(0|(jI=0|Ig(0|zI,0|WI,0|ZI,0|jI)),0|vi,0|qI,0|VI)),0|vi,0|TI,0|KI)),0|vi,0|XI,0|xI)),0|vi,0|LI,0|PI)),0|vi,0|JI,0|q)),0|vi,0|j,0|D)),0|vi,2097151&B|0,0)),0|vi,0|vA,0|DA),D=vi,DA=0|Se(0|vA,0|DA,21),vA=vi,j=0|be(0|(j=0|Ig(0|LA,0|xA,1048576,0)),0|vi,21),q=vi,g=0|Ig(0|(g=0|Ig(0|(g=0|Ig(0|(_A=0|Ig(0|(lI=0|Ig(0|(dI=0|Ig(0|(vI=0|Ig(0|(kI=0|Ig(0|(FI=0|Ig(0|(MI=0|Ig(0|(SI=0|Ig(0|UI,0|NI,0|RI,0|SI)),0|vi,0|YI,0|MI)),0|vi,0|mI,0|FI)),0|vi,0|GI,0|kI)),0|vi,0|bI,0|vI)),0|vi,0|DI,0|dI)),0|vi,0|uI,0|lI)),0|vi,0|wI,0|_A)),0|vi,0|r,0|g)),0|vi,2097151&k|0,0)),0|vi,0|j,0|q),k=vi,q=0|Se(0|j,0|q,21),j=vi,r=0|be(0|(r=0|Ig(0|PA,0|JA,1048576,0)),0|vi,21),_A=vi,t=0|Ig(0|(t=0|Ig(0|(OA=0|Ig(0|(WA=0|Ig(0|(K=0|Ig(0|(CI=0|Ig(0|(z=0|Ig(0|(RA=0|Ig(0|(eI=0|Ig(0|(FA=0|Ig(0|(KA=0|Ig(0|(S=0|Ig(0|(yI=0|Ig(0|pI,0|_I,0|fI,0|yI)),0|vi,0|P,0|S)),0|vi,0|XA,0|KA)),0|vi,0|GA,0|FA)),0|vi,0|II,0|eI)),0|vi,0|SA,0|RA)),0|vi,0|O,0|z)),0|vi,0|nI,0|CI)),0|vi,0|X,0|K)),0|vi,0|ZA,0|WA)),0|vi,0|iI,0|OA)),0|vi,0|I,0|t)),0|vi,0|r,0|_A),I=vi,_A=0|Se(0|r,0|_A,21),r=vi,OA=0|be(0|(OA=0|Ig(0|cI,0|oI,1048576,0)),0|vi,21),iI=vi,p=0|Ig(0|(p=0|Ig(0|(AI=0|Ig(0|(BI=0|Ig(0|(EI=0|Ig(0|(_=0|Ig(0|(u=0|Ig(0|(tA=0|Ig(0|(L=0|Ig(0|(TA=0|Ig(0|mA,0|MA,0|VA,0|TA)),0|vi,0|IA,0|L)),0|vi,0|BA,0|tA)),0|vi,0|s,0|u)),0|vi,0|E,0|_)),0|vi,0|QI,0|EI)),0|vi,0|R,0|BI)),0|vi,0|$A,0|AI)),0|vi,0|d,0|p)),0|vi,0|OA,0|iI),d=vi,iI=0|Se(0|OA,0|iI,21),OA=vi,AI=0|be(0|(AI=0|Ig(0|rI,0|aI,1048576,0)),0|vi,21),$A=vi,a=0|Ig(0|(a=0|Ig(0|(jA=0|Ig(0|(i=0|Ig(0|(h=0|Ig(0|(F=0|Ig(0|(n=0|Ig(0|(Q=0|Ig(0|pA,0|AA,0|J,0|Q)),0|vi,0|uA,0|n)),0|vi,0|Z,0|F)),0|vi,0|V,0|h)),0|vi,0|o,0|i)),0|vi,0|qA,0|jA)),0|vi,0|C,0|a)),0|vi,0|AI,0|$A),C=vi,$A=0|Se(0|AI,0|$A,21),AI=vi,jA=0|be(0|(jA=0|Ig(0|hI,0|H,1048576,0)),0|vi,21),qA=vi,YA=0|Ig(0|(YA=0|Ig(0|(v=0|Ig(0|(dA=0|Ig(0|(e=0|Ig(0|(lA=0|Ig(0|b,0|y,0|wA,0|lA)),0|vi,0|$,0|e)),0|vi,0|kA,0|dA)),0|vi,0|gA,0|v)),0|vi,0|G,0|YA)),0|vi,0|jA,0|qA),G=vi,qA=0|Se(0|jA,0|qA,21),jA=vi,v=0|be(0|(v=0|Ig(0|Y,0|eA,1048576,0)),0|vi,21),gA=vi,N=0|Ig(0|(N=0|Ig(0|(m=0|Ig(0|(l=0|Ig(0|UA,0|iA,0|oA,0|l)),0|vi,0|yA,0|m)),0|vi,0|tI,0|N)),0|vi,0|v,0|gA),tI=vi,gA=0|Ag(0|Y,0|eA,0|(gA=0|Se(0|v,0|gA,21)),0|vi),eA=vi,U=0|Ig(0|HA,0|U,0|(Y=0|be(0|(Y=0|Ig(0|sI,0|M,1048576,0)),0|vi,21)),0|(v=vi)),HA=vi,v=0|Ag(0|sI,0|M,0|(v=0|Se(0|Y,0|v,21)),0|vi),M=vi,m=0|Ag(0|fA,0|c,0|(m=0|Se(0|(sI=0|be(0|(sI=0|Ig(0|fA,0|c,1048576,0)),0|vi,21)),0|(Y=vi),21)),0|vi),c=vi,l=0|Ag(0|cA,0|f,0|(l=0|Se(0|(fA=0|Ue(0|(fA=0|Ig(0|cA,0|f,1048576,0)),0|vi,21)),0|(yA=vi),21)),0|vi),f=vi,iA=0|Ag(0|NA,0|x,0|(iA=0|Se(0|(cA=0|be(0|(cA=0|Ig(0|NA,0|x,1048576,0)),0|vi,21)),0|(oA=vi),21)),0|vi),x=vi,dA=0|Ag(0|bA,0|W,0|(dA=0|Se(0|(NA=0|be(0|(NA=0|Ig(0|bA,0|W,1048576,0)),0|vi,21)),0|(UA=vi),21)),0|vi),W=vi,e=0|Se(0|(bA=0|be(0|(bA=0|Ig(0|B,0|D,1048576,0)),0|vi,21)),0|(kA=vi),21),$=vi,y=0|Se(0|(lA=0|be(0|(lA=0|Ig(0|g,0|k,1048576,0)),0|vi,21)),0|(wA=vi),21),b=vi,h=0|Se(0|(i=0|be(0|(i=0|Ig(0|t,0|I,1048576,0)),0|vi,21)),0|(o=vi),21),V=vi,n=0|Se(0|(F=0|be(0|(F=0|Ig(0|p,0|d,1048576,0)),0|vi,21)),0|(Z=vi),21),uA=vi,AA=0|Se(0|(Q=0|be(0|(Q=0|Ig(0|a,0|C,1048576,0)),0|vi,21)),0|(J=vi),21),pA=vi,eA=0|Ig(0|(BI=0|be(0|(BI=0|Ig(0|YA,0|G,1048576,0)),0|vi,21)),0|(R=vi),0|gA,0|eA),gA=vi,R=0|Ag(0|YA,0|G,0|(R=0|Se(0|BI,0|R,21)),0|vi),G=vi,M=0|Ig(0|(YA=0|be(0|(YA=0|Ig(0|N,0|tI,1048576,0)),0|vi,21)),0|(BI=vi),0|v,0|M),v=vi,BI=0|Ag(0|N,0|tI,0|(BI=0|Se(0|YA,0|BI,21)),0|vi),tI=vi,c=0|Ig(0|(N=0|be(0|(N=0|Ig(0|U,0|HA,1048576,0)),0|vi,21)),0|(YA=vi),0|m,0|c),m=vi,YA=0|Ag(0|U,0|HA,0|(YA=0|Se(0|N,0|YA,21)),0|vi),HA=vi,U=0|he(0|sI,0|Y,666643,0),N=vi,EI=0|he(0|sI,0|Y,470296,0),QI=vi,_=0|he(0|sI,0|Y,654183,0),E=vi,u=0|he(0|sI,0|Y,-997805,-1),s=vi,tA=0|he(0|sI,0|Y,136657,0),BA=vi,J=0|Ig(0|(jA=0|Ag(0|(Y=0|Ig(0|hI,0|H,0|(Y=0|he(0|sI,0|Y,-683901,-1)),0|vi)),0|vi,0|qA,0|jA)),0|vi,0|Q,0|J),Q=vi,jA=0|he(0|c,0|m,666643,0),qA=vi,Y=0|he(0|c,0|m,470296,0),H=vi,hI=0|he(0|c,0|m,654183,0),sI=vi,L=0|he(0|c,0|m,-997805,-1),IA=vi,TA=0|he(0|c,0|m,136657,0),VA=vi,m=0|he(0|c,0|m,-683901,-1),c=vi,MA=0|he(0|YA,0|HA,666643,0),mA=vi,WA=0|he(0|YA,0|HA,470296,0),ZA=vi,K=0|he(0|YA,0|HA,654183,0),X=vi,CI=0|he(0|YA,0|HA,-997805,-1),nI=vi,z=0|he(0|YA,0|HA,136657,0),O=vi,HA=0|he(0|YA,0|HA,-683901,-1),YA=vi,Z=0|Ig(0|(AI=0|Ag(0|(YA=0|Ig(0|(VA=0|Ig(0|(s=0|Ig(0|rI,0|aI,0|u,0|s)),0|vi,0|TA,0|VA)),0|vi,0|HA,0|YA)),0|vi,0|$A,0|AI)),0|vi,0|F,0|Z),F=vi,AI=0|he(0|M,0|v,666643,0),$A=vi,YA=0|he(0|M,0|v,470296,0),HA=vi,VA=0|he(0|M,0|v,654183,0),TA=vi,s=0|he(0|M,0|v,-997805,-1),u=vi,aI=0|he(0|M,0|v,136657,0),rI=vi,v=0|he(0|M,0|v,-683901,-1),M=vi,RA=0|he(0|BI,0|tI,666643,0),SA=vi,eI=0|he(0|BI,0|tI,470296,0),II=vi,FA=0|he(0|BI,0|tI,654183,0),GA=vi,KA=0|he(0|BI,0|tI,-997805,-1),XA=vi,S=0|he(0|BI,0|tI,136657,0),P=vi,tI=0|he(0|BI,0|tI,-683901,-1),BI=vi,o=0|Ig(0|(OA=0|Ag(0|(BI=0|Ig(0|(rI=0|Ig(0|(nI=0|Ig(0|(oI=0|Ig(0|(QI=0|Ig(0|hI,0|sI,0|EI,0|QI)),0|vi,0|cI,0|oI)),0|vi,0|CI,0|nI)),0|vi,0|aI,0|rI)),0|vi,0|tI,0|BI)),0|vi,0|iI,0|OA)),0|vi,0|i,0|o),i=vi,vA=0|Ag(0|(UA=0|Ig(0|(OA=0|Ig(0|gI,0|zA,0|(OA=0|he(0|eA,0|gA,666643,0)),0|vi)),0|vi,0|NA,0|UA)),0|vi,0|DA,0|vA),DA=vi,UA=0|he(0|eA,0|gA,470296,0),NA=vi,OA=0|he(0|eA,0|gA,654183,0),zA=vi,j=0|Ag(0|(kA=0|Ig(0|(xA=0|Ig(0|(zA=0|Ig(0|($A=0|Ig(0|eI,0|II,0|AI,0|$A)),0|vi,0|OA,0|zA)),0|vi,0|LA,0|xA)),0|vi,0|bA,0|kA)),0|vi,0|q,0|j),q=vi,kA=0|he(0|eA,0|gA,-997805,-1),bA=vi,xA=0|he(0|eA,0|gA,136657,0),LA=vi,r=0|Ag(0|(wA=0|Ig(0|(JA=0|Ig(0|(LA=0|Ig(0|(XA=0|Ig(0|(TA=0|Ig(0|(qA=0|Ig(0|WA,0|ZA,0|jA,0|qA)),0|vi,0|VA,0|TA)),0|vi,0|KA,0|XA)),0|vi,0|xA,0|LA)),0|vi,0|PA,0|JA)),0|vi,0|lA,0|wA)),0|vi,0|_A,0|r),_A=vi,gA=0|he(0|eA,0|gA,-683901,-1),eA=vi,wA=0|be(0|(wA=0|Ig(0|vA,0|DA,1048576,0)),0|vi,21),lA=vi,$=0|Ig(0|($=0|Ag(0|(D=0|Ig(0|(SA=0|Ig(0|UA,0|NA,0|RA,0|SA)),0|vi,0|B,0|D)),0|vi,0|e,0|$)),0|vi,0|wA,0|lA),e=vi,lA=0|Se(0|wA,0|lA,21),wA=vi,D=0|be(0|(D=0|Ig(0|j,0|q,1048576,0)),0|vi,21),B=vi,b=0|Ig(0|(b=0|Ag(0|(k=0|Ig(0|(bA=0|Ig(0|(GA=0|Ig(0|(mA=0|Ig(0|YA,0|HA,0|MA,0|mA)),0|vi,0|FA,0|GA)),0|vi,0|kA,0|bA)),0|vi,0|g,0|k)),0|vi,0|y,0|b)),0|vi,0|D,0|B),y=vi,B=0|Se(0|D,0|B,21),D=vi,k=0|be(0|(k=0|Ig(0|r,0|_A,1048576,0)),0|vi,21),g=vi,V=0|Ig(0|(V=0|Ag(0|(I=0|Ig(0|(eA=0|Ig(0|(P=0|Ig(0|(u=0|Ig(0|(X=0|Ig(0|(N=0|Ig(0|Y,0|H,0|U,0|N)),0|vi,0|K,0|X)),0|vi,0|s,0|u)),0|vi,0|S,0|P)),0|vi,0|gA,0|eA)),0|vi,0|t,0|I)),0|vi,0|h,0|V)),0|vi,0|k,0|g),h=vi,g=0|Se(0|k,0|g,21),k=vi,I=0|be(0|(I=0|Ig(0|o,0|i,1048576,0)),0|vi,21),t=vi,uA=0|Ig(0|(uA=0|Ag(0|(d=0|Ig(0|(M=0|Ig(0|(O=0|Ig(0|(E=0|Ig(0|L,0|IA,0|_,0|E)),0|vi,0|z,0|O)),0|vi,0|v,0|M)),0|vi,0|p,0|d)),0|vi,0|n,0|uA)),0|vi,0|I,0|t),n=vi,t=0|Ag(0|o,0|i,0|(t=0|Se(0|I,0|t,21)),0|vi),i=vi,o=0|be(0|(o=0|Ig(0|Z,0|F,1048576,0)),0|vi,21),I=vi,pA=0|Ig(0|(pA=0|Ag(0|(C=0|Ig(0|(BA=0|Ig(0|m,0|c,0|tA,0|BA)),0|vi,0|a,0|C)),0|vi,0|AA,0|pA)),0|vi,0|o,0|I),AA=vi,I=0|Ag(0|Z,0|F,0|(I=0|Se(0|o,0|I,21)),0|vi),F=vi,G=0|Ig(0|(Z=0|be(0|(Z=0|Ig(0|J,0|Q,1048576,0)),0|vi,21)),0|(o=vi),0|R,0|G),R=vi,o=0|Ag(0|J,0|Q,0|(o=0|Se(0|Z,0|o,21)),0|vi),Q=vi,C=0|Se(0|(J=0|be(0|(J=0|Ig(0|$,0|e,1048576,0)),0|vi,21)),0|(Z=vi),21),a=vi,c=0|Se(0|(BA=0|be(0|(BA=0|Ig(0|b,0|y,1048576,0)),0|vi,21)),0|(tA=vi),21),m=vi,i=0|Ig(0|(d=0|be(0|(d=0|Ig(0|V,0|h,1048576,0)),0|vi,21)),0|(p=vi),0|t,0|i),t=vi,p=0|Ag(0|V,0|h,0|(p=0|Se(0|d,0|p,21)),0|vi),h=vi,F=0|Ig(0|(V=0|be(0|(V=0|Ig(0|uA,0|n,1048576,0)),0|vi,21)),0|(d=vi),0|I,0|F),I=vi,d=0|Ag(0|uA,0|n,0|(d=0|Se(0|V,0|d,21)),0|vi),n=vi,Q=0|Ig(0|(uA=0|be(0|(uA=0|Ig(0|pA,0|AA,1048576,0)),0|vi,21)),0|(V=vi),0|o,0|Q),o=vi,V=0|Ag(0|pA,0|AA,0|(V=0|Se(0|uA,0|V,21)),0|vi),AA=vi,pA=0|Ig(0|dA,0|W,0|(pA=0|he(0|G,0|R,666643,0)),0|vi),W=vi,dA=0|he(0|G,0|R,470296,0),uA=vi,M=0|he(0|G,0|R,654183,0),v=vi,O=0|he(0|G,0|R,-997805,-1),z=vi,E=0|he(0|G,0|R,136657,0),_=vi,k=0|Ag(0|(tA=0|Ig(0|(R=0|Ig(0|r,0|_A,0|(R=0|he(0|G,0|R,-683901,-1)),0|vi)),0|vi,0|BA,0|tA)),0|vi,0|g,0|k),g=vi,tA=0|he(0|Q,0|o,666643,0),BA=vi,R=0|Ig(0|pA,0|W,0|(R=0|he(0|Q,0|o,470296,0)),0|vi),W=vi,pA=0|he(0|Q,0|o,654183,0),_A=vi,r=0|he(0|Q,0|o,-997805,-1),G=vi,IA=0|he(0|Q,0|o,136657,0),L=vi,o=0|he(0|Q,0|o,-683901,-1),Q=vi,eA=0|Ig(0|iA,0|x,0|(eA=0|he(0|V,0|AA,666643,0)),0|vi),x=vi,iA=0|he(0|V,0|AA,470296,0),gA=vi,P=0|Ig(0|R,0|W,0|(P=0|he(0|V,0|AA,654183,0)),0|vi),W=vi,R=0|he(0|V,0|AA,-997805,-1),S=vi,u=0|he(0|V,0|AA,136657,0),s=vi,AA=0|he(0|V,0|AA,-683901,-1),V=vi,D=0|Ag(0|(V=0|Ig(0|(L=0|Ig(0|(Z=0|Ig(0|(z=0|Ig(0|j,0|q,0|O,0|z)),0|vi,0|J,0|Z)),0|vi,0|IA,0|L)),0|vi,0|AA,0|V)),0|vi,0|B,0|D),B=vi,V=0|he(0|F,0|I,666643,0),AA=vi,L=0|Ig(0|eA,0|x,0|(L=0|he(0|F,0|I,470296,0)),0|vi),x=vi,eA=0|he(0|F,0|I,654183,0),IA=vi,Z=0|Ig(0|P,0|W,0|(Z=0|he(0|F,0|I,-997805,-1)),0|vi),W=vi,P=0|he(0|F,0|I,136657,0),J=vi,I=0|he(0|F,0|I,-683901,-1),F=vi,z=0|he(0|d,0|n,666643,0),O=vi,q=0|he(0|d,0|n,470296,0),j=vi,X=0|he(0|d,0|n,654183,0),K=vi,N=0|he(0|d,0|n,-997805,-1),U=vi,H=0|he(0|d,0|n,136657,0),Y=vi,n=0|he(0|d,0|n,-683901,-1),d=vi,d=0|Ig(0|(J=0|Ig(0|(S=0|Ig(0|(_A=0|Ig(0|(wA=0|Ag(0|(uA=0|Ig(0|vA,0|DA,0|dA,0|uA)),0|vi,0|lA,0|wA)),0|vi,0|pA,0|_A)),0|vi,0|R,0|S)),0|vi,0|P,0|J)),0|vi,0|n,0|d),n=vi,T=0|Ig(0|(J=0|he(0|i,0|t,666643,0)),0|vi,0|w,0|T),w=vi,J=0|he(0|i,0|t,470296,0),P=vi,S=0|he(0|i,0|t,654183,0),R=vi,j=0|Ig(0|(R=0|Ig(0|(AA=0|Ig(0|(QA=0|Ag(0|(sA=0|Ig(0|fA,0|yA,0|hA,0|sA)),0|vi,0|EA,0|QA)),0|vi,0|V,0|AA)),0|vi,0|S,0|R)),0|vi,0|q,0|j),q=vi,R=0|he(0|i,0|t,-997805,-1),S=vi,AA=0|he(0|i,0|t,136657,0),V=vi,U=0|Ig(0|(V=0|Ig(0|(IA=0|Ig(0|(gA=0|Ig(0|(BA=0|Ig(0|(rA=0|Ag(0|(nA=0|Ig(0|cA,0|oA,0|CA,0|nA)),0|vi,0|aA,0|rA)),0|vi,0|tA,0|BA)),0|vi,0|iA,0|gA)),0|vi,0|eA,0|IA)),0|vi,0|AA,0|V)),0|vi,0|N,0|U),N=vi,t=0|he(0|i,0|t,-683901,-1),i=vi,V=0|be(0|(V=0|Ig(0|T,0|w,1048576,0)),0|vi,21),AA=vi,O=0|Ig(0|(O=0|Ig(0|(P=0|Ig(0|l,0|f,0|J,0|P)),0|vi,0|z,0|O)),0|vi,0|V,0|AA),z=vi,AA=0|Ag(0|T,0|w,0|(AA=0|Se(0|V,0|AA,21)),0|vi),w=vi,T=0|be(0|(T=0|Ig(0|j,0|q,1048576,0)),0|vi,21),V=vi,K=0|Ig(0|(K=0|Ig(0|(S=0|Ig(0|L,0|x,0|R,0|S)),0|vi,0|X,0|K)),0|vi,0|T,0|V),X=vi,V=0|Se(0|T,0|V,21),T=vi,S=0|be(0|(S=0|Ig(0|U,0|N,1048576,0)),0|vi,21),R=vi,Y=0|Ig(0|(Y=0|Ig(0|(i=0|Ig(0|Z,0|W,0|t,0|i)),0|vi,0|H,0|Y)),0|vi,0|S,0|R),H=vi,R=0|Se(0|S,0|R,21),S=vi,i=0|be(0|(i=0|Ig(0|d,0|n,1048576,0)),0|vi,21),t=vi,F=0|Ig(0|(F=0|Ig(0|(s=0|Ig(0|(a=0|Ag(0|(G=0|Ig(0|(v=0|Ig(0|$,0|e,0|M,0|v)),0|vi,0|r,0|G)),0|vi,0|C,0|a)),0|vi,0|u,0|s)),0|vi,0|I,0|F)),0|vi,0|i,0|t),I=vi,t=0|Ag(0|d,0|n,0|(t=0|Se(0|i,0|t,21)),0|vi),n=vi,d=0|be(0|(d=0|Ig(0|D,0|B,1048576,0)),0|vi,21),i=vi,m=0|Ig(0|(m=0|Ag(0|(y=0|Ig(0|(_=0|Ig(0|o,0|Q,0|E,0|_)),0|vi,0|b,0|y)),0|vi,0|c,0|m)),0|vi,0|d,0|i),c=vi,i=0|Ag(0|D,0|B,0|(i=0|Se(0|d,0|i,21)),0|vi),B=vi,h=0|Ig(0|p,0|h,0|(D=0|be(0|(D=0|Ig(0|k,0|g,1048576,0)),0|vi,21)),0|(d=vi)),p=vi,d=0|Se(0|D,0|d,21),D=vi,_=0|Se(0|(y=0|be(0|(y=0|Ig(0|O,0|z,1048576,0)),0|vi,21)),0|(b=vi),21),E=vi,s=0|Se(0|(Q=0|be(0|(Q=0|Ig(0|K,0|X,1048576,0)),0|vi,21)),0|(o=vi),21),u=vi,n=0|Ig(0|t,0|n,0|(a=0|be(0|(a=0|Ig(0|Y,0|H,1048576,0)),0|vi,21)),0|(C=vi)),t=vi,C=0|Se(0|a,0|C,21),a=vi,B=0|Ig(0|i,0|B,0|(G=0|be(0|(G=0|Ig(0|F,0|I,1048576,0)),0|vi,21)),0|(r=vi)),i=vi,r=0|Ag(0|F,0|I,0|(r=0|Se(0|G,0|r,21)),0|vi),I=vi,v=0|Ag(0|m,0|c,0|(v=0|Se(0|(F=0|be(0|(F=0|Ig(0|m,0|c,1048576,0)),0|vi,21)),0|(G=vi),21)),0|vi),c=vi,e=0|Ag(0|h,0|p,0|(e=0|Se(0|(m=0|be(0|(m=0|Ig(0|h,0|p,1048576,0)),0|vi,21)),0|(M=vi),21)),0|vi),p=vi,h=0|Ig(0|AA,0|w,0|(h=0|he(0|m,0|M,666643,0)),0|vi),w=vi,AA=0|he(0|m,0|M,470296,0),$=vi,W=0|he(0|m,0|M,654183,0),Z=vi,x=0|he(0|m,0|M,-997805,-1),L=vi,P=0|he(0|m,0|M,136657,0),J=vi,M=0|he(0|m,0|M,-683901,-1),m=vi,f=0|be(0|h,0|w,21),l=vi,E=0|Ig(0|(E=0|Ag(0|(z=0|Ig(0|AA,0|$,0|O,0|z)),0|vi,0|_,0|E)),0|vi,0|f,0|l),_=vi,l=0|Ag(0|h,0|w,0|(l=0|Se(0|f,0|l,21)),0|vi),w=vi,h=0|be(0|E,0|_,21),f=vi,b=0|Ig(0|(b=0|Ig(0|(T=0|Ag(0|(q=0|Ig(0|W,0|Z,0|j,0|q)),0|vi,0|V,0|T)),0|vi,0|y,0|b)),0|vi,0|h,0|f),y=vi,f=0|Ag(0|E,0|_,0|(f=0|Se(0|h,0|f,21)),0|vi),_=vi,E=0|be(0|b,0|y,21),h=vi,u=0|Ig(0|(u=0|Ag(0|(L=0|Ig(0|K,0|X,0|x,0|L)),0|vi,0|s,0|u)),0|vi,0|E,0|h),s=vi,h=0|Ag(0|b,0|y,0|(h=0|Se(0|E,0|h,21)),0|vi),y=vi,b=0|be(0|u,0|s,21),E=vi,o=0|Ig(0|(o=0|Ig(0|(S=0|Ag(0|(N=0|Ig(0|P,0|J,0|U,0|N)),0|vi,0|R,0|S)),0|vi,0|Q,0|o)),0|vi,0|b,0|E),Q=vi,E=0|Ag(0|u,0|s,0|(E=0|Se(0|b,0|E,21)),0|vi),s=vi,u=0|be(0|o,0|Q,21),b=vi,a=0|Ig(0|(a=0|Ag(0|(m=0|Ig(0|Y,0|H,0|M,0|m)),0|vi,0|C,0|a)),0|vi,0|u,0|b),C=vi,b=0|Ag(0|o,0|Q,0|(b=0|Se(0|u,0|b,21)),0|vi),Q=vi,t=0|Ig(0|n,0|t,0|(o=0|be(0|a,0|C,21)),0|(u=vi)),n=vi,u=0|Ag(0|a,0|C,0|(u=0|Se(0|o,0|u,21)),0|vi),C=vi,I=0|Ig(0|(a=0|be(0|t,0|n,21)),0|(o=vi),0|r,0|I),r=vi,o=0|Ag(0|t,0|n,0|(o=0|Se(0|a,0|o,21)),0|vi),n=vi,i=0|Ig(0|B,0|i,0|(t=0|be(0|I,0|r,21)),0|(a=vi)),B=vi,a=0|Ag(0|I,0|r,0|(a=0|Se(0|t,0|a,21)),0|vi),r=vi,c=0|Ig(0|(I=0|be(0|i,0|B,21)),0|(t=vi),0|v,0|c),v=vi,t=0|Ag(0|i,0|B,0|(t=0|Se(0|I,0|t,21)),0|vi),B=vi,i=0|be(0|c,0|v,21),I=vi,D=0|Ig(0|(D=0|Ag(0|(g=0|Ig(0|F,0|G,0|k,0|g)),0|vi,0|d,0|D)),0|vi,0|i,0|I),d=vi,I=0|Ag(0|c,0|v,0|(I=0|Se(0|i,0|I,21)),0|vi),v=vi,p=0|Ig(0|(c=0|be(0|D,0|d,21)),0|(i=vi),0|e,0|p),e=vi,i=0|Ag(0|D,0|d,0|(i=0|Se(0|c,0|i,21)),0|vi),d=vi,g=0|Ag(0|p,0|e,0|(g=0|Se(0|(D=0|be(0|p,0|e,21)),0|(c=vi),21)),0|vi),e=vi,w=0|Ig(0|(p=0|he(0|D,0|c,666643,0)),0|vi,0|l,0|w),l=vi,p=0|Ig(0|f,0|_,0|(p=0|he(0|D,0|c,470296,0)),0|vi),_=vi,f=0|Ig(0|h,0|y,0|(f=0|he(0|D,0|c,654183,0)),0|vi),y=vi,h=0|Ig(0|E,0|s,0|(h=0|he(0|D,0|c,-997805,-1)),0|vi),s=vi,E=0|Ig(0|b,0|Q,0|(E=0|he(0|D,0|c,136657,0)),0|vi),Q=vi,c=0|Ig(0|u,0|C,0|(c=0|he(0|D,0|c,-683901,-1)),0|vi),C=vi,_=0|Ig(0|p,0|_,0|(u=0|be(0|w,0|l,21)),0|(D=vi)),p=vi,D=0|Ag(0|w,0|l,0|(D=0|Se(0|u,0|D,21)),0|vi),l=vi,y=0|Ig(0|f,0|y,0|(w=0|be(0|_,0|p,21)),0|(u=vi)),f=vi,u=0|Ag(0|_,0|p,0|(u=0|Se(0|w,0|u,21)),0|vi),p=vi,s=0|Ig(0|h,0|s,0|(_=0|be(0|y,0|f,21)),0|(w=vi)),h=vi,w=0|Ag(0|y,0|f,0|(w=0|Se(0|_,0|w,21)),0|vi),f=vi,Q=0|Ig(0|E,0|Q,0|(y=0|be(0|s,0|h,21)),0|(_=vi)),E=vi,_=0|Ag(0|s,0|h,0|(_=0|Se(0|y,0|_,21)),0|vi),h=vi,C=0|Ig(0|c,0|C,0|(s=0|be(0|Q,0|E,21)),0|(y=vi)),c=vi,y=0|Ag(0|Q,0|E,0|(y=0|Se(0|s,0|y,21)),0|vi),E=vi,n=0|Ig(0|(Q=0|be(0|C,0|c,21)),0|(s=vi),0|o,0|n),o=vi,s=0|Ag(0|C,0|c,0|(s=0|Se(0|Q,0|s,21)),0|vi),c=vi,r=0|Ig(0|(C=0|be(0|n,0|o,21)),0|(Q=vi),0|a,0|r),a=vi,Q=0|Ag(0|n,0|o,0|(Q=0|Se(0|C,0|Q,21)),0|vi),o=vi,B=0|Ig(0|(n=0|be(0|r,0|a,21)),0|(C=vi),0|t,0|B),t=vi,C=0|Ag(0|r,0|a,0|(C=0|Se(0|n,0|C,21)),0|vi),a=vi,v=0|Ig(0|(r=0|be(0|B,0|t,21)),0|(n=vi),0|I,0|v),I=vi,n=0|Ag(0|B,0|t,0|(n=0|Se(0|r,0|n,21)),0|vi),t=vi,d=0|Ig(0|(B=0|be(0|v,0|I,21)),0|(r=vi),0|i,0|d),i=vi,r=0|Ag(0|v,0|I,0|(r=0|Se(0|B,0|r,21)),0|vi),I=vi,e=0|Ig(0|(v=0|be(0|d,0|i,21)),0|(B=vi),0|g,0|e),g=vi,B=0|Ag(0|d,0|i,0|(B=0|Se(0|v,0|B,21)),0|vi),i=vi,yi[A>>0]=D,d=0|Ue(0|D,0|l,8),yi[A+1>>0]=d,l=0|Ue(0|D,0|l,16),D=vi,d=0|Se(0|u,0|p,5),yi[A+2>>0]=d|l,l=0|Ue(0|u,0|p,3),yi[A+3>>0]=l,l=0|Ue(0|u,0|p,11),yi[A+4>>0]=l,p=0|Ue(0|u,0|p,19),u=vi,l=0|Se(0|w,0|f,2),yi[A+5>>0]=l|p,p=0|Ue(0|w,0|f,6),yi[A+6>>0]=p,f=0|Ue(0|w,0|f,14),w=vi,p=0|Se(0|_,0|h,7),yi[A+7>>0]=p|f,f=0|Ue(0|_,0|h,1),yi[A+8>>0]=f,f=0|Ue(0|_,0|h,9),yi[A+9>>0]=f,h=0|Ue(0|_,0|h,17),_=vi,f=0|Se(0|y,0|E,4),yi[A+10>>0]=f|h,h=0|Ue(0|y,0|E,4),yi[A+11>>0]=h,h=0|Ue(0|y,0|E,12),yi[A+12>>0]=h,E=0|Ue(0|y,0|E,20),y=vi,h=0|Se(0|s,0|c,1),yi[A+13>>0]=h|E,E=0|Ue(0|s,0|c,7),yi[A+14>>0]=E,c=0|Ue(0|s,0|c,15),s=vi,E=0|Se(0|Q,0|o,6),yi[A+15>>0]=E|c,c=0|Ue(0|Q,0|o,2),yi[A+16>>0]=c,c=0|Ue(0|Q,0|o,10),yi[A+17>>0]=c,o=0|Ue(0|Q,0|o,18),Q=vi,c=0|Se(0|C,0|a,3),yi[A+18>>0]=c|o,o=0|Ue(0|C,0|a,5),yi[A+19>>0]=o,a=0|Ue(0|C,0|a,13),yi[A+20>>0]=a,yi[A+21>>0]=n,a=0|Ue(0|n,0|t,8),yi[A+22>>0]=a,t=0|Ue(0|n,0|t,16),n=vi,a=0|Se(0|r,0|I,5),yi[A+23>>0]=a|t,t=0|Ue(0|r,0|I,3),yi[A+24>>0]=t,t=0|Ue(0|r,0|I,11),yi[A+25>>0]=t,I=0|Ue(0|r,0|I,19),r=vi,t=0|Se(0|B,0|i,2),yi[A+26>>0]=t|I,I=0|Ue(0|B,0|i,6),yi[A+27>>0]=I,i=0|Ue(0|B,0|i,14),B=vi,I=0|Se(0|e,0|g,7),yi[A+28>>0]=i|I,I=0|Ue(0|e,0|g,1),yi[A+29>>0]=I,I=0|Ue(0|e,0|g,9),yi[A+30>>0]=I,g=0|Ue(0|e,0|g,17),yi[A+31>>0]=g}function B(A,I,e,g){A|=0,g|=0;var i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0;ge(e|=0,I|=0),i=A,B=(I=g)+64|0;do{fi[I>>2]=fi[i>>2],I=I+4|0,i=i+4|0}while((0|I)<(0|B));for(y=0,I=0|fi[e>>2],i=0|fi[e+4>>2];;){if(d=0|fi[g+32>>2],s=0|fi[g+32+4>>2],r=0|Ee(d,s,14),v=vi,u=0|Ee(d,s,18),v^=vi,b=0|Ee(d,s,41),h=0|fi[g+40>>2],C=0|fi[g+40+4>>2],n=0|fi[g+48>>2],R=0|fi[g+48+4>>2],Q=304+(y<<3)|0,o=0|fi[Q>>2],Q=0|fi[Q+4>>2],w=0|fi[g+56>>2],_=0|fi[g+56+4>>2],v=0|Ig(0|I,0|i,u^r^b|0,v^vi|0),Q=0|Ig(0|v,0|vi,0|o,0|Q),Q=0|Ig(0|Q,0|vi,(n^h)&d^n|0,(R^C)&s^R|0),_=0|Ig(0|Q,0|vi,0|w,0|_),w=vi,Q=0|Ig(0|_,0|w,0|fi[g+24>>2],0|fi[g+24+4>>2]),o=vi,fi[g+24>>2]=Q,fi[g+24+4>>2]=o,v=0|fi[g>>2],b=0|fi[g+4>>2],r=0|Ee(v,b,28),u=vi,a=0|Ee(v,b,34),u^=vi,p=0|Ee(v,b,39),D=0|fi[g+8>>2],m=0|fi[g+8+4>>2],k=0|fi[g+16>>2],M=0|fi[g+16+4>>2],u=0|Ig(0|_,0|w,a^r^p|0,u^vi|0),u=0|Ig(0|u,0|vi,(k|D)&v|k&D|0,(M|m)&b|M&m|0),p=vi,fi[g+56>>2]=u,fi[g+56+4>>2]=p,r=0|Ee(Q,o,14),a=vi,w=0|Ee(Q,o,18),a^=vi,_=0|Ee(Q,o,41),t=1|y,l=0|fi[304+(t<<3)>>2],S=0|fi[304+(t<<3)+4>>2],a=0|Ig(0|fi[e+(t<<3)>>2],0|fi[e+(t<<3)+4>>2],w^r^_|0,a^vi|0),S=0|Ig(0|a,0|vi,0|l,0|S),S=0|Ig(0|S,0|vi,(h^d)&Q^h|0,(C^s)&o^C|0),R=0|Ig(0|S,0|vi,0|n,0|R),n=vi,M=0|Ig(0|R,0|n,0|k,0|M),k=vi,fi[g+16>>2]=M,fi[g+16+4>>2]=k,S=0|Ee(u,p,28),l=vi,a=0|Ee(u,p,34),l^=vi,_=0|Ee(u,p,39),l=0|Ig(0|R,0|n,a^S^_|0,l^vi|0),l=0|Ig(0|l,0|vi,(D|v)&u|D&v|0,(m|b)&p|m&b|0),_=vi,fi[g+48>>2]=l,fi[g+48+4>>2]=_,S=0|Ee(M,k,14),a=vi,n=0|Ee(M,k,18),a^=vi,R=0|Ee(M,k,41),r=2|y,w=0|fi[304+(r<<3)>>2],c=0|fi[304+(r<<3)+4>>2],a=0|Ig(0|fi[e+(r<<3)>>2],0|fi[e+(r<<3)+4>>2],n^S^R|0,a^vi|0),c=0|Ig(0|a,0|vi,0|w,0|c),s=0|Ig(0|c,0|vi,(d^Q)&M^d|0,(s^o)&k^s|0),C=0|Ig(0|s,0|vi,0|h,0|C),h=vi,m=0|Ig(0|C,0|h,0|D,0|m),D=vi,fi[g+8>>2]=m,fi[g+8+4>>2]=D,s=0|Ee(l,_,28),d=vi,c=0|Ee(l,_,34),d^=vi,w=0|Ee(l,_,39),d=0|Ig(0|C,0|h,c^s^w|0,d^vi|0),d=0|Ig(0|d,0|vi,(v|u)&l|v&u|0,(b|p)&_|b&p|0),w=vi,fi[g+40>>2]=d,fi[g+40+4>>2]=w,s=0|Ee(m,D,14),c=vi,h=0|Ee(m,D,18),c^=vi,C=0|Ee(m,D,41),a=3|y,R=0|fi[304+(a<<3)>>2],S=0|fi[304+(a<<3)+4>>2],n=0|fi[g+32>>2],E=0|fi[g+32+4>>2],c=0|Ig(0|fi[e+(a<<3)>>2],0|fi[e+(a<<3)+4>>2],h^s^C|0,c^vi|0),S=0|Ig(0|c,0|vi,0|R,0|S),o=0|Ig(0|S,0|vi,(Q^M)&m^Q|0,(o^k)&D^o|0),E=0|Ig(0|o,0|vi,0|n,0|E),n=vi,b=0|Ig(0|E,0|n,0|v,0|b),v=vi,fi[g>>2]=b,fi[g+4>>2]=v,o=0|Ee(d,w,28),Q=vi,S=0|Ee(d,w,34),Q^=vi,R=0|Ee(d,w,39),Q=0|Ig(0|E,0|n,S^o^R|0,Q^vi|0),p=0|Ig(0|Q,0|vi,(u|l)&d|u&l|0,(p|_)&w|p&_|0),u=vi,fi[g+32>>2]=p,fi[g+32+4>>2]=u,Q=0|Ee(b,v,14),R=vi,o=0|Ee(b,v,18),R^=vi,S=0|Ee(b,v,41),n=4|y,E=0|fi[304+(n<<3)>>2],c=0|fi[304+(n<<3)+4>>2],C=0|fi[g+24>>2],s=0|fi[g+24+4>>2],R=0|Ig(0|fi[e+(n<<3)>>2],0|fi[e+(n<<3)+4>>2],o^Q^S|0,R^vi|0),c=0|Ig(0|R,0|vi,0|E,0|c),k=0|Ig(0|c,0|vi,(M^m)&b^M|0,(k^D)&v^k|0),s=0|Ig(0|k,0|vi,0|C,0|s),C=vi,k=0|Ig(0|s,0|C,0|fi[g+56>>2],0|fi[g+56+4>>2]),M=vi,fi[g+56>>2]=k,fi[g+56+4>>2]=M,c=0|Ee(p,u,28),E=vi,R=0|Ee(p,u,34),E^=vi,S=0|Ee(p,u,39),E=0|Ig(0|s,0|C,R^c^S|0,E^vi|0),_=0|Ig(0|E,0|vi,(l|d)&p|l&d|0,(_|w)&u|_&w|0),l=vi,fi[g+24>>2]=_,fi[g+24+4>>2]=l,E=0|Ee(k,M,14),S=vi,c=0|Ee(k,M,18),S^=vi,R=0|Ee(k,M,41),C=5|y,s=0|fi[304+(C<<3)>>2],Q=0|fi[304+(C<<3)+4>>2],o=0|fi[g+16>>2],h=0|fi[g+16+4>>2],S=0|Ig(0|fi[e+(C<<3)>>2],0|fi[e+(C<<3)+4>>2],c^E^R|0,S^vi|0),Q=0|Ig(0|S,0|vi,0|s,0|Q),D=0|Ig(0|Q,0|vi,(m^b)&k^m|0,(D^v)&M^D|0),h=0|Ig(0|D,0|vi,0|o,0|h),o=vi,D=0|Ig(0|h,0|o,0|fi[g+48>>2],0|fi[g+48+4>>2]),m=vi,fi[g+48>>2]=D,fi[g+48+4>>2]=m,Q=0|Ee(_,l,28),s=vi,S=0|Ee(_,l,34),s^=vi,R=0|Ee(_,l,39),s=0|Ig(0|h,0|o,S^Q^R|0,s^vi|0),w=0|Ig(0|s,0|vi,(d|p)&_|d&p|0,(w|u)&l|w&u|0),d=vi,fi[g+16>>2]=w,fi[g+16+4>>2]=d,s=0|Ee(D,m,14),R=vi,Q=0|Ee(D,m,18),R^=vi,S=0|Ee(D,m,41),o=6|y,h=0|fi[304+(o<<3)>>2],E=0|fi[304+(o<<3)+4>>2],c=0|fi[g+8>>2],I=0|fi[g+8+4>>2],R=0|Ig(0|fi[e+(o<<3)>>2],0|fi[e+(o<<3)+4>>2],Q^s^S|0,R^vi|0),E=0|Ig(0|R,0|vi,0|h,0|E),v=0|Ig(0|E,0|vi,(b^k)&D^b|0,(v^M)&m^v|0),I=0|Ig(0|v,0|vi,0|c,0|I),c=vi,v=0|Ig(0|I,0|c,0|fi[g+40>>2],0|fi[g+40+4>>2]),b=vi,fi[g+40>>2]=v,fi[g+40+4>>2]=b,E=0|Ee(w,d,28),h=vi,R=0|Ee(w,d,34),h^=vi,S=0|Ee(w,d,39),h=0|Ig(0|I,0|c,R^E^S|0,h^vi|0),u=0|Ig(0|h,0|vi,(p|_)&w|p&_|0,(u|l)&d|u&l|0),p=vi,fi[g+8>>2]=u,fi[g+8+4>>2]=p,h=0|Ee(v,b,14),S=vi,E=0|Ee(v,b,18),S^=vi,R=0|Ee(v,b,41),c=7|y,I=0|fi[304+(c<<3)>>2],s=0|fi[304+(c<<3)+4>>2],Q=0|fi[g>>2],i=0|fi[g+4>>2],S=0|Ig(0|fi[e+(c<<3)>>2],0|fi[e+(c<<3)+4>>2],E^h^R|0,S^vi|0),s=0|Ig(0|S,0|vi,0|I,0|s),M=0|Ig(0|s,0|vi,(k^D)&v^k|0,(M^m)&b^M|0),i=0|Ig(0|M,0|vi,0|Q,0|i),Q=vi,M=0|Ig(0|i,0|Q,0|fi[g+32>>2],0|fi[g+32+4>>2]),k=vi,fi[g+32>>2]=M,fi[g+32+4>>2]=k,s=0|Ee(u,p,28),I=vi,S=0|Ee(u,p,34),I^=vi,R=0|Ee(u,p,39),I=0|Ig(0|i,0|Q,S^s^R|0,I^vi|0),l=0|Ig(0|I,0|vi,(_|w)&u|_&w|0,(l|d)&p|l&d|0),_=vi,fi[g>>2]=l,fi[g+4>>2]=_,I=0|Ee(M,k,14),R=vi,s=0|Ee(M,k,18),R^=vi,S=0|Ee(M,k,41),Q=8|y,i=0|fi[304+(Q<<3)>>2],h=0|fi[304+(Q<<3)+4>>2],E=0|fi[g+56>>2],B=0|fi[g+56+4>>2],R=0|Ig(0|fi[e+(Q<<3)>>2],0|fi[e+(Q<<3)+4>>2],s^I^S|0,R^vi|0),h=0|Ig(0|R,0|vi,0|i,0|h),m=0|Ig(0|h,0|vi,(D^v)&M^D|0,(m^b)&k^m|0),B=0|Ig(0|m,0|vi,0|E,0|B),E=vi,m=0|Ig(0|B,0|E,0|fi[g+24>>2],0|fi[g+24+4>>2]),D=vi,fi[g+24>>2]=m,fi[g+24+4>>2]=D,h=0|Ee(l,_,28),i=vi,R=0|Ee(l,_,34),i^=vi,S=0|Ee(l,_,39),i=0|Ig(0|B,0|E,R^h^S|0,i^vi|0),d=0|Ig(0|i,0|vi,(w|u)&l|w&u|0,(d|p)&_|d&p|0),w=vi,fi[g+56>>2]=d,fi[g+56+4>>2]=w,i=0|Ee(m,D,14),S=vi,h=0|Ee(m,D,18),S^=vi,R=0|Ee(m,D,41),E=9|y,B=0|fi[304+(E<<3)>>2],I=0|fi[304+(E<<3)+4>>2],s=0|fi[g+48>>2],f=0|fi[g+48+4>>2],S=0|Ig(0|fi[e+(E<<3)>>2],0|fi[e+(E<<3)+4>>2],h^i^R|0,S^vi|0),I=0|Ig(0|S,0|vi,0|B,0|I),b=0|Ig(0|I,0|vi,(v^M)&m^v|0,(b^k)&D^b|0),f=0|Ig(0|b,0|vi,0|s,0|f),s=vi,b=0|Ig(0|f,0|s,0|fi[g+16>>2],0|fi[g+16+4>>2]),v=vi,fi[g+16>>2]=b,fi[g+16+4>>2]=v,I=0|Ee(d,w,28),B=vi,S=0|Ee(d,w,34),B^=vi,R=0|Ee(d,w,39),B=0|Ig(0|f,0|s,S^I^R|0,B^vi|0),p=0|Ig(0|B,0|vi,(u|l)&d|u&l|0,(p|_)&w|p&_|0),u=vi,fi[g+48>>2]=p,fi[g+48+4>>2]=u,B=0|Ee(b,v,14),R=vi,I=0|Ee(b,v,18),R^=vi,S=0|Ee(b,v,41),s=10|y,f=0|fi[304+(s<<3)>>2],i=0|fi[304+(s<<3)+4>>2],h=0|fi[g+40>>2],G=0|fi[g+40+4>>2],R=0|Ig(0|fi[e+(s<<3)>>2],0|fi[e+(s<<3)+4>>2],I^B^S|0,R^vi|0),i=0|Ig(0|R,0|vi,0|f,0|i),k=0|Ig(0|i,0|vi,(M^m)&b^M|0,(k^D)&v^k|0),G=0|Ig(0|k,0|vi,0|h,0|G),h=vi,k=0|Ig(0|G,0|h,0|fi[g+8>>2],0|fi[g+8+4>>2]),M=vi,fi[g+8>>2]=k,fi[g+8+4>>2]=M,i=0|Ee(p,u,28),f=vi,R=0|Ee(p,u,34),f^=vi,S=0|Ee(p,u,39),f=0|Ig(0|G,0|h,R^i^S|0,f^vi|0),_=0|Ig(0|f,0|vi,(l|d)&p|l&d|0,(_|w)&u|_&w|0),l=vi,fi[g+40>>2]=_,fi[g+40+4>>2]=l,f=0|Ee(k,M,14),S=vi,i=0|Ee(k,M,18),S^=vi,R=0|Ee(k,M,41),h=11|y,G=0|fi[304+(h<<3)>>2],B=0|fi[304+(h<<3)+4>>2],I=0|fi[g+32>>2],U=0|fi[g+32+4>>2],S=0|Ig(0|fi[e+(h<<3)>>2],0|fi[e+(h<<3)+4>>2],i^f^R|0,S^vi|0),B=0|Ig(0|S,0|vi,0|G,0|B),D=0|Ig(0|B,0|vi,(m^b)&k^m|0,(D^v)&M^D|0),U=0|Ig(0|D,0|vi,0|I,0|U),I=vi,D=0|Ig(0|U,0|I,0|fi[g>>2],0|fi[g+4>>2]),m=vi,fi[g>>2]=D,fi[g+4>>2]=m,B=0|Ee(_,l,28),G=vi,S=0|Ee(_,l,34),G^=vi,R=0|Ee(_,l,39),G=0|Ig(0|U,0|I,S^B^R|0,G^vi|0),w=0|Ig(0|G,0|vi,(d|p)&_|d&p|0,(w|u)&l|w&u|0),d=vi,fi[g+32>>2]=w,fi[g+32+4>>2]=d,G=0|Ee(D,m,14),R=vi,B=0|Ee(D,m,18),R^=vi,S=0|Ee(D,m,41),I=12|y,U=0|fi[304+(I<<3)>>2],f=0|fi[304+(I<<3)+4>>2],i=0|fi[g+24>>2],H=0|fi[g+24+4>>2],R=0|Ig(0|fi[e+(I<<3)>>2],0|fi[e+(I<<3)+4>>2],B^G^S|0,R^vi|0),f=0|Ig(0|R,0|vi,0|U,0|f),v=0|Ig(0|f,0|vi,(b^k)&D^b|0,(v^M)&m^v|0),H=0|Ig(0|v,0|vi,0|i,0|H),i=vi,v=0|Ig(0|H,0|i,0|fi[g+56>>2],0|fi[g+56+4>>2]),b=vi,fi[g+56>>2]=v,fi[g+56+4>>2]=b,f=0|Ee(w,d,28),U=vi,R=0|Ee(w,d,34),U^=vi,S=0|Ee(w,d,39),U=0|Ig(0|H,0|i,R^f^S|0,U^vi|0),u=0|Ig(0|U,0|vi,(p|_)&w|p&_|0,(u|l)&d|u&l|0),p=vi,fi[g+24>>2]=u,fi[g+24+4>>2]=p,U=0|Ee(v,b,14),S=vi,f=0|Ee(v,b,18),S^=vi,R=0|Ee(v,b,41),i=13|y,H=0|fi[304+(i<<3)>>2],G=0|fi[304+(i<<3)+4>>2],B=0|fi[g+16>>2],N=0|fi[g+16+4>>2],S=0|Ig(0|fi[e+(i<<3)>>2],0|fi[e+(i<<3)+4>>2],f^U^R|0,S^vi|0),G=0|Ig(0|S,0|vi,0|H,0|G),M=0|Ig(0|G,0|vi,(k^D)&v^k|0,(M^m)&b^M|0),N=0|Ig(0|M,0|vi,0|B,0|N),B=vi,M=0|Ig(0|N,0|B,0|fi[g+48>>2],0|fi[g+48+4>>2]),k=vi,fi[g+48>>2]=M,fi[g+48+4>>2]=k,G=0|Ee(u,p,28),H=vi,S=0|Ee(u,p,34),H^=vi,R=0|Ee(u,p,39),H=0|Ig(0|N,0|B,S^G^R|0,H^vi|0),l=0|Ig(0|H,0|vi,(_|w)&u|_&w|0,(l|d)&p|l&d|0),_=vi,fi[g+16>>2]=l,fi[g+16+4>>2]=_,H=0|Ee(M,k,14),R=vi,G=0|Ee(M,k,18),R^=vi,S=0|Ee(M,k,41),B=14|y,N=0|fi[304+(B<<3)>>2],U=0|fi[304+(B<<3)+4>>2],f=0|fi[g+8>>2],Y=0|fi[g+8+4>>2],R=0|Ig(0|fi[e+(B<<3)>>2],0|fi[e+(B<<3)+4>>2],G^H^S|0,R^vi|0),U=0|Ig(0|R,0|vi,0|N,0|U),m=0|Ig(0|U,0|vi,(D^v)&M^D|0,(m^b)&k^m|0),Y=0|Ig(0|m,0|vi,0|f,0|Y),f=vi,m=0|Ig(0|Y,0|f,0|fi[g+40>>2],0|fi[g+40+4>>2]),D=vi,fi[g+40>>2]=m,fi[g+40+4>>2]=D,U=0|Ee(l,_,28),N=vi,R=0|Ee(l,_,34),N^=vi,S=0|Ee(l,_,39),N=0|Ig(0|Y,0|f,R^U^S|0,N^vi|0),d=0|Ig(0|N,0|vi,(w|u)&l|w&u|0,(d|p)&_|d&p|0),w=vi,fi[g+8>>2]=d,fi[g+8+4>>2]=w,N=0|Ee(m,D,14),S=vi,U=0|Ee(m,D,18),S^=vi,R=0|Ee(m,D,41),f=15|y,Y=0|fi[304+(f<<3)>>2],H=0|fi[304+(f<<3)+4>>2],G=0|fi[g>>2],F=0|fi[g+4>>2],S=0|Ig(0|fi[e+(f<<3)>>2],0|fi[e+(f<<3)+4>>2],U^N^R|0,S^vi|0),H=0|Ig(0|S,0|vi,0|Y,0|H),b=0|Ig(0|H,0|vi,(v^M)&m^v|0,(b^k)&D^b|0),F=0|Ig(0|b,0|vi,0|G,0|F),G=vi,b=0|Ig(0|F,0|G,0|fi[g+32>>2],0|fi[g+32+4>>2]),fi[g+32>>2]=b,fi[g+32+4>>2]=vi,b=0|Ee(d,w,28),D=vi,k=0|Ee(d,w,34),D^=vi,v=0|Ee(d,w,39),D=0|Ig(0|F,0|G,k^b^v|0,D^vi|0),_=0|Ig(0|D,0|vi,(u|l)&d|u&l|0,(p|_)&w|p&_|0),fi[g>>2]=_,fi[g+4>>2]=vi,64==(0|y)){I=0;break}if(Y=0|fi[e+(B<<3)>>2],M=0|fi[e+(B<<3)+4>>2],N=0|Ee(Y,M,19),v=vi,m=0|Ee(Y,M,61),H=vi,M=0|Ue(0|Y,0|M,6),H=0|Ig(M^N^m|0,vi^v^H|0,0|fi[e+(E<<3)>>2],0|fi[e+(E<<3)+4>>2]),v=vi,m=0|fi[e+(t<<3)>>2],N=0|fi[e+(t<<3)+4>>2],M=0|Ee(m,N,1),Y=vi,F=0|Ee(m,N,8),S=vi,k=0|Ue(0|m,0|N,7),S^=vi^Y,Y=e+(y<<3)|0,Y=0|Ig(0|H,0|v,0|fi[Y>>2],0|fi[Y+4>>2]),S=0|Ig(0|Y,0|vi,k^M^F|0,0|S),F=vi,y=y+16|0,M=e+(y<<3)|0,fi[M>>2]=S,fi[M+4>>2]=F,M=0|fi[e+(f<<3)>>2],k=0|fi[e+(f<<3)+4>>2],Y=0|Ee(M,k,19),v=vi,H=0|Ee(M,k,61),G=vi,k=0|Ue(0|M,0|k,6),G=0|Ig(k^Y^H|0,vi^v^G|0,0|fi[e+(t+9<<3)>>2],0|fi[e+(t+9<<3)+4>>2]),v=vi,H=0|fi[e+(t+1<<3)>>2],Y=0|fi[e+(t+1<<3)+4>>2],k=0|Ee(H,Y,1),M=vi,U=0|Ee(H,Y,8),R=vi,b=0|Ue(0|H,0|Y,7),R^=vi^M,N=0|Ig(0|G,0|v,0|m,0|N),R=0|Ig(0|N,0|vi,b^k^U|0,0|R),U=vi,fi[e+(t+16<<3)>>2]=R,fi[e+(t+16<<3)+4>>2]=U,k=0|Ee(S,F,19),b=vi,N=0|Ee(S,F,61),m=vi,F=0|Ue(0|S,0|F,6),m=0|Ig(F^k^N|0,vi^b^m|0,0|fi[e+(h<<3)>>2],0|fi[e+(h<<3)+4>>2]),b=vi,N=0|fi[e+(a<<3)>>2],k=0|fi[e+(a<<3)+4>>2],F=0|Ee(N,k,1),S=vi,v=0|Ee(N,k,8),G=vi,M=0|Ue(0|N,0|k,7),G^=vi^S,Y=0|Ig(0|m,0|b,0|H,0|Y),G=0|Ig(0|Y,0|vi,M^F^v|0,0|G),v=vi,fi[e+(r+16<<3)>>2]=G,fi[e+(r+16<<3)+4>>2]=v,F=0|Ee(R,U,19),M=vi,Y=0|Ee(R,U,61),H=vi,U=0|Ue(0|R,0|U,6),H=0|Ig(U^F^Y|0,vi^M^H|0,0|fi[e+(a+9<<3)>>2],0|fi[e+(a+9<<3)+4>>2]),M=vi,Y=0|fi[e+(a+1<<3)>>2],F=0|fi[e+(a+1<<3)+4>>2],U=0|Ee(Y,F,1),R=vi,b=0|Ee(Y,F,8),m=vi,S=0|Ue(0|Y,0|F,7),m^=vi^R,k=0|Ig(0|H,0|M,0|N,0|k),m=0|Ig(0|k,0|vi,S^U^b|0,0|m),b=vi,fi[e+(a+16<<3)>>2]=m,fi[e+(a+16<<3)+4>>2]=b,U=0|Ee(G,v,19),S=vi,k=0|Ee(G,v,61),N=vi,v=0|Ue(0|G,0|v,6),N=0|Ig(v^U^k|0,vi^S^N|0,0|fi[e+(i<<3)>>2],0|fi[e+(i<<3)+4>>2]),S=vi,k=0|fi[e+(C<<3)>>2],U=0|fi[e+(C<<3)+4>>2],v=0|Ee(k,U,1),G=vi,M=0|Ee(k,U,8),H=vi,R=0|Ue(0|k,0|U,7),H^=vi^G,F=0|Ig(0|N,0|S,0|Y,0|F),H=0|Ig(0|F,0|vi,R^v^M|0,0|H),M=vi,fi[e+(n+16<<3)>>2]=H,fi[e+(n+16<<3)+4>>2]=M,v=0|Ee(m,b,19),R=vi,F=0|Ee(m,b,61),Y=vi,b=0|Ue(0|m,0|b,6),Y=0|Ig(b^v^F|0,vi^R^Y|0,0|fi[e+(C+9<<3)>>2],0|fi[e+(C+9<<3)+4>>2]),R=vi,F=0|fi[e+(C+1<<3)>>2],v=0|fi[e+(C+1<<3)+4>>2],b=0|Ee(F,v,1),m=vi,S=0|Ee(F,v,8),N=vi,G=0|Ue(0|F,0|v,7),N^=vi^m,U=0|Ig(0|Y,0|R,0|k,0|U),N=0|Ig(0|U,0|vi,G^b^S|0,0|N),S=vi,fi[e+(C+16<<3)>>2]=N,fi[e+(C+16<<3)+4>>2]=S,b=0|Ee(H,M,19),G=vi,U=0|Ee(H,M,61),k=vi,M=0|Ue(0|H,0|M,6),k=0|Ig(M^b^U|0,vi^G^k|0,0|fi[e+(f<<3)>>2],0|fi[e+(f<<3)+4>>2]),G=vi,U=0|fi[e+(c<<3)>>2],b=0|fi[e+(c<<3)+4>>2],M=0|Ee(U,b,1),H=vi,R=0|Ee(U,b,8),Y=vi,m=0|Ue(0|U,0|b,7),Y^=vi^H,v=0|Ig(0|k,0|G,0|F,0|v),Y=0|Ig(0|v,0|vi,m^M^R|0,0|Y),R=vi,fi[e+(o+16<<3)>>2]=Y,fi[e+(o+16<<3)+4>>2]=R,M=0|Ee(N,S,19),m=vi,v=0|Ee(N,S,61),F=vi,S=0|Ue(0|N,0|S,6),F=0|Ig(S^M^v|0,vi^m^F|0,0|fi[e+(c+9<<3)>>2],0|fi[e+(c+9<<3)+4>>2]),m=vi,v=0|fi[e+(c+1<<3)>>2],M=0|fi[e+(c+1<<3)+4>>2],S=0|Ee(v,M,1),N=vi,G=0|Ee(v,M,8),k=vi,H=0|Ue(0|v,0|M,7),k^=vi^N,b=0|Ig(0|F,0|m,0|U,0|b),k=0|Ig(0|b,0|vi,H^S^G|0,0|k),G=vi,fi[e+(c+16<<3)>>2]=k,fi[e+(c+16<<3)+4>>2]=G,S=0|Ee(Y,R,19),H=vi,b=0|Ee(Y,R,61),U=vi,R=0|Ue(0|Y,0|R,6),U=0|Ig(R^S^b|0,vi^H^U|0,0|fi[e+(Q+9<<3)>>2],0|fi[e+(Q+9<<3)+4>>2]),H=vi,b=0|fi[e+(E<<3)>>2],S=0|fi[e+(E<<3)+4>>2],R=0|Ee(b,S,1),Y=vi,m=0|Ee(b,S,8),F=vi,N=0|Ue(0|b,0|S,7),F^=vi^Y,M=0|Ig(0|U,0|H,0|v,0|M),F=0|Ig(0|M,0|vi,N^R^m|0,0|F),m=vi,fi[e+(Q+16<<3)>>2]=F,fi[e+(Q+16<<3)+4>>2]=m,R=0|Ee(k,G,19),N=vi,M=0|Ee(k,G,61),v=vi,G=0|Ue(0|k,0|G,6),v=0|Ig(G^R^M|0,vi^N^v|0,0|fi[e+(E+9<<3)>>2],0|fi[e+(E+9<<3)+4>>2]),N=vi,M=0|fi[e+(E+1<<3)>>2],R=0|fi[e+(E+1<<3)+4>>2],G=0|Ee(M,R,1),k=vi,H=0|Ee(M,R,8),U=vi,Y=0|Ue(0|M,0|R,7),U^=vi^k,S=0|Ig(0|v,0|N,0|b,0|S),U=0|Ig(0|S,0|vi,Y^G^H|0,0|U),H=vi,fi[e+(E+16<<3)>>2]=U,fi[e+(E+16<<3)+4>>2]=H,G=0|Ee(F,m,19),Y=vi,S=0|Ee(F,m,61),b=vi,m=0|Ue(0|F,0|m,6),b=0|Ig(m^G^S|0,vi^Y^b|0,0|fi[e+(s+9<<3)>>2],0|fi[e+(s+9<<3)+4>>2]),Y=vi,S=0|fi[e+(h<<3)>>2],G=0|fi[e+(h<<3)+4>>2],m=0|Ee(S,G,1),F=vi,N=0|Ee(S,G,8),v=vi,k=0|Ue(0|S,0|G,7),v^=vi^F,R=0|Ig(0|b,0|Y,0|M,0|R),v=0|Ig(0|R,0|vi,k^m^N|0,0|v),N=vi,fi[e+(s+16<<3)>>2]=v,fi[e+(s+16<<3)+4>>2]=N,m=0|Ee(U,H,19),k=vi,R=0|Ee(U,H,61),M=vi,H=0|Ue(0|U,0|H,6),M=0|Ig(H^m^R|0,vi^k^M|0,0|fi[e+(h+9<<3)>>2],0|fi[e+(h+9<<3)+4>>2]),k=vi,R=0|fi[e+(h+1<<3)>>2],m=0|fi[e+(h+1<<3)+4>>2],H=0|Ee(R,m,1),U=vi,Y=0|Ee(R,m,8),b=vi,F=0|Ue(0|R,0|m,7),b^=vi^U,G=0|Ig(0|M,0|k,0|S,0|G),b=0|Ig(0|G,0|vi,F^H^Y|0,0|b),Y=vi,fi[e+(h+16<<3)>>2]=b,fi[e+(h+16<<3)+4>>2]=Y,H=0|Ee(v,N,19),F=vi,G=0|Ee(v,N,61),S=vi,N=0|Ue(0|v,0|N,6),S=0|Ig(N^H^G|0,vi^F^S|0,0|fi[e+(I+9<<3)>>2],0|fi[e+(I+9<<3)+4>>2]),F=vi,G=0|fi[e+(i<<3)>>2],H=0|fi[e+(i<<3)+4>>2],N=0|Ee(G,H,1),v=vi,k=0|Ee(G,H,8),M=vi,U=0|Ue(0|G,0|H,7),M^=vi^v,m=0|Ig(0|S,0|F,0|R,0|m),M=0|Ig(0|m,0|vi,U^N^k|0,0|M),k=vi,fi[e+(I+16<<3)>>2]=M,fi[e+(I+16<<3)+4>>2]=k,N=0|Ee(b,Y,19),I=vi,U=0|Ee(b,Y,61),m=vi,Y=0|Ue(0|b,0|Y,6),m=0|Ig(Y^N^U|0,vi^I^m|0,0|fi[e+(i+9<<3)>>2],0|fi[e+(i+9<<3)+4>>2]),I=vi,U=0|fi[e+(i+1<<3)>>2],N=0|fi[e+(i+1<<3)+4>>2],Y=0|Ee(U,N,1),b=vi,R=0|Ee(U,N,8),F=vi,S=0|Ue(0|U,0|N,7),F^=vi^b,H=0|Ig(0|m,0|I,0|G,0|H),F=0|Ig(0|H,0|vi,S^Y^R|0,0|F),R=vi,fi[e+(i+16<<3)>>2]=F,fi[e+(i+16<<3)+4>>2]=R,Y=0|Ee(M,k,19),S=vi,H=0|Ee(M,k,61),G=vi,I=0|Ue(0|M,0|k,6),G=0|Ig(I^Y^H|0,vi^S^G|0,0|fi[e+(B+9<<3)>>2],0|fi[e+(B+9<<3)+4>>2]),S=vi,H=0|fi[e+(f<<3)>>2],Y=0|fi[e+(f<<3)+4>>2],I=0|Ee(H,Y,1),k=vi,M=0|Ee(H,Y,8),i=vi,m=0|Ue(0|H,0|Y,7),i^=vi^k,N=0|Ig(0|G,0|S,0|U,0|N),i=0|Ig(0|N,0|vi,m^I^M|0,0|i),fi[e+(B+16<<3)>>2]=i,fi[e+(B+16<<3)+4>>2]=vi,i=0|Ee(F,R,19),M=vi,I=0|Ee(F,R,61),m=vi,R=0|Ue(0|F,0|R,6),m=0|Ig(R^i^I|0,vi^M^m|0,0|fi[e+(f+9<<3)>>2],0|fi[e+(f+9<<3)+4>>2]),M=vi,I=0|fi[e+(f+1<<3)>>2],i=0|fi[e+(f+1<<3)+4>>2],R=0|Ee(I,i,1),F=vi,N=0|Ee(I,i,8),U=vi,S=0|Ue(0|I,0|i,7),U^=vi^F,Y=0|Ig(0|m,0|M,0|H,0|Y),U=0|Ig(0|Y,0|vi,S^R^N|0,0|U),fi[e+(f+16<<3)>>2]=U,fi[e+(f+16<<3)+4>>2]=vi,(0|y)>=80){I=0;break}}do{N=g+(I<<3)|0,N=0|Ig(0|fi[(U=A+(I<<3)|0)>>2],0|fi[U+4>>2],0|fi[N>>2],0|fi[N+4>>2]),fi[U>>2]=N,fi[U+4>>2]=vi,I=I+1|0}while(8!=(0|I))}function t(A){A|=0;var I=0,e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0;w=wi,Q=wi=wi+63&-64,wi=wi+16|0;do{if(A>>>0<245){if(c=A>>>0<11?16:A+11&-8,(C=0|fi[8682])>>>(c>>>3)&3|0)return A=34768+((C>>>(c>>>3)&1^1)+(c>>>3)<<1<<2)|0,I=0|fi[A+8>>2],e=0|fi[I+8>>2],(0|A)==(0|e)?fi[8682]=C&~(1<<(C>>>(c>>>3)&1^1)+(c>>>3)):(fi[e+12>>2]=A,fi[A+8>>2]=e),p=(C>>>(c>>>3)&1^1)+(c>>>3)<<3,fi[I+4>>2]=3|p,fi[I+p+4>>2]=1|fi[I+p+4>>2],p=I+8|0,wi=w,0|p;if(o=0|fi[8684],c>>>0>o>>>0){if(C>>>(c>>>3)|0)return A=C>>>(c>>>3)<<(c>>>3)&(2<<(c>>>3)|0-(2<<(c>>>3))),i=((A&0-A)-1|0)>>>(((A&0-A)-1|0)>>>12&16),g=i>>>(i>>>5&8)>>>(i>>>(i>>>5&8)>>>2&4),g=(i>>>5&8|((A&0-A)-1|0)>>>12&16|i>>>(i>>>5&8)>>>2&4|g>>>1&2|g>>>(g>>>1&2)>>>1&1)+(g>>>(g>>>1&2)>>>(g>>>(g>>>1&2)>>>1&1))|0,i=0|fi[34768+(g<<1<<2)+8>>2],A=0|fi[i+8>>2],(34768+(g<<1<<2)|0)==(0|A)?(fi[8682]=C&~(1<<g),A=C&~(1<<g)):(fi[A+12>>2]=34768+(g<<1<<2),fi[34768+(g<<1<<2)+8>>2]=A,A=C),fi[i+4>>2]=3|c,fi[i+c+4>>2]=(g<<3)-c|1,fi[i+c+((g<<3)-c)>>2]=(g<<3)-c,0|o&&(e=0|fi[8687],A&1<<(o>>>3)?(A=0|fi[34768+(o>>>3<<1<<2)+8>>2],I=34768+(o>>>3<<1<<2)+8|0):(fi[8682]=A|1<<(o>>>3),A=34768+(o>>>3<<1<<2)|0,I=34768+(o>>>3<<1<<2)+8|0),fi[I>>2]=e,fi[A+12>>2]=e,fi[e+8>>2]=A,fi[e+12>>2]=34768+(o>>>3<<1<<2)),fi[8684]=(g<<3)-c,fi[8687]=i+c,p=i+8|0,wi=w,0|p;if(n=0|fi[8683]){if(I=((n&0-n)-1|0)>>>(((n&0-n)-1|0)>>>12&16),A=I>>>(I>>>5&8)>>>(I>>>(I>>>5&8)>>>2&4),A=0|fi[35032+((I>>>5&8|((n&0-n)-1|0)>>>12&16|I>>>(I>>>5&8)>>>2&4|A>>>1&2|A>>>(A>>>1&2)>>>1&1)+(A>>>(A>>>1&2)>>>(A>>>(A>>>1&2)>>>1&1))<<2)>>2],I=(-8&fi[A+4>>2])-c|0,e=0|fi[A+16+((0==(0|fi[A+16>>2])&1)<<2)>>2]){do{I=(a=(r=(-8&fi[e+4>>2])-c|0)>>>0<I>>>0)?r:I,A=a?e:A,e=0|fi[e+16+((0==(0|fi[e+16>>2])&1)<<2)>>2]}while(0!=(0|e));a=A,t=I}else a=A,t=I;if(r=a+c|0,a>>>0<r>>>0){i=0|fi[a+24>>2],A=0|fi[a+12>>2];do{if((0|A)==(0|a)){if(I=a+20|0,!((A=0|fi[I>>2])||(I=a+16|0,A=0|fi[I>>2]))){I=0;break}for(;;)if(e=A+20|0,0|(g=0|fi[e>>2]))A=g,I=e;else{if(e=A+16|0,!(g=0|fi[e>>2]))break;A=g,I=e}fi[I>>2]=0,I=A}else I=0|fi[a+8>>2],fi[I+12>>2]=A,fi[A+8>>2]=I,I=A}while(0);do{if(0|i){if(A=0|fi[a+28>>2],(0|a)==(0|fi[35032+(A<<2)>>2])){if(fi[35032+(A<<2)>>2]=I,!I){fi[8683]=n&~(1<<A);break}}else if(fi[i+16+(((0|fi[i+16>>2])!=(0|a)&1)<<2)>>2]=I,!I)break;fi[I+24>>2]=i,0|(A=0|fi[a+16>>2])&&(fi[I+16>>2]=A,fi[A+24>>2]=I),0|(A=0|fi[a+20>>2])&&(fi[I+20>>2]=A,fi[A+24>>2]=I)}}while(0);return t>>>0<16?(p=t+c|0,fi[a+4>>2]=3|p,fi[(p=a+p+4|0)>>2]=1|fi[p>>2]):(fi[a+4>>2]=3|c,fi[r+4>>2]=1|t,fi[r+t>>2]=t,0|o&&(e=0|fi[8687],C&1<<(o>>>3)?(A=0|fi[34768+(o>>>3<<1<<2)+8>>2],I=34768+(o>>>3<<1<<2)+8|0):(fi[8682]=C|1<<(o>>>3),A=34768+(o>>>3<<1<<2)|0,I=34768+(o>>>3<<1<<2)+8|0),fi[I>>2]=e,fi[A+12>>2]=e,fi[e+8>>2]=A,fi[e+12>>2]=34768+(o>>>3<<1<<2)),fi[8684]=t,fi[8687]=r),p=a+8|0,wi=w,0|p}}}}else if(A>>>0<=4294967231){if(c=A+11&-8,a=0|fi[8683]){r=(A+11|0)>>>8?c>>>0>16777215?31:c>>>(7+(r=14-((520192+(r=(A+11|0)>>>8<<((1048320+((A+11|0)>>>8)|0)>>>16&8))|0)>>>16&4|(1048320+((A+11|0)>>>8)|0)>>>16&8|(245760+(r<<((r+520192|0)>>>16&4))|0)>>>16&2)+(r<<((r+520192|0)>>>16&4)<<((245760+(r<<((r+520192|0)>>>16&4))|0)>>>16&2)>>>15)|0)|0)&1|r<<1:0,I=0|fi[35032+(r<<2)>>2];A:do{if(I)for(A=0,e=0-c|0,t=c<<(31==(0|r)?0:25-(r>>>1)|0),i=0;;){if((g=(-8&fi[I+4>>2])-c|0)>>>0<e>>>0){if(!g){A=I,e=0,g=I,_=61;break A}A=I,e=g}if(g=0|fi[I+20>>2],I=0|fi[I+16+(t>>>31<<2)>>2],i=0==(0|g)|(0|g)==(0|I)?i:g,g=0==(0|I)){I=i,_=57;break}t<<=1&(1^g)}else I=0,A=0,e=0-c|0,_=57}while(0);if(57==(0|_)){if(0==(0|I)&0==(0|A)){if(A=2<<r,!(a&(A|0-A)))break;C=(a&(A|0-A)&0-(a&(A|0-A)))-1|0,A=0,I=0|fi[35032+((C>>>(C>>>12&16)>>>5&8|C>>>12&16|(o=C>>>(C>>>12&16)>>>(C>>>(C>>>12&16)>>>5&8))>>>2&4|o>>>(o>>>2&4)>>>1&2|(I=o>>>(o>>>2&4)>>>(o>>>(o>>>2&4)>>>1&2))>>>1&1)+(I>>>(I>>>1&1))<<2)>>2]}I?(g=I,_=61):(r=A,t=e)}if(61==(0|_))for(;;){if(_=0,I=(-8&fi[g+4>>2])-c|0,o=I>>>0<e>>>0,I=o?I:e,A=o?g:A,!(g=0|fi[g+16+((0==(0|fi[g+16>>2])&1)<<2)>>2])){r=A,t=I;break}e=I,_=61}if(0!=(0|r)?t>>>0<((0|fi[8684])-c|0)>>>0:0){if(B=r+c|0,r>>>0>=B>>>0)return p=0,wi=w,0|p;i=0|fi[r+24>>2],A=0|fi[r+12>>2];do{if((0|A)==(0|r)){if(I=r+20|0,!((A=0|fi[I>>2])||(I=r+16|0,A=0|fi[I>>2]))){A=0;break}for(;;)if(e=A+20|0,0|(g=0|fi[e>>2]))A=g,I=e;else{if(e=A+16|0,!(g=0|fi[e>>2]))break;A=g,I=e}fi[I>>2]=0}else p=0|fi[r+8>>2],fi[p+12>>2]=A,fi[A+8>>2]=p}while(0);do{if(i){if(I=0|fi[r+28>>2],(0|r)==(0|fi[35032+(I<<2)>>2])){if(fi[35032+(I<<2)>>2]=A,!A){fi[8683]=a&~(1<<I),g=a&~(1<<I);break}}else if(fi[i+16+(((0|fi[i+16>>2])!=(0|r)&1)<<2)>>2]=A,!A){g=a;break}fi[A+24>>2]=i,0|(I=0|fi[r+16>>2])&&(fi[A+16>>2]=I,fi[I+24>>2]=A),(I=0|fi[r+20>>2])?(fi[A+20>>2]=I,fi[I+24>>2]=A,g=a):g=a}else g=a}while(0);do{if(t>>>0>=16){if(fi[r+4>>2]=3|c,fi[B+4>>2]=1|t,fi[B+t>>2]=t,e=t>>>3,t>>>0<256){(A=0|fi[8682])&1<<e?(A=0|fi[34768+(e<<1<<2)+8>>2],I=34768+(e<<1<<2)+8|0):(fi[8682]=A|1<<e,A=34768+(e<<1<<2)|0,I=34768+(e<<1<<2)+8|0),fi[I>>2]=B,fi[A+12>>2]=B,fi[B+8>>2]=A,fi[B+12>>2]=34768+(e<<1<<2);break}if(A=t>>>8,A=A?t>>>0>16777215?31:t>>>(7+(A=14-((520192+(A<<((A+1048320|0)>>>16&8))|0)>>>16&4|(A+1048320|0)>>>16&8|(245760+(p=A<<((A+1048320|0)>>>16&8)<<((520192+(A<<((A+1048320|0)>>>16&8))|0)>>>16&4))|0)>>>16&2)+(p<<((p+245760|0)>>>16&2)>>>15)|0)|0)&1|A<<1:0,e=35032+(A<<2)|0,fi[B+28>>2]=A,fi[B+16+4>>2]=0,fi[B+16>>2]=0,I=1<<A,!(g&I)){fi[8683]=g|I,fi[e>>2]=B,fi[B+24>>2]=e,fi[B+12>>2]=B,fi[B+8>>2]=B;break}for(I=t<<(31==(0|A)?0:25-(A>>>1)|0),e=0|fi[e>>2];;){if((-8&fi[e+4>>2]|0)==(0|t)){_=97;break}if(g=e+16+(I>>>31<<2)|0,!(A=0|fi[g>>2])){_=96;break}I<<=1,e=A}if(96==(0|_)){fi[g>>2]=B,fi[B+24>>2]=e,fi[B+12>>2]=B,fi[B+8>>2]=B;break}if(97==(0|_)){p=0|fi[(_=e+8|0)>>2],fi[p+12>>2]=B,fi[_>>2]=B,fi[B+8>>2]=p,fi[B+12>>2]=e,fi[B+24>>2]=0;break}}else p=t+c|0,fi[r+4>>2]=3|p,fi[(p=r+p+4|0)>>2]=1|fi[p>>2]}while(0);return p=r+8|0,wi=w,0|p}}}else c=-1}while(0);if((e=0|fi[8684])>>>0>=c>>>0)return A=e-c|0,I=0|fi[8687],A>>>0>15?(p=I+c|0,fi[8687]=p,fi[8684]=A,fi[p+4>>2]=1|A,fi[p+A>>2]=A,fi[I+4>>2]=3|c):(fi[8684]=0,fi[8687]=0,fi[I+4>>2]=3|e,fi[I+e+4>>2]=1|fi[I+e+4>>2]),p=I+8|0,wi=w,0|p;if((i=0|fi[8685])>>>0>c>>>0)return f=i-c|0,fi[8685]=f,p=0|fi[8688],_=p+c|0,fi[8688]=_,fi[_+4>>2]=1|f,fi[p+4>>2]=3|c,p=p+8|0,wi=w,0|p;if(0|fi[8800]?A=0|fi[8802]:(fi[8802]=4096,fi[8801]=4096,fi[8803]=-1,fi[8804]=-1,fi[8805]=0,fi[8793]=0,fi[Q>>2]=-16&Q^1431655768,fi[8800]=-16&Q^1431655768,A=4096),t=c+48|0,r=c+47|0,n=A+r|0,a=0-A|0,(n&a)>>>0<=c>>>0)return p=0,wi=w,0|p;if(0|(A=0|fi[8792])?((Q=0|fi[8790])+(n&a)|0)>>>0<=Q>>>0?1:(Q+(n&a)|0)>>>0>A>>>0:0)return p=0,wi=w,0|p;A:do{if(4&fi[8793])A=0,_=133;else{e=0|fi[8688];I:do{if(e){for(I=35176;!((A=0|fi[I>>2])>>>0<=e>>>0?(E=I+4|0,(A+(0|fi[E>>2])|0)>>>0>e>>>0):0);){if(!(A=0|fi[I+8>>2])){_=118;break I}I=A}if((n-i&a)>>>0<2147483647)if((0|(A=0|pI(n-i&a|0)))==((0|fi[I>>2])+(0|fi[E>>2])|0)){if(-1!=(0|A)){t=n-i&a,B=A,_=135;break A}A=n-i&a}else g=A,e=n-i&a,_=126;else A=0}else _=118}while(0);do{if(118==(0|_))if(-1!=(0|(I=0|pI(0)))?(h=0|fi[8801],h=(0==(h+-1&I|0)?0:(h+-1+I&0-h)-I|0)+(n&a)|0,s=0|fi[8790],h>>>0>c>>>0&h>>>0<2147483647):0){if(0|(E=0|fi[8792])?(h+s|0)>>>0<=s>>>0|(h+s|0)>>>0>E>>>0:0){A=0;break}if((0|(A=0|pI(0|h)))==(0|I)){t=h,B=I,_=135;break A}g=A,e=h,_=126}else A=0}while(0);do{if(126==(0|_)){if(I=0-e|0,!(t>>>0>e>>>0&e>>>0<2147483647&-1!=(0|g))){if(-1==(0|g)){A=0;break}t=e,B=g,_=135;break A}if(A=0|fi[8802],(A=r-e+A&0-A)>>>0>=2147483647){t=e,B=g,_=135;break A}if(-1==(0|pI(0|A))){pI(0|I),A=0;break}t=A+e|0,B=g,_=135;break A}}while(0);fi[8793]=4|fi[8793],_=133}}while(0);if(!(133==(0|_)?(n&a)>>>0<2147483647:0)||(B=0|pI(n&a|0),y=0|pI(0),f=(y-B|0)>>>0>(c+40|0)>>>0,-1==(0|B)|1^f|B>>>0<y>>>0&-1!=(0|B)&-1!=(0|y)^1)||(t=f?y-B|0:A,_=135),135==(0|_)){A=(0|fi[8790])+t|0,fi[8790]=A,A>>>0>(0|fi[8791])>>>0&&(fi[8791]=A),a=0|fi[8688];do{if(a){for(A=35176;;){if(I=0|fi[A>>2],e=A+4|0,g=0|fi[e>>2],(0|B)==(I+g|0)){_=145;break}if(!(i=0|fi[A+8>>2]))break;A=i}if((145==(0|_)?0==(8&fi[A+12>>2]|0):0)?a>>>0<B>>>0&a>>>0>=I>>>0:0){fi[e>>2]=g+t,_=0==(a+8&7|0)?0:0-(a+8)&7,p=(0|fi[8685])+(t-_)|0,fi[8688]=a+_,fi[8685]=p,fi[a+_+4>>2]=1|p,fi[a+_+p+4>>2]=40,fi[8689]=fi[8804];break}for(B>>>0<(0|fi[8686])>>>0&&(fi[8686]=B),e=B+t|0,A=35176;;){if((0|fi[A>>2])==(0|e)){_=153;break}if(!(I=0|fi[A+8>>2]))break;A=I}if(153==(0|_)?0==(8&fi[A+12>>2]|0):0){fi[A>>2]=B,fi[(C=A+4|0)>>2]=(0|fi[C>>2])+t,n=(C=B+(0==(7&(C=B+8|0)|0)?0:0-C&7)|0)+c|0,r=(A=e+(0==(e+8&7|0)?0:0-(e+8)&7)|0)-C-c|0,fi[C+4>>2]=3|c;do{if((0|A)!=(0|a)){if((0|A)==(0|fi[8687])){p=(0|fi[8684])+r|0,fi[8684]=p,fi[8687]=n,fi[n+4>>2]=1|p,fi[n+p>>2]=p;break}if(1==(3&(t=0|fi[A+4>>2])|0)){A:do{if(t>>>0<256){if(I=0|fi[A+8>>2],(0|(e=0|fi[A+12>>2]))==(0|I)){fi[8682]=fi[8682]&~(1<<(t>>>3));break}fi[I+12>>2]=e,fi[e+8>>2]=I;break}B=0|fi[A+24>>2],I=0|fi[A+12>>2];do{if((0|I)==(0|A)){if(I=0|fi[A+16+4>>2])i=A+16+4|0;else{if(!(I=0|fi[A+16>>2])){I=0;break}i=A+16|0}for(;;)if(e=I+20|0,0|(g=0|fi[e>>2]))I=g,i=e;else{if(e=I+16|0,!(g=0|fi[e>>2]))break;I=g,i=e}fi[i>>2]=0}else p=0|fi[A+8>>2],fi[p+12>>2]=I,fi[I+8>>2]=p}while(0);if(!B)break;e=0|fi[A+28>>2];do{if((0|A)==(0|fi[35032+(e<<2)>>2])){if(fi[35032+(e<<2)>>2]=I,0|I)break;fi[8683]=fi[8683]&~(1<<e);break A}if(fi[B+16+(((0|fi[B+16>>2])!=(0|A)&1)<<2)>>2]=I,!I)break A}while(0);if(fi[I+24>>2]=B,0|(e=0|fi[A+16>>2])&&(fi[I+16>>2]=e,fi[e+24>>2]=I),!(e=0|fi[A+16+4>>2]))break;fi[I+20>>2]=e,fi[e+24>>2]=I}while(0);A=A+(-8&t)|0,i=(-8&t)+r|0}else i=r;if(e=A+4|0,fi[e>>2]=-2&fi[e>>2],fi[n+4>>2]=1|i,fi[n+i>>2]=i,e=i>>>3,i>>>0<256){(A=0|fi[8682])&1<<e?(A=0|fi[34768+(e<<1<<2)+8>>2],I=34768+(e<<1<<2)+8|0):(fi[8682]=A|1<<e,A=34768+(e<<1<<2)|0,I=34768+(e<<1<<2)+8|0),fi[I>>2]=n,fi[A+12>>2]=n,fi[n+8>>2]=A,fi[n+12>>2]=34768+(e<<1<<2);break}A=i>>>8;do{if(A){if(i>>>0>16777215){A=31;break}A=i>>>(7+(A=14-((520192+(A<<((A+1048320|0)>>>16&8))|0)>>>16&4|(A+1048320|0)>>>16&8|(245760+(p=A<<((A+1048320|0)>>>16&8)<<((520192+(A<<((A+1048320|0)>>>16&8))|0)>>>16&4))|0)>>>16&2)+(p<<((p+245760|0)>>>16&2)>>>15)|0)|0)&1|A<<1}else A=0}while(0);if(g=35032+(A<<2)|0,fi[n+28>>2]=A,fi[n+16+4>>2]=0,fi[n+16>>2]=0,I=0|fi[8683],e=1<<A,!(I&e)){fi[8683]=I|e,fi[g>>2]=n,fi[n+24>>2]=g,fi[n+12>>2]=n,fi[n+8>>2]=n;break}for(I=i<<(31==(0|A)?0:25-(A>>>1)|0),e=0|fi[g>>2];;){if((-8&fi[e+4>>2]|0)==(0|i)){_=194;break}if(g=e+16+(I>>>31<<2)|0,!(A=0|fi[g>>2])){_=193;break}I<<=1,e=A}if(193==(0|_)){fi[g>>2]=n,fi[n+24>>2]=e,fi[n+12>>2]=n,fi[n+8>>2]=n;break}if(194==(0|_)){p=0|fi[(_=e+8|0)>>2],fi[p+12>>2]=n,fi[_>>2]=n,fi[n+8>>2]=p,fi[n+12>>2]=e,fi[n+24>>2]=0;break}}else p=(0|fi[8685])+r|0,fi[8685]=p,fi[8688]=n,fi[n+4>>2]=1|p}while(0);return p=C+8|0,wi=w,0|p}for(A=35176;!((I=0|fi[A>>2])>>>0<=a>>>0?(p=I+(0|fi[A+4>>2])|0)>>>0>a>>>0:0);)A=0|fi[A+8>>2];i=(i=p+-47+(0==(p+-47+8&7|0)?0:0-(p+-47+8)&7)|0)>>>0<(a+16|0)>>>0?a:i,_=B+(A=0==(7&(A=B+8|0)|0)?0:0-A&7)|0,A=t+-40-A|0,fi[8688]=_,fi[8685]=A,fi[_+4>>2]=1|A,fi[_+A+4>>2]=40,fi[8689]=fi[8804],fi[i+4>>2]=27,fi[i+8>>2]=fi[8794],fi[i+8+4>>2]=fi[8795],fi[i+8+8>>2]=fi[8796],fi[i+8+12>>2]=fi[8797],fi[8794]=B,fi[8795]=t,fi[8797]=0,fi[8796]=i+8,A=i+24|0;do{_=A,fi[(A=A+4|0)>>2]=7}while((_+8|0)>>>0<p>>>0);if((0|i)!=(0|a)){if(fi[i+4>>2]=-2&fi[i+4>>2],fi[a+4>>2]=i-a|1,fi[i>>2]=i-a,(i-a|0)>>>0<256){e=34768+((i-a|0)>>>3<<1<<2)|0,(A=0|fi[8682])&1<<((i-a|0)>>>3)?(A=0|fi[e+8>>2],I=e+8|0):(fi[8682]=A|1<<((i-a|0)>>>3),A=e,I=e+8|0),fi[I>>2]=a,fi[A+12>>2]=a,fi[a+8>>2]=A,fi[a+12>>2]=e;break}if(A=(i-a|0)>>>8?(i-a|0)>>>0>16777215?31:(i-a|0)>>>(7+(A=14-((520192+(A=(i-a|0)>>>8<<((1048320+((i-a|0)>>>8)|0)>>>16&8))|0)>>>16&4|(1048320+((i-a|0)>>>8)|0)>>>16&8|(245760+(A<<((A+520192|0)>>>16&4))|0)>>>16&2)+(A<<((A+520192|0)>>>16&4)<<((245760+(A<<((A+520192|0)>>>16&4))|0)>>>16&2)>>>15)|0)|0)&1|A<<1:0,g=35032+(A<<2)|0,fi[a+28>>2]=A,fi[a+20>>2]=0,fi[a+16>>2]=0,I=0|fi[8683],e=1<<A,!(I&e)){fi[8683]=I|e,fi[g>>2]=a,fi[a+24>>2]=g,fi[a+12>>2]=a,fi[a+8>>2]=a;break}for(I=i-a<<(31==(0|A)?0:25-(A>>>1)|0),e=0|fi[g>>2];;){if((-8&fi[e+4>>2]|0)==(i-a|0)){_=216;break}if(g=e+16+(I>>>31<<2)|0,!(A=0|fi[g>>2])){_=215;break}I<<=1,e=A}if(215==(0|_)){fi[g>>2]=a,fi[a+24>>2]=e,fi[a+12>>2]=a,fi[a+8>>2]=a;break}if(216==(0|_)){p=0|fi[(_=e+8|0)>>2],fi[p+12>>2]=a,fi[_>>2]=a,fi[a+8>>2]=p,fi[a+12>>2]=e,fi[a+24>>2]=0;break}}}else{0==(0|(p=0|fi[8686]))|B>>>0<p>>>0&&(fi[8686]=B),fi[8794]=B,fi[8795]=t,fi[8797]=0,fi[8691]=fi[8800],fi[8690]=-1,A=0;do{fi[12+(p=34768+(A<<1<<2)|0)>>2]=p,fi[p+8>>2]=p,A=A+1|0}while(32!=(0|A));_=B+(p=0==(7&(p=B+8|0)|0)?0:0-p&7)|0,p=t+-40-p|0,fi[8688]=_,fi[8685]=p,fi[_+4>>2]=1|p,fi[_+p+4>>2]=40,fi[8689]=fi[8804]}}while(0);if((A=0|fi[8685])>>>0>c>>>0)return f=A-c|0,fi[8685]=f,p=0|fi[8688],_=p+c|0,fi[8688]=_,fi[_+4>>2]=1|f,fi[p+4>>2]=3|c,p=p+8|0,wi=w,0|p}return fi[8202]=12,p=0,wi=w,0|p}function r(A){var I=0,e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0,P=0,L=0,x=0,X=0,K=0,T=0,V=0,q=0,j=0,Z=0,W=0,z=0,O=0,$=0,AA=0,IA=0,eA=0,gA=0,iA=0,BA=0,tA=0,rA=0,aA=0,nA=0,CA=0,oA=0,cA=0,QA=0,EA=0,sA=0;L=0|fe(0|yi[(A|=0)>>0],0|yi[A+1>>0],0|yi[A+2>>0]),e=0|Ue(0|(e=0|HI(A+2|0)),0|vi,5),x=0|Ue(0|(x=0|fe(0|yi[A+5>>0],0|yi[A+6>>0],0|yi[A+7>>0])),0|vi,2),T=0|Ue(0|(T=0|HI(A+7|0)),0|vi,7),w=0|Ue(0|(w=0|HI(A+10|0)),0|vi,4),q=0|Ue(0|(q=0|fe(0|yi[A+13>>0],0|yi[A+14>>0],0|yi[A+15>>0])),0|vi,1),P=0|Ue(0|(P=0|HI(A+15|0)),0|vi,6),gA=0|Ue(0|(gA=0|fe(0|yi[A+18>>0],0|yi[A+19>>0],0|yi[A+20>>0])),0|vi,3),CA=0|fe(0|yi[A+21>>0],0|yi[A+22>>0],0|yi[A+23>>0]),AA=0|Ue(0|(AA=0|HI(A+23|0)),0|vi,5),nA=0|Ue(0|(nA=0|fe(0|yi[A+26>>0],0|yi[A+27>>0],0|yi[A+28>>0])),0|vi,2),f=0|Ue(0|(f=0|HI(A+28|0)),0|vi,7),EA=0|Ue(0|(EA=0|HI(A+31|0)),0|vi,4),_=0|Ue(0|(_=0|fe(0|yi[A+34>>0],0|yi[A+35>>0],0|yi[A+36>>0])),0|vi,1),d=0|Ue(0|(d=0|HI(A+36|0)),0|vi,6),Q=0|Ue(0|(Q=0|fe(0|yi[A+39>>0],0|yi[A+40>>0],0|yi[A+41>>0])),0|vi,3),Z=0|fe(0|yi[A+42>>0],0|yi[A+43>>0],0|yi[A+44>>0]),U=0|Ue(0|(U=0|HI(A+44|0)),0|vi,5),z=0|Ue(0|(z=0|fe(0|yi[A+47>>0],0|yi[A+48>>0],0|yi[A+49>>0])),0|vi,2),sA=0|Ue(0|(sA=0|HI(A+49|0)),0|vi,7),p=0|Ue(0|(p=0|HI(A+52|0)),0|vi,4),y=0|Ue(0|(y=0|fe(0|yi[A+55>>0],0|yi[A+56>>0],0|yi[A+57>>0])),0|vi,1),B=0|Ue(0|(B=0|HI(A+57|0)),0|vi,6),t=0|he(0|(m=0|Ue(0|(m=0|HI(A+60|0)),0|vi,3)),0|(I=vi),666643,0),g=vi,BA=0|he(0|m,0|I,470296,0),n=vi,J=0|he(0|m,0|I,654183,0),C=vi,G=0|he(0|m,0|I,-997805,-1),Y=vi,Q=0|Ig(0|(a=0|he(0|m,0|I,136657,0)),0|vi,2097151&Q|0,0),a=vi,Z=0|Ig(0|(I=0|he(0|m,0|I,-683901,-1)),0|vi,2097151&Z|0,0),I=vi,m=0|he(2097151&B|0,0,666643,0),v=vi,h=0|he(2097151&B|0,0,470296,0),b=vi,i=0|he(2097151&B|0,0,654183,0),c=vi,D=0|he(2097151&B|0,0,-997805,-1),M=vi,j=0|he(2097151&B|0,0,136657,0),F=vi,B=0|Ig(0|Q,0|a,0|(B=0|he(2097151&B|0,0,-683901,-1)),0|vi),a=vi,Q=0|he(2097151&y|0,0,666643,0),o=vi,H=0|he(2097151&y|0,0,470296,0),l=vi,u=0|he(2097151&y|0,0,654183,0),K=vi,oA=0|he(2097151&y|0,0,-997805,-1),iA=vi,E=0|he(2097151&y|0,0,136657,0),W=vi,F=0|Ig(0|(Y=0|Ig(0|(d=0|Ig(0|(y=0|he(2097151&y|0,0,-683901,-1)),0|vi,2097151&d|0,0)),0|vi,0|G,0|Y)),0|vi,0|j,0|F),j=vi,Y=0|he(2097151&p|0,0,666643,0),G=vi,d=0|he(2097151&p|0,0,470296,0),y=vi,tA=0|he(2097151&p|0,0,654183,0),r=vi,N=0|he(2097151&p|0,0,-997805,-1),s=vi,QA=0|he(2097151&p|0,0,136657,0),cA=vi,p=0|he(2097151&p|0,0,-683901,-1),V=vi,k=0|he(2097151&sA|0,0,666643,0),X=vi,IA=0|he(2097151&sA|0,0,470296,0),eA=vi,$=0|he(2097151&sA|0,0,654183,0),O=vi,aA=0|he(2097151&sA|0,0,-997805,-1),rA=vi,S=0|he(2097151&sA|0,0,136657,0),R=vi,c=0|Ig(0|(n=0|Ig(0|(iA=0|Ig(0|(cA=0|Ig(0|(EA=0|Ig(0|(sA=0|he(2097151&sA|0,0,-683901,-1)),0|vi,2097151&EA|0,0)),0|vi,0|QA,0|cA)),0|vi,0|oA,0|iA)),0|vi,0|BA,0|n)),0|vi,0|i,0|c),i=vi,P=0|Ig(0|(n=0|he(2097151&z|0,0,666643,0)),0|vi,2097151&P|0,0),n=vi,BA=0|he(2097151&z|0,0,470296,0),iA=vi,G=0|Ig(0|(eA=0|Ig(0|(CA=0|Ig(0|(oA=0|he(2097151&z|0,0,654183,0)),0|vi,2097151&CA|0,0)),0|vi,0|IA,0|eA)),0|vi,0|Y,0|G),Y=vi,eA=0|he(2097151&z|0,0,-997805,-1),IA=vi,v=0|Ig(0|(l=0|Ig(0|(r=0|Ig(0|(rA=0|Ig(0|(nA=0|Ig(0|(CA=0|he(2097151&z|0,0,136657,0)),0|vi,2097151&nA|0,0)),0|vi,0|aA,0|rA)),0|vi,0|tA,0|r)),0|vi,0|H,0|l)),0|vi,0|m,0|v),m=vi,z=0|he(2097151&z|0,0,-683901,-1),l=vi,H=0|Ue(0|(H=0|Ig(0|P,0|n,1048576,0)),0|vi,21),r=vi,X=0|Ig(0|(X=0|Ig(0|(gA=0|Ig(0|BA,0|iA,2097151&gA|0,0)),0|vi,0|k,0|X)),0|vi,0|H,0|r),k=vi,r=0|Ag(0|P,0|n,0|(r=0|Se(0|H,0|r,21)),0|vi),n=vi,P=0|Ue(0|(P=0|Ig(0|G,0|Y,1048576,0)),0|vi,21),H=vi,o=0|Ig(0|(o=0|Ig(0|(y=0|Ig(0|(O=0|Ig(0|(AA=0|Ig(0|eA,0|IA,2097151&AA|0,0)),0|vi,0|$,0|O)),0|vi,0|d,0|y)),0|vi,0|Q,0|o)),0|vi,0|P,0|H),Q=vi,H=0|Se(0|P,0|H,21),P=vi,y=0|be(0|(y=0|Ig(0|v,0|m,1048576,0)),0|vi,21),d=vi,b=0|Ig(0|(b=0|Ig(0|(g=0|Ig(0|(K=0|Ig(0|(s=0|Ig(0|(R=0|Ig(0|(f=0|Ig(0|z,0|l,2097151&f|0,0)),0|vi,0|S,0|R)),0|vi,0|N,0|s)),0|vi,0|u,0|K)),0|vi,0|t,0|g)),0|vi,0|h,0|b)),0|vi,0|y,0|d),h=vi,d=0|Se(0|y,0|d,21),y=vi,g=0|be(0|(g=0|Ig(0|c,0|i,1048576,0)),0|vi,21),t=vi,M=0|Ig(0|(M=0|Ig(0|(C=0|Ig(0|(W=0|Ig(0|(_=0|Ig(0|p,0|V,2097151&_|0,0)),0|vi,0|E,0|W)),0|vi,0|J,0|C)),0|vi,0|D,0|M)),0|vi,0|g,0|t),D=vi,t=0|Ag(0|c,0|i,0|(t=0|Se(0|g,0|t,21)),0|vi),i=vi,a=0|Ig(0|B,0|a,0|(c=0|be(0|(c=0|Ig(0|F,0|j,1048576,0)),0|vi,21)),0|(g=vi)),B=vi,g=0|Ag(0|F,0|j,0|(g=0|Se(0|c,0|g,21)),0|vi),j=vi,U=0|Ig(0|(F=0|be(0|(F=0|Ig(0|Z,0|I,1048576,0)),0|vi,21)),0|(c=vi),2097151&U|0,0),C=vi,c=0|Ag(0|Z,0|I,0|(c=0|Se(0|F,0|c,21)),0|vi),I=vi,J=0|Ag(0|X,0|k,0|(J=0|Se(0|(Z=0|Ue(0|(Z=0|Ig(0|X,0|k,1048576,0)),0|vi,21)),0|(F=vi),21)),0|vi),k=vi,E=0|Se(0|(X=0|be(0|(X=0|Ig(0|o,0|Q,1048576,0)),0|vi,21)),0|(W=vi),21),_=vi,i=0|Ig(0|(V=0|be(0|(V=0|Ig(0|b,0|h,1048576,0)),0|vi,21)),0|(p=vi),0|t,0|i),t=vi,p=0|Ag(0|b,0|h,0|(p=0|Se(0|V,0|p,21)),0|vi),h=vi,j=0|Ig(0|(b=0|be(0|(b=0|Ig(0|M,0|D,1048576,0)),0|vi,21)),0|(V=vi),0|g,0|j),g=vi,V=0|Ag(0|M,0|D,0|(V=0|Se(0|b,0|V,21)),0|vi),D=vi,I=0|Ig(0|(M=0|be(0|(M=0|Ig(0|a,0|B,1048576,0)),0|vi,21)),0|(b=vi),0|c,0|I),c=vi,b=0|Ag(0|a,0|B,0|(b=0|Se(0|M,0|b,21)),0|vi),B=vi,q=0|Ig(0|(a=0|he(0|U,0|C,666643,0)),0|vi,2097151&q|0,0),a=vi,M=0|Ig(0|r,0|n,0|(M=0|he(0|U,0|C,470296,0)),0|vi),n=vi,r=0|Ig(0|J,0|k,0|(r=0|he(0|U,0|C,654183,0)),0|vi),k=vi,J=0|he(0|U,0|C,-997805,-1),K=vi,u=0|he(0|U,0|C,136657,0),s=vi,y=0|Ag(0|(W=0|Ig(0|(m=0|Ig(0|(C=0|he(0|U,0|C,-683901,-1)),0|vi,0|v,0|m)),0|vi,0|X,0|W)),0|vi,0|d,0|y),d=vi,w=0|Ig(0|(W=0|he(0|I,0|c,666643,0)),0|vi,2097151&w|0,0),W=vi,X=0|Ig(0|q,0|a,0|(X=0|he(0|I,0|c,470296,0)),0|vi),a=vi,q=0|Ig(0|M,0|n,0|(q=0|he(0|I,0|c,654183,0)),0|vi),n=vi,M=0|Ig(0|r,0|k,0|(M=0|he(0|I,0|c,-997805,-1)),0|vi),k=vi,r=0|he(0|I,0|c,136657,0),m=vi,c=0|he(0|I,0|c,-683901,-1),I=vi,T=0|Ig(0|(v=0|he(0|b,0|B,666643,0)),0|vi,2097151&T|0,0),v=vi,C=0|Ig(0|w,0|W,0|(C=0|he(0|b,0|B,470296,0)),0|vi),W=vi,w=0|Ig(0|X,0|a,0|(w=0|he(0|b,0|B,654183,0)),0|vi),a=vi,X=0|Ig(0|q,0|n,0|(X=0|he(0|b,0|B,-997805,-1)),0|vi),n=vi,q=0|Ig(0|M,0|k,0|(q=0|he(0|b,0|B,136657,0)),0|vi),k=vi,B=0|he(0|b,0|B,-683901,-1),b=vi,b=0|Ig(0|(m=0|Ig(0|(K=0|Ig(0|(P=0|Ag(0|(Y=0|Ig(0|Z,0|F,0|G,0|Y)),0|vi,0|H,0|P)),0|vi,0|J,0|K)),0|vi,0|r,0|m)),0|vi,0|B,0|b),B=vi,x=0|Ig(0|(m=0|he(0|j,0|g,666643,0)),0|vi,2097151&x|0,0),m=vi,r=0|Ig(0|T,0|v,0|(r=0|he(0|j,0|g,470296,0)),0|vi),v=vi,T=0|Ig(0|C,0|W,0|(T=0|he(0|j,0|g,654183,0)),0|vi),W=vi,C=0|Ig(0|w,0|a,0|(C=0|he(0|j,0|g,-997805,-1)),0|vi),a=vi,w=0|Ig(0|X,0|n,0|(w=0|he(0|j,0|g,136657,0)),0|vi),n=vi,g=0|Ig(0|q,0|k,0|(g=0|he(0|j,0|g,-683901,-1)),0|vi),k=vi,q=0|he(0|V,0|D,666643,0),j=vi,X=0|he(0|V,0|D,470296,0),K=vi,J=0|he(0|V,0|D,654183,0),P=vi,H=0|he(0|V,0|D,-997805,-1),Y=vi,G=0|he(0|V,0|D,136657,0),F=vi,D=0|Ig(0|w,0|n,0|(D=0|he(0|V,0|D,-683901,-1)),0|vi),n=vi,L=0|Ig(0|(w=0|he(0|i,0|t,666643,0)),0|vi,2097151&L|0,0),w=vi,V=0|he(0|i,0|t,470296,0),Z=vi,K=0|Ig(0|(M=0|Ig(0|x,0|m,0|(M=0|he(0|i,0|t,654183,0)),0|vi)),0|vi,0|X,0|K),X=vi,M=0|he(0|i,0|t,-997805,-1),m=vi,Y=0|Ig(0|(x=0|Ig(0|T,0|W,0|(x=0|he(0|i,0|t,136657,0)),0|vi)),0|vi,0|H,0|Y),H=vi,t=0|he(0|i,0|t,-683901,-1),i=vi,x=0|be(0|(x=0|Ig(0|L,0|w,1048576,0)),0|vi,21),W=vi,j=0|Ig(0|(j=0|Ig(0|(e=0|Ig(0|V,0|Z,2097151&e|0,0)),0|vi,0|q,0|j)),0|vi,0|x,0|W),q=vi,W=0|Ag(0|L,0|w,0|(W=0|Se(0|x,0|W,21)),0|vi),w=vi,L=0|be(0|(L=0|Ig(0|K,0|X,1048576,0)),0|vi,21),x=vi,P=0|Ig(0|(P=0|Ig(0|(m=0|Ig(0|r,0|v,0|M,0|m)),0|vi,0|J,0|P)),0|vi,0|L,0|x),J=vi,x=0|Se(0|L,0|x,21),L=vi,m=0|be(0|(m=0|Ig(0|Y,0|H,1048576,0)),0|vi,21),M=vi,F=0|Ig(0|(F=0|Ig(0|(i=0|Ig(0|C,0|a,0|t,0|i)),0|vi,0|G,0|F)),0|vi,0|m,0|M),G=vi,M=0|Se(0|m,0|M,21),m=vi,k=0|Ig(0|g,0|k,0|(i=0|be(0|(i=0|Ig(0|D,0|n,1048576,0)),0|vi,21)),0|(t=vi)),g=vi,t=0|Ag(0|D,0|n,0|(t=0|Se(0|i,0|t,21)),0|vi),n=vi,D=0|be(0|(D=0|Ig(0|b,0|B,1048576,0)),0|vi,21),i=vi,I=0|Ig(0|(I=0|Ig(0|(_=0|Ag(0|(Q=0|Ig(0|u,0|s,0|o,0|Q)),0|vi,0|E,0|_)),0|vi,0|c,0|I)),0|vi,0|D,0|i),c=vi,i=0|Ag(0|b,0|B,0|(i=0|Se(0|D,0|i,21)),0|vi),B=vi,h=0|Ig(0|(b=0|be(0|(b=0|Ig(0|y,0|d,1048576,0)),0|vi,21)),0|(D=vi),0|p,0|h),p=vi,D=0|Ag(0|y,0|d,0|(D=0|Se(0|b,0|D,21)),0|vi),d=vi,_=0|Se(0|(y=0|be(0|(y=0|Ig(0|j,0|q,1048576,0)),0|vi,21)),0|(b=vi),21),E=vi,s=0|Se(0|(Q=0|be(0|(Q=0|Ig(0|P,0|J,1048576,0)),0|vi,21)),0|(o=vi),21),u=vi,n=0|Ig(0|t,0|n,0|(a=0|be(0|(a=0|Ig(0|F,0|G,1048576,0)),0|vi,21)),0|(C=vi)),t=vi,C=0|Se(0|a,0|C,21),a=vi,B=0|Ig(0|i,0|B,0|(v=0|be(0|(v=0|Ig(0|k,0|g,1048576,0)),0|vi,21)),0|(r=vi)),i=vi,r=0|Ag(0|k,0|g,0|(r=0|Se(0|v,0|r,21)),0|vi),g=vi,d=0|Ig(0|D,0|d,0|(k=0|be(0|(k=0|Ig(0|I,0|c,1048576,0)),0|vi,21)),0|(v=vi)),D=vi,v=0|Ag(0|I,0|c,0|(v=0|Se(0|k,0|v,21)),0|vi),c=vi,e=0|Ag(0|h,0|p,0|(e=0|Se(0|(I=0|be(0|(I=0|Ig(0|h,0|p,1048576,0)),0|vi,21)),0|(k=vi),21)),0|vi),p=vi,h=0|Ig(0|W,0|w,0|(h=0|he(0|I,0|k,666643,0)),0|vi),w=vi,W=0|he(0|I,0|k,470296,0),Z=vi,V=0|he(0|I,0|k,654183,0),T=vi,U=0|he(0|I,0|k,-997805,-1),N=vi,R=0|he(0|I,0|k,136657,0),S=vi,k=0|he(0|I,0|k,-683901,-1),I=vi,f=0|be(0|h,0|w,21),l=vi,E=0|Ig(0|(E=0|Ag(0|(q=0|Ig(0|W,0|Z,0|j,0|q)),0|vi,0|_,0|E)),0|vi,0|f,0|l),_=vi,l=0|Ag(0|h,0|w,0|(l=0|Se(0|f,0|l,21)),0|vi),w=vi,h=0|be(0|E,0|_,21),f=vi,b=0|Ig(0|(b=0|Ig(0|(L=0|Ag(0|(X=0|Ig(0|V,0|T,0|K,0|X)),0|vi,0|x,0|L)),0|vi,0|y,0|b)),0|vi,0|h,0|f),y=vi,f=0|Ag(0|E,0|_,0|(f=0|Se(0|h,0|f,21)),0|vi),_=vi,E=0|be(0|b,0|y,21),h=vi,u=0|Ig(0|(u=0|Ag(0|(N=0|Ig(0|P,0|J,0|U,0|N)),0|vi,0|s,0|u)),0|vi,0|E,0|h),s=vi,h=0|Ag(0|b,0|y,0|(h=0|Se(0|E,0|h,21)),0|vi),y=vi,b=0|be(0|u,0|s,21),E=vi,o=0|Ig(0|(o=0|Ig(0|(m=0|Ag(0|(H=0|Ig(0|R,0|S,0|Y,0|H)),0|vi,0|M,0|m)),0|vi,0|Q,0|o)),0|vi,0|b,0|E),Q=vi,E=0|Ag(0|u,0|s,0|(E=0|Se(0|b,0|E,21)),0|vi),s=vi,u=0|be(0|o,0|Q,21),b=vi,a=0|Ig(0|(a=0|Ag(0|(I=0|Ig(0|F,0|G,0|k,0|I)),0|vi,0|C,0|a)),0|vi,0|u,0|b),C=vi,b=0|Ag(0|o,0|Q,0|(b=0|Se(0|u,0|b,21)),0|vi),Q=vi,t=0|Ig(0|n,0|t,0|(o=0|be(0|a,0|C,21)),0|(u=vi)),n=vi,u=0|Ag(0|a,0|C,0|(u=0|Se(0|o,0|u,21)),0|vi),C=vi,g=0|Ig(0|(a=0|be(0|t,0|n,21)),0|(o=vi),0|r,0|g),r=vi,o=0|Ag(0|t,0|n,0|(o=0|Se(0|a,0|o,21)),0|vi),n=vi,i=0|Ig(0|B,0|i,0|(t=0|be(0|g,0|r,21)),0|(a=vi)),B=vi,a=0|Ag(0|g,0|r,0|(a=0|Se(0|t,0|a,21)),0|vi),r=vi,c=0|Ig(0|(g=0|be(0|i,0|B,21)),0|(t=vi),0|v,0|c),v=vi,t=0|Ag(0|i,0|B,0|(t=0|Se(0|g,0|t,21)),0|vi),B=vi,D=0|Ig(0|d,0|D,0|(i=0|be(0|c,0|v,21)),0|(g=vi)),d=vi,g=0|Ag(0|c,0|v,0|(g=0|Se(0|i,0|g,21)),0|vi),v=vi,p=0|Ig(0|(c=0|be(0|D,0|d,21)),0|(i=vi),0|e,0|p),e=vi,i=0|Ag(0|D,0|d,0|(i=0|Se(0|c,0|i,21)),0|vi),d=vi,I=0|Ag(0|p,0|e,0|(I=0|Se(0|(D=0|be(0|p,0|e,21)),0|(c=vi),21)),0|vi),e=vi,w=0|Ig(0|(p=0|he(0|D,0|c,666643,0)),0|vi,0|l,0|w),l=vi,p=0|Ig(0|f,0|_,0|(p=0|he(0|D,0|c,470296,0)),0|vi),_=vi,f=0|Ig(0|h,0|y,0|(f=0|he(0|D,0|c,654183,0)),0|vi),y=vi,h=0|Ig(0|E,0|s,0|(h=0|he(0|D,0|c,-997805,-1)),0|vi),s=vi,E=0|Ig(0|b,0|Q,0|(E=0|he(0|D,0|c,136657,0)),0|vi),Q=vi,c=0|Ig(0|u,0|C,0|(c=0|he(0|D,0|c,-683901,-1)),0|vi),C=vi,_=0|Ig(0|p,0|_,0|(u=0|be(0|w,0|l,21)),0|(D=vi)),p=vi,D=0|Ag(0|w,0|l,0|(D=0|Se(0|u,0|D,21)),0|vi),l=vi,y=0|Ig(0|f,0|y,0|(w=0|be(0|_,0|p,21)),0|(u=vi)),f=vi,u=0|Ag(0|_,0|p,0|(u=0|Se(0|w,0|u,21)),0|vi),p=vi,s=0|Ig(0|h,0|s,0|(_=0|be(0|y,0|f,21)),0|(w=vi)),h=vi,w=0|Ag(0|y,0|f,0|(w=0|Se(0|_,0|w,21)),0|vi),f=vi,Q=0|Ig(0|E,0|Q,0|(y=0|be(0|s,0|h,21)),0|(_=vi)),E=vi,_=0|Ag(0|s,0|h,0|(_=0|Se(0|y,0|_,21)),0|vi),h=vi,C=0|Ig(0|c,0|C,0|(s=0|be(0|Q,0|E,21)),0|(y=vi)),c=vi,y=0|Ag(0|Q,0|E,0|(y=0|Se(0|s,0|y,21)),0|vi),E=vi,n=0|Ig(0|(Q=0|be(0|C,0|c,21)),0|(s=vi),0|o,0|n),o=vi,s=0|Ag(0|C,0|c,0|(s=0|Se(0|Q,0|s,21)),0|vi),c=vi,r=0|Ig(0|(C=0|be(0|n,0|o,21)),0|(Q=vi),0|a,0|r),a=vi,Q=0|Ag(0|n,0|o,0|(Q=0|Se(0|C,0|Q,21)),0|vi),o=vi,B=0|Ig(0|(n=0|be(0|r,0|a,21)),0|(C=vi),0|t,0|B),t=vi,C=0|Ag(0|r,0|a,0|(C=0|Se(0|n,0|C,21)),0|vi),a=vi,v=0|Ig(0|(r=0|be(0|B,0|t,21)),0|(n=vi),0|g,0|v),g=vi,n=0|Ag(0|B,0|t,0|(n=0|Se(0|r,0|n,21)),0|vi),t=vi,d=0|Ig(0|(B=0|be(0|v,0|g,21)),0|(r=vi),0|i,0|d),i=vi,r=0|Ag(0|v,0|g,0|(r=0|Se(0|B,0|r,21)),0|vi),g=vi,e=0|Ig(0|(v=0|be(0|d,0|i,21)),0|(B=vi),0|I,0|e),I=vi,B=0|Ag(0|d,0|i,0|(B=0|Se(0|v,0|B,21)),0|vi),i=vi,yi[A>>0]=D,d=0|Ue(0|D,0|l,8),yi[A+1>>0]=d,l=0|Ue(0|D,0|l,16),D=vi,d=0|Se(0|u,0|p,5),yi[A+2>>0]=d|l,l=0|Ue(0|u,0|p,3),yi[A+3>>0]=l,l=0|Ue(0|u,0|p,11),yi[A+4>>0]=l,p=0|Ue(0|u,0|p,19),u=vi,l=0|Se(0|w,0|f,2),yi[A+5>>0]=l|p,p=0|Ue(0|w,0|f,6),yi[A+6>>0]=p,f=0|Ue(0|w,0|f,14),w=vi,p=0|Se(0|_,0|h,7),yi[A+7>>0]=p|f,f=0|Ue(0|_,0|h,1),yi[A+8>>0]=f,f=0|Ue(0|_,0|h,9),yi[A+9>>0]=f,h=0|Ue(0|_,0|h,17),_=vi,f=0|Se(0|y,0|E,4),yi[A+10>>0]=f|h,h=0|Ue(0|y,0|E,4),yi[A+11>>0]=h,h=0|Ue(0|y,0|E,12),yi[A+12>>0]=h,E=0|Ue(0|y,0|E,20),y=vi,h=0|Se(0|s,0|c,1),yi[A+13>>0]=h|E,E=0|Ue(0|s,0|c,7),yi[A+14>>0]=E,c=0|Ue(0|s,0|c,15),s=vi,E=0|Se(0|Q,0|o,6),yi[A+15>>0]=E|c,c=0|Ue(0|Q,0|o,2),yi[A+16>>0]=c,c=0|Ue(0|Q,0|o,10),yi[A+17>>0]=c,o=0|Ue(0|Q,0|o,18),Q=vi,c=0|Se(0|C,0|a,3),yi[A+18>>0]=c|o,o=0|Ue(0|C,0|a,5),yi[A+19>>0]=o,a=0|Ue(0|C,0|a,13),yi[A+20>>0]=a,yi[A+21>>0]=n,a=0|Ue(0|n,0|t,8),yi[A+22>>0]=a,t=0|Ue(0|n,0|t,16),n=vi,a=0|Se(0|r,0|g,5),yi[A+23>>0]=a|t,t=0|Ue(0|r,0|g,3),yi[A+24>>0]=t,t=0|Ue(0|r,0|g,11),yi[A+25>>0]=t,g=0|Ue(0|r,0|g,19),r=vi,t=0|Se(0|B,0|i,2),yi[A+26>>0]=t|g,g=0|Ue(0|B,0|i,6),yi[A+27>>0]=g,i=0|Ue(0|B,0|i,14),B=vi,g=0|Se(0|e,0|I,7),yi[A+28>>0]=i|g,g=0|Ue(0|e,0|I,1),yi[A+29>>0]=g,g=0|Ue(0|e,0|I,9),yi[A+30>>0]=g,I=0|Ue(0|e,0|I,17),yi[A+31>>0]=I}function a(A,I,e){A|=0,e|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0,P=0,L=0,x=0,X=0,K=0,T=0,V=0,q=0,j=0,Z=0,W=0,z=0,O=0,$=0,AA=0,IA=0,eA=0,gA=0,iA=0,BA=0,tA=0,rA=0,aA=0,nA=0,CA=0,oA=0,cA=0,QA=0,EA=0,sA=0,hA=0,yA=0,fA=0,_A=0,pA=0,wA=0,lA=0,uA=0,dA=0,DA=0,vA=0,bA=0,kA=0,GA=0,FA=0,mA=0,MA=0,HA=0,YA=0,SA=0,RA=0,NA=0,UA=0,JA=0,PA=0,LA=0,xA=0,XA=0,KA=0,TA=0,VA=0,qA=0,jA=0,ZA=0,WA=0,zA=0,OA=0,$A=0,AI=0,II=0,eI=0,gI=0,iI=0,BI=0,tI=0,rI=0,aI=0,nI=0,CI=0,oI=0,cI=0,QI=0,EI=0,sI=0,hI=0,yI=0,fI=0,_I=0,pI=0,wI=0,lI=0,uI=0,dI=0,DI=0,vI=0,bI=0,kI=0,GI=0,FI=0,mI=0,MI=0,HI=0,YI=0,SI=0,RI=0,NI=0,UI=0,JI=0,PI=0,LI=0,xI=0,XI=0,KI=0,TI=0,VI=0,qI=0,jI=0,ZI=0,WI=0,zI=0,OI=0,$I=0,Ae=0,Ie=0,ee=0,ge=0,ie=0,Be=0,te=0,re=0,ae=0,ne=0,Ce=0,oe=0,ce=0,Qe=0,Ee=0,se=0,ye=0,fe=0,_e=0,pe=0,we=0,le=0,ue=0,de=0,De=0,ve=0,ke=0,Ge=0,Fe=0,me=0,Me=0,He=0,Ye=0,Re=0,Ne=0,Ue=0,Je=0,Pe=0,Le=0,xe=0;Q=0|fi[(I|=0)>>2],c=0|fi[I+4>>2],n=0|fi[I+8>>2],gA=0|fi[I+12>>2],N=0|fi[I+16>>2],R=0|fi[I+20>>2],B=0|fi[I+24>>2],eA=0|fi[I+28>>2],S=0|fi[I+32>>2],s=0|fi[I+36>>2],M=0|fi[e>>2],Le=0|fi[e+4>>2],Ae=0|fi[e+8>>2],hI=0|fi[e+12>>2],MA=0|fi[e+16>>2],re=0|fi[e+20>>2],bI=0|fi[e+24>>2],XA=0|fi[e+28>>2],iA=0|fi[e+32>>2],xe=0|fi[e+36>>2],Je=0|he(0|M,((0|M)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),Ue=vi,we=0|he(0|Le,((0|Le)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),pe=vi,fI=0|he(0|Ae,((0|Ae)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),yI=vi,YA=0|he(0|hI,((0|hI)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),HA=vi,Ce=0|he(0|MA,((0|MA)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),ne=vi,FI=0|he(0|re,((0|re)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),GI=vi,VA=0|he(0|bI,((0|bI)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),TA=vi,rA=0|he(0|XA,((0|XA)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),tA=vi,J=0|he(0|iA,((0|iA)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),U=vi,Q=0|he(0|xe,((0|xe)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),C=vi,Ie=0|he(0|M,((0|M)<0)<<31>>31|0,0|c,((0|c)<0)<<31>>31|0),ee=vi,lI=0|he(0|Le,((0|Le)<0)<<31>>31|0,c<<1|0,((c<<1|0)<0)<<31>>31|0),wI=vi,RA=0|he(0|Ae,((0|Ae)<0)<<31>>31|0,0|c,((0|c)<0)<<31>>31|0),SA=vi,ce=0|he(0|hI,((0|hI)<0)<<31>>31|0,c<<1|0,((c<<1|0)<0)<<31>>31|0),oe=vi,MI=0|he(0|MA,((0|MA)<0)<<31>>31|0,0|c,((0|c)<0)<<31>>31|0),mI=vi,jA=0|he(0|re,((0|re)<0)<<31>>31|0,c<<1|0,((c<<1|0)<0)<<31>>31|0),qA=vi,nA=0|he(0|bI,((0|bI)<0)<<31>>31|0,0|c,((0|c)<0)<<31>>31|0),aA=vi,L=0|he(0|XA,((0|XA)<0)<<31>>31|0,c<<1|0,((c<<1|0)<0)<<31>>31|0),P=vi,f=0|he(0|iA,((0|iA)<0)<<31>>31|0,0|c,((0|c)<0)<<31>>31|0),y=vi,c=0|he(19*xe|0,0|(e=((19*xe|0)<0)<<31>>31),c<<1|0,((c<<1|0)<0)<<31>>31|0),E=vi,pI=0|he(0|M,((0|M)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),_I=vi,PA=0|he(0|Le,((0|Le)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),JA=vi,Ee=0|he(0|Ae,((0|Ae)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),Qe=vi,YI=0|he(0|hI,((0|hI)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),HI=vi,WA=0|he(0|MA,((0|MA)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),ZA=vi,oA=0|he(0|re,((0|re)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),CA=vi,X=0|he(0|bI,((0|bI)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),x=vi,p=0|he(0|XA,((0|XA)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),_=vi,ue=0|he(19*iA|0,0|(BA=((19*iA|0)<0)<<31>>31),0|n,((0|n)<0)<<31>>31|0),le=vi,n=0|he(19*xe|0,0|e,0|n,((0|n)<0)<<31>>31|0),a=vi,UA=0|he(0|M,((0|M)<0)<<31>>31|0,0|gA,((0|gA)<0)<<31>>31|0),NA=vi,_e=0|he(0|Le,((0|Le)<0)<<31>>31|0,gA<<1|0,((gA<<1|0)<0)<<31>>31|0),fe=vi,RI=0|he(0|Ae,((0|Ae)<0)<<31>>31|0,0|gA,((0|gA)<0)<<31>>31|0),SI=vi,OA=0|he(0|hI,((0|hI)<0)<<31>>31|0,gA<<1|0,((gA<<1|0)<0)<<31>>31|0),zA=vi,QA=0|he(0|MA,((0|MA)<0)<<31>>31|0,0|gA,((0|gA)<0)<<31>>31|0),cA=vi,T=0|he(0|re,((0|re)<0)<<31>>31|0,gA<<1|0,((gA<<1|0)<0)<<31>>31|0),K=vi,l=0|he(0|bI,((0|bI)<0)<<31>>31|0,0|gA,((0|gA)<0)<<31>>31|0),w=vi,De=0|he(19*XA|0,0|(KA=((19*XA|0)<0)<<31>>31),gA<<1|0,((gA<<1|0)<0)<<31>>31|0),de=vi,xI=0|he(19*iA|0,0|BA,0|gA,((0|gA)<0)<<31>>31|0),LI=vi,gA=0|he(19*xe|0,0|e,gA<<1|0,((gA<<1|0)<0)<<31>>31|0),i=vi,ye=0|he(0|M,((0|M)<0)<<31>>31|0,0|N,((0|N)<0)<<31>>31|0),se=vi,PI=0|he(0|Le,((0|Le)<0)<<31>>31|0,0|N,((0|N)<0)<<31>>31|0),JI=vi,AI=0|he(0|Ae,((0|Ae)<0)<<31>>31|0,0|N,((0|N)<0)<<31>>31|0),$A=vi,sA=0|he(0|hI,((0|hI)<0)<<31>>31|0,0|N,((0|N)<0)<<31>>31|0),EA=vi,q=0|he(0|MA,((0|MA)<0)<<31>>31|0,0|N,((0|N)<0)<<31>>31|0),V=vi,d=0|he(0|re,((0|re)<0)<<31>>31|0,0|N,((0|N)<0)<<31>>31|0),u=vi,ke=0|he(19*bI|0,0|(kI=((19*bI|0)<0)<<31>>31),0|N,((0|N)<0)<<31>>31|0),ve=vi,KI=0|he(19*XA|0,0|KA,0|N,((0|N)<0)<<31>>31|0),XI=vi,tI=0|he(19*iA|0,0|BA,0|N,((0|N)<0)<<31>>31|0),BI=vi,N=0|he(19*xe|0,0|e,0|N,((0|N)<0)<<31>>31|0),g=vi,UI=0|he(0|M,((0|M)<0)<<31>>31|0,0|R,((0|R)<0)<<31>>31|0),NI=vi,iI=0|he(0|Le,((0|Le)<0)<<31>>31|0,R<<1|0,((R<<1|0)<0)<<31>>31|0),gI=vi,yA=0|he(0|Ae,((0|Ae)<0)<<31>>31|0,0|R,((0|R)<0)<<31>>31|0),hA=vi,Z=0|he(0|hI,((0|hI)<0)<<31>>31|0,R<<1|0,((R<<1|0)<0)<<31>>31|0),j=vi,v=0|he(0|MA,((0|MA)<0)<<31>>31|0,0|R,((0|R)<0)<<31>>31|0),D=vi,Fe=0|he(19*re|0,0|(ae=((19*re|0)<0)<<31>>31),R<<1|0,((R<<1|0)<0)<<31>>31|0),Ge=vi,VI=0|he(19*bI|0,0|kI,0|R,((0|R)<0)<<31>>31|0),TI=vi,aI=0|he(19*XA|0,0|KA,R<<1|0,((R<<1|0)<0)<<31>>31|0),rI=vi,dA=0|he(19*iA|0,0|BA,0|R,((0|R)<0)<<31>>31|0),uA=vi,I=0|he(19*xe|0,0|e,R<<1|0,((R<<1|0)<0)<<31>>31|0),R=vi,eI=0|he(0|M,((0|M)<0)<<31>>31|0,0|B,((0|B)<0)<<31>>31|0),II=vi,wA=0|he(0|Le,((0|Le)<0)<<31>>31|0,0|B,((0|B)<0)<<31>>31|0),pA=vi,z=0|he(0|Ae,((0|Ae)<0)<<31>>31|0,0|B,((0|B)<0)<<31>>31|0),W=vi,k=0|he(0|hI,((0|hI)<0)<<31>>31|0,0|B,((0|B)<0)<<31>>31|0),b=vi,Me=0|he(19*MA|0,((19*MA|0)<0)<<31>>31|0,0|B,((0|B)<0)<<31>>31|0),me=vi,jI=0|he(19*re|0,0|ae,0|B,((0|B)<0)<<31>>31|0),qI=vi,CI=0|he(19*bI|0,0|kI,0|B,((0|B)<0)<<31>>31|0),nI=vi,vA=0|he(19*XA|0,0|KA,0|B,((0|B)<0)<<31>>31|0),DA=vi,o=0|he(19*iA|0,0|BA,0|B,((0|B)<0)<<31>>31|0),h=vi,B=0|he(19*xe|0,0|e,0|B,((0|B)<0)<<31>>31|0),lA=vi,_A=0|he(0|M,((0|M)<0)<<31>>31|0,0|eA,((0|eA)<0)<<31>>31|0),fA=vi,IA=0|he(0|Le,((0|Le)<0)<<31>>31|0,eA<<1|0,((eA<<1|0)<0)<<31>>31|0),AA=vi,F=0|he(0|Ae,((0|Ae)<0)<<31>>31|0,0|eA,((0|eA)<0)<<31>>31|0),G=vi,Ye=0|he(19*hI|0,((19*hI|0)<0)<<31>>31|0,eA<<1|0,((eA<<1|0)<0)<<31>>31|0),He=vi,WI=0|he(19*MA|0,((19*MA|0)<0)<<31>>31|0,0|eA,((0|eA)<0)<<31>>31|0),ZI=vi,cI=0|he(19*re|0,0|ae,eA<<1|0,((eA<<1|0)<0)<<31>>31|0),oI=vi,kA=0|he(19*bI|0,0|kI,0|eA,((0|eA)<0)<<31>>31|0),bA=vi,ie=0|he(19*XA|0,0|KA,eA<<1|0,((eA<<1|0)<0)<<31>>31|0),ge=vi,dI=0|he(19*iA|0,0|BA,0|eA,((0|eA)<0)<<31>>31|0),uI=vi,eA=0|he(19*xe|0,0|e,eA<<1|0,((eA<<1|0)<0)<<31>>31|0),r=vi,$=0|he(0|M,((0|M)<0)<<31>>31|0,0|S,((0|S)<0)<<31>>31|0),O=vi,Y=0|he(0|Le,((0|Le)<0)<<31>>31|0,0|S,((0|S)<0)<<31>>31|0),H=vi,Ne=0|he(19*Ae|0,((19*Ae|0)<0)<<31>>31|0,0|S,((0|S)<0)<<31>>31|0),Re=vi,OI=0|he(19*hI|0,((19*hI|0)<0)<<31>>31|0,0|S,((0|S)<0)<<31>>31|0),zI=vi,EI=0|he(19*MA|0,((19*MA|0)<0)<<31>>31|0,0|S,((0|S)<0)<<31>>31|0),QI=vi,FA=0|he(19*re|0,0|ae,0|S,((0|S)<0)<<31>>31|0),GA=vi,te=0|he(19*bI|0,0|kI,0|S,((0|S)<0)<<31>>31|0),Be=vi,vI=0|he(19*XA|0,0|KA,0|S,((0|S)<0)<<31>>31|0),DI=vi,xA=0|he(19*iA|0,0|BA,0|S,((0|S)<0)<<31>>31|0),LA=vi,S=0|he(19*xe|0,0|e,0|S,((0|S)<0)<<31>>31|0),t=vi,M=0|he(0|M,((0|M)<0)<<31>>31|0,0|s,((0|s)<0)<<31>>31|0),m=vi,Le=0|he(19*Le|0,((19*Le|0)<0)<<31>>31|0,s<<1|0,((s<<1|0)<0)<<31>>31|0),Pe=vi,Ae=0|he(19*Ae|0,((19*Ae|0)<0)<<31>>31|0,0|s,((0|s)<0)<<31>>31|0),$I=vi,hI=0|he(19*hI|0,((19*hI|0)<0)<<31>>31|0,s<<1|0,((s<<1|0)<0)<<31>>31|0),sI=vi,MA=0|he(19*MA|0,((19*MA|0)<0)<<31>>31|0,0|s,((0|s)<0)<<31>>31|0),mA=vi,ae=0|he(19*re|0,0|ae,s<<1|0,((s<<1|0)<0)<<31>>31|0),re=vi,kI=0|he(19*bI|0,0|kI,0|s,((0|s)<0)<<31>>31|0),bI=vi,KA=0|he(19*XA|0,0|KA,s<<1|0,((s<<1|0)<0)<<31>>31|0),XA=vi,BA=0|he(19*iA|0,0|BA,0|s,((0|s)<0)<<31>>31|0),iA=vi,s=0|he(19*xe|0,0|e,s<<1|0,((s<<1|0)<0)<<31>>31|0),e=vi,E=0|Ig(0|(le=0|Ig(0|(de=0|Ig(0|(ve=0|Ig(0|(Ge=0|Ig(0|(me=0|Ig(0|(He=0|Ig(0|(Re=0|Ig(0|(Ue=0|Ig(0|Le,0|Pe,0|Je,0|Ue)),0|vi,0|Ne,0|Re)),0|vi,0|Ye,0|He)),0|vi,0|Me,0|me)),0|vi,0|Fe,0|Ge)),0|vi,0|ke,0|ve)),0|vi,0|De,0|de)),0|vi,0|ue,0|le)),0|vi,0|c,0|E),c=vi,ee=0|Ig(0|we,0|pe,0|Ie,0|ee),Ie=vi,R=0|Ig(0|(h=0|Ig(0|(ge=0|Ig(0|(Be=0|Ig(0|(re=0|Ig(0|(ne=0|Ig(0|(oe=0|Ig(0|(Qe=0|Ig(0|(se=0|Ig(0|_e,0|fe,0|ye,0|se)),0|vi,0|Ee,0|Qe)),0|vi,0|ce,0|oe)),0|vi,0|Ce,0|ne)),0|vi,0|ae,0|re)),0|vi,0|te,0|Be)),0|vi,0|ie,0|ge)),0|vi,0|o,0|h)),0|vi,0|I,0|R),I=vi,h=0|be(0|(h=0|Ig(0|E,0|c,33554432,0)),0|vi,26),o=vi,a=0|Ig(0|(a=0|Ig(0|(LI=0|Ig(0|(XI=0|Ig(0|(TI=0|Ig(0|(qI=0|Ig(0|(ZI=0|Ig(0|(zI=0|Ig(0|($I=0|Ig(0|ee,0|Ie,0|Ae,0|$I)),0|vi,0|OI,0|zI)),0|vi,0|WI,0|ZI)),0|vi,0|jI,0|qI)),0|vi,0|VI,0|TI)),0|vi,0|KI,0|XI)),0|vi,0|xI,0|LI)),0|vi,0|n,0|a)),0|vi,0|h,0|o),n=vi,o=0|Ag(0|E,0|c,0|(o=0|Se(0|h,0|o,26)),0|vi),c=vi,E=0|be(0|(E=0|Ig(0|R,0|I,33554432,0)),0|vi,26),h=vi,lA=0|Ig(0|(lA=0|Ig(0|(uI=0|Ig(0|(DI=0|Ig(0|(bI=0|Ig(0|(GI=0|Ig(0|(mI=0|Ig(0|(HI=0|Ig(0|(SI=0|Ig(0|(NI=0|Ig(0|PI,0|JI,0|UI,0|NI)),0|vi,0|RI,0|SI)),0|vi,0|YI,0|HI)),0|vi,0|MI,0|mI)),0|vi,0|FI,0|GI)),0|vi,0|kI,0|bI)),0|vi,0|vI,0|DI)),0|vi,0|dI,0|uI)),0|vi,0|B,0|lA)),0|vi,0|E,0|h),B=vi,h=0|Ag(0|R,0|I,0|(h=0|Se(0|E,0|h,26)),0|vi),I=vi,R=0|be(0|(R=0|Ig(0|a,0|n,16777216,0)),0|vi,25),E=vi,i=0|Ig(0|(i=0|Ig(0|(BI=0|Ig(0|(rI=0|Ig(0|(nI=0|Ig(0|(oI=0|Ig(0|(QI=0|Ig(0|(sI=0|Ig(0|(yI=0|Ig(0|(_I=0|Ig(0|lI,0|wI,0|pI,0|_I)),0|vi,0|fI,0|yI)),0|vi,0|hI,0|sI)),0|vi,0|EI,0|QI)),0|vi,0|cI,0|oI)),0|vi,0|CI,0|nI)),0|vi,0|aI,0|rI)),0|vi,0|tI,0|BI)),0|vi,0|gA,0|i)),0|vi,0|R,0|E),gA=vi,E=0|Ag(0|a,0|n,0|(E=0|Se(0|R,0|E,25)),0|vi),n=vi,a=0|be(0|(a=0|Ig(0|lA,0|B,16777216,0)),0|vi,25),R=vi,r=0|Ig(0|(r=0|Ig(0|(LA=0|Ig(0|(XA=0|Ig(0|(TA=0|Ig(0|(qA=0|Ig(0|(ZA=0|Ig(0|(zA=0|Ig(0|($A=0|Ig(0|(II=0|Ig(0|iI,0|gI,0|eI,0|II)),0|vi,0|AI,0|$A)),0|vi,0|OA,0|zA)),0|vi,0|WA,0|ZA)),0|vi,0|jA,0|qA)),0|vi,0|VA,0|TA)),0|vi,0|KA,0|XA)),0|vi,0|xA,0|LA)),0|vi,0|eA,0|r)),0|vi,0|a,0|R),eA=vi,R=0|Ag(0|lA,0|B,0|(R=0|Se(0|a,0|R,25)),0|vi),B=vi,lA=0|be(0|(lA=0|Ig(0|i,0|gA,33554432,0)),0|vi,26),a=vi,g=0|Ig(0|(g=0|Ig(0|(uA=0|Ig(0|(DA=0|Ig(0|(bA=0|Ig(0|(GA=0|Ig(0|(mA=0|Ig(0|(HA=0|Ig(0|(SA=0|Ig(0|(NA=0|Ig(0|PA,0|JA,0|UA,0|NA)),0|vi,0|RA,0|SA)),0|vi,0|YA,0|HA)),0|vi,0|MA,0|mA)),0|vi,0|FA,0|GA)),0|vi,0|kA,0|bA)),0|vi,0|vA,0|DA)),0|vi,0|dA,0|uA)),0|vi,0|N,0|g)),0|vi,0|lA,0|a),N=vi,a=0|Ag(0|i,0|gA,0|(a=0|Se(0|lA,0|a,26)),0|vi),gA=0|be(0|(gA=0|Ig(0|r,0|eA,33554432,0)),0|vi,26),i=vi,t=0|Ig(0|(t=0|Ig(0|(iA=0|Ig(0|(tA=0|Ig(0|(aA=0|Ig(0|(CA=0|Ig(0|(cA=0|Ig(0|(EA=0|Ig(0|(hA=0|Ig(0|(fA=0|Ig(0|wA,0|pA,0|_A,0|fA)),0|vi,0|yA,0|hA)),0|vi,0|sA,0|EA)),0|vi,0|QA,0|cA)),0|vi,0|oA,0|CA)),0|vi,0|nA,0|aA)),0|vi,0|rA,0|tA)),0|vi,0|BA,0|iA)),0|vi,0|S,0|t)),0|vi,0|gA,0|i),S=vi,i=0|Ag(0|r,0|eA,0|(i=0|Se(0|gA,0|i,26)),0|vi),I=0|Ig(0|(eA=0|be(0|(eA=0|Ig(0|g,0|N,16777216,0)),0|vi,25)),0|(r=vi),0|h,0|I),h=vi,r=0|Ag(0|g,0|N,0|(r=0|Se(0|eA,0|r,25)),0|vi),N=0|be(0|(N=0|Ig(0|t,0|S,16777216,0)),0|vi,25),g=vi,e=0|Ig(0|(e=0|Ig(0|(U=0|Ig(0|(P=0|Ig(0|(x=0|Ig(0|(K=0|Ig(0|(V=0|Ig(0|(j=0|Ig(0|(W=0|Ig(0|(O=0|Ig(0|IA,0|AA,0|$,0|O)),0|vi,0|z,0|W)),0|vi,0|Z,0|j)),0|vi,0|q,0|V)),0|vi,0|T,0|K)),0|vi,0|X,0|x)),0|vi,0|L,0|P)),0|vi,0|J,0|U)),0|vi,0|s,0|e)),0|vi,0|N,0|g),s=vi,g=0|Ag(0|t,0|S,0|(g=0|Se(0|N,0|g,25)),0|vi),B=0|Ig(0|R,0|B,0|(S=0|be(0|(S=0|Ig(0|I,0|h,33554432,0)),0|vi,26)),0|(t=vi)),t=0|Ag(0|I,0|h,0|(t=0|Se(0|S,0|t,26)),0|vi),h=0|be(0|(h=0|Ig(0|e,0|s,33554432,0)),0|vi,26),I=vi,C=0|Ig(0|(C=0|Ig(0|(y=0|Ig(0|(_=0|Ig(0|(w=0|Ig(0|(u=0|Ig(0|(D=0|Ig(0|(b=0|Ig(0|(G=0|Ig(0|(m=0|Ig(0|Y,0|H,0|M,0|m)),0|vi,0|F,0|G)),0|vi,0|k,0|b)),0|vi,0|v,0|D)),0|vi,0|d,0|u)),0|vi,0|l,0|w)),0|vi,0|p,0|_)),0|vi,0|f,0|y)),0|vi,0|Q,0|C)),0|vi,0|h,0|I),Q=vi,I=0|Ag(0|e,0|s,0|(I=0|Se(0|h,0|I,26)),0|vi),c=0|Ig(0|(h=0|he(0|(s=0|be(0|(s=0|Ig(0|C,0|Q,16777216,0)),0|vi,25)),0|(e=vi),19,0)),0|vi,0|o,0|c),o=vi,e=0|Ag(0|C,0|Q,0|(e=0|Se(0|s,0|e,25)),0|vi),n=0|Ig(0|E,0|n,0|(Q=0|be(0|(Q=0|Ig(0|c,0|o,33554432,0)),0|vi,26)),0|(C=vi)),C=0|Ag(0|c,0|o,0|(C=0|Se(0|Q,0|C,26)),0|vi),fi[A>>2]=C,fi[A+4>>2]=n,fi[A+8>>2]=a,fi[A+12>>2]=r,fi[A+16>>2]=t,fi[A+20>>2]=B,fi[A+24>>2]=i,fi[A+28>>2]=g,fi[A+32>>2]=I,fi[A+36>>2]=e}function n(A,I,e){A|=0,e|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0;g=wi,i=wi=wi+63&-64,wi=wi+2048|0,Og(i+1024|0,I|=0),RI(i+1024|0,A),Og(i,i+1024|0),RI(i,e),A=0;do{f=0|fi[i+1024+((4|(I=A<<4))<<3)>>2],w=0|fi[i+1024+((4|I)<<3)+4>>2],u=0|JI(0|fi[i+1024+(I<<3)>>2],0|fi[i+1024+(I<<3)+4>>2],f,w),G=vi,l=0|Ee(fi[i+1024+((12|I)<<3)>>2]^u,fi[i+1024+((12|I)<<3)+4>>2]^G,32),y=vi,y=0|Ee(l^(G=0|JI(u,G,w=0|Ee(f^(v=0|JI(0|fi[i+1024+((8|I)<<3)>>2],0|fi[i+1024+((8|I)<<3)+4>>2],l,y)),w^(E=vi),24),f=vi)),y^(u=vi),16),l=vi,fi[i+1024+((12|I)<<3)>>2]=y,fi[i+1024+((12|I)<<3)+4>>2]=l,E=0|JI(v,E,y,l),v=vi,fi[i+1024+((8|I)<<3)>>2]=E,fi[i+1024+((8|I)<<3)+4>>2]=v,v=0|Ee(w^E,f^v,63),fi[i+1024+((4|I)<<3)>>2]=v,fi[i+1024+((4|I)<<3)+4>>2]=vi,v=0|fi[i+1024+((5|I)<<3)>>2],f=0|fi[i+1024+((5|I)<<3)+4>>2],E=0|JI(0|fi[i+1024+((1|I)<<3)>>2],0|fi[i+1024+((1|I)<<3)+4>>2],v,f),w=vi,h=0|Ee(fi[i+1024+((13|I)<<3)>>2]^E,fi[i+1024+((13|I)<<3)+4>>2]^w,32),C=vi,Q=0|JI(d=0|JI(0|fi[i+1024+((9|I)<<3)>>2],0|fi[i+1024+((9|I)<<3)+4>>2],h,C),Q=vi,C=0|Ee(h^(w=0|JI(E,w,f=0|Ee(v^d,f^Q,24),v=vi)),C^(E=vi),16),h=vi),d=vi,fi[i+1024+((9|I)<<3)>>2]=Q,fi[i+1024+((9|I)<<3)+4>>2]=d,d=0|Ee(f^Q,v^d,63),v=vi,Q=0|fi[i+1024+((6|I)<<3)>>2],f=0|fi[i+1024+((6|I)<<3)+4>>2],t=0|JI(0|fi[i+1024+((2|I)<<3)>>2],0|fi[i+1024+((2|I)<<3)+4>>2],Q,f),s=vi,c=0|Ee(fi[i+1024+((14|I)<<3)>>2]^t,fi[i+1024+((14|I)<<3)+4>>2]^s,32),r=vi,Q=0|Ee((f=0|Ee(Q^(k=0|JI(0|fi[i+1024+((10|I)<<3)>>2],0|fi[i+1024+((10|I)<<3)+4>>2],c,r)),f^(b=vi),24))^(b=0|JI(k,b,r=0|Ee(c^(s=0|JI(t,s,f,Q=vi)),r^(t=vi),16),c=vi)),Q^(k=vi),63),f=vi,a=0|fi[i+1024+((7|I)<<3)>>2],n=0|fi[i+1024+((7|I)<<3)+4>>2],B=0|JI(0|fi[i+1024+((3|I)<<3)>>2],0|fi[i+1024+((3|I)<<3)+4>>2],a,n),o=vi,F=0|Ee(fi[i+1024+((15|I)<<3)>>2]^B,fi[i+1024+((15|I)<<3)+4>>2]^o,32),D=vi,a=0|Ee((n=0|Ee(a^(p=0|JI(0|fi[i+1024+((11|I)<<3)>>2],0|fi[i+1024+((11|I)<<3)+4>>2],F,D)),n^(_=vi),24))^(_=0|JI(p,_,D=0|Ee(F^(o=0|JI(B,o,n,a=vi)),D^(B=vi),16),F=vi)),a^(p=vi),63),n=vi,G=0|JI(u=0|JI(G,u,d,v),G=vi,v=0|Ee(d^(k=0|JI(b,k,F=0|Ee(D^u,F^G,32),D=vi)),v^(b=vi),24),d=vi),u=vi,fi[i+1024+(I<<3)>>2]=G,fi[i+1024+(I<<3)+4>>2]=u,u=0|Ee(F^G,D^u,16),D=vi,fi[i+1024+((15|I)<<3)>>2]=u,fi[i+1024+((15|I)<<3)+4>>2]=D,D=0|JI(k,b,u,D),u=vi,fi[i+1024+((10|I)<<3)>>2]=D,fi[i+1024+((10|I)<<3)+4>>2]=u,u=0|Ee(v^D,d^u,63),fi[i+1024+((5|I)<<3)>>2]=u,fi[i+1024+((5|I)<<3)+4>>2]=vi,w=0|JI(E=0|JI(w,E,Q,f),w=vi,f=0|Ee(Q^(p=0|JI(_,p,l=0|Ee(y^E,l^w,32),y=vi)),f^(_=vi),24),Q=vi),E=vi,fi[i+1024+((1|I)<<3)>>2]=w,fi[i+1024+((1|I)<<3)+4>>2]=E,E=0|Ee(l^w,y^E,16),y=vi,fi[i+1024+((12|I)<<3)>>2]=E,fi[i+1024+((12|I)<<3)+4>>2]=y,y=0|JI(p,_,E,y),E=vi,fi[i+1024+((11|I)<<3)>>2]=y,fi[i+1024+((11|I)<<3)+4>>2]=E,E=0|Ee(f^y,Q^E,63),fi[i+1024+((6|I)<<3)>>2]=E,fi[i+1024+((6|I)<<3)+4>>2]=vi,h=0|Ee(C^(t=0|JI(s,t,a,n)),h^(s=vi),32),C=vi,s=0|JI(t,s,n=0|Ee(a^(E=0|JI(0|fi[i+1024+((8|I)<<3)>>2],0|fi[i+1024+((8|I)<<3)+4>>2],h,C)),n^(Q=vi),24),a=vi),t=vi,fi[i+1024+((2|I)<<3)>>2]=s,fi[i+1024+((2|I)<<3)+4>>2]=t,t=0|Ee(h^s,C^t,16),C=vi,fi[i+1024+((13|I)<<3)>>2]=t,fi[i+1024+((13|I)<<3)+4>>2]=C,C=0|JI(E,Q,t,C),t=vi,fi[i+1024+((8|I)<<3)>>2]=C,fi[i+1024+((8|I)<<3)+4>>2]=t,t=0|Ee(n^C,a^t,63),fi[i+1024+((7|I)<<3)>>2]=t,fi[i+1024+((7|I)<<3)+4>>2]=vi,c=0|Ee(r^(B=0|JI(o,B,t=0|fi[i+1024+((4|I)<<3)>>2],a=0|fi[i+1024+((4|I)<<3)+4>>2])),c^(o=vi),32),r=vi,o=0|JI(B,o,a=0|Ee(t^(C=0|JI(0|fi[i+1024+((9|I)<<3)>>2],0|fi[i+1024+((9|I)<<3)+4>>2],c,r)),a^(n=vi),24),t=vi),B=vi,fi[i+1024+((3|I)<<3)>>2]=o,fi[i+1024+((3|I)<<3)+4>>2]=B,B=0|Ee(c^o,r^B,16),r=vi,fi[i+1024+((14|I)<<3)>>2]=B,fi[i+1024+((14|I)<<3)+4>>2]=r,r=0|JI(C,n,B,r),B=vi,fi[i+1024+((9|I)<<3)>>2]=r,fi[i+1024+((9|I)<<3)+4>>2]=B,B=0|Ee(a^r,t^B,63),fi[i+1024+((4|I)<<3)>>2]=B,fi[i+1024+((4|I)<<3)+4>>2]=vi,A=A+1|0}while(8!=(0|A));A=0;do{h=0|fi[(Q=i+1024+(32+(F=A<<1)<<3)|0)>>2],Q=0|fi[Q+4>>2],C=0|JI(0|fi[i+1024+(F<<3)>>2],0|fi[i+1024+(F<<3)+4>>2],h,Q),B=vi,c=0|Ee(fi[(c=i+1024+(F+96<<3)|0)>>2]^C,fi[c+4>>2]^B,32),y=vi,y=0|Ee(c^(B=0|JI(C,B,Q=0|Ee(h^(a=0|JI(0|fi[(a=i+1024+(F+64<<3)|0)>>2],0|fi[a+4>>2],c,y)),Q^(w=vi),24),h=vi)),y^(C=vi),16),c=vi,fi[(f=i+1024+(F+96<<3)|0)>>2]=y,fi[f+4>>2]=c,w=0|JI(a,w,y,c),a=vi,fi[(f=i+1024+(F+64<<3)|0)>>2]=w,fi[f+4>>2]=a,a=0|Ee(Q^w,h^a,63),fi[(h=i+1024+(F+32<<3)|0)>>2]=a,fi[h+4>>2]=vi,a=0|fi[(h=i+1024+(F+33<<3)|0)>>2],h=0|fi[h+4>>2],w=0|JI(0|fi[i+1024+((1|F)<<3)>>2],0|fi[i+1024+((1|F)<<3)+4>>2],a,h),Q=vi,f=0|Ee(fi[(f=i+1024+(F+97<<3)|0)>>2]^w,fi[f+4>>2]^Q,32),d=vi,k=0|JI(o=0|JI(0|fi[(o=i+1024+(F+65<<3)|0)>>2],0|fi[o+4>>2],f,d),k=vi,d=0|Ee(f^(Q=0|JI(w,Q,h=0|Ee(a^o,h^k,24),a=vi)),d^(w=vi),16),f=vi),o=vi,fi[(p=i+1024+(F+65<<3)|0)>>2]=k,fi[p+4>>2]=o,o=0|Ee(h^k,a^o,63),a=vi,k=i+1024+(F+16<<3)|0,p=0|fi[(h=i+1024+(F+48<<3)|0)>>2],h=0|fi[h+4>>2],k=0|JI(0|fi[k>>2],0|fi[k+4>>2],p,h),_=vi,l=0|Ee(fi[(l=i+1024+(F+112<<3)|0)>>2]^k,fi[l+4>>2]^_,32),b=vi,p=0|Ee((h=0|Ee(p^(t=0|JI(0|fi[(t=i+1024+(F+80<<3)|0)>>2],0|fi[t+4>>2],l,b)),h^(r=vi),24))^(r=0|JI(t,r,b=0|Ee(l^(_=0|JI(k,_,h,p=vi)),b^(k=vi),16),l=vi)),p^(t=vi),63),h=vi,G=i+1024+(F+17<<3)|0,v=0|fi[(D=i+1024+(F+49<<3)|0)>>2],D=0|fi[D+4>>2],G=0|JI(0|fi[G>>2],0|fi[G+4>>2],v,D),u=vi,I=0|Ee(fi[(I=i+1024+(F+113<<3)|0)>>2]^G,fi[I+4>>2]^u,32),n=vi,v=0|Ee((D=0|Ee(v^(E=0|JI(0|fi[(E=i+1024+(F+81<<3)|0)>>2],0|fi[E+4>>2],I,n)),D^(s=vi),24))^(s=0|JI(E,s,n=0|Ee(I^(u=0|JI(G,u,D,v=vi)),n^(G=vi),16),I=vi)),v^(E=vi),63),D=vi,B=0|JI(C=0|JI(B,C,o,a),B=vi,a=0|Ee(o^(t=0|JI(r,t,I=0|Ee(n^C,I^B,32),n=vi)),a^(r=vi),24),o=vi),C=vi,fi[i+1024+(F<<3)>>2]=B,fi[i+1024+(F<<3)+4>>2]=C,C=0|Ee(I^B,n^C,16),n=vi,fi[(B=i+1024+(F+113<<3)|0)>>2]=C,fi[B+4>>2]=n,n=0|JI(t,r,C,n),C=vi,fi[(r=i+1024+(F+80<<3)|0)>>2]=n,fi[r+4>>2]=C,C=0|Ee(a^n,o^C,63),fi[(o=i+1024+(F+33<<3)|0)>>2]=C,fi[o+4>>2]=vi,Q=0|JI(w=0|JI(Q,w,p,h),Q=vi,h=0|Ee(p^(E=0|JI(s,E,c=0|Ee(y^w,c^Q,32),y=vi)),h^(s=vi),24),p=vi),w=vi,fi[i+1024+((1|F)<<3)>>2]=Q,fi[i+1024+((1|F)<<3)+4>>2]=w,w=0|Ee(c^Q,y^w,16),y=vi,fi[(Q=i+1024+(F+96<<3)|0)>>2]=w,fi[Q+4>>2]=y,y=0|JI(E,s,w,y),w=vi,fi[(s=i+1024+(F+81<<3)|0)>>2]=y,fi[s+4>>2]=w,w=0|Ee(h^y,p^w,63),fi[(p=i+1024+(F+48<<3)|0)>>2]=w,fi[p+4>>2]=vi,f=0|Ee(d^(k=0|JI(_,k,v,D)),f^(_=vi),32),d=vi,_=0|JI(k,_,D=0|Ee(v^(p=0|JI(0|fi[(p=i+1024+(F+64<<3)|0)>>2],0|fi[p+4>>2],f,d)),D^(w=vi),24),v=vi),k=vi,fi[(y=i+1024+(F+16<<3)|0)>>2]=_,fi[y+4>>2]=k,k=0|Ee(f^_,d^k,16),d=vi,fi[(_=i+1024+(F+97<<3)|0)>>2]=k,fi[_+4>>2]=d,d=0|JI(p,w,k,d),k=vi,fi[(w=i+1024+(F+64<<3)|0)>>2]=d,fi[w+4>>2]=k,k=0|Ee(D^d,v^k,63),fi[(v=i+1024+(F+49<<3)|0)>>2]=k,fi[v+4>>2]=vi,l=0|Ee(b^(G=0|JI(u,G,k=0|fi[(v=i+1024+(F+32<<3)|0)>>2],v=0|fi[v+4>>2])),l^(u=vi),32),b=vi,u=0|JI(G,u,v=0|Ee(k^(d=0|JI(0|fi[(d=i+1024+(F+65<<3)|0)>>2],0|fi[d+4>>2],l,b)),v^(D=vi),24),k=vi),G=vi,fi[(w=i+1024+(F+17<<3)|0)>>2]=u,fi[w+4>>2]=G,G=0|Ee(l^u,b^G,16),b=vi,fi[(u=i+1024+(F+112<<3)|0)>>2]=G,fi[u+4>>2]=b,b=0|JI(d,D,G,b),G=vi,fi[(D=i+1024+(F+65<<3)|0)>>2]=b,fi[D+4>>2]=G,G=0|Ee(v^b,k^G,63),fi[(F=i+1024+(F+32<<3)|0)>>2]=G,fi[F+4>>2]=vi,A=A+1|0}while(8!=(0|A));Og(e,i),RI(e,i+1024|0),wi=g}function C(A,I,e){A|=0,e|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0;g=wi,i=wi=wi+63&-64,wi=wi+2048|0,Og(i+1024|0,I|=0),RI(i+1024|0,A),Og(i,i+1024|0),A=0;do{f=0|fi[i+1024+((4|(I=A<<4))<<3)>>2],w=0|fi[i+1024+((4|I)<<3)+4>>2],u=0|JI(0|fi[i+1024+(I<<3)>>2],0|fi[i+1024+(I<<3)+4>>2],f,w),G=vi,l=0|Ee(fi[i+1024+((12|I)<<3)>>2]^u,fi[i+1024+((12|I)<<3)+4>>2]^G,32),y=vi,y=0|Ee(l^(G=0|JI(u,G,w=0|Ee(f^(v=0|JI(0|fi[i+1024+((8|I)<<3)>>2],0|fi[i+1024+((8|I)<<3)+4>>2],l,y)),w^(E=vi),24),f=vi)),y^(u=vi),16),l=vi,fi[i+1024+((12|I)<<3)>>2]=y,fi[i+1024+((12|I)<<3)+4>>2]=l,E=0|JI(v,E,y,l),v=vi,fi[i+1024+((8|I)<<3)>>2]=E,fi[i+1024+((8|I)<<3)+4>>2]=v,v=0|Ee(w^E,f^v,63),fi[i+1024+((4|I)<<3)>>2]=v,fi[i+1024+((4|I)<<3)+4>>2]=vi,v=0|fi[i+1024+((5|I)<<3)>>2],f=0|fi[i+1024+((5|I)<<3)+4>>2],E=0|JI(0|fi[i+1024+((1|I)<<3)>>2],0|fi[i+1024+((1|I)<<3)+4>>2],v,f),w=vi,h=0|Ee(fi[i+1024+((13|I)<<3)>>2]^E,fi[i+1024+((13|I)<<3)+4>>2]^w,32),C=vi,Q=0|JI(d=0|JI(0|fi[i+1024+((9|I)<<3)>>2],0|fi[i+1024+((9|I)<<3)+4>>2],h,C),Q=vi,C=0|Ee(h^(w=0|JI(E,w,f=0|Ee(v^d,f^Q,24),v=vi)),C^(E=vi),16),h=vi),d=vi,fi[i+1024+((9|I)<<3)>>2]=Q,fi[i+1024+((9|I)<<3)+4>>2]=d,d=0|Ee(f^Q,v^d,63),v=vi,Q=0|fi[i+1024+((6|I)<<3)>>2],f=0|fi[i+1024+((6|I)<<3)+4>>2],t=0|JI(0|fi[i+1024+((2|I)<<3)>>2],0|fi[i+1024+((2|I)<<3)+4>>2],Q,f),s=vi,c=0|Ee(fi[i+1024+((14|I)<<3)>>2]^t,fi[i+1024+((14|I)<<3)+4>>2]^s,32),r=vi,Q=0|Ee((f=0|Ee(Q^(k=0|JI(0|fi[i+1024+((10|I)<<3)>>2],0|fi[i+1024+((10|I)<<3)+4>>2],c,r)),f^(b=vi),24))^(b=0|JI(k,b,r=0|Ee(c^(s=0|JI(t,s,f,Q=vi)),r^(t=vi),16),c=vi)),Q^(k=vi),63),f=vi,a=0|fi[i+1024+((7|I)<<3)>>2],n=0|fi[i+1024+((7|I)<<3)+4>>2],B=0|JI(0|fi[i+1024+((3|I)<<3)>>2],0|fi[i+1024+((3|I)<<3)+4>>2],a,n),o=vi,F=0|Ee(fi[i+1024+((15|I)<<3)>>2]^B,fi[i+1024+((15|I)<<3)+4>>2]^o,32),D=vi,a=0|Ee((n=0|Ee(a^(p=0|JI(0|fi[i+1024+((11|I)<<3)>>2],0|fi[i+1024+((11|I)<<3)+4>>2],F,D)),n^(_=vi),24))^(_=0|JI(p,_,D=0|Ee(F^(o=0|JI(B,o,n,a=vi)),D^(B=vi),16),F=vi)),a^(p=vi),63),n=vi,G=0|JI(u=0|JI(G,u,d,v),G=vi,v=0|Ee(d^(k=0|JI(b,k,F=0|Ee(D^u,F^G,32),D=vi)),v^(b=vi),24),d=vi),u=vi,fi[i+1024+(I<<3)>>2]=G,fi[i+1024+(I<<3)+4>>2]=u,u=0|Ee(F^G,D^u,16),D=vi,fi[i+1024+((15|I)<<3)>>2]=u,fi[i+1024+((15|I)<<3)+4>>2]=D,D=0|JI(k,b,u,D),u=vi,fi[i+1024+((10|I)<<3)>>2]=D,fi[i+1024+((10|I)<<3)+4>>2]=u,u=0|Ee(v^D,d^u,63),fi[i+1024+((5|I)<<3)>>2]=u,fi[i+1024+((5|I)<<3)+4>>2]=vi,w=0|JI(E=0|JI(w,E,Q,f),w=vi,f=0|Ee(Q^(p=0|JI(_,p,l=0|Ee(y^E,l^w,32),y=vi)),f^(_=vi),24),Q=vi),E=vi,fi[i+1024+((1|I)<<3)>>2]=w,fi[i+1024+((1|I)<<3)+4>>2]=E,E=0|Ee(l^w,y^E,16),y=vi,fi[i+1024+((12|I)<<3)>>2]=E,fi[i+1024+((12|I)<<3)+4>>2]=y,y=0|JI(p,_,E,y),E=vi,fi[i+1024+((11|I)<<3)>>2]=y,fi[i+1024+((11|I)<<3)+4>>2]=E,E=0|Ee(f^y,Q^E,63),fi[i+1024+((6|I)<<3)>>2]=E,fi[i+1024+((6|I)<<3)+4>>2]=vi,h=0|Ee(C^(t=0|JI(s,t,a,n)),h^(s=vi),32),C=vi,s=0|JI(t,s,n=0|Ee(a^(E=0|JI(0|fi[i+1024+((8|I)<<3)>>2],0|fi[i+1024+((8|I)<<3)+4>>2],h,C)),n^(Q=vi),24),a=vi),t=vi,fi[i+1024+((2|I)<<3)>>2]=s,fi[i+1024+((2|I)<<3)+4>>2]=t,t=0|Ee(h^s,C^t,16),C=vi,fi[i+1024+((13|I)<<3)>>2]=t,fi[i+1024+((13|I)<<3)+4>>2]=C,C=0|JI(E,Q,t,C),t=vi,fi[i+1024+((8|I)<<3)>>2]=C,fi[i+1024+((8|I)<<3)+4>>2]=t,t=0|Ee(n^C,a^t,63),fi[i+1024+((7|I)<<3)>>2]=t,fi[i+1024+((7|I)<<3)+4>>2]=vi,c=0|Ee(r^(B=0|JI(o,B,t=0|fi[i+1024+((4|I)<<3)>>2],a=0|fi[i+1024+((4|I)<<3)+4>>2])),c^(o=vi),32),r=vi,o=0|JI(B,o,a=0|Ee(t^(C=0|JI(0|fi[i+1024+((9|I)<<3)>>2],0|fi[i+1024+((9|I)<<3)+4>>2],c,r)),a^(n=vi),24),t=vi),B=vi,fi[i+1024+((3|I)<<3)>>2]=o,fi[i+1024+((3|I)<<3)+4>>2]=B,B=0|Ee(c^o,r^B,16),r=vi,fi[i+1024+((14|I)<<3)>>2]=B,fi[i+1024+((14|I)<<3)+4>>2]=r,r=0|JI(C,n,B,r),B=vi,fi[i+1024+((9|I)<<3)>>2]=r,fi[i+1024+((9|I)<<3)+4>>2]=B,B=0|Ee(a^r,t^B,63),fi[i+1024+((4|I)<<3)>>2]=B,fi[i+1024+((4|I)<<3)+4>>2]=vi,A=A+1|0}while(8!=(0|A));A=0;do{h=0|fi[(Q=i+1024+(32+(F=A<<1)<<3)|0)>>2],Q=0|fi[Q+4>>2],C=0|JI(0|fi[i+1024+(F<<3)>>2],0|fi[i+1024+(F<<3)+4>>2],h,Q),B=vi,c=0|Ee(fi[(c=i+1024+(F+96<<3)|0)>>2]^C,fi[c+4>>2]^B,32),y=vi,y=0|Ee(c^(B=0|JI(C,B,Q=0|Ee(h^(a=0|JI(0|fi[(a=i+1024+(F+64<<3)|0)>>2],0|fi[a+4>>2],c,y)),Q^(w=vi),24),h=vi)),y^(C=vi),16),c=vi,fi[(f=i+1024+(F+96<<3)|0)>>2]=y,fi[f+4>>2]=c,w=0|JI(a,w,y,c),a=vi,fi[(f=i+1024+(F+64<<3)|0)>>2]=w,fi[f+4>>2]=a,a=0|Ee(Q^w,h^a,63),fi[(h=i+1024+(F+32<<3)|0)>>2]=a,fi[h+4>>2]=vi,a=0|fi[(h=i+1024+(F+33<<3)|0)>>2],h=0|fi[h+4>>2],w=0|JI(0|fi[i+1024+((1|F)<<3)>>2],0|fi[i+1024+((1|F)<<3)+4>>2],a,h),Q=vi,f=0|Ee(fi[(f=i+1024+(F+97<<3)|0)>>2]^w,fi[f+4>>2]^Q,32),d=vi,k=0|JI(o=0|JI(0|fi[(o=i+1024+(F+65<<3)|0)>>2],0|fi[o+4>>2],f,d),k=vi,d=0|Ee(f^(Q=0|JI(w,Q,h=0|Ee(a^o,h^k,24),a=vi)),d^(w=vi),16),f=vi),o=vi,fi[(p=i+1024+(F+65<<3)|0)>>2]=k,fi[p+4>>2]=o,o=0|Ee(h^k,a^o,63),a=vi,k=i+1024+(F+16<<3)|0,p=0|fi[(h=i+1024+(F+48<<3)|0)>>2],h=0|fi[h+4>>2],k=0|JI(0|fi[k>>2],0|fi[k+4>>2],p,h),_=vi,l=0|Ee(fi[(l=i+1024+(F+112<<3)|0)>>2]^k,fi[l+4>>2]^_,32),b=vi,p=0|Ee((h=0|Ee(p^(t=0|JI(0|fi[(t=i+1024+(F+80<<3)|0)>>2],0|fi[t+4>>2],l,b)),h^(r=vi),24))^(r=0|JI(t,r,b=0|Ee(l^(_=0|JI(k,_,h,p=vi)),b^(k=vi),16),l=vi)),p^(t=vi),63),h=vi,G=i+1024+(F+17<<3)|0,v=0|fi[(D=i+1024+(F+49<<3)|0)>>2],D=0|fi[D+4>>2],G=0|JI(0|fi[G>>2],0|fi[G+4>>2],v,D),u=vi,I=0|Ee(fi[(I=i+1024+(F+113<<3)|0)>>2]^G,fi[I+4>>2]^u,32),n=vi,v=0|Ee((D=0|Ee(v^(E=0|JI(0|fi[(E=i+1024+(F+81<<3)|0)>>2],0|fi[E+4>>2],I,n)),D^(s=vi),24))^(s=0|JI(E,s,n=0|Ee(I^(u=0|JI(G,u,D,v=vi)),n^(G=vi),16),I=vi)),v^(E=vi),63),D=vi,B=0|JI(C=0|JI(B,C,o,a),B=vi,a=0|Ee(o^(t=0|JI(r,t,I=0|Ee(n^C,I^B,32),n=vi)),a^(r=vi),24),o=vi),C=vi,fi[i+1024+(F<<3)>>2]=B,fi[i+1024+(F<<3)+4>>2]=C,C=0|Ee(I^B,n^C,16),n=vi,fi[(B=i+1024+(F+113<<3)|0)>>2]=C,fi[B+4>>2]=n,n=0|JI(t,r,C,n),C=vi,fi[(r=i+1024+(F+80<<3)|0)>>2]=n,fi[r+4>>2]=C,C=0|Ee(a^n,o^C,63),fi[(o=i+1024+(F+33<<3)|0)>>2]=C,fi[o+4>>2]=vi,Q=0|JI(w=0|JI(Q,w,p,h),Q=vi,h=0|Ee(p^(E=0|JI(s,E,c=0|Ee(y^w,c^Q,32),y=vi)),h^(s=vi),24),p=vi),w=vi,fi[i+1024+((1|F)<<3)>>2]=Q,fi[i+1024+((1|F)<<3)+4>>2]=w,w=0|Ee(c^Q,y^w,16),y=vi,fi[(Q=i+1024+(F+96<<3)|0)>>2]=w,fi[Q+4>>2]=y,y=0|JI(E,s,w,y),w=vi,fi[(s=i+1024+(F+81<<3)|0)>>2]=y,fi[s+4>>2]=w,w=0|Ee(h^y,p^w,63),fi[(p=i+1024+(F+48<<3)|0)>>2]=w,fi[p+4>>2]=vi,f=0|Ee(d^(k=0|JI(_,k,v,D)),f^(_=vi),32),d=vi,_=0|JI(k,_,D=0|Ee(v^(p=0|JI(0|fi[(p=i+1024+(F+64<<3)|0)>>2],0|fi[p+4>>2],f,d)),D^(w=vi),24),v=vi),k=vi,fi[(y=i+1024+(F+16<<3)|0)>>2]=_,fi[y+4>>2]=k,k=0|Ee(f^_,d^k,16),d=vi,fi[(_=i+1024+(F+97<<3)|0)>>2]=k,fi[_+4>>2]=d,d=0|JI(p,w,k,d),k=vi,fi[(w=i+1024+(F+64<<3)|0)>>2]=d,fi[w+4>>2]=k,k=0|Ee(D^d,v^k,63),fi[(v=i+1024+(F+49<<3)|0)>>2]=k,fi[v+4>>2]=vi,l=0|Ee(b^(G=0|JI(u,G,k=0|fi[(v=i+1024+(F+32<<3)|0)>>2],v=0|fi[v+4>>2])),l^(u=vi),32),b=vi,u=0|JI(G,u,v=0|Ee(k^(d=0|JI(0|fi[(d=i+1024+(F+65<<3)|0)>>2],0|fi[d+4>>2],l,b)),v^(D=vi),24),k=vi),G=vi,fi[(w=i+1024+(F+17<<3)|0)>>2]=u,fi[w+4>>2]=G,G=0|Ee(l^u,b^G,16),b=vi,fi[(u=i+1024+(F+112<<3)|0)>>2]=G,fi[u+4>>2]=b,b=0|JI(d,D,G,b),G=vi,fi[(D=i+1024+(F+65<<3)|0)>>2]=b,fi[D+4>>2]=G,G=0|Ee(v^b,k^G,63),fi[(F=i+1024+(F+32<<3)|0)>>2]=G,fi[F+4>>2]=vi,A=A+1|0}while(8!=(0|A));Og(e,i),RI(e,i+1024|0),wi=g}function o(A,I){A|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0,P=0,L=0,x=0,X=0,K=0,T=0,V=0,q=0,j=0,Z=0,W=0,z=0,O=0,$=0,AA=0,IA=0,eA=0,gA=0,iA=0,BA=0,tA=0,rA=0,aA=0,nA=0,CA=0,oA=0,cA=0,QA=0,EA=0,sA=0,hA=0,yA=0,fA=0,_A=0,pA=0,wA=0,lA=0,uA=0,dA=0,DA=0,vA=0,bA=0,kA=0,GA=0,FA=0,mA=0,MA=0,HA=0,YA=0,SA=0,RA=0,NA=0,UA=0,JA=0,PA=0,LA=0,xA=0,XA=0,KA=0,TA=0,VA=0,qA=0,jA=0,ZA=0,WA=0,zA=0,OA=0,$A=0,AI=0,II=0,eI=0;C=0|fi[(I|=0)>>2],c=0|fi[I+4>>2],n=0|fi[I+8>>2],i=0|fi[I+12>>2],_=0|fi[I+16>>2],f=0|fi[I+20>>2],B=0|fi[I+24>>2],p=0|fi[I+28>>2],y=0|fi[I+32>>2],s=0|fi[I+36>>2],AI=0|he(0|C,((0|C)<0)<<31>>31|0,0|C,((0|C)<0)<<31>>31|0),$A=vi,KA=0|he(C<<1|0,0|(Q=((C<<1|0)<0)<<31>>31),0|c,((0|c)<0)<<31>>31|0),XA=vi,UA=0|he(0|n,((0|n)<0)<<31>>31|0,C<<1|0,0|Q),NA=vi,kA=0|he(0|i,((0|i)<0)<<31>>31|0,C<<1|0,0|Q),bA=vi,hA=0|he(0|_,((0|_)<0)<<31>>31|0,C<<1|0,0|Q),sA=vi,tA=0|he(0|f,((0|f)<0)<<31>>31|0,C<<1|0,0|Q),BA=vi,W=0|he(0|B,((0|B)<0)<<31>>31|0,C<<1|0,0|Q),Z=vi,P=0|he(0|p,((0|p)<0)<<31>>31|0,C<<1|0,0|Q),J=vi,F=0|he(0|y,((0|y)<0)<<31>>31|0,C<<1|0,0|Q),G=vi,Q=0|he(0|s,((0|s)<0)<<31>>31|0,C<<1|0,0|Q),C=vi,RA=0|he(c<<1|0,0|(E=((c<<1|0)<0)<<31>>31),0|c,((0|c)<0)<<31>>31|0),SA=vi,vA=0|he(c<<1|0,0|E,0|n,((0|n)<0)<<31>>31|0),DA=vi,pA=0|he(i<<1|0,0|(w=((i<<1|0)<0)<<31>>31),c<<1|0,0|E),_A=vi,CA=0|he(0|_,((0|_)<0)<<31>>31|0,c<<1|0,0|E),nA=vi,O=0|he(f<<1|0,((f<<1|0)<0)<<31>>31|0,c<<1|0,0|E),z=vi,x=0|he(0|B,((0|B)<0)<<31>>31|0,c<<1|0,0|E),L=vi,M=0|he(p<<1|0,((p<<1|0)<0)<<31>>31|0,c<<1|0,0|E),m=vi,o=0|he(0|y,((0|y)<0)<<31>>31|0,c<<1|0,0|E),h=vi,E=0|he(38*s|0,0|(I=((38*s|0)<0)<<31>>31),c<<1|0,0|E),c=vi,fA=0|he(0|n,((0|n)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),yA=vi,aA=0|he(n<<1|0,((n<<1|0)<0)<<31>>31|0,0|i,((0|i)<0)<<31>>31|0),rA=vi,AA=0|he(0|_,((0|_)<0)<<31>>31|0,n<<1|0,((n<<1|0)<0)<<31>>31|0),$=vi,V=0|he(0|f,((0|f)<0)<<31>>31|0,n<<1|0,((n<<1|0)<0)<<31>>31|0),T=vi,U=0|he(0|B,((0|B)<0)<<31>>31|0,n<<1|0,((n<<1|0)<0)<<31>>31|0),N=vi,d=0|he(0|p,((0|p)<0)<<31>>31|0,n<<1|0,((n<<1|0)<0)<<31>>31|0),u=vi,jA=0|he(19*y|0,0|(j=((19*y|0)<0)<<31>>31),n<<1|0,((n<<1|0)<0)<<31>>31|0),qA=vi,n=0|he(38*s|0,0|I,0|n,((0|n)<0)<<31>>31|0),a=vi,eA=0|he(i<<1|0,0|w,0|i,((0|i)<0)<<31>>31|0),IA=vi,K=0|he(i<<1|0,0|w,0|_,((0|_)<0)<<31>>31|0),X=vi,Y=0|he(f<<1|0,((f<<1|0)<0)<<31>>31|0,i<<1|0,0|w),H=vi,k=0|he(0|B,((0|B)<0)<<31>>31|0,i<<1|0,0|w),b=vi,WA=0|he(38*p|0,0|(EA=((38*p|0)<0)<<31>>31),i<<1|0,0|w),ZA=vi,PA=0|he(19*y|0,0|j,i<<1|0,0|w),JA=vi,w=0|he(38*s|0,0|I,i<<1|0,0|w),i=vi,R=0|he(0|_,((0|_)<0)<<31>>31|0,0|_,((0|_)<0)<<31>>31|0),S=vi,v=0|he(_<<1|0,((_<<1|0)<0)<<31>>31|0,0|f,((0|f)<0)<<31>>31|0),D=vi,OA=0|he(19*B|0,((19*B|0)<0)<<31>>31|0,_<<1|0,((_<<1|0)<0)<<31>>31|0),zA=vi,xA=0|he(38*p|0,0|EA,0|_,((0|_)<0)<<31>>31|0),LA=vi,FA=0|he(19*y|0,0|j,_<<1|0,((_<<1|0)<0)<<31>>31|0),GA=vi,_=0|he(38*s|0,0|I,0|_,((0|_)<0)<<31>>31|0),g=vi,eI=0|he(38*f|0,((38*f|0)<0)<<31>>31|0,0|f,((0|f)<0)<<31>>31|0),II=vi,VA=0|he(19*B|0,((19*B|0)<0)<<31>>31|0,f<<1|0,((f<<1|0)<0)<<31>>31|0),TA=vi,MA=0|he(38*p|0,0|EA,f<<1|0,((f<<1|0)<0)<<31>>31|0),mA=vi,lA=0|he(19*y|0,0|j,f<<1|0,((f<<1|0)<0)<<31>>31|0),wA=vi,f=0|he(38*s|0,0|I,f<<1|0,((f<<1|0)<0)<<31>>31|0),e=vi,YA=0|he(19*B|0,((19*B|0)<0)<<31>>31|0,0|B,((0|B)<0)<<31>>31|0),HA=vi,dA=0|he(38*p|0,0|EA,0|B,((0|B)<0)<<31>>31|0),uA=vi,cA=0|he(19*y|0,0|j,B<<1|0,((B<<1|0)<0)<<31>>31|0),oA=vi,B=0|he(38*s|0,0|I,0|B,((0|B)<0)<<31>>31|0),l=vi,EA=0|he(38*p|0,0|EA,0|p,((0|p)<0)<<31>>31|0),QA=vi,iA=0|he(19*y|0,0|j,p<<1|0,((p<<1|0)<0)<<31>>31|0),gA=vi,p=0|he(38*s|0,0|I,p<<1|0,((p<<1|0)<0)<<31>>31|0),r=vi,j=0|he(19*y|0,0|j,0|y,((0|y)<0)<<31>>31|0),q=vi,y=0|he(38*s|0,0|I,0|y,((0|y)<0)<<31>>31|0),t=vi,s=0|he(38*s|0,0|I,0|s,((0|s)<0)<<31>>31|0),I=vi,c=0|Ig(0|(qA=0|Ig(0|(ZA=0|Ig(0|(zA=0|Ig(0|($A=0|Ig(0|eI,0|II,0|AI,0|$A)),0|vi,0|OA,0|zA)),0|vi,0|WA,0|ZA)),0|vi,0|jA,0|qA)),0|vi,0|E,0|c),E=vi,a=0|Ig(0|(JA=0|Ig(0|(LA=0|Ig(0|(XA=0|Ig(0|VA,0|TA,0|KA,0|XA)),0|vi,0|xA,0|LA)),0|vi,0|PA,0|JA)),0|vi,0|n,0|a),n=vi,i=0|Ig(0|(GA=0|Ig(0|(mA=0|Ig(0|(HA=0|Ig(0|(SA=0|Ig(0|UA,0|NA,0|RA,0|SA)),0|vi,0|YA,0|HA)),0|vi,0|MA,0|mA)),0|vi,0|FA,0|GA)),0|vi,0|w,0|i),w=vi,g=0|Ig(0|(wA=0|Ig(0|(uA=0|Ig(0|(DA=0|Ig(0|kA,0|bA,0|vA,0|DA)),0|vi,0|dA,0|uA)),0|vi,0|lA,0|wA)),0|vi,0|_,0|g),_=vi,e=0|Ig(0|(oA=0|Ig(0|(QA=0|Ig(0|(sA=0|Ig(0|(yA=0|Ig(0|pA,0|_A,0|fA,0|yA)),0|vi,0|hA,0|sA)),0|vi,0|EA,0|QA)),0|vi,0|cA,0|oA)),0|vi,0|f,0|e),f=vi,l=0|Ig(0|(gA=0|Ig(0|(BA=0|Ig(0|(rA=0|Ig(0|CA,0|nA,0|aA,0|rA)),0|vi,0|tA,0|BA)),0|vi,0|iA,0|gA)),0|vi,0|B,0|l),B=vi,r=0|Ig(0|(q=0|Ig(0|(Z=0|Ig(0|(z=0|Ig(0|($=0|Ig(0|eA,0|IA,0|AA,0|$)),0|vi,0|O,0|z)),0|vi,0|W,0|Z)),0|vi,0|j,0|q)),0|vi,0|p,0|r),p=vi,t=0|Ig(0|(J=0|Ig(0|(L=0|Ig(0|(X=0|Ig(0|V,0|T,0|K,0|X)),0|vi,0|x,0|L)),0|vi,0|P,0|J)),0|vi,0|y,0|t),y=vi,I=0|Ig(0|(G=0|Ig(0|(m=0|Ig(0|(H=0|Ig(0|(S=0|Ig(0|U,0|N,0|R,0|S)),0|vi,0|Y,0|H)),0|vi,0|M,0|m)),0|vi,0|F,0|G)),0|vi,0|s,0|I),s=vi,C=0|Ig(0|(h=0|Ig(0|(u=0|Ig(0|(D=0|Ig(0|k,0|b,0|v,0|D)),0|vi,0|d,0|u)),0|vi,0|o,0|h)),0|vi,0|Q,0|C),Q=vi,E=0|Se(0|c,0|E,1),c=vi,n=0|Se(0|a,0|n,1),a=vi,w=0|Se(0|i,0|w,1),i=vi,_=0|Se(0|g,0|_,1),g=vi,f=0|Se(0|e,0|f,1),e=vi,B=0|Se(0|l,0|B,1),l=vi,p=0|Se(0|r,0|p,1),r=vi,y=0|Se(0|t,0|y,1),t=vi,s=0|Se(0|I,0|s,1),I=vi,Q=0|Se(0|C,0|Q,1),C=vi,a=0|Ig(0|(h=0|be(0|(h=0|Ig(0|E,0|c,33554432,0)),0|vi,26)),0|(o=vi),0|n,0|a),n=vi,o=0|Ag(0|E,0|c,0|(o=0|Se(0|h,0|o,26)),0|vi),c=vi,l=0|Ig(0|(E=0|be(0|(E=0|Ig(0|f,0|e,33554432,0)),0|vi,26)),0|(h=vi),0|B,0|l),B=vi,h=0|Ag(0|f,0|e,0|(h=0|Se(0|E,0|h,26)),0|vi),e=vi,i=0|Ig(0|(f=0|be(0|(f=0|Ig(0|a,0|n,16777216,0)),0|vi,25)),0|(E=vi),0|w,0|i),w=vi,E=0|Ag(0|a,0|n,0|(E=0|Se(0|f,0|E,25)),0|vi),n=vi,r=0|Ig(0|(a=0|be(0|(a=0|Ig(0|l,0|B,16777216,0)),0|vi,25)),0|(f=vi),0|p,0|r),p=vi,f=0|Ag(0|l,0|B,0|(f=0|Se(0|a,0|f,25)),0|vi),B=vi,g=0|Ig(0|(l=0|be(0|(l=0|Ig(0|i,0|w,33554432,0)),0|vi,26)),0|(a=vi),0|_,0|g),_=vi,a=0|Ag(0|i,0|w,0|(a=0|Se(0|l,0|a,26)),0|vi),t=0|Ig(0|(w=0|be(0|(w=0|Ig(0|r,0|p,33554432,0)),0|vi,26)),0|(i=vi),0|y,0|t),y=vi,i=0|Ag(0|r,0|p,0|(i=0|Se(0|w,0|i,26)),0|vi),e=0|Ig(0|(p=0|be(0|(p=0|Ig(0|g,0|_,16777216,0)),0|vi,25)),0|(r=vi),0|h,0|e),h=vi,r=0|Ag(0|g,0|_,0|(r=0|Se(0|p,0|r,25)),0|vi),I=0|Ig(0|(_=0|be(0|(_=0|Ig(0|t,0|y,16777216,0)),0|vi,25)),0|(g=vi),0|s,0|I),s=vi,g=0|Ag(0|t,0|y,0|(g=0|Se(0|_,0|g,25)),0|vi),B=0|Ig(0|f,0|B,0|(y=0|be(0|(y=0|Ig(0|e,0|h,33554432,0)),0|vi,26)),0|(t=vi)),t=0|Ag(0|e,0|h,0|(t=0|Se(0|y,0|t,26)),0|vi),C=0|Ig(0|(h=0|be(0|(h=0|Ig(0|I,0|s,33554432,0)),0|vi,26)),0|(e=vi),0|Q,0|C),Q=vi,e=0|Ag(0|I,0|s,0|(e=0|Se(0|h,0|e,26)),0|vi),c=0|Ig(0|(h=0|he(0|(s=0|be(0|(s=0|Ig(0|C,0|Q,16777216,0)),0|vi,25)),0|(I=vi),19,0)),0|vi,0|o,0|c),o=vi,I=0|Ag(0|C,0|Q,0|(I=0|Se(0|s,0|I,25)),0|vi),n=0|Ig(0|E,0|n,0|(Q=0|be(0|(Q=0|Ig(0|c,0|o,33554432,0)),0|vi,26)),0|(C=vi)),C=0|Ag(0|c,0|o,0|(C=0|Se(0|Q,0|C,26)),0|vi),fi[A>>2]=C,fi[A+4>>2]=n,fi[A+8>>2]=a,fi[A+12>>2]=r,fi[A+16>>2]=t,fi[A+20>>2]=B,fi[A+24>>2]=i,fi[A+28>>2]=g,fi[A+32>>2]=e,fi[A+36>>2]=I}function c(A,I){A|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0,P=0,L=0,x=0,X=0,K=0,T=0,V=0,q=0,j=0,Z=0,W=0,z=0,O=0,$=0,AA=0,IA=0,eA=0,gA=0,iA=0,BA=0,tA=0,rA=0,aA=0,nA=0,CA=0,oA=0,cA=0,QA=0,EA=0,sA=0,hA=0,yA=0,fA=0,_A=0,pA=0,wA=0,lA=0,uA=0,dA=0,DA=0,vA=0,bA=0,kA=0,GA=0,FA=0,mA=0,MA=0,HA=0,YA=0,SA=0,RA=0,NA=0,UA=0,JA=0,PA=0,LA=0,xA=0,XA=0,KA=0,TA=0,VA=0,qA=0,jA=0,ZA=0,WA=0,zA=0,OA=0,$A=0,AI=0,II=0,eI=0;C=0|fi[(I|=0)>>2],E=0|fi[I+4>>2],n=0|fi[I+8>>2],i=0|fi[I+12>>2],b=0|fi[I+16>>2],e=0|fi[I+20>>2],B=0|fi[I+24>>2],U=0|fi[I+28>>2],D=0|fi[I+32>>2],s=0|fi[I+36>>2],AI=0|he(0|C,((0|C)<0)<<31>>31|0,0|C,((0|C)<0)<<31>>31|0),$A=vi,MA=0|he(C<<1|0,0|(Q=((C<<1|0)<0)<<31>>31),0|E,((0|E)<0)<<31>>31|0),mA=vi,VA=0|he(0|n,((0|n)<0)<<31>>31|0,C<<1|0,0|Q),TA=vi,KA=0|he(0|i,((0|i)<0)<<31>>31|0,C<<1|0,0|Q),XA=vi,UA=0|he(0|b,((0|b)<0)<<31>>31|0,C<<1|0,0|Q),NA=vi,lA=0|he(0|e,((0|e)<0)<<31>>31|0,C<<1|0,0|Q),wA=vi,iA=0|he(0|B,((0|B)<0)<<31>>31|0,C<<1|0,0|Q),gA=vi,L=0|he(0|U,((0|U)<0)<<31>>31|0,C<<1|0,0|Q),P=vi,G=0|he(0|D,((0|D)<0)<<31>>31|0,C<<1|0,0|Q),k=vi,Q=0|he(0|s,((0|s)<0)<<31>>31|0,C<<1|0,0|Q),C=vi,yA=0|he(E<<1|0,0|(c=((E<<1|0)<0)<<31>>31),0|E,((0|E)<0)<<31>>31|0),fA=vi,$=0|he(E<<1|0,0|c,0|n,((0|n)<0)<<31>>31|0),AA=vi,xA=0|he(i<<1|0,0|(J=((i<<1|0)<0)<<31>>31),E<<1|0,0|c),LA=vi,vA=0|he(0|b,((0|b)<0)<<31>>31|0,E<<1|0,0|c),DA=vi,tA=0|he(e<<1|0,((e<<1|0)<0)<<31>>31|0,E<<1|0,0|c),BA=vi,X=0|he(0|B,((0|B)<0)<<31>>31|0,E<<1|0,0|c),x=vi,m=0|he(U<<1|0,((U<<1|0)<0)<<31>>31|0,E<<1|0,0|c),F=vi,f=0|he(0|D,((0|D)<0)<<31>>31|0,E<<1|0,0|c),y=vi,c=0|he(38*s|0,0|(I=((38*s|0)<0)<<31>>31),E<<1|0,0|c),E=vi,PA=0|he(0|n,((0|n)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),JA=vi,dA=0|he(n<<1|0,((n<<1|0)<0)<<31>>31|0,0|i,((0|i)<0)<<31>>31|0),uA=vi,aA=0|he(0|b,((0|b)<0)<<31>>31|0,n<<1|0,((n<<1|0)<0)<<31>>31|0),rA=vi,q=0|he(0|e,((0|e)<0)<<31>>31|0,n<<1|0,((n<<1|0)<0)<<31>>31|0),V=vi,N=0|he(0|B,((0|B)<0)<<31>>31|0,n<<1|0,((n<<1|0)<0)<<31>>31|0),R=vi,p=0|he(0|U,((0|U)<0)<<31>>31|0,n<<1|0,((n<<1|0)<0)<<31>>31|0),_=vi,jA=0|he(19*D|0,0|(eA=((19*D|0)<0)<<31>>31),n<<1|0,((n<<1|0)<0)<<31>>31|0),qA=vi,n=0|he(38*s|0,0|I,0|n,((0|n)<0)<<31>>31|0),a=vi,CA=0|he(i<<1|0,0|J,0|i,((0|i)<0)<<31>>31|0),nA=vi,T=0|he(i<<1|0,0|J,0|b,((0|b)<0)<<31>>31|0),K=vi,H=0|he(e<<1|0,((e<<1|0)<0)<<31>>31|0,i<<1|0,0|J),M=vi,d=0|he(0|B,((0|B)<0)<<31>>31|0,i<<1|0,0|J),u=vi,WA=0|he(38*U|0,0|(RA=((38*U|0)<0)<<31>>31),i<<1|0,0|J),ZA=vi,kA=0|he(19*D|0,0|eA,i<<1|0,0|J),bA=vi,J=0|he(38*s|0,0|I,i<<1|0,0|J),i=vi,S=0|he(0|b,((0|b)<0)<<31>>31|0,0|b,((0|b)<0)<<31>>31|0),Y=vi,l=0|he(b<<1|0,((b<<1|0)<0)<<31>>31|0,0|e,((0|e)<0)<<31>>31|0),w=vi,OA=0|he(19*B|0,((19*B|0)<0)<<31>>31|0,b<<1|0,((b<<1|0)<0)<<31>>31|0),zA=vi,FA=0|he(38*U|0,0|RA,0|b,((0|b)<0)<<31>>31|0),GA=vi,cA=0|he(19*D|0,0|eA,b<<1|0,((b<<1|0)<0)<<31>>31|0),oA=vi,b=0|he(38*s|0,0|I,0|b,((0|b)<0)<<31>>31|0),g=vi,eI=0|he(38*e|0,((38*e|0)<0)<<31>>31|0,0|e,((0|e)<0)<<31>>31|0),II=vi,YA=0|he(19*B|0,((19*B|0)<0)<<31>>31|0,e<<1|0,((e<<1|0)<0)<<31>>31|0),HA=vi,EA=0|he(38*U|0,0|RA,e<<1|0,((e<<1|0)<0)<<31>>31|0),QA=vi,W=0|he(19*D|0,0|eA,e<<1|0,((e<<1|0)<0)<<31>>31|0),Z=vi,e=0|he(38*s|0,0|I,e<<1|0,((e<<1|0)<0)<<31>>31|0),v=vi,hA=0|he(19*B|0,((19*B|0)<0)<<31>>31|0,0|B,((0|B)<0)<<31>>31|0),sA=vi,O=0|he(38*U|0,0|RA,0|B,((0|B)<0)<<31>>31|0),z=vi,o=0|he(19*D|0,0|eA,B<<1|0,((B<<1|0)<0)<<31>>31|0),h=vi,B=0|he(38*s|0,0|I,0|B,((0|B)<0)<<31>>31|0),j=vi,RA=0|he(38*U|0,0|RA,0|U,((0|U)<0)<<31>>31|0),SA=vi,pA=0|he(19*D|0,0|eA,U<<1|0,((U<<1|0)<0)<<31>>31|0),_A=vi,U=0|he(38*s|0,0|I,U<<1|0,((U<<1|0)<0)<<31>>31|0),r=vi,eA=0|he(19*D|0,0|eA,0|D,((0|D)<0)<<31>>31|0),IA=vi,D=0|he(38*s|0,0|I,0|D,((0|D)<0)<<31>>31|0),t=vi,s=0|he(38*s|0,0|I,0|s,((0|s)<0)<<31>>31|0),I=vi,E=0|Ig(0|(qA=0|Ig(0|(ZA=0|Ig(0|(zA=0|Ig(0|($A=0|Ig(0|eI,0|II,0|AI,0|$A)),0|vi,0|OA,0|zA)),0|vi,0|WA,0|ZA)),0|vi,0|jA,0|qA)),0|vi,0|c,0|E),c=vi,fA=0|Ig(0|VA,0|TA,0|yA,0|fA),yA=vi,AA=0|Ig(0|KA,0|XA,0|$,0|AA),$=vi,v=0|Ig(0|(h=0|Ig(0|(SA=0|Ig(0|(NA=0|Ig(0|(JA=0|Ig(0|xA,0|LA,0|PA,0|JA)),0|vi,0|UA,0|NA)),0|vi,0|RA,0|SA)),0|vi,0|o,0|h)),0|vi,0|e,0|v),e=vi,h=0|be(0|(h=0|Ig(0|E,0|c,33554432,0)),0|vi,26),o=vi,a=0|Ig(0|(a=0|Ig(0|(bA=0|Ig(0|(GA=0|Ig(0|(mA=0|Ig(0|YA,0|HA,0|MA,0|mA)),0|vi,0|FA,0|GA)),0|vi,0|kA,0|bA)),0|vi,0|n,0|a)),0|vi,0|h,0|o),n=vi,o=0|Ag(0|E,0|c,0|(o=0|Se(0|h,0|o,26)),0|vi),c=vi,E=0|be(0|(E=0|Ig(0|v,0|e,33554432,0)),0|vi,26),h=vi,j=0|Ig(0|(j=0|Ig(0|(_A=0|Ig(0|(wA=0|Ig(0|(uA=0|Ig(0|vA,0|DA,0|dA,0|uA)),0|vi,0|lA,0|wA)),0|vi,0|pA,0|_A)),0|vi,0|B,0|j)),0|vi,0|E,0|h),B=vi,h=0|Ag(0|v,0|e,0|(h=0|Se(0|E,0|h,26)),0|vi),e=vi,v=0|be(0|(v=0|Ig(0|a,0|n,16777216,0)),0|vi,25),E=vi,i=0|Ig(0|(i=0|Ig(0|(oA=0|Ig(0|(QA=0|Ig(0|(sA=0|Ig(0|fA,0|yA,0|hA,0|sA)),0|vi,0|EA,0|QA)),0|vi,0|cA,0|oA)),0|vi,0|J,0|i)),0|vi,0|v,0|E),J=vi,E=0|Ag(0|a,0|n,0|(E=0|Se(0|v,0|E,25)),0|vi),n=vi,a=0|be(0|(a=0|Ig(0|j,0|B,16777216,0)),0|vi,25),v=vi,r=0|Ig(0|(r=0|Ig(0|(IA=0|Ig(0|(gA=0|Ig(0|(BA=0|Ig(0|(rA=0|Ig(0|CA,0|nA,0|aA,0|rA)),0|vi,0|tA,0|BA)),0|vi,0|iA,0|gA)),0|vi,0|eA,0|IA)),0|vi,0|U,0|r)),0|vi,0|a,0|v),U=vi,v=0|Ag(0|j,0|B,0|(v=0|Se(0|a,0|v,25)),0|vi),B=vi,j=0|be(0|(j=0|Ig(0|i,0|J,33554432,0)),0|vi,26),a=vi,g=0|Ig(0|(g=0|Ig(0|(Z=0|Ig(0|(z=0|Ig(0|AA,0|$,0|O,0|z)),0|vi,0|W,0|Z)),0|vi,0|b,0|g)),0|vi,0|j,0|a),b=vi,a=0|Ag(0|i,0|J,0|(a=0|Se(0|j,0|a,26)),0|vi),J=0|be(0|(J=0|Ig(0|r,0|U,33554432,0)),0|vi,26),i=vi,t=0|Ig(0|(t=0|Ig(0|(P=0|Ig(0|(x=0|Ig(0|(K=0|Ig(0|q,0|V,0|T,0|K)),0|vi,0|X,0|x)),0|vi,0|L,0|P)),0|vi,0|D,0|t)),0|vi,0|J,0|i),D=vi,i=0|Ag(0|r,0|U,0|(i=0|Se(0|J,0|i,26)),0|vi),e=0|Ig(0|(U=0|be(0|(U=0|Ig(0|g,0|b,16777216,0)),0|vi,25)),0|(r=vi),0|h,0|e),h=vi,r=0|Ag(0|g,0|b,0|(r=0|Se(0|U,0|r,25)),0|vi),b=0|be(0|(b=0|Ig(0|t,0|D,16777216,0)),0|vi,25),g=vi,I=0|Ig(0|(I=0|Ig(0|(k=0|Ig(0|(F=0|Ig(0|(M=0|Ig(0|(Y=0|Ig(0|N,0|R,0|S,0|Y)),0|vi,0|H,0|M)),0|vi,0|m,0|F)),0|vi,0|G,0|k)),0|vi,0|s,0|I)),0|vi,0|b,0|g),s=vi,g=0|Ag(0|t,0|D,0|(g=0|Se(0|b,0|g,25)),0|vi),B=0|Ig(0|v,0|B,0|(D=0|be(0|(D=0|Ig(0|e,0|h,33554432,0)),0|vi,26)),0|(t=vi)),t=0|Ag(0|e,0|h,0|(t=0|Se(0|D,0|t,26)),0|vi),h=0|be(0|(h=0|Ig(0|I,0|s,33554432,0)),0|vi,26),e=vi,C=0|Ig(0|(C=0|Ig(0|(y=0|Ig(0|(_=0|Ig(0|(w=0|Ig(0|d,0|u,0|l,0|w)),0|vi,0|p,0|_)),0|vi,0|f,0|y)),0|vi,0|Q,0|C)),0|vi,0|h,0|e),Q=vi,e=0|Ag(0|I,0|s,0|(e=0|Se(0|h,0|e,26)),0|vi),c=0|Ig(0|(h=0|he(0|(s=0|be(0|(s=0|Ig(0|C,0|Q,16777216,0)),0|vi,25)),0|(I=vi),19,0)),0|vi,0|o,0|c),o=vi,I=0|Ag(0|C,0|Q,0|(I=0|Se(0|s,0|I,25)),0|vi),n=0|Ig(0|E,0|n,0|(Q=0|be(0|(Q=0|Ig(0|c,0|o,33554432,0)),0|vi,26)),0|(C=vi)),C=0|Ag(0|c,0|o,0|(C=0|Se(0|Q,0|C,26)),0|vi),fi[A>>2]=C,fi[A+4>>2]=n,fi[A+8>>2]=a,fi[A+12>>2]=r,fi[A+16>>2]=t,fi[A+20>>2]=B,fi[A+24>>2]=i,fi[A+28>>2]=g,fi[A+32>>2]=e,fi[A+36>>2]=I}function Q(A){var I=0,e=0,g=0,i=0,B=0,t=0,r=0,a=0;if(A|=0){I=0|fi[8686],a=A+-8+(-8&(e=0|fi[A+-4>>2]))|0;do{if(1&e)r=A+-8|0,I=-8&e,t=A+-8|0;else{if(g=0|fi[A+-8>>2],!(3&e))return;if(t=A+-8+(0-g)|0,B=g+(-8&e)|0,t>>>0<I>>>0)return;if((0|t)==(0|fi[8687])){if(3!=(3&(A=0|fi[a+4>>2])|0)){r=t,I=B;break}return fi[8684]=B,fi[a+4>>2]=-2&A,fi[t+4>>2]=1|B,void(fi[t+B>>2]=B)}if(g>>>0<256){if(A=0|fi[t+8>>2],(0|(I=0|fi[t+12>>2]))==(0|A)){fi[8682]=fi[8682]&~(1<<(g>>>3)),r=t,I=B;break}fi[A+12>>2]=I,fi[I+8>>2]=A,r=t,I=B;break}i=0|fi[t+24>>2],A=0|fi[t+12>>2];do{if((0|A)==(0|t)){if(A=0|fi[t+16+4>>2])g=t+16+4|0;else{if(!(A=0|fi[t+16>>2])){A=0;break}g=t+16|0}for(;;)if(I=A+20|0,0|(e=0|fi[I>>2]))A=e,g=I;else{if(I=A+16|0,!(e=0|fi[I>>2]))break;A=e,g=I}fi[g>>2]=0}else r=0|fi[t+8>>2],fi[r+12>>2]=A,fi[A+8>>2]=r}while(0);if(i){if(I=0|fi[t+28>>2],(0|t)==(0|fi[35032+(I<<2)>>2])){if(fi[35032+(I<<2)>>2]=A,!A){fi[8683]=fi[8683]&~(1<<I),r=t,I=B;break}}else if(fi[i+16+(((0|fi[i+16>>2])!=(0|t)&1)<<2)>>2]=A,!A){r=t,I=B;break}fi[A+24>>2]=i,0|(I=0|fi[t+16>>2])&&(fi[A+16>>2]=I,fi[I+24>>2]=A),(I=0|fi[t+16+4>>2])?(fi[A+20>>2]=I,fi[I+24>>2]=A,r=t,I=B):(r=t,I=B)}else r=t,I=B}}while(0);if(!(t>>>0>=a>>>0)&&1&(e=0|fi[a+4>>2])){if(2&e)fi[a+4>>2]=-2&e,fi[r+4>>2]=1|I,fi[t+I>>2]=I,i=I;else{if(A=0|fi[8687],(0|a)==(0|fi[8688])){if(a=(0|fi[8685])+I|0,fi[8685]=a,fi[8688]=r,fi[r+4>>2]=1|a,(0|r)!=(0|A))return;return fi[8687]=0,void(fi[8684]=0)}if((0|a)==(0|A))return a=(0|fi[8684])+I|0,fi[8684]=a,fi[8687]=t,fi[r+4>>2]=1|a,void(fi[t+a>>2]=a);i=(-8&e)+I|0;do{if(e>>>0<256){if(I=0|fi[a+8>>2],(0|(A=0|fi[a+12>>2]))==(0|I)){fi[8682]=fi[8682]&~(1<<(e>>>3));break}fi[I+12>>2]=A,fi[A+8>>2]=I;break}B=0|fi[a+24>>2],A=0|fi[a+12>>2];do{if((0|A)==(0|a)){if(A=0|fi[a+16+4>>2])g=a+16+4|0;else{if(!(A=0|fi[a+16>>2])){I=0;break}g=a+16|0}for(;;)if(I=A+20|0,0|(e=0|fi[I>>2]))A=e,g=I;else{if(I=A+16|0,!(e=0|fi[I>>2]))break;A=e,g=I}fi[g>>2]=0,I=A}else I=0|fi[a+8>>2],fi[I+12>>2]=A,fi[A+8>>2]=I,I=A}while(0);if(0|B){if(A=0|fi[a+28>>2],(0|a)==(0|fi[35032+(A<<2)>>2])){if(fi[35032+(A<<2)>>2]=I,!I){fi[8683]=fi[8683]&~(1<<A);break}}else if(fi[B+16+(((0|fi[B+16>>2])!=(0|a)&1)<<2)>>2]=I,!I)break;fi[I+24>>2]=B,0|(A=0|fi[a+16>>2])&&(fi[I+16>>2]=A,fi[A+24>>2]=I),0|(A=0|fi[a+16+4>>2])&&(fi[I+20>>2]=A,fi[A+24>>2]=I)}}while(0);if(fi[r+4>>2]=1|i,fi[t+i>>2]=i,(0|r)==(0|fi[8687]))return void(fi[8684]=i)}if(e=i>>>3,i>>>0<256)return(A=0|fi[8682])&1<<e?(A=0|fi[34768+(e<<1<<2)+8>>2],I=34768+(e<<1<<2)+8|0):(fi[8682]=A|1<<e,A=34768+(e<<1<<2)|0,I=34768+(e<<1<<2)+8|0),fi[I>>2]=r,fi[A+12>>2]=r,fi[r+8>>2]=A,void(fi[r+12>>2]=34768+(e<<1<<2));g=35032+((A=(A=i>>>8)?i>>>0>16777215?31:i>>>(7+(A=14-((520192+(A<<((A+1048320|0)>>>16&8))|0)>>>16&4|(A+1048320|0)>>>16&8|(245760+(a=A<<((A+1048320|0)>>>16&8)<<((520192+(A<<((A+1048320|0)>>>16&8))|0)>>>16&4))|0)>>>16&2)+(a<<((a+245760|0)>>>16&2)>>>15)|0)|0)&1|A<<1:0)<<2)|0,fi[r+28>>2]=A,fi[r+20>>2]=0,fi[r+16>>2]=0,I=0|fi[8683],e=1<<A;do{if(I&e){for(I=i<<(31==(0|A)?0:25-(A>>>1)|0),e=0|fi[g>>2];;){if((-8&fi[e+4>>2]|0)==(0|i)){A=73;break}if(g=e+16+(I>>>31<<2)|0,!(A=0|fi[g>>2])){A=72;break}I<<=1,e=A}if(72==(0|A)){fi[g>>2]=r,fi[r+24>>2]=e,fi[r+12>>2]=r,fi[r+8>>2]=r;break}if(73==(0|A)){a=0|fi[(t=e+8|0)>>2],fi[a+12>>2]=r,fi[t>>2]=r,fi[r+8>>2]=a,fi[r+12>>2]=e,fi[r+24>>2]=0;break}}else fi[8683]=I|e,fi[g>>2]=r,fi[r+24>>2]=g,fi[r+12>>2]=r,fi[r+8>>2]=r}while(0);if(a=(0|fi[8690])-1|0,fi[8690]=a,!a){for(A=35184;A=0|fi[A>>2];)A=A+8|0;fi[8690]=-1}}}}function E(A,I){I|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0;e=0|fi[4+(A|=0)>>2];do{if(1&e)a=A,e=I;else{if(r=0|fi[A>>2],!(3&e))return;if((A+(0-r)|0)==(0|fi[8687])){if(3!=(3&(e=0|fi[A+I+4>>2])|0)){a=A+(0-r)|0,e=r+I|0;break}return fi[8684]=r+I,fi[A+I+4>>2]=-2&e,fi[A+(0-r)+4>>2]=r+I|1,void(fi[A+(0-r)+(r+I)>>2]=r+I)}if(r>>>0<256){if(e=0|fi[A+(0-r)+8>>2],(0|(g=0|fi[A+(0-r)+12>>2]))==(0|e)){fi[8682]=fi[8682]&~(1<<(r>>>3)),a=A+(0-r)|0,e=r+I|0;break}fi[e+12>>2]=g,fi[g+8>>2]=e,a=A+(0-r)|0,e=r+I|0;break}t=0|fi[A+(0-r)+24>>2],e=0|fi[A+(0-r)+12>>2];do{if((0|e)==(A+(0-r)|0)){if(g=A+(0-r)+16|0,e=0|fi[g+4>>2])g=g+4|0;else if(!(e=0|fi[g>>2])){e=0;break}for(;;)if(i=e+20|0,0|(B=0|fi[i>>2]))e=B,g=i;else{if(i=e+16|0,!(B=0|fi[i>>2]))break;e=B,g=i}fi[g>>2]=0}else a=0|fi[A+(0-r)+8>>2],fi[a+12>>2]=e,fi[e+8>>2]=a}while(0);if(t){if(g=0|fi[A+(0-r)+28>>2],(A+(0-r)|0)==(0|fi[35032+(g<<2)>>2])){if(fi[35032+(g<<2)>>2]=e,!e){fi[8683]=fi[8683]&~(1<<g),a=A+(0-r)|0,e=r+I|0;break}}else if(fi[t+16+(((0|fi[t+16>>2])!=(A+(0-r)|0)&1)<<2)>>2]=e,!e){a=A+(0-r)|0,e=r+I|0;break}fi[e+24>>2]=t,0|(g=0|fi[A+(0-r)+16>>2])&&(fi[e+16>>2]=g,fi[g+24>>2]=e),(g=0|fi[A+(0-r)+16+4>>2])?(fi[e+20>>2]=g,fi[g+24>>2]=e,a=A+(0-r)|0,e=r+I|0):(a=A+(0-r)|0,e=r+I|0)}else a=A+(0-r)|0,e=r+I|0}}while(0);if(2&(i=0|fi[A+I+4>>2]))fi[A+I+4>>2]=-2&i,fi[a+4>>2]=1|e,fi[a+e>>2]=e,t=e;else{if(g=0|fi[8687],(A+I|0)==(0|fi[8688])){if(I=(0|fi[8685])+e|0,fi[8685]=I,fi[8688]=a,fi[a+4>>2]=1|I,(0|a)!=(0|g))return;return fi[8687]=0,void(fi[8684]=0)}if((A+I|0)==(0|g))return I=(0|fi[8684])+e|0,fi[8684]=I,fi[8687]=a,fi[a+4>>2]=1|I,void(fi[a+I>>2]=I);t=(-8&i)+e|0;do{if(i>>>0<256){if(g=0|fi[A+I+8>>2],(0|(e=0|fi[A+I+12>>2]))==(0|g)){fi[8682]=fi[8682]&~(1<<(i>>>3));break}fi[g+12>>2]=e,fi[e+8>>2]=g;break}r=0|fi[A+I+24>>2],e=0|fi[A+I+12>>2];do{if((0|e)==(A+I|0)){if(e=0|fi[A+I+16+4>>2])B=A+I+16+4|0;else{if(!(e=0|fi[A+I+16>>2])){g=0;break}B=A+I+16|0}for(;;)if(g=e+20|0,0|(i=0|fi[g>>2]))e=i,B=g;else{if(g=e+16|0,!(i=0|fi[g>>2]))break;e=i,B=g}fi[B>>2]=0,g=e}else g=0|fi[A+I+8>>2],fi[g+12>>2]=e,fi[e+8>>2]=g,g=e}while(0);if(0|r){if(e=0|fi[A+I+28>>2],(A+I|0)==(0|fi[35032+(e<<2)>>2])){if(fi[35032+(e<<2)>>2]=g,!g){fi[8683]=fi[8683]&~(1<<e);break}}else if(fi[r+16+(((0|fi[r+16>>2])!=(A+I|0)&1)<<2)>>2]=g,!g)break;fi[g+24>>2]=r,0|(e=0|fi[A+I+16>>2])&&(fi[g+16>>2]=e,fi[e+24>>2]=g),0|(e=0|fi[A+I+16+4>>2])&&(fi[g+20>>2]=e,fi[e+24>>2]=g)}}while(0);if(fi[a+4>>2]=1|t,fi[a+t>>2]=t,(0|a)==(0|fi[8687]))return void(fi[8684]=t)}if(i=t>>>3,t>>>0<256)return(e=0|fi[8682])&1<<i?(e=0|fi[34768+(i<<1<<2)+8>>2],g=34768+(i<<1<<2)+8|0):(fi[8682]=e|1<<i,e=34768+(i<<1<<2)|0,g=34768+(i<<1<<2)+8|0),fi[g>>2]=a,fi[e+12>>2]=a,fi[a+8>>2]=e,void(fi[a+12>>2]=34768+(i<<1<<2));if(e=t>>>8,e=e?t>>>0>16777215?31:t>>>(7+(e=14-((520192+(e<<((e+1048320|0)>>>16&8))|0)>>>16&4|(e+1048320|0)>>>16&8|(245760+(I=e<<((e+1048320|0)>>>16&8)<<((520192+(e<<((e+1048320|0)>>>16&8))|0)>>>16&4))|0)>>>16&2)+(I<<((I+245760|0)>>>16&2)>>>15)|0)|0)&1|e<<1:0,B=35032+(e<<2)|0,fi[a+28>>2]=e,fi[a+20>>2]=0,fi[a+16>>2]=0,g=0|fi[8683],i=1<<e,!(g&i))return fi[8683]=g|i,fi[B>>2]=a,fi[a+24>>2]=B,fi[a+12>>2]=a,void(fi[a+8>>2]=a);for(g=t<<(31==(0|e)?0:25-(e>>>1)|0),i=0|fi[B>>2];;){if((-8&fi[i+4>>2]|0)==(0|t)){e=69;break}if(B=i+16+(g>>>31<<2)|0,!(e=0|fi[B>>2])){e=68;break}g<<=1,i=e}return 68==(0|e)?(fi[B>>2]=a,fi[a+24>>2]=i,fi[a+12>>2]=a,void(fi[a+8>>2]=a)):69==(0|e)?(A=i+8|0,I=0|fi[A>>2],fi[I+12>>2]=a,fi[A>>2]=a,fi[a+8>>2]=I,fi[a+12>>2]=i,void(fi[a+24>>2]=0)):void 0}function s(A,I,e,g,i){A|=0,I|=0,e|=0,g|=0;var B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0;if(o=0|oe(i|=0),Q=vi,B=0|oe(i+8|0),t=vi,g=0|Se(0|e,0|g,56),i=vi,(I+e+(0-(7&e))|0)==(0|I))s=2037671283^B,a=1952801890^t,c=1886610805^o,n=1936682341^Q,r=1852075885^B,h=1685025377^t,t=1852142177^o,B=1819895653^Q;else for(y=I,s=2037671283^B,a=1952801890^t,c=1886610805^o,C=1936682341^Q,n=1852075885^B,r=1685025377^t,t=1852142177^o,B=1819895653^Q;;){if(E=0|oe(y),f=vi,p=E^s,a^=f,C=0|Ig(0|c,0|C,0|n,0|r),h=vi,c=0|se(n,r,13),n=vi^h,h=0|se(C,h,32),s=vi,o=0|Ig(0|p,0|a,0|t,0|B),Q=vi,a=0|se(p,a,16),r=vi^Q,s=0|Ig(a^o|0,0|r,0|h,0|s),h=vi,r=0|se(a^o,r,21),a=h^vi,Q=0|Ig(0|o,0|Q,c^C|0,0|n),o=vi,n=0|se(c^C,n,17),B=vi^o,o=0|se(Q,o,32),t=vi,h=0|Ig(n^Q|0,0|B,0|s,0|h),C=vi,B=0|se(n^Q,B,13),Q=vi^C,C=0|se(h,C,32),n=vi,t=0|Ig(0|o,0|t,s^r|0,0|a),o=vi,a=0|se(s^r,a,16),r=vi^o,n=0|Ig(a^t|0,0|r,0|C,0|n),C=vi,r=0|se(a^t,r,21),a=C^vi,o=0|Ig(B^h|0,0|Q,0|t,0|o),t=vi,Q=0|se(B^h,Q,17),h=vi^t,t=0|se(o,t,32),B=vi,(0|(y=y+8|0))==(I+e+(0-(7&e))|0)){I=I+e+(0-(7&e))|0,s=n^r,c=n^E,n=C^f,r=Q^o;break}s=n^r,c=n^E,C^=f,n=Q^o,r=h}switch(7&e){case 7:g=0|Se(0|_i[I+6>>0],0,48)|g,i|=vi,_=5;break;case 6:_=5;break;case 5:_=6;break;case 4:_=7;break;case 3:_=8;break;case 2:_=9;break;case 1:_=10}5==(0|_)&&(p=0|Se(0|_i[I+5>>0],0,40),i|=vi,g|=p,_=6),6==(0|_)&&(i=0|_i[I+4>>0]|i,_=7),7==(0|_)&&(g|=p=0|Se(0|_i[I+3>>0],0,24),i|=vi,_=8),8==(0|_)&&(g|=p=0|Se(0|_i[I+2>>0],0,16),i|=vi,_=9),9==(0|_)&&(g|=p=0|Se(0|_i[I+1>>0],0,8),i|=vi,_=10),10==(0|_)&&(g=0|_i[I>>0]|g),y=g^s,e=i^a,Q=0|Ig(0|c,0|n,0|r,0|h),E=vi,s=0|se(r,h,13),I=vi^E,E=0|se(Q,E,32),_=vi,f=0|Ig(0|y,0|e,0|t,0|B),p=vi,_=0|Ig((h=0|se(y,e,16))^f|0,0|(e=vi^p),0|E,0|_),E=vi,e=0|se(h^f,e,21),h=E^vi,p=0|Ig(0|f,0|p,s^Q|0,0|I),f=vi,I=0|se(s^Q,I,17),Q=vi^f,f=0|se(p,f,32),s=vi,E=0|Ig(I^p|0,0|Q,0|_,0|E),y=vi,Q=0|se(I^p,Q,13),p=vi^y,y=0|se(E,y,32),I=vi,s=0|Ig(0|f,0|s,_^e|0,0|h),f=vi,I=0|Ig((h=0|se(_^e,h,16))^s|0,0|(e=vi^f),0|y,0|I),y=vi,e=0|se(h^s,e,21),h=y^vi,f=0|Ig(Q^E|0,0|p,0|s,0|f),s=vi,p=0|se(Q^E,p,17),E=vi^s,s=0|se(f,s,32),Q=vi,y=0|Ig(I^g|0,y^i|0,p^f|0,0|E),_=vi,E=0|se(p^f,E,13),f=vi^_,_=0|se(y,_,32),p=vi,Q=0|Ig(255^s|0,0|Q,I^e|0,0|h),s=vi,p=0|Ig((h=0|se(I^e,h,16))^Q|0,0|(e=vi^s),0|_,0|p),_=vi,e=0|se(h^Q,e,21),h=_^vi,s=0|Ig(0|Q,0|s,E^y|0,0|f),Q=vi,f=0|se(E^y,f,17),y=vi^Q,Q=0|se(s,Q,32),E=vi,_=0|Ig(f^s|0,0|y,0|p,0|_),I=vi,y=0|se(f^s,y,13),s=vi^I,I=0|se(_,I,32),f=vi,E=0|Ig(0|Q,0|E,p^e|0,0|h),Q=vi,f=0|Ig((h=0|se(p^e,h,16))^E|0,0|(e=vi^Q),0|I,0|f),I=vi,e=0|se(h^E,e,21),h=I^vi,Q=0|Ig(y^_|0,0|s,0|E,0|Q),E=vi,s=0|se(y^_,s,17),_=vi^E,E=0|se(Q,E,32),y=vi,I=0|Ig(s^Q|0,0|_,0|f,0|I),p=vi,_=0|se(s^Q,_,13),Q=vi^p,p=0|se(I,p,32),s=vi,y=0|Ig(0|E,0|y,f^e|0,0|h),E=vi,s=0|Ig((h=0|se(f^e,h,16))^y|0,0|(e=vi^E),0|p,0|s),p=vi,e=0|se(h^y,e,21),h=p^vi,E=0|Ig(_^I|0,0|Q,0|y,0|E),y=vi,Q=0|se(_^I,Q,17),I=vi^y,y=0|se(E,y,32),_=vi,p=0|Ig(Q^E|0,0|I,0|s,0|p),f=vi,I=0|se(Q^E,I,13),f^=vi,_=0|Ig(0|y,0|_,s^e|0,0|h),y=vi,h=0|se((h=0|se(s^e,h,16))^_,vi^y,21),e=vi,y=0|Ig(I^p|0,0|f,0|_,0|y),_=vi,f=0|se(I^p,f,17),p=vi,WI(A,h^y^f^(I=0|se(y,_,32)),e^_^p^vi)}function h(A,I,e,g,i){A|=0,I|=0,e|=0;var B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0,P=0,L=0,x=0,X=0,K=0,T=0,V=0,q=0,j=0,Z=0,W=0,z=0,O=0,$=0,AA=0,IA=0,eA=0,gA=0,iA=0,BA=0,tA=0,rA=0,aA=0,nA=0;if(L=wi,P=wi=wi+63&-64,wi=wi+64|0,!(0==(0|(g|=0))&0==(0|(i|=0)))){for(i>>>0>0|0==(0|i)&g>>>0>4294967295&&hi(),v=0|fi[A>>2],b=0|fi[A+4>>2],k=0|fi[A+8>>2],G=0|fi[A+12>>2],F=0|fi[A+16>>2],m=0|fi[A+20>>2],M=0|fi[A+24>>2],H=0|fi[A+28>>2],Y=0|fi[A+32>>2],S=0|fi[A+36>>2],R=0|fi[A+40>>2],N=0|fi[A+44>>2],U=0|fi[A+56>>2],J=0|fi[A+60>>2],B=0,u=0|fi[A+52>>2],w=0|fi[A+48>>2],d=i,D=g;;){if(l=d>>>0<0|0==(0|d)&D>>>0<64){g=(i=P)+64|0;do{yi[i>>0]=0,i=i+1|0}while((0|i)<(0|g));i=0;do{yi[P+i>>0]=0|yi[I+i>>0],i=i+1|0}while(0<d>>>0|0==(0|d)&i>>>0<D>>>0);B=e,I=P,e=P}i=v,g=b,t=k,r=G,a=F,n=m,C=M,o=H,c=Y,Q=S,E=R,s=J,h=U,y=u,f=w,_=N,p=20;do{V=0|$g((W=0|$g((aA=0|$g((Z=(W=0|$g((rA=i+a|0)^f,16))+c|0)^a,12))+rA^W,8))+Z^aA,7),nA=0|$g((K=0|$g((iA=0|$g((X=(K=0|$g((gA=g+n|0)^y,16))+Q|0)^n,12))+gA^K,8))+X^iA,7),BA=0|$g((T=0|$g(($=0|$g((z=(T=0|$g((O=t+C|0)^h,16))+E|0)^C,12))+O^T,8))+z^$,7),AA=0|$g((IA=0|$g((j=0|$g((x=(IA=0|$g((q=r+o|0)^s,16))+_|0)^o,12))+q^IA,8))+x^j,7),n=0|$g((E=(s=0|$g((i=(eA=0|$g((tA=0|$g(IA^nA+(aA+rA),16))+(T+z)^nA,12))+(nA+(aA+rA))|0)^tA,8))+(tA+(T+z))|0)^eA,7),C=0|$g((_=(f=0|$g((g=(z=0|$g((eA=0|$g(BA+(iA+gA)^W,16))+(IA+x)^BA,12))+(BA+(iA+gA))|0)^eA,8))+(eA+(IA+x))|0)^z,7),o=0|$g((c=(y=0|$g((t=(x=0|$g((z=0|$g(AA+($+O)^K,16))+(W+Z)^AA,12))+(AA+($+O))|0)^z,8))+(z+(W+Z))|0)^x,7),a=0|$g((Q=(h=0|$g((r=(x=0|$g((T=0|$g(j+q+V^T,16))+(K+X)^V,12))+(j+q+V)|0)^T,8))+(T+(K+X))|0)^x,7),p=p+-2|0}while(0!=(0|p));if(j=(0|ug(I))^i+v,Z=(0|ug(I+4|0))^g+b,W=(0|ug(I+8|0))^t+k,z=(0|ug(I+12|0))^r+G,O=(0|ug(I+16|0))^a+F,$=(0|ug(I+20|0))^n+m,AA=(0|ug(I+24|0))^C+M,IA=(0|ug(I+28|0))^o+H,eA=(0|ug(I+32|0))^c+Y,gA=(0|ug(I+36|0))^Q+S,iA=(0|ug(I+40|0))^E+R,BA=(0|ug(I+44|0))^_+N,tA=(0|ug(I+48|0))^f+w,rA=(0|ug(I+52|0))^y+u,aA=(0|ug(I+56|0))^h+U,nA=(0|ug(I+60|0))^s+J,g=w+1|0,i=(0==(0|g)&1)+u|0,Bg(e,j),Bg(e+4|0,Z),Bg(e+8|0,W),Bg(e+12|0,z),Bg(e+16|0,O),Bg(e+20|0,$),Bg(e+24|0,AA),Bg(e+28|0,IA),Bg(e+32|0,eA),Bg(e+36|0,gA),Bg(e+40|0,iA),Bg(e+44|0,BA),Bg(e+48|0,tA),Bg(e+52|0,rA),Bg(e+56|0,aA),Bg(e+60|0,nA),d>>>0<0|0==(0|d)&D>>>0<65)break;nA=0|Ig(0|D,0|d,-64,-1),I=I+64|0,e=e+64|0,u=i,w=g,d=vi,D=nA}if(l?0|D:0){I=0;do{yi[B+I>>0]=0|yi[e+I>>0],I=I+1|0}while((0|I)!=(0|D))}fi[A+48>>2]=g,fi[A+52>>2]=i}wi=L}function y(A,I,e,g){I|=0,e|=0,g|=0;var i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0;if(h=0|yi[80+(A|=0)>>0]?0:16777216,y=0|fi[A+4>>2],c=0|fi[A+8>>2],Q=0|fi[A+12>>2],E=0|fi[A+16>>2],a=0|fi[A+20>>2],r=0|fi[A+24>>2],t=0|fi[A+28>>2],B=0|fi[A+32>>2],i=0|fi[A+36>>2],g>>>0>0|0==(0|g)&e>>>0>15)for(s=0|fi[A>>2],C=e;;){if(l=(67108863&(0|ug(I)))+a|0,u=((0|ug(I+3|0))>>>2&67108863)+r|0,w=((0|ug(I+6|0))>>>4&67108863)+t|0,p=((0|ug(I+9|0))>>>6)+B|0,a=((0|ug(I+12|0))>>>8|h)+i|0,i=0|he(0|l,0,0|s,0),e=vi,t=0|he(0|u,0,5*E|0,0),e=0|Ig(0|t,0|vi,0|i,0|e),i=vi,t=0|he(0|w,0,5*Q|0,0),t=0|Ig(0|e,0|i,0|t,0|vi),i=vi,e=0|he(0|p,0,5*c|0,0),e=0|Ig(0|t,0|i,0|e,0|vi),i=vi,t=0|he(0|a,0,5*y|0,0),t=0|Ig(0|e,0|i,0|t,0|vi),i=vi,e=0|he(0|l,0,0|y,0),n=vi,_=0|he(0|u,0,0|s,0),n=0|Ig(0|_,0|vi,0|e,0|n),e=vi,_=0|he(0|w,0,5*E|0,0),_=0|Ig(0|n,0|e,0|_,0|vi),e=vi,n=0|he(0|p,0,5*Q|0,0),n=0|Ig(0|_,0|e,0|n,0|vi),e=vi,_=0|he(0|a,0,5*c|0,0),_=0|Ig(0|n,0|e,0|_,0|vi),e=vi,n=0|he(0|l,0,0|c,0),o=vi,f=0|he(0|u,0,0|y,0),o=0|Ig(0|f,0|vi,0|n,0|o),n=vi,f=0|he(0|w,0,0|s,0),f=0|Ig(0|o,0|n,0|f,0|vi),n=vi,o=0|he(0|p,0,5*E|0,0),o=0|Ig(0|f,0|n,0|o,0|vi),n=vi,f=0|he(0|a,0,5*Q|0,0),f=0|Ig(0|o,0|n,0|f,0|vi),n=vi,o=0|he(0|l,0,0|Q,0),B=vi,r=0|he(0|u,0,0|c,0),B=0|Ig(0|r,0|vi,0|o,0|B),o=vi,r=0|he(0|w,0,0|y,0),r=0|Ig(0|B,0|o,0|r,0|vi),o=vi,B=0|he(0|p,0,0|s,0),B=0|Ig(0|r,0|o,0|B,0|vi),o=vi,r=0|he(0|a,0,5*E|0,0),r=0|Ig(0|B,0|o,0|r,0|vi),o=vi,B=0|he(0|l,0,0|E,0),l=vi,u=0|he(0|u,0,0|Q,0),l=0|Ig(0|u,0|vi,0|B,0|l),B=vi,w=0|he(0|w,0,0|c,0),w=0|Ig(0|l,0|B,0|w,0|vi),B=vi,p=0|he(0|p,0,0|y,0),p=0|Ig(0|w,0|B,0|p,0|vi),B=vi,a=0|he(0|a,0,0|s,0),a=0|Ig(0|p,0|B,0|a,0|vi),B=vi,i=0|Ue(0|t,0|i,26),i=0|Ig(0|_,0|e,0|i,0),e=0|Ue(0|i,0|vi,26),e=0|Ig(0|f,0|n,0|e,0),n=0|Ue(0|e,0|vi,26),n=0|Ig(0|r,0|o,0|n,0),o=0|Ue(0|n,0|vi,26),o=0|Ig(0|a,0|B,0|o,0),B=0|Ue(0|o,0|vi,26),C=0|Ig(0|C,0|g,-16,-1),!((g=vi)>>>0>0|0==(0|g)&C>>>0>15)){a=(5*B|0)+t&67108863,r=(((5*B|0)+(67108863&t)|0)>>>26)+(67108863&i)|0,t=67108863&e,B=67108863&n,i=67108863&o;break}a=(5*B|0)+t&67108863,r=(((5*B|0)+(67108863&t)|0)>>>26)+(67108863&i)|0,t=67108863&e,B=67108863&n,i=67108863&o,I=I+16|0}fi[A+20>>2]=a,fi[A+24>>2]=r,fi[A+28>>2]=t,fi[A+32>>2]=B,fi[A+36>>2]=i}function f(A,I){A|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0;l=0|HI(I|=0),a=vi,w=0|Se(0|(w=0|fe(0|yi[I+4>>0],0|yi[I+5>>0],0|yi[I+6>>0])),0|vi,6),n=vi,p=0|Se(0|(p=0|fe(0|yi[I+7>>0],0|yi[I+8>>0],0|yi[I+9>>0])),0|vi,5),t=vi,y=0|Se(0|(y=0|fe(0|yi[I+10>>0],0|yi[I+11>>0],0|yi[I+12>>0])),0|vi,3),r=vi,h=0|Se(0|(h=0|fe(0|yi[I+13>>0],0|yi[I+14>>0],0|yi[I+15>>0])),0|vi,2),i=vi,g=0|HI(I+16|0),B=vi,Q=0|Se(0|(Q=0|fe(0|yi[I+20>>0],0|yi[I+21>>0],0|yi[I+22>>0])),0|vi,7),e=vi,_=0|Se(0|(_=0|fe(0|yi[I+23>>0],0|yi[I+24>>0],0|yi[I+25>>0])),0|vi,5),f=vi,o=0|Se(0|(o=0|fe(0|yi[I+26>>0],0|yi[I+27>>0],0|yi[I+28>>0])),0|vi,4),c=vi,a=0|Ig(19&(u=0|Ag(0,0,0|(I=0|Ue(0|(I=0|Ig(33554428&(s=0|Se(0|(s=0|fe(0|yi[I+29>>0],0|yi[I+30>>0],0|yi[I+31>>0])),0|vi,2))|0,0,16777216,0)),0|vi,25)),0|(E=vi)))|0,0,0|l,0|a),l=vi,E=0|Se(0|I,0|E,25),I=vi,t=0|Ig(0|(u=0|be(0|(u=0|Ig(0|w,0|n,16777216,0)),0|vi,25)),0|(D=vi),0|p,0|t),p=vi,D=0|Ag(0|w,0|n,0|(D=0|Se(0|u,0|D,25)),0|vi),n=vi,i=0|Ig(0|(w=0|be(0|(w=0|Ig(0|y,0|r,16777216,0)),0|vi,25)),0|(u=vi),0|h,0|i),h=vi,u=0|Ag(0|y,0|r,0|(u=0|Se(0|w,0|u,25)),0|vi),r=vi,e=0|Ig(0|Q,0|e,0|(y=0|be(0|(y=0|Ig(0|g,0|B,16777216,0)),0|vi,25)),0|(w=vi)),Q=vi,w=0|Ag(0|g,0|B,0|(w=0|Se(0|y,0|w,25)),0|vi),B=vi,c=0|Ig(0|(g=0|be(0|(g=0|Ig(0|_,0|f,16777216,0)),0|vi,25)),0|(y=vi),0|o,0|c),o=vi,y=0|Se(0|g,0|y,25),g=vi,n=0|Ig(0|D,0|n,0|(d=0|be(0|(d=0|Ig(0|a,0|l,33554432,0)),0|vi,26)),0|(C=vi)),C=0|Ag(0|a,0|l,0|(C=0|Se(0|d,0|C,26)),0|vi),r=0|Ig(0|u,0|r,0|(l=0|be(0|(l=0|Ig(0|t,0|p,33554432,0)),0|vi,26)),0|(a=vi)),a=0|Ag(0|t,0|p,0|(a=0|Se(0|l,0|a,26)),0|vi),B=0|Ig(0|w,0|B,0|(p=0|be(0|(p=0|Ig(0|i,0|h,33554432,0)),0|vi,26)),0|(t=vi)),t=0|Ag(0|i,0|h,0|(t=0|Se(0|p,0|t,26)),0|vi),g=0|Ag(0|(f=0|Ig(0|(h=0|be(0|(h=0|Ig(0|e,0|Q,33554432,0)),0|vi,26)),0|(i=vi),0|_,0|f)),0|vi,0|y,0|g),i=0|Ag(0|e,0|Q,0|(i=0|Se(0|h,0|i,26)),0|vi),I=0|Ag(0|(s=0|Ig(0|(Q=0|be(0|(Q=0|Ig(0|c,0|o,33554432,0)),0|vi,26)),0|(e=vi),33554428&s|0,0)),0|vi,0|E,0|I),e=0|Ag(0|c,0|o,0|(e=0|Se(0|Q,0|e,26)),0|vi),fi[A>>2]=C,fi[A+4>>2]=n,fi[A+8>>2]=a,fi[A+12>>2]=r,fi[A+16>>2]=t,fi[A+20>>2]=B,fi[A+24>>2]=i,fi[A+28>>2]=g,fi[A+32>>2]=e,fi[A+36>>2]=I}function _(A,I){A|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0;_=0|fi[(I|=0)>>2],f=0|fi[I+4>>2],y=0|fi[I+8>>2],h=0|fi[I+12>>2],s=0|fi[I+16>>2],C=0|fi[I+20>>2],Q=0|fi[I+24>>2],w=0|fi[I+28>>2],o=0|fi[I+32>>2],p=0|fi[I+36>>2],_=0|he(0|_,((0|_)<0)<<31>>31|0,121666,0),a=vi,f=0|he(0|f,((0|f)<0)<<31>>31|0,121666,0),n=vi,y=0|he(0|y,((0|y)<0)<<31>>31|0,121666,0),t=vi,h=0|he(0|h,((0|h)<0)<<31>>31|0,121666,0),r=vi,s=0|he(0|s,((0|s)<0)<<31>>31|0,121666,0),i=vi,C=0|he(0|C,((0|C)<0)<<31>>31|0,121666,0),B=vi,Q=0|he(0|Q,((0|Q)<0)<<31>>31|0,121666,0),e=vi,w=0|he(0|w,((0|w)<0)<<31>>31|0,121666,0),g=vi,o=0|he(0|o,((0|o)<0)<<31>>31|0,121666,0),c=vi,a=0|Ig(0|he(0|(l=0|be(0|(l=0|Ig(0|(p=0|he(0|p,((0|p)<0)<<31>>31|0,121666,0)),0|(I=vi),16777216,0)),0|vi,25)),0|(E=vi),19,0),0|vi,0|_,0|a),_=vi,E=0|Ag(0|p,0|I,0|(E=0|Se(0|l,0|E,25)),0|vi),I=vi,t=0|Ig(0|(p=0|be(0|(p=0|Ig(0|f,0|n,16777216,0)),0|vi,25)),0|(l=vi),0|y,0|t),y=vi,l=0|Ag(0|f,0|n,0|(l=0|Se(0|p,0|l,25)),0|vi),n=vi,i=0|Ig(0|(f=0|be(0|(f=0|Ig(0|h,0|r,16777216,0)),0|vi,25)),0|(p=vi),0|s,0|i),s=vi,p=0|Ag(0|h,0|r,0|(p=0|Se(0|f,0|p,25)),0|vi),r=vi,e=0|Ig(0|(h=0|be(0|(h=0|Ig(0|C,0|B,16777216,0)),0|vi,25)),0|(f=vi),0|Q,0|e),Q=vi,f=0|Ag(0|C,0|B,0|(f=0|Se(0|h,0|f,25)),0|vi),B=vi,c=0|Ig(0|(C=0|be(0|(C=0|Ig(0|w,0|g,16777216,0)),0|vi,25)),0|(h=vi),0|o,0|c),o=vi,h=0|Ag(0|w,0|g,0|(h=0|Se(0|C,0|h,25)),0|vi),g=vi,n=0|Ig(0|l,0|n,0|(w=0|be(0|(w=0|Ig(0|a,0|_,33554432,0)),0|vi,26)),0|(C=vi)),C=0|Ag(0|a,0|_,0|(C=0|Se(0|w,0|C,26)),0|vi),r=0|Ig(0|p,0|r,0|(_=0|be(0|(_=0|Ig(0|t,0|y,33554432,0)),0|vi,26)),0|(a=vi)),a=0|Ag(0|t,0|y,0|(a=0|Se(0|_,0|a,26)),0|vi),B=0|Ig(0|f,0|B,0|(y=0|be(0|(y=0|Ig(0|i,0|s,33554432,0)),0|vi,26)),0|(t=vi)),t=0|Ag(0|i,0|s,0|(t=0|Se(0|y,0|t,26)),0|vi),g=0|Ig(0|h,0|g,0|(s=0|be(0|(s=0|Ig(0|e,0|Q,33554432,0)),0|vi,26)),0|(i=vi)),i=0|Ag(0|e,0|Q,0|(i=0|Se(0|s,0|i,26)),0|vi),I=0|Ig(0|E,0|I,0|(Q=0|be(0|(Q=0|Ig(0|c,0|o,33554432,0)),0|vi,26)),0|(e=vi)),e=0|Ag(0|c,0|o,0|(e=0|Se(0|Q,0|e,26)),0|vi),fi[A>>2]=C,fi[A+4>>2]=n,fi[A+8>>2]=a,fi[A+12>>2]=r,fi[A+16>>2]=t,fi[A+20>>2]=B,fi[A+24>>2]=i,fi[A+28>>2]=g,fi[A+32>>2]=e,fi[A+36>>2]=I}function p(A,I,e,g,i){A|=0,e|=0,g|=0,i|=0;var B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0;if(!(I|=0))return g?i?(fi[i>>2]=0|A,fi[i+4>>2]=0&I,g=0,i=0,0|(vi=g,i)):(g=0,i=0,0|(vi=g,i)):(0|i&&(fi[i>>2]=(A>>>0)%(e>>>0),fi[i+4>>2]=0),g=0,i=(A>>>0)/(e>>>0)>>>0,0|(vi=g,i));do{if(e){if(0|g){if((t=(0|ki(0|g))-(0|ki(0|I))|0)>>>0<=31){c=t+1|0,r=A>>>((t+1|0)>>>0)&t-31>>31|I<<31-t,o=I>>>((t+1|0)>>>0)&t-31>>31,B=0,t=A<<31-t;break}return i?(fi[i>>2]=0|A,fi[i+4>>2]=I|0&I,g=0,i=0,0|(vi=g,i)):(g=0,i=0,0|(vi=g,i))}if(e-1&e|0){c=t=33+(0|ki(0|e))-(0|ki(0|I))|0,r=32-t-1>>31&I>>>((t-32|0)>>>0)|(I<<32-t|A>>>(t>>>0))&t-32>>31,o=t-32>>31&I>>>(t>>>0),B=A<<64-t&32-t>>31,t=(I<<64-t|A>>>((t-32|0)>>>0))&32-t>>31|A<<32-t&t-33>>31;break}return 0|i&&(fi[i>>2]=e-1&A,fi[i+4>>2]=0),1==(0|e)?(g=I|0&I,i=0|A,0|(vi=g,i)):(i=0|NI(0|e),g=I>>>(i>>>0)|0,i=I<<32-i|A>>>(i>>>0)|0,0|(vi=g,i))}if(!g)return 0|i&&(fi[i>>2]=(I>>>0)%(e>>>0),fi[i+4>>2]=0),g=0,i=(I>>>0)/(e>>>0)>>>0,0|(vi=g,i);if(!A)return 0|i&&(fi[i>>2]=0,fi[i+4>>2]=(I>>>0)%(g>>>0)),e=0,i=(I>>>0)/(g>>>0)>>>0,0|(vi=e,i);if(!(g-1&g))return 0|i&&(fi[i>>2]=0|A,fi[i+4>>2]=g-1&I|0&I),e=0,i=I>>>((0|NI(0|g))>>>0),0|(vi=e,i);if((t=(0|ki(0|g))-(0|ki(0|I))|0)>>>0<=30){c=t+1|0,r=I<<31-t|A>>>((t+1|0)>>>0),o=I>>>((t+1|0)>>>0),B=0,t=A<<31-t;break}return i?(fi[i>>2]=0|A,fi[i+4>>2]=I|0&I,g=0,i=0,0|(vi=g,i)):(g=0,i=0,0|(vi=g,i))}while(0);if(c){n=0|Ig(0|e,g|0&g|0,-1,-1),C=vi,a=t,I=o,A=c,t=0;do{E=a,a=B>>>31|a<<1,B=t|B<<1,Ag(0|n,0|C,0|(E=r<<1|E>>>31|0),0|(Q=r>>>31|I<<1|0)),t=1&(o=(c=vi)>>31|((0|c)<0?-1:0)<<1),r=0|Ag(0|E,0|Q,o&(0|e)|0,(((0|c)<0?-1:0)>>31|((0|c)<0?-1:0)<<1)&(g|0&g)|0),I=vi,A=A-1|0}while(0!=(0|A));A=0}else a=t,I=o,A=0,t=0;return 0|i&&(fi[i>>2]=r,fi[i+4>>2]=I),Q=(0|B)>>>31|a<<1|0&(0|B>>>31)|A,E=-2&(B<<1|0)|t,0|(vi=Q,E)}function w(A,I,e){A|=0,I|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0,P=0,L=0,x=0,X=0,K=0,T=0;v=0|ug(e|=0),b=0|ug(e+4|0),k=0|ug(e+8|0),G=0|ug(e+12|0),u=0|ug(e+16|0),d=0|ug(e+20|0),D=0|ug(e+24|0),_=0|ug(e+28|0),p=0|ug(I),w=0|ug(I+4|0),l=0|ug(I+8|0),f=0|ug(I+12|0),e=0,I=v,g=b,i=k,B=G,t=p,r=w,a=l,n=f,C=u,o=_,c=D,Q=d,E=1634760805,s=857760878,h=2036477234,y=1797285236;do{x=(0|$g((H=(0|$g((R=(0|$g((J=(0|$g(E+Q|0,7))^B)+E|0,9))^a)+J|0,13))^Q)+R|0,18))^E,U=(0|$g((T=(0|$g((M=(0|$g((S=(0|$g(I+s|0,7))^n)+s|0,9))^c)+S|0,13))^I)+M|0,18))^s,Y=(0|$g((L=(0|$g((K=(0|$g((m=(0|$g(t+h|0,7))^o)+h|0,9))^g)+m|0,13))^t)+K|0,18))^h,F=(0|$g((N=(0|$g((P=(0|$g((X=(0|$g(C+y|0,7))^i)+y|0,9))^r)+X|0,13))^C)+P|0,18))^y,E=(0|$g((i=(0|$g((g=(0|$g((I=(0|$g(X+x|0,7))^T)+x|0,9))^K)+I|0,13))^X)+g|0,18))^x,s=(0|$g((B=(0|$g((r=(0|$g((t=(0|$g(U+J|0,7))^L)+U|0,9))^P)+t|0,13))^J)+r|0,18))^U,h=(0|$g((n=(0|$g((a=(0|$g((C=(0|$g(Y+S|0,7))^N)+Y|0,9))^R)+C|0,13))^S)+a|0,18))^Y,y=(0|$g((o=(0|$g((c=(0|$g((Q=(0|$g(F+m|0,7))^H)+F|0,9))^M)+Q|0,13))^m)+c|0,18))^F,e=e+2|0}while((0|e)<20);Bg(A,E+1634760805|0),Bg(A+4|0,I+v|0),Bg(A+8|0,g+b|0),Bg(A+12|0,i+k|0),Bg(A+16|0,B+G|0),Bg(A+20|0,s+857760878|0),Bg(A+24|0,t+p|0),Bg(A+28|0,r+w|0),Bg(A+32|0,a+l|0),Bg(A+36|0,n+f|0),Bg(A+40|0,h+2036477234|0),Bg(A+44|0,C+u|0),Bg(A+48|0,Q+d|0),Bg(A+52|0,c+D|0),Bg(A+56|0,o+_|0),Bg(A+60|0,y+1797285236|0)}function l(A,I,e,g){A|=0,I|=0,e|=0;var i=0,B=0,t=0,r=0,a=0,n=0,C=0;switch(C=wi,r=wi=wi+63&-64,wi=wi+16|0,0|(g|=0)){case 2:if(I>>>0<13)g=-31;else{i=33732,B=(g=A)+13|0;do{yi[g>>0]=0|yi[i>>0],g=g+1|0,i=i+1|0}while((0|g)<(0|B));A=A+12|0,i=I+-12|0,B=6}break;case 1:if(I>>>0<12)g=-31;else{i=33745,B=(g=A)+12|0;do{yi[g>>0]=0|yi[i>>0],g=g+1|0,i=i+1|0}while((0|g)<(0|B));A=A+11|0,i=I+-11|0,B=6}break;default:g=-31}do{if(6==(0|B)&&!(g=0|O(e))){if(EI(r,19),g=0|TA(r),B=A+g|0,t=i-g|0,i>>>0<=g>>>0){g=-31;break}if(T(0|A,0|r,g+1|0),t>>>0>=4){if(yi[B>>0]=36,yi[B+1>>0]=109,yi[B+2>>0]=61,yi[B+3>>0]=0,EI(r,0|fi[e+44>>2]),i=0|TA(r),A=B+3+i|0,(t+-3|0)>>>0<=i>>>0){g=-31;break}if(T(B+3|0,0|r,i+1|0),(t+-3-i|0)>>>0>=4){if(yi[A>>0]=44,yi[A+1>>0]=116,yi[A+2>>0]=61,yi[A+3>>0]=0,EI(r,0|fi[e+40>>2]),g=0|TA(r),B=A+3+g|0,I=t+-3-i-3-g|0,(t+-3-i-3|0)>>>0<=g>>>0){g=-31;break}if(T(A+3|0,0|r,g+1|0),I>>>0>=4){if(yi[B>>0]=44,yi[B+1>>0]=112,yi[B+2>>0]=61,yi[B+3>>0]=0,EI(r,0|fi[e+48>>2]),i=0|TA(r),(I+-3|0)>>>0<=i>>>0){g=-31;break}if(T(B+3|0,0|r,i+1|0),g=B+3+i+1|0,((I+-3-i|0)>>>0>=2?(yi[B+3+i>>0]=36,yi[B+3+i+1>>0]=0,0!=(0|U(g,I+-3-i-1|0,0|fi[e+16>>2],0|fi[e+20>>2],3))):0)?(a=0|TA(g),(n=I+-3-i-1-a|0)>>>0>=2):0)return yi[g+a>>0]=36,yi[g+a+1>>0]=0,n=0!=(0|U(g+a+1|0,n+-1|0,0|fi[e>>2],0|fi[e+4>>2],3)),wi=C,0|(n?0:-31);g=-31}else g=-31}else g=-31}else g=-31}}while(0);return wi=C,0|g}function u(A,I,e,g){A|=0,I|=0,e|=0;var i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0;(g|=0)?(t=0|ug(g),B=0|ug(g+4|0),i=0|ug(g+8|0),g=0|ug(g+12|0)):(g=1797285236,i=2036477234,B=857760878,t=1634760805),y=0|ug(e),h=0|ug(e+4|0),s=0|ug(e+8|0),E=0|ug(e+12|0),Q=0|ug(e+16|0),c=0|ug(e+20|0),o=0|ug(e+24|0),C=0|ug(e+28|0),n=0|ug(I),a=0|ug(I+4|0),r=0|ug(I+8|0),f=0,I=0|ug(I+12|0),e=t;do{l=0|$g((v=0|$g((U=0|$g((D=(v=0|$g(n^(N=y+e|0),16))+Q|0)^y,12))+N^v,8))+D^U,7),J=0|$g((p=0|$g((Y=0|$g((_=(p=0|$g(a^(H=h+B|0),16))+c|0)^h,12))+H^p,8))+_^Y,7),S=0|$g((w=0|$g((G=0|$g((b=(w=0|$g(r^(k=s+i|0),16))+o|0)^s,12))+k^w,8))+b^G,7),F=0|$g((m=0|$g((d=0|$g((t=(m=0|$g(I^(u=E+g|0),16))+C|0)^E,12))+u^m,8))+t^d,7),h=0|$g((o=(I=0|$g((e=(M=0|$g((R=0|$g(m^J+(U+N),16))+(w+b)^J,12))+(J+(U+N))|0)^R,8))+(R+(w+b))|0)^M,7),s=0|$g((C=(n=0|$g((B=(b=0|$g((M=0|$g(S+(Y+H)^v,16))+(m+t)^S,12))+(S+(Y+H))|0)^M,8))+(M+(m+t))|0)^b,7),E=0|$g((Q=(a=0|$g((i=(t=0|$g((b=0|$g(F+(G+k)^p,16))+(v+D)^F,12))+(F+(G+k))|0)^b,8))+(b+(v+D))|0)^t,7),y=0|$g((c=(r=0|$g((g=(t=0|$g((w=0|$g(d+u+l^w,16))+(p+_)^l,12))+(d+u+l)|0)^w,8))+(w+(p+_))|0)^t,7),f=f+1|0}while(10!=(0|f));return Bg(A,e),Bg(A+4|0,B),Bg(A+8|0,i),Bg(A+12|0,g),Bg(A+16|0,n),Bg(A+20|0,a),Bg(A+24|0,r),Bg(A+28|0,I),0}function d(A,I,e,g){A|=0,I|=0,e|=0,g|=0;var i=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0;o=wi,C=wi=wi+63&-64,wi=wi+704|0;A:do{if(!(0==(0|e)&0==(0|g))){if(s=0|fi[A+72>>2],Q=0|fi[A+72+4>>2],n=0|Ue(0|s,0|Q,3),c=0|Se(0|e,0|g,3),E=vi,r=0|Ue(0|e,0|g,61),a=vi,Q=0|Ig(0|s,0|Q,0|c,0|E),s=vi,fi[A+72>>2]=Q,fi[A+72+4>>2]=s,i=0|fi[A+64>>2],t=0|fi[A+64+4>>2],s>>>0<E>>>0|(0|s)==(0|E)&Q>>>0<c>>>0&&(i=0|Ig(0|i,0|t,1,0),t=vi,fi[A+64>>2]=i,fi[A+64+4>>2]=t),a=0|Ig(0|i,0|t,0|r,0|a),fi[A+64>>2]=a,fi[A+64+4>>2]=vi,a=0|Ag(128,0,127&n|0,0),(i=vi)>>>0>g>>>0|(0|i)==(0|g)&a>>>0>e>>>0)for(i=0,t=0;;)if(E=0|yi[I+i>>0],s=0|Ig(0|i,0|t,127&n|0,0),yi[A+80+s>>0]=E,i=0|Ig(0|i,0|t,1,0),!((t=vi)>>>0<g>>>0|(0|t)==(0|g)&i>>>0<e>>>0))break A;if(!(0==(0|a)&0==(0|i))){t=0,r=0;do{E=0|yi[I+t>>0],s=0|Ig(0|t,0|r,127&n|0,0),yi[A+80+s>>0]=E,t=0|Ig(0|t,0|r,1,0),r=vi}while(r>>>0<i>>>0|(0|r)==(0|i)&t>>>0<a>>>0)}if(B(A,A+80|0,C,C+640|0),i=0|Ag(0|e,0|g,0|a,0|i),(t=vi)>>>0>0|0==(0|t)&i>>>0>127){r=I+a|0;do{B(A,r,C,C+640|0),r=r+128|0,i=0|Ig(0|i,0|t,-128,-1),t=vi}while(t>>>0>0|0==(0|t)&i>>>0>127);a=r}else a=I+a|0;if(!(0==(0|(i&=127))&!0)){t=0,r=0;do{yi[A+80+t>>0]=0|yi[a+t>>0],t=0|Ig(0|t,0|r,1,0),r=vi}while(r>>>0<0|0==(0|r)&t>>>0<i>>>0)}YI(C,704)}}while(0);wi=o}function D(A,I,e,g){A|=0,e|=0,g|=0;var i=0,B=0;for(i=wi,B=wi=wi+63&-64,wi=wi+2272|0,BA(B+2016|0,I|=0),BA(B+1760|0,g),we(B+480|0,e),ue(B+320|0,e),Qe(B,B+320|0),jA(B+320|0,B,B+480|0),Qe(B+160|0,B+320|0),we(B+480+160|0,B+160|0),jA(B+320|0,B,B+480+160|0),Qe(B+160|0,B+320|0),we(B+480+320|0,B+160|0),jA(B+320|0,B,B+480+320|0),Qe(B+160|0,B+320|0),we(B+480+480|0,B+160|0),jA(B+320|0,B,B+480+480|0),Qe(B+160|0,B+320|0),we(B+480+640|0,B+160|0),jA(B+320|0,B,B+480+640|0),Qe(B+160|0,B+320|0),we(B+480+800|0,B+160|0),jA(B+320|0,B,B+480+800|0),Qe(B+160|0,B+320|0),we(B+480+960|0,B+160|0),jA(B+320|0,B,B+480+960|0),Qe(B+160|0,B+320|0),we(B+480+1120|0,B+160|0),Tg(A),I=255;!(0|yi[B+2016+I>>0]||0|yi[B+1760+I>>0]);){if(e=I+-1|0,!((0|I)>0)){I=e;break}I=e}if((0|I)>-1)for(;nI(B+320|0,A),(e=0|yi[B+2016+I>>0])<<24>>24<=0?e<<24>>24<0&&(Qe(B+160|0,B+320|0),qA(B+320|0,B+160|0,B+480+(160*(((e<<24>>24)/-2|0)<<24>>24)|0)|0)):(Qe(B+160|0,B+320|0),jA(B+320|0,B+160|0,B+480+(160*((255&e)>>>1&255)|0)|0)),(e=0|yi[B+1760+I>>0])<<24>>24<=0?e<<24>>24<0&&(Qe(B+160|0,B+320|0),WA(B+320|0,B+160|0,1064+(120*(((e<<24>>24)/-2|0)<<24>>24)|0)|0)):(Qe(B+160|0,B+320|0),zA(B+320|0,B+160|0,1064+(120*((255&e)>>>1&255)|0)|0)),Xe(A,B+320|0),(0|I)>0;)I=I+-1|0;wi=i}function v(A,I,e,g,i,B,t,r){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0;var a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0;if(h=wi,s=wi=wi+63&-64,wi=wi+16|0,fi[s>>2]=0,Ng(r),g){n=0,o=0,C=0,a=0;A:for(;;){for(;Q=0|yi[e+a>>0],255==(0|(c=4&r?0|xA(Q):0|XA(Q)));){if(!i){c=18;break A}if(!(0|wg(i,Q))){c=19;break A}if((a=a+1|0)>>>0>=g>>>0){c=17;break A}}if(o=c+(o<<6)|0,(c=n+6|0)>>>0>7){if(n=n+-2|0,C>>>0>=I>>>0){c=13;break}yi[A+C>>0]=o>>>n,C=C+1|0}else n=c;if((a=a+1|0)>>>0>=g>>>0){c=16;break}}13==(0|c)?(fi[s>>2]=a,fi[8202]=34,a=-1):16==(0|c)?(fi[s>>2]=a,a=0):17==(0|c)?(fi[s>>2]=a,a=0):18==(0|c)?(fi[s>>2]=a,a=0):19==(0|c)&&(fi[s>>2]=a,a=0),n>>>0>4?(a=-1,C=0):c=21}else a=0,C=0,o=0,n=0,c=21;do{if(21==(0|c))if((1<<n)-1&o)a=-1,C=0;else if(a|2&r||(a=0|DA(e,g,s,i,n>>>1)),a)C=0;else if(0!=(0|i)?(E=0|fi[s>>2])>>>0<g>>>0:0){for(a=E;;){if(!(0|wg(i,0|yi[e+a>>0]))){c=30;break}if((a=a+1|0)>>>0>=g>>>0){c=29;break}}if(29==(0|c)){fi[s>>2]=a,a=0;break}if(30==(0|c)){fi[s>>2]=a,a=0;break}}else a=0}while(0);return n=0|fi[s>>2],t?fi[t>>2]=e+n:(0|n)!=(0|g)&&(fi[8202]=22,a=-1),0|B&&(fi[B>>2]=C),wi=h,0|a}function b(A,I,e){I|=0,e|=0;var g=0,i=0,B=0,t=0,r=0,a=0;switch(a=wi,r=wi=wi+63&-64,wi=wi+16|0,B=0|fi[20+(A|=0)>>2],t=0|fi[A+4>>2],fi[A+20>>2]=0,fi[A+4>>2]=0,0|e){case 2:0|NA(I,33697,9)?I=-32:(I=I+9|0,i=4);break;case 1:0|NA(I,33707,8)?I=-32:(I=I+8|0,i=4);break;default:I=-26}do{if(4==(0|i))if(0==(0|NA(I,33716,3))?0!=(0|(g=0|LA(I+3|0,r+4|0))):0)if(19==(0|fi[r+4>>2]))if(0|NA(g,33720,3))I=-32;else{if(!(I=0|LA(g+3|0,r+4|0))){I=-32;break}if(fi[A+44>>2]=fi[r+4>>2],0|NA(I,33724,3))I=-32;else{if(!(I=0|LA(I+3|0,r+4|0))){I=-32;break}if(fi[A+40>>2]=fi[r+4>>2],0|NA(I,33728,3))I=-32;else{if(!(I=0|LA(I+3|0,r+4|0))){I=-32;break}if(i=0|fi[r+4>>2],fi[A+48>>2]=i,fi[A+52>>2]=i,i=36==(0|yi[I>>0]),I=i?I+1|0:I,i){if(fi[r+4>>2]=B,i=0|fi[A+16>>2],0|v(i,B,I,0|TA(I),0,r+4|0,r,3)){I=-32;break}if(fi[A+20>>2]=fi[r+4>>2],I=0|fi[r>>2],B=36==(0|yi[I>>0]),I=B?I+1|0:I,B){if(fi[r+4>>2]=t,B=0|fi[A>>2],0|v(B,t,I,0|TA(I),0,r+4|0,r,3)){I=-32;break}fi[A+4>>2]=fi[r+4>>2],e=0|fi[r>>2],(I=0|O(A))||(I=0==(0|yi[e>>0])?0:-32)}else I=-32}else I=-32}}}else I=-26;else I=-32}while(0);return wi=a,0|I}function k(A,I,e){A|=0,I|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0;for(a=0|ug(e|=0),r=0|ug(e+4|0),t=0|ug(e+8|0),B=0|ug(e+12|0),y=0|ug(e+16|0),h=0|ug(e+20|0),s=0|ug(e+24|0),E=0|ug(e+28|0),i=0|ug(I),g=0|ug(I+4|0),n=0|ug(I+8|0),e=0|ug(I+12|0),I=n,n=20,C=2036477234,o=857760878,c=1634760805,Q=1797285236;b=(0|$g(h+c|0,7))^B,d=(0|$g(b+c|0,9))^I,w=(0|$g(d+b|0,13))^h,F=(0|$g(w+d|0,18))^c,u=(0|$g(o+a|0,7))^e,p=(0|$g(u+o|0,9))^s,H=(0|$g(p+u|0,13))^a,v=(0|$g(H+p|0,18))^o,_=(0|$g(C+i|0,7))^E,M=(0|$g(_+C|0,9))^r,G=(0|$g(M+_|0,13))^i,l=(0|$g(G+M|0,18))^C,m=(0|$g(Q+y|0,7))^t,k=(0|$g(m+Q|0,9))^g,D=(0|$g(k+m|0,13))^y,f=(0|$g(D+k|0,18))^Q,a=(0|$g(m+F|0,7))^H,r=(0|$g(a+F|0,9))^M,t=(0|$g(r+a|0,13))^m,c=(0|$g(t+r|0,18))^F,i=(0|$g(v+b|0,7))^G,g=(0|$g(i+v|0,9))^k,B=(0|$g(g+i|0,13))^b,o=(0|$g(B+g|0,18))^v,y=(0|$g(l+u|0,7))^D,I=(0|$g(y+l|0,9))^d,e=(0|$g(I+y|0,13))^u,C=(0|$g(e+I|0,18))^l,h=(0|$g(f+_|0,7))^w,s=(0|$g(h+f|0,9))^p,E=(0|$g(s+h|0,13))^_,Q=(0|$g(E+s|0,18))^f,!((0|n)<=2);)n=n+-2|0;Bg(A,c),Bg(A+4|0,o),Bg(A+8|0,C),Bg(A+12|0,Q),Bg(A+16|0,i),Bg(A+20|0,g),Bg(A+24|0,I),Bg(A+28|0,e)}function G(A,I,e,g){I|=0,e|=0,g|=0;var i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0;if(B=0|fi[56+(A|=0)>>2],i=0|fi[A+56+4>>2],0==(0|B)&0==(0|i))C=6;else{if(r=0|Ag(16,0,0|B,0|i),n=vi,a=n>>>0>g>>>0|(0|n)==(0|g)&r>>>0>e>>>0?e:r,n=n>>>0>g>>>0|(0|n)==(0|g)&r>>>0>e>>>0?g:n,!(0==(0|a)&0==(0|n))){r=0,t=0;do{o=0|yi[I+r>>0],B=0|Ig(0|B,0|i,0|r,0|t),yi[A+64+B>>0]=o,r=0|Ig(0|r,0|t,1,0),t=vi,B=0|fi[A+56>>2],i=0|fi[A+56+4>>2]}while(t>>>0<n>>>0|(0|t)==(0|n)&r>>>0<a>>>0)}o=0|Ig(0|B,0|i,0|a,0|n),r=vi,fi[A+56>>2]=o,fi[A+56+4>>2]=r,r>>>0<0|0==(0|r)&o>>>0<16||(e=0|Ag(0|e,0|g,0|a,0|n),g=vi,y(A,A+64|0,16,0),fi[A+56>>2]=0,fi[A+56+4>>2]=0,I=I+a|0,C=6)}if(6==(0|C)&&(i=-16&e,g>>>0>0|0==(0|g)&e>>>0>15?(e=0|Ag(0|e,0|g,0|i,0|g),o=vi,y(A,I,i,g),I=I+i|0,i=o):i=g,!(0==(0|e)&0==(0|i)))){g=0,B=0|fi[A+56>>2],t=0|fi[A+56+4>>2],r=0;do{C=0|yi[I+g>>0],o=0|Ig(0|B,0|t,0|g,0|r),yi[A+64+o>>0]=C,g=0|Ig(0|g,0|r,1,0),r=vi,B=0|fi[A+56>>2],t=0|fi[A+56+4>>2]}while(r>>>0<i>>>0|(0|r)==(0|i)&g>>>0<e>>>0);o=0|Ig(0|B,0|t,0|e,0|i),fi[A+56>>2]=o,fi[A+56+4>>2]=vi}}function F(A,I,e){e|=0;var g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+400|0,0==(0|(A|=0))|0==(0|(I|=0))||(II(i,0,0,64),Bg(i+384|0,0|fi[I+48>>2]),rg(i,i+384|0,4,0),Bg(i+384|0,0|fi[I+4>>2]),rg(i,i+384|0,4,0),Bg(i+384|0,0|fi[I+44>>2]),rg(i,i+384|0,4,0),Bg(i+384|0,0|fi[I+40>>2]),rg(i,i+384|0,4,0),Bg(i+384|0,19),rg(i,i+384|0,4,0),Bg(i+384|0,e),rg(i,i+384|0,4,0),Bg(i+384|0,0|fi[I+12>>2]),rg(i,i+384|0,4,0),(0|(e=0|fi[I+8>>2])?(rg(i,e,0|fi[I+12>>2],0),1&fi[I+56>>2]|0):0)&&(YI(0|fi[I+8>>2],0|fi[I+12>>2]),fi[I+12>>2]=0),Bg(i+384|0,0|fi[I+20>>2]),rg(i,i+384|0,4,0),0|(e=0|fi[I+16>>2])&&rg(i,e,0|fi[I+20>>2],0),Bg(i+384|0,0|fi[I+28>>2]),rg(i,i+384|0,4,0),(0|(e=0|fi[I+24>>2])?(rg(i,e,0|fi[I+28>>2],0),2&fi[I+56>>2]|0):0)&&(YI(0|fi[I+24>>2],0|fi[I+28>>2]),fi[I+28>>2]=0),Bg(i+384|0,0|fi[I+36>>2]),rg(i,i+384|0,4,0),0|(e=0|fi[I+32>>2])&&rg(i,e,0|fi[I+36>>2],0),ye(i,A,64)),wi=g}function m(A,I,e,g){A|=0,I|=0,e|=0,g|=0;var i=0,B=0,t=0,r=0,a=0;if(r=wi,a=wi=wi+63&-64,wi=wi+528|0,fi[a+384>>2]=0,Bg(a+384|0,I),I>>>0<65)(0|II(a,0,0,I))>=0&&(rg(a,a+384|0,4,0),rg(a,e,g,0),ye(a,A,I));else A:do{if((0|II(a,0,0,64))>=0?(rg(a,a+384|0,4,0),rg(a,e,g,0),(0|ye(a,a+456|0,64))>=0):0){B=a+456|0,t=(i=A)+32|0;do{yi[i>>0]=0|yi[B>>0],i=i+1|0,B=B+1|0}while((0|i)<(0|t));B=a+456|0,t=64+(i=a+392|0)|0;do{yi[i>>0]=0|yi[B>>0],i=i+1|0,B=B+1|0}while((0|i)<(0|t));if((I+-32|0)>>>0>64){g=I+-32|0,e=A+32|0;do{if((0|aI(a+456|0,64,a+392|0,64,0,0,0))<0)break A;B=a+456|0,t=(i=e)+32|0;do{yi[i>>0]=0|yi[B>>0],i=i+1|0,B=B+1|0}while((0|i)<(0|t));g=g+-32|0,e=e+32|0,B=a+456|0,t=64+(i=a+392|0)|0;do{yi[i>>0]=0|yi[B>>0],i=i+1|0,B=B+1|0}while((0|i)<(0|t))}while(g>>>0>64)}else g=I+-32|0,e=A+32|0;(0|aI(a+456|0,g,a+392|0,64,0,0,0))>=0&&T(0|e,a+456|0,0|g)}}while(0);YI(a,384),wi=r}function M(A,I){A|=0,I|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,o=0,c=0,Q=0;A:do{if(0|A){do{if(2==(0|fi[A+36>>2])){if(0==(0|(e=0|fi[I>>2]))?(0|_i[I+8>>0])<=1:0){g=6;break}Q=0,c=0|fi[A+4>>2]}else g=6}while(0);if(6==(0|g)&&(z(A,I,c=0|fi[A+4>>2]),Q=1,e=0|fi[I>>2]),i=0|yi[I+8>>0],e=0==(0|e)&i<<24>>24==0?2:0,g=0|fi[A+24>>2],a=0|bi(g,0|fi[I+4>>2]),o=0|fi[A+20>>2],i=e+a+(0|bi(o,255&i))|0,e>>>0<o>>>0)for(o=i,i=(0==(0|(i>>>0)%(g>>>0))?g+-1|0:-1)+i|0;;){if(a=1==(0|(o>>>0)%(g>>>0))?o+-1|0:i,g=Q?c+(e<<3)|0:(0|fi[4+(0|fi[A>>2])>>2])+(a<<10)|0,B=0|fi[g>>2],g=0|ne(0|fi[g+4>>2],0,0|fi[A+28>>2],0),i=vi,((r=0==(0|fi[I>>2]))?0==(0|yi[I+8>>0]):0)&&(g=0|fi[I+4>>2],i=0),fi[I+12>>2]=e,B=0|aA(A,I,B,1&(0==(0|i)?(0|g)==(0|fi[I+4>>2]):0)),t=0|fi[4+(0|fi[A>>2])>>2],g=0|he(0|fi[A+24>>2],0,0|g,0|i),i=t+(o<<10)|0,r?C(t+(a<<10)|0,t+(g<<10)+(B<<10)|0,i):n(t+(a<<10)|0,t+(g<<10)+(B<<10)|0,i),(e=e+1|0)>>>0>=(0|fi[A+20>>2])>>>0)break A;o=o+1|0,i=a+1|0,g=0|fi[A+24>>2]}}}while(0)}function H(A,I,e,g,i,B,t,r){A|=0,I|=0,i|=0,B|=0,t|=0,r|=0;var a=0,n=0,C=0,o=0;if(C=wi,o=wi=wi+63&-64,wi=wi+112|0,!(0==(0|(e|=0))&0==(0|(g|=0)))){a=32+(n=o+16|0)|0;do{yi[n>>0]=0|yi[r>>0],n=n+1|0,r=r+1|0}while((0|n)<(0|a));for(r=_i[i+4>>0]|_i[i+4+1>>0]<<8|_i[i+4+2>>0]<<16|_i[i+4+3>>0]<<24,fi[o>>2]=_i[i>>0]|_i[i+1>>0]<<8|_i[i+2>>0]<<16|_i[i+3>>0]<<24,fi[o+4>>2]=r,r=8;yi[o+r>>0]=B,B=0|Ue(0|B,0|t,8),16!=(0|(r=r+1|0));)t=vi;if(g>>>0>0|0==(0|g)&e>>>0>63)for(r=A,B=e;;){Ug(o+48|0,o,o+16|0),A=0;do{yi[r+A>>0]=yi[o+48+A>>0]^yi[I+A>>0],A=A+1|0}while(64!=(0|A));for(A=1,t=8;e=o+t|0,A=(0|_i[e>>0])+A|0,yi[e>>0]=A,16!=(0|(t=t+1|0));)A>>>=8;if(t=0|Ig(0|B,0|g,-64,-1),g=vi,A=r+64|0,I=I+64|0,!(g>>>0>0|0==(0|g)&t>>>0>63))break;r=A,B=t}else t=e;if(0==(0|t)&0==(0|g)?0:(Ug(o+48|0,o,o+16|0),0|t)){g=0;do{yi[A+g>>0]=yi[o+48+g>>0]^yi[I+g>>0],g=g+1|0}while((0|g)!=(0|t))}YI(o+48|0,64),YI(o+16|0,32)}wi=C}function Y(A,I){A|=0;var e=0,g=0;e=wi,g=wi=wi+63&-64,wi=wi+160|0,c(g+120|0,I|=0),c(g+80|0,g+120|0),c(g+80|0,g+80|0),a(g+80|0,I,g+80|0),a(g+120|0,g+120|0,g+80|0),c(g+40|0,g+120|0),a(g+80|0,g+80|0,g+40|0),c(g+40|0,g+80|0),I=1;do{c(g+40|0,g+40|0),I=I+1|0}while(5!=(0|I));a(g+80|0,g+40|0,g+80|0),c(g+40|0,g+80|0),I=1;do{c(g+40|0,g+40|0),I=I+1|0}while(10!=(0|I));a(g+40|0,g+40|0,g+80|0),c(g,g+40|0),I=1;do{c(g,g),I=I+1|0}while(20!=(0|I));a(g+40|0,g,g+40|0),c(g+40|0,g+40|0),I=1;do{c(g+40|0,g+40|0),I=I+1|0}while(10!=(0|I));a(g+80|0,g+40|0,g+80|0),c(g+40|0,g+80|0),I=1;do{c(g+40|0,g+40|0),I=I+1|0}while(50!=(0|I));a(g+40|0,g+40|0,g+80|0),c(g,g+40|0),I=1;do{c(g,g),I=I+1|0}while(100!=(0|I));a(g+40|0,g,g+40|0),c(g+40|0,g+40|0),I=1;do{c(g+40|0,g+40|0),I=I+1|0}while(50!=(0|I));a(g+80|0,g+40|0,g+80|0),c(g+80|0,g+80|0),I=1;do{c(g+80|0,g+80|0),I=I+1|0}while(5!=(0|I));a(A,g+80|0,g+120|0),wi=e}function S(A,I,e,g,i,B,t){A|=0,I|=0,e|=0,g|=0,i|=0;var r=0,a=0,n=0,C=0;a=wi,n=wi=wi+63&-64,wi=wi+352|0,k(n+256|0,B|=0,t|=0),(A>>>0>e>>>0?0<i>>>0|0==(0|i)&(A-e|0)>>>0<g>>>0:0)?r=5:(e>>>0>A>>>0?0<i>>>0|0==(0|i)&(e-A|0)>>>0<g>>>0:0)&&(r=5),5==(0|r)&&(GI(0|A,0|e,0|g),e=A),r=32+(t=n+288|0)|0;do{yi[t>>0]=0,t=t+1|0}while((0|t)<(0|r));return t=i>>>0>0|0==(0|i)&g>>>0>32?32:g,r=i>>>0>0|0==(0|i)&g>>>0>32?0:i,0==(0|t)&0==(0|r)||T(n+288+32|0,0|e,1+(C=0|Ag(-2,-1,0|(~i>>>0>4294967295|-1==(0|~i)&~g>>>0>4294967263?~g:-33),0|(~i>>>0>4294967295|-1==(0|~i)&~g>>>0>4294967263?~i:-1)))|0),C=0|Ig(0|t,0|r,32,0),ze(n+288|0,n+288|0,C,vi,B+16|0,n+256|0),Mg(n,n+288|0),0==(0|t)&0==(0|r)||T(0|A,n+288+32|0,1+(C=0|Ag(-2,-1,0|(~i>>>0>4294967295|-1==(0|~i)&~g>>>0>4294967263?~g:-33),0|(~i>>>0>4294967295|-1==(0|~i)&~g>>>0>4294967263?~i:-1)))|0),YI(n+288|0,64),i>>>0>0|0==(0|i)&g>>>0>32&&qe(A+t|0,e+t|0,C=0|Ag(0|g,0|i,0|t,0|r),vi,B+16|0,n+256|0),YI(n+256|0,32),eg(n,A,g,i),mg(n,I),YI(n,256),wi=a,0}function R(A,I){I|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0;if(g=0|fi[56+(A|=0)>>2],e=0|fi[A+56+4>>2],!(0==(0|g)&0==(0|e))){for(i=1;yi[A+64+g>>0]=i,g=0|Ig(0|g,0|e,1,0),(e=vi)>>>0<0|0==(0|e)&g>>>0<16;)i=0;yi[A+80>>0]=1,y(A,A+64|0,16,0)}g=0|fi[A+24>>2],a=(((n=(((B=(5*((t=((a=((i=(0|fi[A+28>>2])+(g>>>26)|0)>>>26)+(0|fi[A+32>>2])|0)>>>26)+(0|fi[A+36>>2])|0)>>>26)|0)+(0|fi[A+20>>2])|0)>>>26)+(67108863&g)+((5+(67108863&B)|0)>>>26)|0)>>>26)+(67108863&i)|0)>>>26)+a&67108863&((r=(-67108864|t)+((((n+(67108863&i)|0)>>>26)+(67108863&a)|0)>>>26)|0)>>>31)-1|r>>31&67108863&a,B=0|Ig(B+5&67108863&(r>>>31)-1|r>>31&67108863&B|(g=(B>>>26)+(67108863&g)+((5+(67108863&B)|0)>>>26)&67108863&(r>>>31)-1|r>>31&(B>>>26)+(67108863&g))<<26|0,0,0|fi[A+40>>2],0),e=vi,e=0|Ig(0|(g=0|Ig(g>>>6|(n+i&67108863&(r>>>31)-1|r>>31&67108863&i)<<20|0,0,0|fi[A+44>>2],0)),0|vi,0|e,0),g=vi,g=0|Ig(0|(i=0|Ig((n+i&67108863&(r>>>31)-1|r>>31&67108863&i)>>>12|a<<14|0,0,0|fi[A+48>>2],0)),0|vi,0|g,0),i=vi,i=0|Ig(0|(t=0|Ig(a>>>18|((r>>>31)-1&r|r>>31&t)<<8|0,0,0|fi[A+52>>2],0)),0|vi,0|i,0),Bg(I,B),Bg(I+4|0,e),Bg(I+8|0,g),Bg(I+12|0,i),YI(A,88)}function N(A,I){A|=0;var e=0,g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+128|0,c(i+80|0,I|=0),c(i+40|0,i+80|0),c(i+40|0,i+40|0),a(i+40|0,I,i+40|0),a(i+80|0,i+80|0,i+40|0),c(i+80|0,i+80|0),a(i+80|0,i+40|0,i+80|0),c(i+40|0,i+80|0),e=1;do{c(i+40|0,i+40|0),e=e+1|0}while(5!=(0|e));a(i+80|0,i+40|0,i+80|0),c(i+40|0,i+80|0),e=1;do{c(i+40|0,i+40|0),e=e+1|0}while(10!=(0|e));a(i+40|0,i+40|0,i+80|0),c(i,i+40|0),e=1;do{c(i,i),e=e+1|0}while(20!=(0|e));a(i+40|0,i,i+40|0),c(i+40|0,i+40|0),e=1;do{c(i+40|0,i+40|0),e=e+1|0}while(10!=(0|e));a(i+80|0,i+40|0,i+80|0),c(i+40|0,i+80|0),e=1;do{c(i+40|0,i+40|0),e=e+1|0}while(50!=(0|e));a(i+40|0,i+40|0,i+80|0),c(i,i+40|0),e=1;do{c(i,i),e=e+1|0}while(100!=(0|e));a(i+40|0,i,i+40|0),c(i+40|0,i+40|0),e=1;do{c(i+40|0,i+40|0),e=e+1|0}while(50!=(0|e));a(i+80|0,i+40|0,i+80|0),c(i+80|0,i+80|0),c(i+80|0,i+80|0),a(A,i+80|0,I),wi=g}function U(A,I,e,g,i){A|=0,I|=0,e|=0,g|=0;var B=0,t=0,r=0,a=0,n=0,C=0;Ng(i|=0),t=(0|bi((g>>>0)/3|0,-3))+g|0,B=((g>>>0)/3|0)<<2;do{if(t){if(2&i){B=(2|B)+(t>>>1)|0;break}B=B+4|0;break}}while(0);if(B>>>0>=I>>>0&&hi(),4&i)if(0|g){r=0,n=0,t=0,i=0;do{for(i=0|_i[e+n>>0]|i<<8,C=r+8|0,a=t;r=C+-6|0,t=a+1|0,yi[A+a>>0]=0|OI(i>>>r&63),r>>>0>5;)C=r,a=t;n=n+1|0}while((0|n)!=(0|g));r&&(yi[A+t>>0]=0|OI(i<<12-C&63),t=a+2|0)}else t=0;else if(0|g){a=0,i=0,t=0,r=0;do{for(i=0|_i[e+a>>0]|i<<8,C=t,n=r+8|0;r=n+-6|0,t=C+1|0,yi[A+C>>0]=0|Ae(i>>>r&63),r>>>0>5;)C=t,n=r;a=a+1|0}while((0|a)!=(0|g));r&&(yi[A+t>>0]=0|Ae(i<<12-n&63),t=C+2|0)}else t=0;return B>>>0<t>>>0&&Mi(34645,34664,230,34680),B>>>0>t>>>0?wA(A+t|0,61,B-t|0):B=t,g=B+1|0,wA(A+B|0,0,(g>>>0<I>>>0?I:g)-B|0),0|A}function J(A,I){A|=0;var e=0,g=0,i=0;for(g=wi,i=wi=wi+63&-64,wi=wi+1760|0,we(i+480|0,I|=0),ue(i+320|0,I),Qe(i,i+320|0),jA(i+320|0,i,i+480|0),Qe(i+160|0,i+320|0),we(i+480+160|0,i+160|0),jA(i+320|0,i,i+480+160|0),Qe(i+160|0,i+320|0),we(i+480+320|0,i+160|0),jA(i+320|0,i,i+480+320|0),Qe(i+160|0,i+320|0),we(i+480+480|0,i+160|0),jA(i+320|0,i,i+480+480|0),Qe(i+160|0,i+320|0),we(i+480+640|0,i+160|0),jA(i+320|0,i,i+480+640|0),Qe(i+160|0,i+320|0),we(i+480+800|0,i+160|0),jA(i+320|0,i,i+480+800|0),Qe(i+160|0,i+320|0),we(i+480+960|0,i+160|0),jA(i+320|0,i,i+480+960|0),Qe(i+160|0,i+320|0),we(i+480+1120|0,i+160|0),bg(A),I=252;ue(i+320|0,A),(e=0|yi[32988+I>>0])<<24>>24<=0?e<<24>>24<0&&(Qe(i+160|0,i+320|0),qA(i+320|0,i+160|0,i+480+(160*(((e<<24>>24)/-2|0)<<24>>24)|0)|0)):(Qe(i+160|0,i+320|0),jA(i+320|0,i+160|0,i+480+(160*((255&e)>>>1&255)|0)|0)),Qe(A,i+320|0),(0|I)>0;)I=I+-1|0;wi=g}function P(A,I,e){A|=0,I|=0,e|=0;var g=0,i=0,B=0;i=wi,B=wi=wi+63&-64,wi=wi+288|0,g=0;do{yi[A+g>>0]=0|yi[I+g>>0],g=g+1|0}while(32!=(0|g));for(yi[A>>0]=-8&yi[A>>0],yi[A+31>>0]=63&yi[A+31>>0]|64,f(B+240|0,e),$e(B+200|0),fg(B+160|0),KA(B+120|0,B+240|0),$e(B+80|0),g=0,I=254;e=g,g=(0|_i[A+(I>>>3)>>0])>>>(7&I)&1,e^=g,x(B+200|0,B+120|0,e),x(B+160|0,B+80|0,e),hA(B+40|0,B+120|0,B+80|0),hA(B,B+200|0,B+160|0),yA(B+200|0,B+200|0,B+160|0),yA(B+160|0,B+120|0,B+80|0),a(B+80|0,B+40|0,B+200|0),a(B+160|0,B+160|0,B),c(B+40|0,B),c(B,B+200|0),yA(B+120|0,B+80|0,B+160|0),hA(B+160|0,B+80|0,B+160|0),a(B+200|0,B,B+40|0),hA(B,B,B+40|0),c(B+160|0,B+160|0),_(B+80|0,B),c(B+120|0,B+120|0),yA(B+40|0,B+40|0,B+80|0),a(B+80|0,B+240|0,B+160|0),a(B+160|0,B,B+40|0),!((0|I)<=0);)I=I+-1|0;return x(B+200|0,B+120|0,g),x(B+160|0,B+80|0,g),Y(B+160|0,B+160|0),a(B+200|0,B+200|0,B+160|0),q(A,B+200|0),wi=i,0}function L(A,I,e){A|=0,I|=0;var i=0,B=0,t=0,r=0,a=0;if(a=wi,r=wi=wi+63&-64,wi=wi+64|0,(e|=0)<<24>>24?(255&e)<=64:0){if(0|jg(0|fi[A+80>>2],0|fi[A+80+4>>2]))i=-1;else{i=0|fi[A+352>>2];do{if(i>>>0>128){if(QI(A,128,0),g(A,A+96|0),i=(0|fi[A+352>>2])-128|0,fi[A+352>>2]=i,i>>>0<129){T(A+96|0,A+224|0,0|i),B=A+96|0,t=0|fi[A+352>>2];break}Mi(33273,33305,304,33350)}else B=A+96|0,t=i}while(0);QI(A,t,0),ig(A),wA(A+96+(i=0|fi[A+352>>2])|0,0,256-i|0),g(A,B),WI(r,0|fi[A>>2],0|fi[A+4>>2]),WI(r+8|0,0|fi[A+8>>2],0|fi[A+8+4>>2]),WI(r+16|0,0|fi[A+16>>2],0|fi[A+16+4>>2]),WI(r+24|0,0|fi[A+24>>2],0|fi[A+24+4>>2]),WI(r+32|0,0|fi[A+32>>2],0|fi[A+32+4>>2]),WI(r+40|0,0|fi[A+40>>2],0|fi[A+40+4>>2]),WI(r+48|0,0|fi[A+48>>2],0|fi[A+48+4>>2]),WI(r+56|0,0|fi[A+56>>2],0|fi[A+56+4>>2]),T(0|I,0|r,255&e|0),YI(A,64),YI(B,256),i=0}return wi=a,0|i}return hi(),0}function x(A,I,e){I|=0,e|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0;l=0|fi[(A|=0)>>2],p=0|fi[A+4>>2],f=0|fi[A+8>>2],h=0|fi[A+12>>2],E=0|fi[A+16>>2],c=0|fi[A+20>>2],C=0|fi[A+24>>2],a=0|fi[A+28>>2],t=0|fi[A+32>>2],i=0|fi[A+36>>2],w=0|fi[I>>2],_=0|fi[I+4>>2],y=0|fi[I+8>>2],s=0|fi[I+12>>2],Q=0|fi[I+16>>2],o=0|fi[I+20>>2],n=0|fi[I+24>>2],r=0|fi[I+28>>2],B=0|fi[I+32>>2],g=0|fi[I+36>>2],fi[A>>2]=(w^l)&0-e^l,fi[A+4>>2]=(_^p)&0-e^p,fi[A+8>>2]=(y^f)&0-e^f,fi[A+12>>2]=(s^h)&0-e^h,fi[A+16>>2]=(Q^E)&0-e^E,fi[A+20>>2]=(o^c)&0-e^c,fi[A+24>>2]=(n^C)&0-e^C,fi[A+28>>2]=(r^a)&0-e^a,fi[A+32>>2]=(B^t)&0-e^t,fi[A+36>>2]=(g^i)&0-e^i,fi[I>>2]=(w^l)&0-e^w,fi[I+4>>2]=(_^p)&0-e^_,fi[I+8>>2]=(y^f)&0-e^y,fi[I+12>>2]=(s^h)&0-e^s,fi[I+16>>2]=(Q^E)&0-e^Q,fi[I+20>>2]=(o^c)&0-e^o,fi[I+24>>2]=(n^C)&0-e^n,fi[I+28>>2]=(r^a)&0-e^r,fi[I+32>>2]=(B^t)&0-e^B,fi[I+36>>2]=(g^i)&0-e^g}function X(A,I,e,g,i,B,t){A|=0,I|=0,e|=0,g|=0,i|=0;var r=0,a=0,n=0;return n=wi,a=wi=wi+63&-64,wi=wi+96|0,k(a,B|=0,t|=0),Sg(a+32|0,B+16|0,a),0|We(e,I,g,i,a+32|0)?(YI(a,32),e=-1):A?((I>>>0>=A>>>0?0<i>>>0|0==(0|i)&(I-A|0)>>>0<g>>>0:0)?r=8:(A>>>0>=I>>>0?0<i>>>0|0==(0|i)&(A-I|0)>>>0<g>>>0:0)&&(r=8),8==(0|r)&&(GI(0|A,0|I,0|g),I=A),0==(0|(e=i>>>0>0|0==(0|i)&g>>>0>32?32:g))&0==(0|(t=i>>>0>0|0==(0|i)&g>>>0>32?0:i))?ze(a+32|0,a+32|0,32,0,B+16|0,a):(T(a+32+32|0,0|I,1+(r=0|Ag(-2,-1,0|(~i>>>0>4294967295|-1==(0|~i)&~g>>>0>4294967263?~g:-33),0|(~i>>>0>4294967295|-1==(0|~i)&~g>>>0>4294967263?~i:-1)))|0),ze(a+32|0,a+32|0,0|Ig(0|e,0|t,32,0),vi,B+16|0,a),T(0|A,a+32+32|0,r+1|0)),i>>>0>0|0==(0|i)&g>>>0>32&&qe(A+e|0,I+e|0,0|Ag(0|g,0|i,0|e,0|t),vi,B+16|0,a),YI(a,32),e=0):e=0,wi=n,0|e}function K(A,I,e,g,i){A|=0,g|=0,i|=0;var B=0,t=0,r=0,a=0,n=0,C=0,o=0;if(C=wi,o=wi=wi+63&-64,wi=wi+112|0,!(0==(0|(I|=0))&0==(0|(e|=0)))){B=32+(t=o+16|0)|0;do{yi[t>>0]=0|yi[i>>0],t=t+1|0,i=i+1|0}while((0|t)<(0|B));if(t=_i[g+4>>0]|_i[g+4+1>>0]<<8|_i[g+4+2>>0]<<16|_i[g+4+3>>0]<<24,fi[o>>2]=_i[g>>0]|_i[g+1>>0]<<8|_i[g+2>>0]<<16|_i[g+3>>0]<<24,fi[o+4>>2]=t,fi[o+8>>2]=0,fi[o+8+4>>2]=0,e>>>0>0|0==(0|e)&I>>>0>63){do{for(Ug(A,o,o+16|0),i=1,B=8;t=o+B|0,i=(0|_i[t>>0])+i|0,yi[t>>0]=i,16!=(0|(B=B+1|0));)i>>>=8;I=0|Ig(0|I,0|e,-64,-1),e=vi,A=A+64|0}while(e>>>0>0|0==(0|e)&I>>>0>63);0==(0|I)&0==(0|e)||(a=A,n=I,r=7)}else a=A,n=I,r=7;if(7==(0|r)?(Ug(o+48|0,o,o+16|0),0|n):0){i=0;do{yi[a+i>>0]=0|yi[o+48+i>>0],i=i+1|0}while((0|i)!=(0|n))}YI(o+48|0,64),YI(o+16|0,32)}wi=C}function T(A,I,e){A|=0,I|=0;var g=0,i=0,B=0;if((0|(e|=0))>=8192)return 0|Ri(0|A,0|I,0|e);if(B=0|A,i=A+e|0,(3&A)==(3&I)){for(;3&A;){if(!e)return 0|B;yi[A>>0]=0|yi[I>>0],A=A+1|0,I=I+1|0,e=e-1|0}for(g=(e=-4&i|0)-64|0;(0|A)<=(0|g);)fi[A>>2]=fi[I>>2],fi[A+4>>2]=fi[I+4>>2],fi[A+8>>2]=fi[I+8>>2],fi[A+12>>2]=fi[I+12>>2],fi[A+16>>2]=fi[I+16>>2],fi[A+20>>2]=fi[I+20>>2],fi[A+24>>2]=fi[I+24>>2],fi[A+28>>2]=fi[I+28>>2],fi[A+32>>2]=fi[I+32>>2],fi[A+36>>2]=fi[I+36>>2],fi[A+40>>2]=fi[I+40>>2],fi[A+44>>2]=fi[I+44>>2],fi[A+48>>2]=fi[I+48>>2],fi[A+52>>2]=fi[I+52>>2],fi[A+56>>2]=fi[I+56>>2],fi[A+60>>2]=fi[I+60>>2],A=A+64|0,I=I+64|0;for(;(0|A)<(0|e);)fi[A>>2]=fi[I>>2],A=A+4|0,I=I+4|0}else for(e=i-4|0;(0|A)<(0|e);)yi[A>>0]=0|yi[I>>0],yi[A+1>>0]=0|yi[I+1>>0],yi[A+2>>0]=0|yi[I+2>>0],yi[A+3>>0]=0|yi[I+3>>0],A=A+4|0,I=I+4|0;for(;(0|A)<(0|i);)yi[A>>0]=0|yi[I>>0],A=A+1|0,I=I+1|0;return 0|B}function V(A){var I=0,e=0,g=0,i=0,B=0;e=wi,g=wi=wi+63&-64,wi=wi+48|0,i=A|=0,B=(I=g)+32|0;do{yi[I>>0]=0|yi[i>>0],I=I+1|0,i=i+1|0}while((0|I)<(0|B));i=_i[A+36>>0]|_i[A+36+1>>0]<<8|_i[A+36+2>>0]<<16|_i[A+36+3>>0]<<24,I=_i[A+36+4>>0]|_i[A+36+4+1>>0]<<8|_i[A+36+4+2>>0]<<16|_i[A+36+4+3>>0]<<24,yi[g+32>>0]=i,yi[g+32+1>>0]=i>>8,yi[g+32+2>>0]=i>>16,yi[g+32+3>>0]=i>>24,yi[g+32+4>>0]=I,yi[g+32+4+1>>0]=I>>8,yi[g+32+4+2>>0]=I>>16,yi[g+32+4+3>>0]=I>>24,ng(g,g,A+32|0,A),i=g,B=(I=A)+32|0;do{yi[I>>0]=0|yi[i>>0],I=I+1|0,i=i+1|0}while((0|I)<(0|B));i=_i[g+32>>0]|_i[g+32+1>>0]<<8|_i[g+32+2>>0]<<16|_i[g+32+3>>0]<<24,B=_i[g+32+4>>0]|_i[g+32+4+1>>0]<<8|_i[g+32+4+2>>0]<<16|_i[g+32+4+3>>0]<<24,yi[A+36>>0]=i,yi[A+36+1>>0]=i>>8,yi[A+36+2>>0]=i>>16,yi[A+36+3>>0]=i>>24,yi[A+36+4>>0]=B,yi[A+36+4+1>>0]=B>>8,yi[A+36+4+2>>0]=B>>16,yi[A+36+4+3>>0]=B>>24,Ye(A),wi=e}function q(A,I){A|=0;var e=0,g=0,i=0;e=wi,i=wi=wi+63&-64,wi=wi+48|0,j(i,I|=0),I=0|fi[i>>2],yi[A>>0]=I,yi[A+1>>0]=I>>>8,yi[A+2>>0]=I>>>16,g=0|fi[i+4>>2],yi[A+3>>0]=g<<2|I>>>24,yi[A+4>>0]=g>>>6,yi[A+5>>0]=g>>>14,I=0|fi[i+8>>2],yi[A+6>>0]=I<<3|g>>>22,yi[A+7>>0]=I>>>5,yi[A+8>>0]=I>>>13,g=0|fi[i+12>>2],yi[A+9>>0]=g<<5|I>>>21,yi[A+10>>0]=g>>>3,yi[A+11>>0]=g>>>11,I=0|fi[i+16>>2],yi[A+12>>0]=I<<6|g>>>19,yi[A+13>>0]=I>>>2,yi[A+14>>0]=I>>>10,yi[A+15>>0]=I>>>18,I=0|fi[i+20>>2],yi[A+16>>0]=I,yi[A+17>>0]=I>>>8,yi[A+18>>0]=I>>>16,g=0|fi[i+24>>2],yi[A+19>>0]=g<<1|I>>>24,yi[A+20>>0]=g>>>7,yi[A+21>>0]=g>>>15,I=0|fi[i+28>>2],yi[A+22>>0]=I<<3|g>>>23,yi[A+23>>0]=I>>>5,yi[A+24>>0]=I>>>13,g=0|fi[i+32>>2],yi[A+25>>0]=g<<4|I>>>21,yi[A+26>>0]=g>>>4,yi[A+27>>0]=g>>>12,I=0|fi[i+36>>2],yi[A+28>>0]=I<<6|g>>>20,yi[A+29>>0]=I>>>2,yi[A+30>>0]=I>>>10,yi[A+31>>0]=I>>>18,wi=e}function j(A,I){A|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0;Q=0|fi[(I|=0)>>2],o=0|fi[I+4>>2],C=0|fi[I+8>>2],n=0|fi[I+12>>2],r=0|fi[I+16>>2],t=0|fi[I+20>>2],B=0|fi[I+24>>2],g=0|fi[I+28>>2],e=0|fi[I+32>>2],i=(((a=(((c=(19*((((((((((((16777216+(19*(I=0|fi[I+36>>2])|0)|0)>>>25)+Q>>26)+o>>25)+C>>26)+n>>25)+r>>26)+t>>25)+B>>26)+g>>25)+e>>26)+I>>25)|0)+Q>>26)+o>>25)+C>>26)+n>>25)+r>>26)+t>>25)+B>>26,fi[A>>2]=(19*((((((((((((16777216+(19*I|0)|0)>>>25)+Q>>26)+o>>25)+C>>26)+n>>25)+r>>26)+t>>25)+B>>26)+g>>25)+e>>26)+I>>25)|0)+Q-(c<<26),fi[A+4>>2]=c+o-(c+o>>25<<25),fi[A+8>>2]=(c+o>>25)+C-((c+o>>25)+C>>26<<26),fi[A+12>>2]=((c+o>>25)+C>>26)+n-(a<<25),fi[A+16>>2]=a+r-(a+r>>26<<26),fi[A+20>>2]=(a+r>>26)+t-((a+r>>26)+t>>25<<25),fi[A+24>>2]=((a+r>>26)+t>>25)+B-(i<<26),fi[A+28>>2]=i+g-(i+g>>25<<25),fi[A+32>>2]=(i+g>>25)+e-((i+g>>25)+e>>26<<26),fi[A+36>>2]=((i+g>>25)+e>>26)+I&33554431}function Z(A,I){A|=0,I|=0;var e=0,g=0,i=0,B=0,t=0;g=wi,i=wi=wi+63&-64,wi=wi+464|0,e=0;do{t=0|yi[I+e>>0],yi[i+400+(B=e<<1)>>0]=15&t,yi[i+400+(1|B)>>0]=(255&t)>>>4,e=e+1|0}while(32!=(0|e));e=0,I=0;do{e=134217728+((B=(0|_i[(t=i+400+I|0)>>0])+e|0)<<24)>>28,yi[t>>0]=B-(e<<4),I=I+1|0}while(63!=(0|I));yi[i+400+63>>0]=(0|_i[i+400+63>>0])+e,bg(A),e=1;do{vg(i,(0|e)/2|0,0|yi[i+400+e>>0]),zA(i+240|0,A,i),Qe(A,i+240|0),e=e+2|0}while((0|e)<64);ue(i+240|0,A),Xe(i+120|0,i+240|0),nI(i+240|0,i+120|0),Xe(i+120|0,i+240|0),nI(i+240|0,i+120|0),Xe(i+120|0,i+240|0),nI(i+240|0,i+120|0),Qe(A,i+240|0),e=0;do{vg(i,(0|e)/2|0,0|yi[i+400+e>>0]),zA(i+240|0,A,i),Qe(A,i+240|0),e=e+2|0}while((0|e)<64);wi=g}function W(A,I,e,g){A|=0,I|=0,e|=0,g|=0;var i=0,B=0,r=0,a=0,n=0,C=0,o=0;o=wi,C=wi=wi+63&-64,wi=wi+64|0,B=52+(i=C+8|0)|0;do{fi[i>>2]=0,i=i+4|0}while((0|i)<(0|B));i=0|TA(A),fi[C+36>>2]=i,fi[C+20>>2]=i,fi[C+4>>2]=i,B=0|t(i),fi[C+32>>2]=B,r=0|t(i),fi[C+16>>2]=r,a=0|t(i),fi[C>>2]=a;do{if(0==(0|r)|0==(0|a)|0==(0|B))Q(B),Q(r),Q(a),i=-22;else{if(!(n=0|t(i))){Q(B),Q(r),Q(a),i=-22;break}if(0|(i=0|b(C,A,g))){Q(0|fi[C+32>>2]),Q(0|fi[C+16>>2]),Q(0|fi[C>>2]),Q(n);break}g=0|eA(0|fi[C+40>>2],0|fi[C+44>>2],0|fi[C+52>>2],I,e,0|fi[C+16>>2],0|fi[C+20>>2],n,0|fi[C+4>>2],0,0,g),Q(0|fi[C+32>>2]),Q(0|fi[C+16>>2]),i=(0==(0|g)?0==(0|iI(n,0|fi[C>>2],0|fi[C+4>>2])):0)?0:-35,Q(n),Q(0|fi[C>>2])}}while(0);return wi=o,0|i}function z(A,I,e){A|=0,I|=0,e|=0;var g=0,i=0,B=0,t=0,r=0;if(i=wi,B=wi=wi+63&-64,wi=wi+4096|0,ei(B+3072|0),ei(B+2048|0),0!=(0|A)&0!=(0|I)?(fi[B+2048>>2]=fi[I>>2],fi[B+2048+4>>2]=0,fi[B+2048+8>>2]=fi[I+4>>2],fi[B+2048+8+4>>2]=0,fi[B+2048+16>>2]=_i[I+8>>0],fi[B+2048+16+4>>2]=0,fi[B+2048+24>>2]=fi[A+16>>2],fi[B+2048+24+4>>2]=0,fi[B+2048+32>>2]=fi[A+8>>2],fi[B+2048+32+4>>2]=0,fi[B+2048+40>>2]=fi[A+36>>2],fi[B+2048+40+4>>2]=0,0|fi[A+20>>2]):0){I=0;do{(g=127&I)||(t=0|Ig(0|fi[B+2048+48>>2],0|fi[B+2048+48+4>>2],1,0),fi[B+2048+48>>2]=t,fi[B+2048+48+4>>2]=vi,ei(B),ei(B+1024|0),n(B+3072|0,B+2048|0,B),n(B+3072|0,B,B+1024|0)),r=0|fi[B+1024+(g<<3)+4>>2],fi[(t=e+(I<<3)|0)>>2]=fi[B+1024+(g<<3)>>2],fi[t+4>>2]=r,I=I+1|0}while(I>>>0<(0|fi[A+20>>2])>>>0)}wi=i}function O(A){A|=0;var I=0,e=0;do{if(A)if(0|fi[A>>2])if((0|fi[A+4>>2])>>>0>=16){if(0==(0|fi[A+8>>2])?0|fi[A+12>>2]:0){I=-18;break}if(I=0|fi[A+20>>2],0!=(0|fi[A+16>>2])|0==(0|I))if(I>>>0>=8){if(0==(0|fi[A+24>>2])?0|fi[A+28>>2]:0){I=-20;break}if(0==(0|fi[A+32>>2])?0|fi[A+36>>2]:0){I=-21;break}if((I=0|fi[A+44>>2])>>>0>=8)if(I>>>0<=2097152)if(e=0|fi[A+48>>2],I>>>0>=e<<3>>>0)if(0|fi[A+40>>2])if(e){if(!(e>>>0>16777215))return 0|(0==(0|(A=0|fi[A+52>>2]))?-28:A>>>0>16777215?-29:0);I=-17}else I=-16;else I=-12;else I=-14;else I=-15;else I=-14}else I=-6;else I=-19}else I=-2;else I=-1;else I=-25}while(0);return 0|I}function $(A,I,e,g,i){A|=0,e|=0,g|=0,i|=0;var B=0,t=0,r=0;t=wi,r=wi=wi+63&-64,wi=wi+192|0,((I|=0)-1&255)>63&&hi(),e||hi(),yi[r+128>>0]=I,yi[r+128+1>>0]=32,yi[r+128+2>>0]=1,yi[r+128+3>>0]=1,Dg(r+128+4|0),WI(r+128+8|0,0,0),B=16+(I=r+128+16|0)|0;do{yi[I>>0]=0,I=I+1|0}while((0|I)<(0|B));if(g)de(r+128|0,g);else{B=16+(I=r+128+32|0)|0;do{yi[I>>0]=0,I=I+1|0}while((0|I)<(0|B))}if(i)le(r+128|0,i);else{B=16+(I=r+128+48|0)|0;do{yi[I>>0]=0,I=I+1|0}while((0|I)<(0|B))}bI(A,r+128|0),B=96+(I=r+32|0)|0;do{yi[I>>0]=0,I=I+1|0}while((0|I)<(0|B));B=(I=r)+32|0;do{yi[I>>0]=0|yi[e>>0],I=I+1|0,e=e+1|0}while((0|I)<(0|B));rA(A,r,128,0),YI(r,128),wi=t}function AA(A,I,e,g,i,B,t,r,a,n,C){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0;var o=0;o=wi,wi=wi+352|0,ag(o+280|0,64,0,n|=0,C|=0),Mg(o,o+280|0),YI(o+280|0,64),eg(o,t,r,a),eg(o,35288,15&(I=0|Ag(0,0,0|r,0|a)),0),eg(o,e,g,i),eg(o,35288,15&(I=0|Ag(0,0,0|g,0|i)),0),WI(o+272|0,r,a),eg(o,o+272|0,8,0),WI(o+272|0,g,i),eg(o,o+272|0,8,0),mg(o,o+256|0),YI(o,256),I=0|zg(o+256|0,B),YI(o+256|0,16);do{if(A){if(I){wA(0|A,0,0|g),I=-1;break}He(A,e,g,i,n,1,C),I=0;break}}while(0);return wi=o,0|I}function IA(A){var I=0,e=0,g=0,i=0;if((A|=0)>>>0>=4294967168)return fi[8202]=12,0|(i=0);if(i=A>>>0<11?16:A+11&-8,!(g=0|t(i+76|0)))return 0|(i=0);do{if(63&g){if(e=((g+63&-64)-8-(g+-8)|0)>>>0>15?(g+63&-64)-8|0:56+(g+63&-64)|0,A=e-(g+-8)|0,3&(I=0|fi[g+-4>>2])){fi[e+4>>2]=(-8&I)-A|1&fi[e+4>>2]|2,fi[e+((-8&I)-A)+4>>2]=1|fi[e+((-8&I)-A)+4>>2],fi[g+-4>>2]=A|1&fi[g+-4>>2]|2,fi[e+4>>2]=1|fi[e+4>>2],E(g+-8|0,A),A=e;break}fi[e>>2]=(0|fi[g+-8>>2])+A,fi[e+4>>2]=(-8&I)-A,A=e;break}A=g+-8|0,e=g+-8|0}while(0);return A=A+4|0,(3&(I=0|fi[A>>2])|0?(-8&I)>>>0>(i+16|0)>>>0:0)&&(g=e+i|0,fi[A>>2]=i|1&I|2,fi[g+4>>2]=(-8&I)-i|3,fi[g+((-8&I)-i)+4>>2]=1|fi[g+((-8&I)-i)+4>>2],E(g,(-8&I)-i|0)),0|(i=e+8|0)}function eA(A,I,e,g,i,B,r,a,n,C,o,c){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,r|=0,a|=0,C|=0,o|=0,c|=0;var E=0,s=0,h=0;h=wi,s=wi=wi+63&-64,wi=wi+64|0,E=0|t(n|=0);do{if(E){if(fi[s>>2]=E,fi[s+4>>2]=n,fi[s+8>>2]=g,fi[s+12>>2]=i,fi[s+16>>2]=B,fi[s+20>>2]=r,fi[s+24>>2]=0,fi[s+24+4>>2]=0,fi[s+24+8>>2]=0,fi[s+24+12>>2]=0,fi[s+40>>2]=A,fi[s+44>>2]=I,fi[s+48>>2]=e,fi[s+52>>2]=e,fi[s+56>>2]=4,0|(A=0|cA(s,c))){YI(E,n),Q(E);break}if(0|a&&T(0|a,0|E,0|n),0!=(0|C)&0!=(0|o)?0|l(C,o,s,c):0){YI(E,n),YI(C,o),Q(E),A=-31;break}YI(E,n),Q(E),A=0}else A=-22}while(0);return wi=h,0|A}function gA(A,I){var e=0,g=0,i=0;return i=wi,e=wi=wi+63&-64,wi=wi+240|0,f(40+(A|=0)|0,I|=0),$e(A+80|0),c(e+200|0,A+40|0),a(e+160|0,e+200|0,944),hA(e+200|0,e+200|0,A+80|0),yA(e+160|0,e+160|0,A+80|0),c(e+120|0,e+160|0),a(e+120|0,e+120|0,e+160|0),c(A,e+120|0),a(A,A,e+160|0),a(A,A,e+200|0),N(A,A),a(A,A,e+120|0),a(A,A,e+200|0),c(e+80|0,A),a(e+80|0,e+80|0,e+160|0),hA(e+40|0,e+80|0,e+200|0),0|ve(e+40|0)?g=4:(yA(e,e+80|0,e+200|0),0|ve(e)?(a(A,A,984),g=4):A=-1),4==(0|g)&&((0|(g=0|Re(A)))==((0|_i[I+31>>0])>>>7|0)&&RA(A,A),a(A+120|0,A,A+40|0),A=0),wi=i,0|A}function iA(A,I,e){I|=0,e|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0;w=0|fi[(A|=0)>>2],_=0|fi[A+4>>2],y=0|fi[A+8>>2],s=0|fi[A+12>>2],Q=0|fi[A+16>>2],o=0|fi[A+20>>2],n=0|fi[A+24>>2],r=0|fi[A+28>>2],B=0|fi[A+32>>2],g=0|fi[A+36>>2],p=(fi[I+4>>2]^_)&0-e,f=(fi[I+8>>2]^y)&0-e,h=(fi[I+12>>2]^s)&0-e,E=(fi[I+16>>2]^Q)&0-e,c=(fi[I+20>>2]^o)&0-e,C=(fi[I+24>>2]^n)&0-e,a=(fi[I+28>>2]^r)&0-e,t=(fi[I+32>>2]^B)&0-e,i=(fi[I+36>>2]^g)&0-e,fi[A>>2]=(fi[I>>2]^w)&0-e^w,fi[A+4>>2]=p^_,fi[A+8>>2]=f^y,fi[A+12>>2]=h^s,fi[A+16>>2]=E^Q,fi[A+20>>2]=c^o,fi[A+24>>2]=C^n,fi[A+28>>2]=a^r,fi[A+32>>2]=t^B,fi[A+36>>2]=i^g}function BA(A,I){A|=0,I|=0;var e=0,g=0,i=0,B=0,t=0;e=0;do{yi[A+e>>0]=(0|_i[I+(e>>3)>>0])>>>(7&e)&1,e=e+1|0}while(256!=(0|e));B=0;do{t=A+B|0;A:do{if(0|yi[t>>0]){i=1;do{if((0|(e=i+B|0))>=256)break A;I=0|yi[A+e>>0];I:do{if(I<<24>>24){if(I=I<<24>>24<<i,((g=0|yi[t>>0])+I|0)<16){yi[t>>0]=g+I,yi[A+e>>0]=0;break}if((g-I|0)<-15)break A;for(yi[t>>0]=g-I;I=A+e|0,0|yi[I>>0];)if(yi[I>>0]=0,(0|(e=e+1|0))>=256)break I;yi[I>>0]=1}}while(0);i=i+1|0}while((0|i)<7)}}while(0);B=B+1|0}while(256!=(0|B))}function tA(A,I,e,g,i,B,t,r,a,n,C,o){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,o|=0,n=wi,wi=wi+336|0,ag(n+264|0,64,0,C,o),Mg(n,n+264|0),YI(n+264|0,64),eg(n,t,r,a),t=0|Ag(0,0,0|r,0|a),eg(n,35288,15&t,0),He(A,g,i,B,C,1,o),eg(n,A,i,B),t=0|Ag(0,0,0|i,0|B),eg(n,35288,15&t,0),WI(n+256|0,r,a),eg(n,n+256|0,8,0),WI(n+256|0,i,B),eg(n,n+256|0,8,0),mg(n,I),YI(n,256),0|e&&(fi[e>>2]=16,fi[e+4>>2]=0),wi=n,0}function rA(A,I,e,i){A|=0,I|=0,e|=0,i|=0;var B=0,t=0,r=0,a=0;A:do{if(!(0==(0|e)&0==(0|i))){for(B=0|fi[A+352>>2],a=i;r=256-B|0,i=A+96+B|0,a>>>0>0|0==(0|a)&e>>>0>r>>>0;){T(0|i,0|I,0|r),fi[A+352>>2]=(0|fi[A+352>>2])+r,QI(A,128,0),g(A,A+96|0),B=A+224|0,t=128+(i=A+96|0)|0;do{yi[i>>0]=0|yi[B>>0],i=i+1|0,B=B+1|0}while((0|i)<(0|t));if(B=(0|fi[A+352>>2])-128|0,fi[A+352>>2]=B,e=0|Ag(0|e,0|a,0|r,0),i=vi,0==(0|e)&0==(0|i))break A;I=I+r|0,a=i}T(0|i,0|I,0|e),a=0|Ig(0|fi[A+352>>2],0,0|e,0|a),fi[A+352>>2]=a}}while(0)}function aA(A,I,e,g){A|=0,e|=0,g|=0;var i=0,B=0,t=0,r=0;r=0==(0|fi[(I|=0)>>2]),B=0|fi[I+12>>2];do{if(r){if(!((i=0|yi[I+8>>0])<<24>>24)){i=B+-1|0;break}if(i=0|bi(0|fi[A+20>>2],255&i),g){i=B+-1+i|0;break}i=i+((0==(0|B))<<31>>31)|0;break}if(i=(0|fi[A+24>>2])-(0|fi[A+20>>2])|0,g){i=B+-1+i|0;break}i=i+((0==(0|B))<<31>>31)|0;break}while(0);return he(0|e,0,0|e,0),he(0|i,0,0|vi,0),B=0|Ag(i+-1|0,0,0|vi,0),e=vi,(r?0:(t=0|yi[I+8>>0])<<24>>24!=3)?(i=0|bi(0|fi[A+20>>2],1+(255&t)|0),g=0):(i=0,g=0),r=0|Ig(0|B,0|e,0|i,0|g),0|(A=0|ne(0|r,0|vi,0|fi[A+24>>2],0))}function nA(A,I,e,g,i,B,t,r,a,n,C){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0;var o=0;o=wi,wi=wi+352|0,Rg(o+280|0,n|=0,C|=0),Mg(o,o+280|0),YI(o+280|0,64),eg(o,t,r,a),WI(o+272|0,r,a),eg(o,o+272|0,8,0),eg(o,e,g,i),WI(o+272|0,g,i),eg(o,o+272|0,8,0),mg(o,o+256|0),YI(o,256),I=0|zg(o+256|0,B),YI(o+256|0,16);do{if(A){if(I){wA(0|A,0,0|g),I=-1;break}Oe(A,e,g,i,n,C),I=0;break}}while(0);return wi=o,0|I}function CA(A,I,e,g,B,t,a){A|=0,I|=0,e|=0,g|=0,B|=0,t|=0;var n=0,C=0;n=wi,C=wi=wi+63&-64,wi=wi+560|0,gg(C,a|=0),KI(C+496|0,t,32,0),d(C,C+496+32|0,32,0),d(C,e,g,B),ee(C,C+432|0),GI(A+32|0,t+32|0,32),r(C+432|0),Z(C+208|0,C+432|0),fI(A,C+208|0),gg(C,a),d(C,A,64,0),d(C,e,g,B),ee(C,C+368|0),r(C+368|0),pg(C+496|0),i(A+32|0,C+368|0,C+496|0,C+432|0),YI(C+496|0,64),YI(C+432|0,64),0|I&&(fi[I>>2]=64,fi[I+4>>2]=0),wi=n}function oA(A,I,e,g,i){I|=0,e|=0,g|=0,i|=0;var B=0,t=0,r=0,a=0;if(a=wi,r=wi=wi+63&-64,wi=wi+64|0,t=0|TA(A|=0),e>>>0>0|0==(0|e)&I>>>0>4294967295|t>>>0>127)fi[8202]=22,e=-1;else{B=(e=r)+60|0;do{fi[e>>2]=0,e=e+4|0}while((0|e)<(0|B));(B=0|Ne(t))?(fi[r+16>>2]=B,fi[r+8>>2]=B,fi[r>>2]=B,fi[r+20>>2]=t,fi[r+12>>2]=t,fi[r+4>>2]=t,fi[r+24>>2]=0,fi[r+24+4>>2]=0,fi[r+24+8>>2]=0,fi[r+24+12>>2]=0,0|b(r,A,i)?(fi[8202]=22,e=-1):e=(0|fi[r+40>>2])==(0|I)?(0|fi[r+44>>2])!=(g>>>10|0)&1:1,Q(B)):e=-1}return wi=a,0|e}function cA(A,I){I|=0;var e=0,g=0,i=0,B=0,t=0;if(i=wi,g=wi=wi+63&-64,wi=wi+48|0,!(e=0|O(A|=0)))if((I+-1|0)>>>0<=1){if(B=0|fi[A+44>>2],e=0|fi[A+48>>2],B=((B>>>0<e<<3>>>0?e<<3:B)>>>0)/(e<<2>>>0)|0,t=0|bi(B,e<<2),fi[g>>2]=0,fi[g+8>>2]=fi[A+40>>2],fi[g+12>>2]=-1,fi[g+16>>2]=t,fi[g+20>>2]=B,fi[g+24>>2]=B<<2,fi[g+28>>2]=e,fi[g+32>>2]=fi[A+52>>2],fi[g+36>>2]=I,!(e=0|PA(g,A))){if(0|fi[g+8>>2]){e=0;do{lA(g,e),e=e+1|0}while(e>>>0<(0|fi[g+8>>2])>>>0)}uA(A,g),e=0}}else e=-26;return wi=i,0|e}function QA(A,I,e,g,i,B){I|=0,e|=0,g|=0,i|=0,B|=0;var t=0,a=0;return a=wi,t=wi=wi+63&-64,wi=wi+592|0,((((0!=(0|DI(32+(A|=0)|0))?0==(0|tI(A)):0)?0!=(0|re(i)):0)?0==(0|tI(i)):0)?0==(0|gA(t+328|0,i)):0)?(gg(t,B),d(t,A,32,0),d(t,i,32,0),d(t,I,e,g),ee(t,t+520|0),r(t+520|0),D(t+208|0,t+520|0,t+328|0,A+32|0),fI(t+488|0,t+208|0),B=0|Wg(t+488|0,A),A=0|((t+488|0)==(0|A)?-1:B)|iI(A,t+488|0,32)):A=-1,wi=a,0|A}function EA(A,I){A|=0,I|=0;var e=0,g=0;A:do{if(255&I){if(3&A)do{if((g=0|yi[A>>0])<<24>>24==0?1:g<<24>>24==(255&I)<<24>>24)break A;A=A+1|0}while(0!=(3&A|0));g=0|bi(255&I,16843009),e=0|fi[A>>2];I:do{if(!((-2139062144&e^-2139062144)&e+-16843009))do{if((-2139062144&(e^=g)^-2139062144)&e+-16843009|0)break I;e=0|fi[(A=A+4|0)>>2]}while(!((-2139062144&e^-2139062144)&e+-16843009|0))}while(0);for(;(g=0|yi[A>>0])<<24>>24!=0&&g<<24>>24!=(255&I)<<24>>24;)A=A+1|0}else A=A+(0|TA(A))|0}while(0);return 0|A}function sA(A,I){I|=0;var e=0,g=0,i=0;i=wi,wi=wi+192|0,XI(A|=0),g=127+(e=i+64+1|0)|0;do{yi[e>>0]=54,e=e+1|0}while((0|e)<(0|g));yi[i+64>>0]=54^yi[I>>0],e=1;do{yi[(g=i+64+e|0)>>0]=yi[g>>0]^yi[I+e>>0],e=e+1|0}while(32!=(0|e));d(A,i+64|0,128,0),XI(A+208|0),g=127+(e=i+64+1|0)|0;do{yi[e>>0]=92,e=e+1|0}while((0|e)<(0|g));yi[i+64>>0]=92^yi[I>>0],e=1;do{yi[(g=i+64+e|0)>>0]=yi[g>>0]^yi[I+e>>0],e=e+1|0}while(32!=(0|e));d(A+208|0,i+64|0,128,0),YI(i+64|0,128),YI(i,64),wi=i}function hA(A,I,e){A|=0,e|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0;o=(0|fi[4+(I|=0)>>2])-(0|fi[e+4>>2])|0,C=(0|fi[I+8>>2])-(0|fi[e+8>>2])|0,n=(0|fi[I+12>>2])-(0|fi[e+12>>2])|0,a=(0|fi[I+16>>2])-(0|fi[e+16>>2])|0,r=(0|fi[I+20>>2])-(0|fi[e+20>>2])|0,t=(0|fi[I+24>>2])-(0|fi[e+24>>2])|0,B=(0|fi[I+28>>2])-(0|fi[e+28>>2])|0,i=(0|fi[I+32>>2])-(0|fi[e+32>>2])|0,g=(0|fi[I+36>>2])-(0|fi[e+36>>2])|0,fi[A>>2]=(0|fi[I>>2])-(0|fi[e>>2]),fi[A+4>>2]=o,fi[A+8>>2]=C,fi[A+12>>2]=n,fi[A+16>>2]=a,fi[A+20>>2]=r,fi[A+24>>2]=t,fi[A+28>>2]=B,fi[A+32>>2]=i,fi[A+36>>2]=g}function yA(A,I,e){A|=0,I|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0;o=(0|fi[4+(e|=0)>>2])+(0|fi[I+4>>2])|0,C=(0|fi[e+8>>2])+(0|fi[I+8>>2])|0,n=(0|fi[e+12>>2])+(0|fi[I+12>>2])|0,a=(0|fi[e+16>>2])+(0|fi[I+16>>2])|0,r=(0|fi[e+20>>2])+(0|fi[I+20>>2])|0,t=(0|fi[e+24>>2])+(0|fi[I+24>>2])|0,B=(0|fi[e+28>>2])+(0|fi[I+28>>2])|0,i=(0|fi[e+32>>2])+(0|fi[I+32>>2])|0,g=(0|fi[e+36>>2])+(0|fi[I+36>>2])|0,fi[A>>2]=(0|fi[e>>2])+(0|fi[I>>2]),fi[A+4>>2]=o,fi[A+8>>2]=C,fi[A+12>>2]=n,fi[A+16>>2]=a,fi[A+20>>2]=r,fi[A+24>>2]=t,fi[A+28>>2]=B,fi[A+32>>2]=i,fi[A+36>>2]=g}function fA(A,I,e,g,i,B){A|=0,I|=0,e|=0,g|=0,B|=0;var t=0,r=0,a=0;return r=wi,t=wi=wi+63&-64,wi=wi+32|0,a=_i[4+(i|=0)>>0]|_i[i+4+1>>0]<<8|_i[i+4+2>>0]<<16|_i[i+4+3>>0]<<24,fi[t>>2]=_i[i>>0]|_i[i+1>>0]<<8|_i[i+2>>0]<<16|_i[i+3>>0]<<24,fi[t+4>>2]=a,fi[t+8>>2]=0,fi[t+8+4>>2]=0,WI(t+16|0,e,g),i=t+16+8|0,yi[i>>0]=0,yi[i+1>>0]=0,yi[i+2>>0]=0,yi[i+3>>0]=0,i=t+16+8+4|0,yi[i>>0]=0,yi[i+1>>0]=0,yi[i+2>>0]=0,yi[i+3>>0]=0,(I+-16|0)>>>0>48?(fi[8202]=22,A=-1):A=0|te(A,I,B,t+16|0,t),wi=r,0|A}function _A(A,I,e,g){A|=0,e|=0,g|=0;var i=0,B=0,t=0;if(B=wi,t=wi=wi+63&-64,wi=wi+192|0,((I|=0)-1&255)>63&&hi(),!((g+-1&255)>63|0==(0|e))){yi[t+128>>0]=I,yi[t+128+1>>0]=g,yi[t+128+2>>0]=1,yi[t+128+3>>0]=1,Dg(t+128+4|0),WI(t+128+8|0,0,0),i=48+(I=t+128+16|0)|0;do{yi[I>>0]=0,I=I+1|0}while((0|I)<(0|i));return bI(A,t+128|0),wA(t+(255&g)|0,0,0|(g<<24>>24<0?0:128-(255&g)|0)),T(0|t,0|e,255&g|0),rA(A,t,128,0),YI(t,128),void(wi=B)}hi()}function pA(A,I,e,g,i,B,t,r,a,n,C,o){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,o|=0,n=wi,wi=wi+336|0,Rg(n+264|0,C,o),Mg(n,n+264|0),YI(n+264|0,64),eg(n,t,r,a),WI(n+256|0,r,a),eg(n,n+256|0,8,0),Oe(A,g,i,B,C,o),eg(n,A,i,B),WI(n+256|0,i,B),eg(n,n+256|0,8,0),mg(n,I),YI(n,256),0|e&&(fi[e>>2]=16,fi[e+4>>2]=0),wi=n,0}function wA(A,I,e){I|=0;var g=0,i=0;if(g=(A|=0)+(e|=0)|0,I&=255,(0|e)>=67){for(;3&A;)yi[A>>0]=I,A=A+1|0;for(i=I|I<<8|I<<16|I<<24;(0|A)<=((-4&g)-64|0);)fi[A>>2]=i,fi[A+4>>2]=i,fi[A+8>>2]=i,fi[A+12>>2]=i,fi[A+16>>2]=i,fi[A+20>>2]=i,fi[A+24>>2]=i,fi[A+28>>2]=i,fi[A+32>>2]=i,fi[A+36>>2]=i,fi[A+40>>2]=i,fi[A+44>>2]=i,fi[A+48>>2]=i,fi[A+52>>2]=i,fi[A+56>>2]=i,fi[A+60>>2]=i,A=A+64|0;for(;(0|A)<(-4&g|0);)fi[A>>2]=i,A=A+4|0}for(;(0|A)<(0|g);)yi[A>>0]=I,A=A+1|0;return g-e|0}function lA(A,I){I|=0;var e=0,g=0,i=0,B=0;if(i=wi,B=wi=wi+63&-64,wi=wi+32|0,0|(A|=0)?0|(e=0|fi[A+28>>2]):0){fi[B>>2]=I,g=0,I=e;do{if(yi[B+8>>0]=g,I){e=0;do{fi[B+4>>2]=e,fi[B+12>>2]=0,fi[B+16>>2]=fi[B>>2],fi[B+16+4>>2]=fi[B+4>>2],fi[B+16+8>>2]=fi[B+8>>2],fi[B+16+12>>2]=fi[B+12>>2],M(A,B+16|0),e=e+1|0,I=0|fi[A+28>>2]}while(e>>>0<I>>>0)}else I=0;g=g+1|0}while(4!=(0|g))}wi=i}function uA(A,I){var e=0,g=0,i=0,B=0;if(g=wi,i=wi=wi+63&-64,wi=wi+2048|0,0!=(0|(A|=0))&0!=(0|(I|=0))){if(Og(i,(0|fi[4+(0|fi[I>>2])>>2])+(fi[I+24>>2]<<10)-1024|0),(0|fi[I+28>>2])>>>0>1){e=1;do{B=(B=0|fi[I+24>>2])-1+(0|bi(B,e))|0,RI(i,(0|fi[4+(0|fi[I>>2])>>2])+(B<<10)|0),e=e+1|0}while(e>>>0<(0|fi[I+28>>2])>>>0)}Ce(i+1024|0,i),m(0|fi[A>>2],0|fi[A+4>>2],i+1024|0,1024),YI(i,1024),YI(i+1024|0,1024),Te(I,0|fi[A+56>>2])}wi=g}function dA(A,I,e,g,i,B,t,r,a,n,C,o){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,o|=0,n=wi,wi=wi+48|0,fi[n>>2]=0,u(n+16|0,C,o,0),o=_i[C+16+4>>0]|_i[C+16+4+1>>0]<<8|_i[C+16+4+2>>0]<<16|_i[C+16+4+3>>0]<<24,fi[n+4>>2]=_i[C+16>>0]|_i[C+16+1>>0]<<8|_i[C+16+2>>0]<<16|_i[C+16+3>>0]<<24,fi[n+4+4>>2]=o,tA(A,I,e,g,i,B,t,r,a,0,n,n+16|0),YI(n+16|0,32),wi=n,0}function DA(A,I,e,g,i){A|=0,I|=0,e|=0,g|=0,i|=0;var B=0,t=0;A:do{if(i){B=0|fi[e>>2];I:for(;;){if(B>>>0>=I>>>0){i=34;break}for(;(t=0|yi[A+B>>0])<<24>>24!=61;){if(!g){i=22;break I}if(!(0|wg(g,t<<24>>24))){i=22;break I}if(B=B+1|0,fi[e>>2]=B,B>>>0>=I>>>0){i=34;break I}}if(i=i+-1|0,B=B+1|0,fi[e>>2]=B,!i){i=0;break A}}fi[8202]=i,i=-1}else i=0}while(0);return 0|i}function vA(A,I,e,g,i,B,t,r,a,n){e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,wA(0|(A|=0),0,0|(I|=0));do{if(!(e>>>0>0|0==(0|e)&I>>>0>4294967295)){if(e>>>0<0|0==(0|e)&I>>>0<16){fi[8202]=22,A=-1;break}if((a|B)>>>0>0|0==(a|B|0)&(r|i)>>>0>4294967295|n>>>0>2147483648){fi[8202]=27,A=-1;break}if(a>>>0<0|0==(0|a)&r>>>0<3|n>>>0<8192){fi[8202]=22,A=-1;break}A=(0!=(0|xe(r,n>>>10,g,i,t,A,I)))<<31>>31;break}fi[8202]=27,A=-1}while(0);return 0|A}function bA(A,I,e,g,i,B,t,r,a,n,C){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,I=wi,wi=wi+48|0,fi[I>>2]=0,u(I+16|0,n,C,0),C=_i[n+16+4>>0]|_i[n+16+4+1>>0]<<8|_i[n+16+4+2>>0]<<16|_i[n+16+4+3>>0]<<24,fi[I+4>>2]=_i[n+16>>0]|_i[n+16+1>>0]<<8|_i[n+16+2>>0]<<16|_i[n+16+3>>0]<<24,fi[I+4+4>>2]=C,n=0|AA(A,0,e,g,i,B,t,r,a,I,I+16|0),YI(I+16|0,32),wi=I,0|n}function kA(A,I,e){A|=0,I|=0;var g=0,i=0,B=0;g=wi,B=wi=wi+63&-64,wi=wi+128|0,e=((e|=0)<<24>>24)-((e<<24>>24&0-(255&(i=0|lg(e))))<<1)&255,Lg(A),Je(A,I,0|Zg(e,1)),Je(A,I+120|0,0|Zg(e,2)),Je(A,I+240|0,0|Zg(e,3)),Je(A,I+360|0,0|Zg(e,4)),Je(A,I+480|0,0|Zg(e,5)),Je(A,I+600|0,0|Zg(e,6)),Je(A,I+720|0,0|Zg(e,7)),Je(A,I+840|0,0|Zg(e,8)),KA(B,A+40|0),KA(B+40|0,A),RA(B+80|0,A+80|0),Je(A,B,i),wi=g}function GA(A,I,e,g,i,B,t,r,a,n){e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,wA(0|(A|=0),0,0|(I|=0));do{if(!(e>>>0>0|0==(0|e)&I>>>0>4294967295)){if(e>>>0<0|0==(0|e)&I>>>0<16){fi[8202]=22,A=-1;break}if((a|B)>>>0>0|0==(a|B|0)&(r|i)>>>0>4294967295|n>>>0>2147483648){fi[8202]=27,A=-1;break}if(0==(0|r)&0==(0|a)|n>>>0<8192){fi[8202]=22,A=-1;break}A=(0!=(0|Le(r,n>>>10,g,i,t,A,I)))<<31>>31;break}fi[8202]=27,A=-1}while(0);return 0|A}function FA(A,I,e,g,i,B,t){I|=0,e|=0,g|=0,i|=0,B|=0,t|=0;var r=0,a=0,n=0,C=0;C=wi,a=wi=wi+63&-64,wi=wi+16|0,n=128+(r=A|=0)|0;do{yi[r>>0]=0,r=r+1|0}while((0|r)<(0|n));do{if(!((B|g)>>>0>0|0==(B|g|0)&(i|e)>>>0>4294967295|t>>>0>2147483648)){if(B>>>0<0|0==(0|B)&i>>>0<3|t>>>0<8192){fi[8202]=22,A=-1;break}pe(a,16),A=(0!=(0|je(i,t>>>10,I,e,a,A)))<<31>>31;break}fi[8202]=27,A=-1}while(0);return wi=C,0|A}function mA(A,I,e,g,i,B,t){I|=0,e|=0,g|=0,i|=0,B|=0,t|=0;var r=0,a=0,n=0,C=0;C=wi,a=wi=wi+63&-64,wi=wi+16|0,n=128+(r=A|=0)|0;do{yi[r>>0]=0,r=r+1|0}while((0|r)<(0|n));do{if(!((B|g)>>>0>0|0==(B|g|0)&(i|e)>>>0>4294967295|t>>>0>2147483648)){if(0==(0|i)&0==(0|B)|t>>>0<8192){fi[8202]=22,A=-1;break}pe(a,16),A=(0!=(0|Ve(i,t>>>10,I,e,a,A)))<<31>>31;break}fi[8202]=27,A=-1}while(0);return wi=C,0|A}function MA(A,I){I|=0,fi[(A|=0)>>2]=67108863&(0|ug(I)),fi[A+4>>2]=(0|ug(I+3|0))>>>2&67108611,fi[A+8>>2]=(0|ug(I+6|0))>>>4&67092735,fi[A+12>>2]=(0|ug(I+9|0))>>>6&66076671,fi[A+16>>2]=(0|ug(I+12|0))>>>8&1048575,fi[A+20>>2]=0,fi[A+20+4>>2]=0,fi[A+20+8>>2]=0,fi[A+20+12>>2]=0,fi[A+20+16>>2]=0,fi[A+40>>2]=0|ug(I+16|0),fi[A+44>>2]=0|ug(I+20|0),fi[A+48>>2]=0|ug(I+24|0),fi[A+52>>2]=0|ug(I+28|0),fi[A+56>>2]=0,fi[A+56+4>>2]=0,yi[A+80>>0]=0}function HA(A,I){A|=0,I|=0;var e=0,g=0,i=0;i=wi,g=wi=wi+63&-64,wi=wi+16|0;do{if(((0!=(0|A)?0!=(0|I):0)?1024==(0|(I<<10>>>0)/(I>>>0)):0)?(e=0|t(12),fi[A>>2]=e,0!=(0|e)):0){if(fi[e+4>>2]=0,fi[e>>2]=0,e=0|Me(g,I<<10),fi[8202]=e,0|e){fi[g>>2]=0,e=-22;break}(e=0|fi[g>>2])?(fi[fi[A>>2]>>2]=e,fi[4+(0|fi[A>>2])>>2]=e,fi[8+(0|fi[A>>2])>>2]=I<<10,e=0):e=-22}else e=-22}while(0);return wi=i,0|e}function YA(A,I,e,g,i,B,t){A|=0,e|=0,g|=0,t|=0;var r=0,a=0;r=wi,a=wi=wi+63&-64,wi=wi+384|0,0==(0|(I|=0))&(0!=(0|(i|=0))|0!=(0|(B|=0)))&&hi(),A||hi(),(g+-1&255)>63&&hi(),0!=(0|e)|t<<24>>24!=0^1||hi(),(255&t)>64&&hi(),t<<24>>24?_A(a,g,e,t):OA(a,g),rA(a,I,i,B),L(a,A,g),wi=r}function SA(A,I,e,g,i,B){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0;var t=0,r=0,a=0;do{if(i>>>0<0|0==(0|i)&g>>>0<64||(t=0|Ig(0|g,0|i,-64,-1),(r=vi)>>>0>0|0==(0|r)&t>>>0>4294967231))a=8;else{if(0|Ze(e,e+64|0,t,r,B)){wA(0|A,0,0|t),a=8;break}0|I&&(fi[I>>2]=t,fi[I+4>>2]=r),GI(0|A,e+64|0,0|t),A=0}}while(0);return 8==(0|a)&&(I?(fi[I>>2]=0,fi[I+4>>2]=0,A=-1):A=-1),0|A}function RA(A,I){A|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0;C=0-(0|fi[4+(I|=0)>>2])|0,n=0-(0|fi[I+8>>2])|0,a=0-(0|fi[I+12>>2])|0,r=0-(0|fi[I+16>>2])|0,t=0-(0|fi[I+20>>2])|0,B=0-(0|fi[I+24>>2])|0,i=0-(0|fi[I+28>>2])|0,g=0-(0|fi[I+32>>2])|0,e=0-(0|fi[I+36>>2])|0,fi[A>>2]=0-(0|fi[I>>2]),fi[A+4>>2]=C,fi[A+8>>2]=n,fi[A+12>>2]=a,fi[A+16>>2]=r,fi[A+20>>2]=t,fi[A+24>>2]=B,fi[A+28>>2]=i,fi[A+32>>2]=g,fi[A+36>>2]=e}function NA(A,I,e){A|=0,I|=0;var g=0,i=0,B=0,t=0,r=0,a=0;if(e|=0){r=0|yi[A>>0],g=0|yi[I>>0];A:do{if(r<<24>>24){a=A,t=e,i=g,B=r,e=255&g,A=255&r;do{if(t=t+-1|0,!(B<<24>>24==i<<24>>24&0!=(0|t)&i<<24>>24!=0))break A;I=I+1|0,A=255&(B=0|yi[(a=a+1|0)>>0]),e=255&(i=0|yi[I>>0])}while(B<<24>>24!=0)}else e=255&g,A=255&r}while(0);A=A-e|0}else A=0;return 0|A}function UA(A,I){A|=0;var e=0,g=0,i=0;if(g=wi,i=wi=wi+63&-64,wi=wi+1024|0,0|fi[28+(I|=0)>>2]){e=0;do{Bg(A+64|0,0),Bg(A+68|0,e),m(i,1024,A,72),ie((0|fi[4+(0|fi[I>>2])>>2])+((0|bi(0|fi[I+24>>2],e))<<10)|0,i),Bg(A+64|0,1),m(i,1024,A,72),ie((0|fi[4+(0|fi[I>>2])>>2])+(1+(0|bi(0|fi[I+24>>2],e))<<10)|0,i),e=e+1|0}while(e>>>0<(0|fi[I+28>>2])>>>0)}YI(i,1024),wi=g}function JA(A,I,e,g,i,B){I|=0,i|=0,B|=0;var t=0,r=0;return t=wi,r=wi=wi+63&-64,wi=wi+16|0,GI(64+(A|=0)|0,0|(e|=0),0|(g|=0)),Ke(A,r,A+64|0,g,i,B),64==(0|fi[r>>2])&0==(0|fi[r+4>>2])?0|I?(A=0|Ig(0|g,0|i,64,0),fi[I>>2]=A,fi[I+4>>2]=vi,A=0):A=0:(0|I&&(fi[I>>2]=0,fi[I+4>>2]=0),wA(0|A,0,0|(r=0|Ig(0|g,0|i,64,0))),A=-1),wi=t,0|A}function PA(A,I){A|=0,I|=0;var e=0,g=0,i=0;i=wi,g=wi=wi+63&-64,wi=wi+80|0;do{if(0==(0|A)|0==(0|I))e=-25;else{if(e=0|t(fi[A+20>>2]<<3),fi[A+4>>2]=e,e){if(e=0|HA(A,0|fi[A+16>>2])){Te(A,0|fi[I+56>>2]);break}F(g,I,0|fi[A+36>>2]),YI(g+64|0,8),UA(g,A),YI(g,72),e=0;break}e=-22}}while(0);return wi=i,0|e}function LA(A,I){I|=0;var e=0,g=0,i=0,B=0,t=0;t=0|yi[(A|=0)>>0];A:do{if((t+-48&255)<=9){for(i=0,B=A,g=t;;){if(e=(g<<24>>24)-48|0,g=10*i|0,!(i>>>0<429496730&(e>>>0>~g>>>0^1))){e=0;break A}if(i=(e>>>0>~g>>>0?0:e)+g|0,e=B+1|0,((g=0|yi[e>>0])-48&255)>9)break;B=e}((0|e)!=(0|A)?(0|B)==(0|A)|t<<24>>24!=48:0)?fi[I>>2]=i:e=0}else e=0}while(0);return 0|e}function xA(A){return((0-((0-(95^(A|=0))|0)>>>8&63^63|(0-(45^A)|0)>>>8&62^62|((A+65439|0)>>>8^255)&A+185&((122-A|0)>>>8&255^255)|((A+-65|0)>>>8^255)&A+-65&((90-A|0)>>>8&255^255)|((A+65488|0)>>>8^255)&A+4&((57-A|0)>>>8&255^255))|0)>>>8&255^255)&(0-(65^A)|0)>>>8|(0-(95^A)|0)>>>8&63^63|(0-(45^A)|0)>>>8&62^62|((A+65439|0)>>>8^255)&A+185&((122-A|0)>>>8&255^255)|((A+-65|0)>>>8^255)&A+-65&((90-A|0)>>>8&255^255)|((A+65488|0)>>>8^255)&A+4&((57-A|0)>>>8&255^255)|0}function XA(A){return((0-((0-(47^(A|=0))|0)>>>8&63^63|(0-(43^A)|0)>>>8&62^62|((A+65439|0)>>>8^255)&A+185&((122-A|0)>>>8&255^255)|((A+-65|0)>>>8^255)&A+-65&((90-A|0)>>>8&255^255)|((A+65488|0)>>>8^255)&A+4&((57-A|0)>>>8&255^255))|0)>>>8&255^255)&(0-(65^A)|0)>>>8|(0-(47^A)|0)>>>8&63^63|(0-(43^A)|0)>>>8&62^62|((A+65439|0)>>>8^255)&A+185&((122-A|0)>>>8&255^255)|((A+-65|0)>>>8^255)&A+-65&((90-A|0)>>>8&255^255)|((A+65488|0)>>>8^255)&A+4&((57-A|0)>>>8&255^255)|0}function KA(A,I){A|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0;C=0|fi[4+(I|=0)>>2],n=0|fi[I+8>>2],a=0|fi[I+12>>2],r=0|fi[I+16>>2],t=0|fi[I+20>>2],B=0|fi[I+24>>2],i=0|fi[I+28>>2],g=0|fi[I+32>>2],e=0|fi[I+36>>2],fi[A>>2]=fi[I>>2],fi[A+4>>2]=C,fi[A+8>>2]=n,fi[A+12>>2]=a,fi[A+16>>2]=r,fi[A+20>>2]=t,fi[A+24>>2]=B,fi[A+28>>2]=i,fi[A+32>>2]=g,fi[A+36>>2]=e}function TA(A){A|=0;var I=0,e=0,g=0;A:do{if(3&A)for(I=A,e=A;;){if(!(0|yi[I>>0])){I=e;break A}if(I=I+1|0,!(3&(e=I))){g=4;break}}else I=A,g=4}while(0);if(4==(0|g)){for(;!((-2139062144&(e=0|fi[I>>2])^-2139062144)&e+-16843009);)I=I+4|0;if((255&e)<<24>>24)do{I=I+1|0}while(0!=(0|yi[I>>0]))}return I-A|0}function VA(A,I){I|=0;var e=0,g=0;if((127&(e=0|Ue(0|fi[72+(A|=0)>>2],0|fi[A+72+4>>2],3)))>>>0<112)112-(127&e)|0&&T(A+80+(127&e)|0,33569,112-(127&e)|0);else{128-(127&e)|0&&T(A+80+(127&e)|0,33569,128-(127&e)|0),B(A,A+80|0,I,I+640|0),g=112+(e=A+80|0)|0;do{fi[e>>2]=0,e=e+4|0}while((0|e)<(0|g))}TI(A+192|0,A+64|0,16),B(A,A+80|0,I,I+640|0)}function qA(A,I,e){e|=0;var g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+48|0,yA(A|=0,40+(I|=0)|0,I),hA(A+40|0,I+40|0,I),a(A+80|0,A,e+40|0),a(A+40|0,A+40|0,e),a(A+120|0,e+120|0,I+120|0),a(A,I+80|0,e+80|0),yA(i,A,A),hA(A,A+80|0,A+40|0),yA(A+40|0,A+80|0,A+40|0),hA(A+80|0,i,A+120|0),yA(A+120|0,i,A+120|0),wi=g}function jA(A,I,e){e|=0;var g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+48|0,yA(A|=0,40+(I|=0)|0,I),hA(A+40|0,I+40|0,I),a(A+80|0,A,e),a(A+40|0,A+40|0,e+40|0),a(A+120|0,e+120|0,I+120|0),a(A,I+80|0,e+80|0),yA(i,A,A),hA(A,A+80|0,A+40|0),yA(A+40|0,A+80|0,A+40|0),yA(A+80|0,i,A+120|0),hA(A+120|0,i,A+120|0),wi=g}function ZA(A){var I=0,e=0,g=0,i=0,B=0,t=0,r=0;return B=0|_i[7+(A|=0)>>0],t=0|Se(0|_i[A+6>>0],0,8),r=vi,i=0|Se(0|_i[A+5>>0],0,16),r|=vi,g=0|Se(0|_i[A+4>>0],0,24),r=r|vi|0|_i[A+3>>0],e=0|Se(0|_i[A+2>>0],0,40),r|=vi,I=0|Se(0|_i[A+1>>0],0,48),r|=vi,A=0|Se(0|_i[A>>0],0,56),vi|=r,t|B|i|g|e|I|A|0}function WA(A,I,e){e|=0;var g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+48|0,yA(A|=0,40+(I|=0)|0,I),hA(A+40|0,I+40|0,I),a(A+80|0,A,e+40|0),a(A+40|0,A+40|0,e),a(A+120|0,e+80|0,I+120|0),yA(i,I+80|0,I+80|0),hA(A,A+80|0,A+40|0),yA(A+40|0,A+80|0,A+40|0),hA(A+80|0,i,A+120|0),yA(A+120|0,i,A+120|0),wi=g}function zA(A,I,e){e|=0;var g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+48|0,yA(A|=0,40+(I|=0)|0,I),hA(A+40|0,I+40|0,I),a(A+80|0,A,e),a(A+40|0,A+40|0,e+40|0),a(A+120|0,e+80|0,I+120|0),yA(i,I+80|0,I+80|0),hA(A,A+80|0,A+40|0),yA(A+40|0,A+80|0,A+40|0),yA(A+80|0,i,A+120|0),hA(A+120|0,i,A+120|0),wi=g}function OA(A,I){A|=0;var e=0,g=0,i=0;if(g=wi,i=wi=wi+63&-64,wi=wi+64|0,!(((I|=0)-1&255)>63)){yi[i>>0]=I,yi[i+1>>0]=0,yi[i+2>>0]=1,yi[i+3>>0]=1,Dg(i+4|0),WI(i+8|0,0,0),e=48+(I=i+16|0)|0;do{yi[I>>0]=0,I=I+1|0}while((0|I)<(0|e));return bI(A,i),void(wi=g)}hi()}function $A(A,I){I|=0,fi[(A|=0)>>2]=1634760805,fi[A+4>>2]=857760878,fi[A+8>>2]=2036477234,fi[A+12>>2]=1797285236,fi[A+16>>2]=0|ug(I),fi[A+20>>2]=0|ug(I+4|0),fi[A+24>>2]=0|ug(I+8|0),fi[A+28>>2]=0|ug(I+12|0),fi[A+32>>2]=0|ug(I+16|0),fi[A+36>>2]=0|ug(I+20|0),fi[A+40>>2]=0|ug(I+24|0),fi[A+44>>2]=0|ug(I+28|0)}function AI(A,I,e,g,i){I|=0,e|=0,g|=0,i|=0;var B=0,t=0;if(B=wi,t=wi=wi+63&-64,wi=wi+384|0,(A|=0)||hi(),(e+-1&255)>63&&hi(),I)return $(t,e,I,g,i),rA(t,0,0,0),L(t,A,e),void(wi=B);hi()}function II(A,I,e,g){A|=0,I|=0,e|=0,g|=0;do{if(!(e>>>0>64|(g+-1|0)>>>0>63)){if(g>>>0>=256&&Mi(33384,33404,53,33504),e>>>0>=256&&Mi(33484,33404,54,33504),0==(0|I)|0==(0|e)){OA(A,255&g),A=0;break}_A(A,255&g,I,255&e),A=0;break}A=-1}while(0);return 0|A}function eI(A,I,e){A|=0,I|=0,e|=0;var g=0,i=0;if(g=wi,i=wi=wi+63&-64,wi=wi+16|0,fi[i+8>>2]=A,fi[i+4>>2]=I,fi[i>>2]=0,(0|e)>0){A=0;do{fi[i>>2]=255&(yi[(0|fi[i+4>>2])+A>>0]^yi[(0|fi[i+8>>2])+A>>0])|fi[i>>2],A=A+1|0}while((0|A)!=(0|e))}return wi=g,((511+(0|fi[i>>2])|0)>>>8&1)-1|0}function gI(A,I){A|=0,I|=0;var e=0,g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+208|0,e=0;do{yi[A+e>>0]=0|yi[I+e>>0],e=e+1|0}while(32!=(0|e));return yi[A>>0]=-8&yi[A>>0],yi[A+31>>0]=63&yi[A+31>>0]|64,Z(i+40|0,A),jI(i,i+40+40|0,i+40+80|0),q(A,i),wi=g,0}function iI(A,I,e){A|=0,I|=0,e|=0;var g=0,i=0;if(g=wi,i=wi=wi+63&-64,wi=wi+16|0,fi[i+4>>2]=A,fi[i>>2]=I,yi[i+8>>0]=0,0|e){A=0;do{yi[i+8>>0]=yi[i+8>>0]|yi[(0|fi[i>>2])+A>>0]^yi[(0|fi[i+4>>2])+A>>0],A=A+1|0}while((0|A)!=(0|e))}return wi=g,((511+(0|_i[i+8>>0])|0)>>>8&1)-1|0}function BI(A,I,e){I|=0,e|=0;var g=0;yi[7+(A|=0)>>0]=I,g=0|Ue(0|I,0|e,8),yi[A+6>>0]=g,g=0|Ue(0|I,0|e,16),yi[A+5>>0]=g,g=0|Ue(0|I,0|e,24),yi[A+4>>0]=g,yi[A+3>>0]=e,g=0|Ue(0|I,0|e,40),yi[A+2>>0]=g,g=0|Ue(0|I,0|e,48),yi[A+1>>0]=g,e=0|Ue(0|I,0|e,56),yi[A>>0]=e}function tI(A){var I=0,e=0,g=0,i=0,B=0,t=0;for(i=0|yi[(A|=0)>>0],e=0;;){I=0,g=0,B=0|yi[16+(e<<5)>>0],t=i;do{g=255&(B^t)|255&g,t=0|yi[A+(I=I+1|0)>>0],B=0|yi[16+(e<<5)+I>>0]}while(31!=(0|I));if(e=e+1|0,!(255&(127&t^B)|g)){I=1;break}if(e>>>0>=7){I=0;break}}return 0|I}function rI(A,I,e,g,i,B,t,r){A|=0,I|=0,i|=0,B|=0,t|=0,r|=0;var a=0,n=0;a=wi,n=wi=wi+63&-64,wi=wi+80|0,0==(0|(e|=0))&0==(0|(g|=0))||(Bg(n+64|0,B),Bg(n+64+4|0,t),$A(n,r),UI(n,i,n+64|0),h(n,I,A,e,g),YI(n,64)),wi=a}function aI(A,I,e,g,i,B,t){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0;var r=0;do{if((I+-1|0)>>>0>63|t>>>0>64)r=-1;else{if(I>>>0>=256&&Mi(33384,33404,19,33457),t>>>0<256){YA(A,e,B,255&I,g,i,255&t),r=0;break}Mi(33484,33404,20,33457)}}while(0);return 0|r}function nI(A,I){var e=0,g=0;e=wi,g=wi=wi+63&-64,wi=wi+48|0,c(A|=0,I|=0),c(A+80|0,I+40|0),o(A+120|0,I+80|0),yA(A+40|0,I,I+40|0),c(g,A+40|0),yA(A+40|0,A+80|0,A),hA(A+80|0,A+80|0,A),hA(A,g,A+40|0),hA(A+120|0,A+120|0,A+80|0),wi=e}function CI(A,I,e){A|=0,I|=0,e|=0;var g=0,i=0;if(i=wi,g=wi=wi+63&-64,wi=wi+16|0,yi[g>>0]=0,0|P(A,I,e))I=-1;else{I=0;do{yi[g>>0]=yi[g>>0]|yi[A+I>>0],I=I+1|0}while(32!=(0|I));I=0-((511+(0|_i[g>>0])|0)>>>8&1)|0}return wi=i,0|I}function oI(A,I,e){A|=0,I|=0;var g=0,i=0,B=0,t=0;B=wi,t=wi=wi+63&-64,wi=wi+64|0,KI(t,e|=0,32,0),g=t,i=(e=I)+32|0;do{yi[e>>0]=0|yi[g>>0],e=e+1|0,g=g+1|0}while((0|e)<(0|i));return YI(t,64),t=0|Fg(A,I),wi=B,0|t}function cI(A,I,e,g,i,B,t){A|=0,I|=0,i|=0,B|=0,t|=0;var r=0,a=0;r=wi,a=wi=wi+63&-64,wi=wi+80|0,0==(0|(e|=0))&0==(0|(g|=0))||(Bg(a+64|0,B),$A(a,t),ZI(a,i,a+64|0),h(a,I,A,e,g),YI(a,64)),wi=r}function QI(A,I,e){I|=0,e|=0;var g=0,i=0;g=0|Ig(0|fi[64+(A|=0)>>2],0|fi[A+64+4>>2],0|I,0|e),i=vi,fi[A+64>>2]=g,fi[A+64+4>>2]=i,e=0|Ig(1&(i>>>0<e>>>0|(0|i)==(0|e)&g>>>0<I>>>0)|0,0,0|fi[A+72>>2],0|fi[A+72+4>>2]),fi[A+72>>2]=e,fi[A+72+4>>2]=vi}function EI(A,I){A|=0,I|=0;var e=0,g=0,i=0,B=0;for(i=wi,B=wi=wi+63&-64,wi=wi+16|0,g=10;e=g+-1|0,yi[B+e>>0]=48|(I>>>0)%10,I>>>0>9&0!=(0|e);)g=e,I=(I>>>0)/10|0;T(0|A,B+e|0,0|(g=11-g|0)),yi[A+g>>0]=0,wi=i}function sI(A,I,e){A|=0;var g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+160|0,KI(I|=0,e|=0,32,0),yi[I>>0]=-8&yi[I>>0],yi[I+31>>0]=63&yi[I+31>>0]|64,Z(i,I),fI(A,i),GI(0|I,0|e,32),GI(I+32|0,0|A,32),wi=g}function hI(A,I,e,g){A|=0,I|=0,e|=0,g|=0;A:do{if(g>>>0>0|0==(0|g)&e>>>0>4294967295)fi[8202]=27,A=-1;else{switch(0|xg(A,I,e)){case 0:A=0;break A;case-35:fi[8202]=22}A=-1}}while(0);return 0|A}function yI(A,I,e,g,i){A|=0,g|=0,i|=0;var B=0,t=0;B=wi,t=wi=wi+63&-64,wi=wi+64|0,0==(0|(I|=0))&0==(0|(e|=0))||($A(t,i),ZI(t,g,0),wA(0|A,0,0|I),h(t,A,A,I,e),YI(t,64)),wi=B}function fI(A,I){A|=0;var e=0,g=0;e=wi,g=wi=wi+63&-64,wi=wi+128|0,Y(g+80|0,80+(I|=0)|0),a(g+40|0,I,g+80|0),a(g,I+40|0,g+80|0),q(A,g),I=(0|Re(g+40|0))<<7,yi[A+31>>0]=(0|_i[A+31>>0])^I,wi=e}function _I(A,I,e,g){A|=0,I|=0,e|=0,g|=0;A:do{if(g>>>0>0|0==(0|g)&e>>>0>4294967295)fi[8202]=27,A=-1;else{switch(0|Kg(A,I,e)){case 0:A=0;break A;case-35:fi[8202]=22}A=-1}}while(0);return 0|A}function pI(A){var I=0,e=0;return e=15+(A|=0)&-16|0,I=0|fi[pi>>2],A=I+e|0,(0|e)>0&(0|A)<(0|I)|(0|A)<0?(mi(),Hi(12),-1):(fi[pi>>2]=A,((0|A)>(0|Fi())?0==(0|Gi()):0)?(fi[pi>>2]=I,Hi(12),-1):0|I)}function wI(A,I,e,g,i){A|=0,g|=0,i|=0;var B=0,t=0;B=wi,t=wi=wi+63&-64,wi=wi+64|0,0==(0|(I|=0))&0==(0|(e|=0))||($A(t,i),UI(t,g,0),wA(0|A,0,0|I),h(t,A,A,I,e),YI(t,64)),wi=B}function lI(A,I,e,g,i,B,t,r){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0;var a=0;return a=wi,wi=wi+32|0,0|_g(a,t|=0,r|=0)?A=-1:(A=0|Ge(A,I,e,g,i,B,a),YI(a,32)),wi=a,0|A}function uI(A,I,e,g,i,B,t,r){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0;var a=0;return a=wi,wi=wi+32|0,0|_g(a,t|=0,r|=0)?A=-1:(me(A,I,e,g,i,B,a),YI(a,32),A=0),wi=a,0|A}function dI(A,I){A|=0,I|=0;var e=0,g=0,i=0;if(g=wi,i=wi=wi+63&-64,wi=wi+16|0,yi[i>>0]=0,0|I){e=0;do{yi[i>>0]=yi[i>>0]|yi[A+e>>0],e=e+1|0}while((0|e)!=(0|I))}return wi=g,(511+(0|_i[i>>0])|0)>>>8&1|0}function DI(A){A|=0;var I=0,e=0,g=0,i=0,B=0;for(e=32,I=1,g=0;e=e+-1|0,i=0|yi[A+e>>0],B=0|yi[33241+e>>0],I&=255,g=((255&i)-(255&B)|0)>>>8&I|255&g,e;)I&=(65535+(255&(B^i))|0)>>>8;return 0!=(0|g)|0}function vI(A,I){var e=0,g=0,i=0;return e=0|bi(65535&(I|=0),65535&(A|=0)),i=(e>>>16)+(0|bi(65535&I,A>>>16))|0,g=0|bi(I>>>16,65535&A),0|(vi=(i>>>16)+(0|bi(I>>>16,A>>>16))+(((65535&i)+g|0)>>>16)|0,i+g<<16|65535&e|0)}function bI(A,I){I|=0;var e=0,g=0,i=0,B=0;ce(A|=0),e=0;do{B=0|oe(I+(e<<3)|0),i=fi[4+(g=A+(e<<3)|0)>>2]^vi,fi[g>>2]=fi[g>>2]^B,fi[g+4>>2]=i,e=e+1|0}while(8!=(0|e))}function kI(A,I,e){A|=0,I|=0,e|=0;var g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+384|0,sg(i,0,0,24),og(i,I,32,0),og(i,e,32,0),dg(i,A,24),wi=g}function GI(A,I,e){var g=0;if((0|(I|=0))<(0|(A|=0))&(0|A)<(I+(e|=0)|0)){for(g=A,I=I+e|0,A=A+e|0;(0|e)>0;)I=I-1|0,e=e-1|0,yi[(A=A-1|0)>>0]=0|yi[I>>0];A=g}else T(A,I,e);return 0|A}function FI(A,I,e,g,i){A|=0;var B=0;return B=wi,wi=wi+32|0,xI(B,I|=0,e|=0,g|=0,i|=0),i=0|Wg(A,B),i=0|((0|B)==(0|A)?-1:i)|iI(B,A,32),wi=B,0|i}function mI(A,I,e){A|=0;var g=0,i=0;return i=wi,g=wi=wi+63&-64,wi=wi+32|0,0|CI(g,e|=0,I|=0)?A=-1:(k(A,35304,g),A=0),wi=i,0|A}function MI(A,I,e,g,i,B,t){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,0|(A=g>>>0<0|0==(0|g)&e>>>0<16?-1:0|lI(A,I+16|0,I,g=0|Ig(0|e,0|g,-16,-1),vi,i,B,t))}function HI(A){var I=0,e=0,g=0,i=0;return e=0|_i[(A|=0)>>0],g=0|Se(0|_i[A+1>>0],0,8),i=vi,I=0|Se(0|_i[A+2>>0],0,16),i|=vi,A=0|Se(0|_i[A+3>>0],0,24),vi|=i,g|e|I|A|0}function YI(A,I){A|=0,I|=0;var e=0,g=0;if(e=wi,g=wi=wi+63&-64,wi=wi+16|0,fi[g>>2]=A,0|I){A=0;do{yi[(0|fi[g>>2])+A>>0]=0,A=A+1|0}while((0|A)!=(0|I))}wi=e}function SI(A,I,e,g,i){A|=0;var B=0,t=0;return B=wi,t=wi=wi+63&-64,wi=wi+16|0,LI(t,I|=0,e|=0,g|=0,i|=0),i=0|zg(A,t),wi=B,0|i}function RI(A,I){A|=0,I|=0;var e=0,g=0,i=0,B=0;e=0;do{B=I+(e<<3)|0,i=fi[4+(g=A+(e<<3)|0)>>2]^fi[B+4>>2],fi[g>>2]=fi[g>>2]^fi[B>>2],fi[g+4>>2]=i,e=e+1|0}while(128!=(0|e))}function NI(A){var I=0;return(0|(I=0|yi[ui+(255&(A|=0))>>0]))<8?0|I:(0|(I=0|yi[ui+(A>>8&255)>>0]))<8?I+8|0:(0|(I=0|yi[ui+(A>>16&255)>>0]))<8?I+16|0:24+(0|yi[ui+(A>>>24)>>0])|0}function UI(A,I,e){A|=0,I|=0,(e|=0)?(fi[A+48>>2]=0|ug(e),e=0|ug(e+4|0)):(fi[A+48>>2]=0,e=0),fi[A+52>>2]=e,fi[A+56>>2]=0|ug(I),fi[A+60>>2]=0|ug(I+4|0)}function JI(A,I,e,g){var i=0,B=0;return B=0|Ig(0|(e|=0),0|(g|=0),0|(A|=0),0|(I|=0)),i=vi,g=0|Se(0|A,0|I,1),g=0|he(-2&g|0,1&vi|0,0|e,0),0|(g=0|Ig(0|B,0|i,0|g,0|vi))}function PI(A,I){I|=0;var e=0,g=0;g=wi,wi=wi+64|0,$I(A|=0,g),A=g,e=I+32|0;do{yi[I>>0]=0|yi[A>>0],I=I+1|0,A=A+1|0}while((0|I)<(0|e));wi=g}function LI(A,I,e,g,i){A|=0,I|=0,e|=0,g|=0;var B=0,t=0;B=wi,t=wi=wi+63&-64,wi=wi+96|0,MA(t,i|=0),G(t,I,e,g),R(t,A),wi=B}function xI(A,I,e,g,i){A|=0,I|=0,e|=0,g|=0;var B=0;B=wi,wi=wi+416|0,Pg(B,i|=0),cg(B,I,e,g),PI(B,A),wi=B}function XI(A){var I=0,e=0;fi[64+(A|=0)>>2]=0,fi[A+64+4>>2]=0,fi[A+64+8>>2]=0,fi[A+64+12>>2]=0,I=240,e=A+64|0;do{fi[A>>2]=fi[I>>2],A=A+4|0,I=I+4|0}while((0|A)<(0|e))}function KI(A,I,e,g){A|=0,I|=0,e|=0,g|=0;var i=0,B=0;i=wi,B=wi=wi+63&-64,wi=wi+208|0,XI(B),d(B,I,e,g),ee(B,A),wi=i}function TI(A,I,e){A|=0,I|=0;var g=0,i=0;if((e|=0)>>>3|0){g=0;do{BI(A+(g<<3)|0,0|fi[(i=I+(g<<3)|0)>>2],0|fi[i+4>>2]),g=g+1|0}while((0|g)!=(e>>>3|0))}}function VI(A,I,e){I|=0,e|=0;var g=0,i=0;return g=wi,i=wi=wi+63&-64,wi=wi+64|0,ee(A|=0,i),e=0|QA(I,i,64,0,e,1),wi=g,0|e}function qI(A,I,e,g){I|=0,e|=0,g|=0;var i=0,B=0;i=wi,B=wi=wi+63&-64,wi=wi+64|0,ee(A|=0,B),CA(I,e,B,64,0,g,1),wi=i}function jI(A,I,e){A|=0;var g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+80|0,yA(i+40|0,e|=0,I|=0),hA(i,e,I),Y(i,i),a(A,i+40|0,i),wi=g}function ZI(A,I,e){A|=0,I|=0,e=(e|=0)?0|ug(e):0,fi[A+48>>2]=e,fi[A+52>>2]=0|ug(I),fi[A+56>>2]=0|ug(I+4|0),fi[A+60>>2]=0|ug(I+8|0)}function WI(A,I,e){I|=0,e|=0,yi[(A|=0)>>0]=I,yi[A+1>>0]=I>>8,yi[A+2>>0]=I>>16,yi[A+3>>0]=I>>24,yi[A+4>>0]=e,yi[A+4+1>>0]=e>>8,yi[A+4+2>>0]=e>>16,yi[A+4+3>>0]=e>>24}function zI(A,I,e,g,i,B,t){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,g>>>0>0|0==(0|g)&e>>>0>4294967279?(hi(),0):0|uI(A+16|0,A,I,e,g,i,B,t)}function OI(A){return(0-(62^(A|=0))|0)>>>8&45^45|(A+65510|0)>>>8&255&A+65|(0-(63^A)|0)>>>8&95^95|(A+65484|0)>>>8&A+71&((A+65510|0)>>>8&255^255)|(A+65474|0)>>>8&A+252&((A+65484|0)>>>8&255^255)|0}function $I(A,I){I|=0;var e=0;e=wi,wi=wi+64|0,ee(A|=0,e),d(A+208|0,e,64,0),ee(A+208|0,I),YI(e,64),wi=e}function Ae(A){return(0-(62^(A|=0))|0)>>>8&43^43|(A+65510|0)>>>8&255&A+65|(0-(63^A)|0)>>>8&47^47|(A+65484|0)>>>8&A+71&((A+65510|0)>>>8&255^255)|(A+65474|0)>>>8&A+252&((A+65484|0)>>>8&255^255)|0}function Ie(A,I){A|=0,0|(I|=0)&&(0|(I=0|fi[A>>2])&&YI(0|fi[I+4>>2],fi[A+16>>2]<<10),0|(I=0|fi[A+4>>2])&&YI(I,fi[A+20>>2]<<3))}function ee(A,I){I|=0;var e=0,g=0;e=wi,g=wi=wi+63&-64,wi=wi+704|0,VA(A|=0,g),TI(I,A,64),YI(g,704),YI(A,208),wi=e}function ge(A,I){A|=0,I|=0;var e=0,g=0,i=0;e=0;do{i=0|ZA(I+(e<<3)|0),fi[(g=A+(e<<3)|0)>>2]=i,fi[g+4>>2]=vi,e=e+1|0}while(16!=(0|e))}function ie(A,I){A|=0,I|=0;var e=0,g=0,i=0;e=0;do{i=0|oe(I+(e<<3)|0),fi[(g=A+(e<<3)|0)>>2]=i,fi[g+4>>2]=vi,e=e+1|0}while(128!=(0|e))}function Be(A,I){A|=0,I|=0;var e=0,g=0;e=wi,g=wi=wi+63&-64,wi=wi+32|0,pe(g,32),sI(A,I,g),YI(g,32),wi=e}function te(A,I,e,g,i){return A|=0,I|=0,e|=0,g|=0,i|=0,(I+-1|0)>>>0>63?A=-1:(AI(A,e,255&I,g,i),A=0),0|A}function re(A){var I=0,e=0;I=127&yi[31+(A|=0)>>0]^127,e=30;do{I|=~yi[A+e>>0],e=e+-1|0}while(0!=(0|e));return(236-(0|_i[A>>0])&511+(255&I))>>>8&1^1|0}function ae(A){A|=0;var I=0,e=0,g=0;for(e=0,I=1;g=A+e|0,I=(0|_i[g>>0])+I|0,yi[g>>0]=I,4!=(0|(e=e+1|0));)I>>>=8}function ne(A,I,e,g){var i=0;return i=wi,wi=wi+16|0,p(A|=0,I|=0,e|=0,g|=0,0|i),wi=i,0|(vi=0|fi[i+4>>2],0|fi[i>>2])}function Ce(A,I){A|=0,I|=0;var e=0,g=0;e=0;do{WI(A+(e<<3)|0,0|fi[(g=I+(e<<3)|0)>>2],0|fi[g+4>>2]),e=e+1|0}while(128!=(0|e))}function oe(A){return A|=0,vi=_i[A+4>>0]|_i[A+4+1>>0]<<8|_i[A+4+2>>0]<<16|_i[A+4+3>>0]<<24,_i[A>>0]|_i[A+1>>0]<<8|_i[A+2>>0]<<16|_i[A+3>>0]<<24|0}function ce(A){var I=0,e=0,g=0;e=240,g=64+(I=A|=0)|0;do{fi[I>>2]=fi[e>>2],I=I+4|0,e=e+4|0}while((0|I)<(0|g));wA(A+64|0,0,293)}function Qe(A,I){a(A|=0,I|=0,I+120|0),a(A+40|0,I+40|0,I+80|0),a(A+80|0,I+80|0,I+120|0),a(A+120|0,I,I+40|0)}function Ee(A,I,e){var g=0,i=0;return g=0|Ue(0|(A|=0),0|(I|=0),0|(e|=0)),i=vi,e=0|Se(0|A,0|I,64-e|0),vi|=i,e|g|0}function se(A,I,e){var g=0,i=0;return g=0|Se(0|(A|=0),0|(I|=0),0|(e|=0)),i=vi,e=0|Ue(0|A,0|I,64-e|0),vi|=i,e|g|0}function he(A,I,e,g){I|=0,g|=0;var i=0,B=0;return i=0|vI(A|=0,e|=0),B=vi,0|(vi=(0|bi(I,e))+(0|bi(g,A))+B|0&B,0|i)}function ye(A,I,e){return A|=0,I|=0,(e|=0)>>>0<256?0|L(A,I,255&e):(Mi(33384,33404,103,33536),0)}function fe(A,I,e){A|=0,e|=0;var g=0;return I=0|Se(255&(I|=0)|0,0,8),g=vi,e=0|Se(255&e|0,0,16),vi|=g,I|255&A|e|0}function _e(A){var I=0,e=0;return I=wi,e=wi=wi+63&-64,wi=wi+160|0,J(e,A|=0),A=0|ve(e),wi=I,0|A}function pe(A,I){A|=0;var e=0;if(0|(I|=0)){e=0;do{yi[A+e>>0]=0|Bi(),e=e+1|0}while((0|e)!=(0|I))}}function we(A,I){yA(A|=0,40+(I|=0)|0,I),hA(A+40|0,I+40|0,I),KA(A+80|0,I+80|0),a(A+120|0,I+120|0,1024)}function le(A,I){I|=0;var e=0;A=16+(e=48+(A|=0)|0)|0;do{yi[e>>0]=0|yi[I>>0],e=e+1|0,I=I+1|0}while((0|e)<(0|A))}function ue(A,I){A|=0;var e=0,g=0;e=wi,g=wi=wi+63&-64,wi=wi+128|0,tg(g,I|=0),nI(A,g),wi=e}function de(A,I){I|=0;var e=0;A=16+(e=32+(A|=0)|0)|0;do{yi[e>>0]=0|yi[I>>0],e=e+1|0,I=I+1|0}while((0|e)<(0|A))}function De(){var A=0;(0|(A=0|Ni(30)))>0?fi[8681]=A:A=0|fi[8681],A>>>0<16?hi():pe(35336,16)}function ve(A){var I=0,e=0;return I=wi,e=wi=wi+63&-64,wi=wi+32|0,q(e,A|=0),A=0|dI(e,32),wi=I,0|A}function be(A,I,e){return A|=0,I|=0,(0|(e|=0))<32?(vi=I>>e,A>>>e|(I&(1<<e)-1)<<32-e):(vi=(0|I)<0?-1:0,I>>e-32|0)}function ke(A,I){A|=0,I|=0;var e=0,g=0;e=0;do{yi[(g=A+e|0)>>0]=yi[g>>0]^yi[I+e>>0],e=e+1|0}while(8!=(0|e))}function Ge(A,I,e,g,i,B,t){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,0|X(A,I,e,g,i,B,t)}function Fe(){var A=0,I=0;A=wi,I=wi=wi+63&-64,wi=wi+16|0,Gg(I),0|fi[I>>2]&&Gg(I),wi=A}function me(A,I,e,g,i,B,t){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,S(A,I,e,g,i,B,t),0}function Me(A,I){A|=0;var e=0;return((I|=0)>>>0<=4294967168?0!=(0|(e=0|IA(I))):0)?(fi[A>>2]=e,A=0):A=12,0|A}function He(A,I,e,g,i,B,t){cI(A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0)}function Ye(A){yi[32+(A|=0)>>0]=0,yi[A+32+1>>0]=0,yi[A+32+2>>0]=0,yi[A+32+3>>0]=0,yi[A+32>>0]=1}function Se(A,I,e){return A|=0,I|=0,(0|(e|=0))<32?(vi=I<<e|(A&(1<<e)-1<<32-e)>>>32-e,A<<e):(vi=A<<e-32,0)}function Re(A){var I=0,e=0;return e=wi,I=wi=wi+63&-64,wi=wi+32|0,q(I,A|=0),wi=e,1&yi[I>>0]|0}function Ne(A){var I=0;return(I=0|t(A|=0))&&3&fi[I+-4>>2]?(wA(0|I,0,0|A),0|I):0|I}function Ue(A,I,e){return A|=0,I|=0,(0|(e|=0))<32?(vi=I>>>e,A>>>e|(I&(1<<e)-1)<<32-e):(vi=0,I>>>e-32|0)}function Je(A,I,e){iA(A|=0,I|=0,255&(e|=0)),iA(A+40|0,I+40|0,255&e),iA(A+80|0,I+80|0,255&e)}function Pe(A,I,e,g,i,B,t){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,0|aI(A,I,e,g,i,B,t)}function Le(A,I,e,g,i,B,t){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,0|eA(A,I,1,e,g,i,16,B,t,0,0,2)}function xe(A,I,e,g,i,B,t){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,0|eA(A,I,1,e,g,i,16,B,t,0,0,1)}function Xe(A,I){a(A|=0,I|=0,I+120|0),a(A+40|0,I+40|0,I+80|0),a(A+80|0,I+80|0,I+120|0)}function Ke(A,I,e,g,i,B){CA(A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,0)}function Te(A,I){Ie(A|=0,4&(I|=0)),Q(0|fi[A+4>>2]),fi[A+4>>2]=0,kg(0|fi[A>>2]),fi[A>>2]=0}function Ve(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,0|eA(A,I,1,e,g,i,16,0,32,B,128,2)}function qe(A,I,e,g,i,B){H(A|=0,I|=0,e|=0,g|=0,i|=0,1,0,B|=0)}function je(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,0|eA(A,I,1,e,g,i,16,0,32,B,128,1)}function Ze(A,I,e,g,i){return A|=0,I|=0,e|=0,g|=0,i|=0,0|QA(A,I,e,g,i,0)}function We(A,I,e,g,i){return A|=0,I|=0,e|=0,g|=0,i|=0,0|SI(A,I,e,g,i)}function ze(A,I,e,g,i,B){H(A|=0,I|=0,e|=0,g|=0,i|=0,0,0,B|=0)}function Oe(A,I,e,g,i,B){rI(A|=0,I|=0,e|=0,g|=0,i|=0,1,0,B|=0)}function $e(A){var I=0;fi[(A|=0)>>2]=1,I=36+(A=A+4|0)|0;do{fi[A>>2]=0,A=A+4|0}while((0|A)<(0|I))}function Ag(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,g=I-g-(e>>>0>A>>>0|0)>>>0,0|(vi=g,A-e>>>0|0)}function Ig(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,0|(vi=I+g+(A+e>>>0>>>0<A>>>0|0)>>>0,A+e>>>0|0)}function eg(A,I,e,g){hg(A|=0,I|=0,e|=0,g|=0)}function gg(A,I){I|=0,XI(A|=0),0|I&&d(A,33786,34,0)}function ig(A){0|yi[356+(A|=0)>>0]&&qg(A),fi[A+80>>2]=-1,fi[A+80+4>>2]=-1}function Bg(A,I){I|=0,yi[(A|=0)>>0]=I,yi[A+1>>0]=I>>8,yi[A+2>>0]=I>>16,yi[A+3>>0]=I>>24}function tg(A,I){KA(A|=0,I|=0),KA(A+40|0,I+40|0),KA(A+80|0,I+80|0)}function rg(A,I,e,g){rA(A|=0,I|=0,e|=0,g|=0)}function ag(A,I,e,g,i){yI(A|=0,I|=0,e|=0,g|=0,i|=0)}function ng(A,I,e,g){cI(A|=0,I|=0,40,0,e|=0,0,g|=0)}function Cg(A,I){return A|=0,I|=0,pe(I,32),0|Fg(A,I)}function og(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,rg(A,I,e,g),0}function cg(A,I,e,g){yg(A|=0,I|=0,e|=0,g|=0)}function Qg(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,0|oA(A,I,e,g,2)}function Eg(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,0|oA(A,I,e,g,1)}function sg(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,0|II(A,I,e,g)}function hg(A,I,e,g){G(A|=0,I|=0,e|=0,g|=0)}function yg(A,I,e,g){d(A|=0,I|=0,e|=0,g|=0)}function fg(A){var I=0;I=40+(A|=0)|0;do{fi[A>>2]=0,A=A+4|0}while((0|A)<(0|I))}function _g(A,I,e){return A|=0,I|=0,e|=0,0|mI(A,I,e)}function pg(A){yi[(A|=0)>>0]=-8&yi[A>>0],yi[A+31>>0]=63&yi[A+31>>0]|64}function wg(A,I){return A|=0,I|=0,A=0|EA(A,I),0|((0|yi[A>>0])==(255&I)<<24>>24?A:0)}function lg(A){return A|=0,255&(A=0|Ue(A<<24>>24|0,((A<<24>>24|0)<0)<<31>>31|0,63))|0}function ug(A){return A|=0,_i[A>>0]|_i[A+1>>0]<<8|_i[A+2>>0]<<16|_i[A+3>>0]<<24|0}function dg(A,I,e){return A|=0,I|=0,e|=0,0|ye(A,I,e)}function Dg(A){yi[(A|=0)>>0]=0,yi[A+1>>0]=0,yi[A+2>>0]=0,yi[A+3>>0]=0}function vg(A,I,e){kA(A|=0,2024+(960*(I|=0)|0)|0,e|=0)}function bg(A){fg(A|=0),$e(A+40|0),$e(A+80|0),fg(A+120|0)}function kg(A){var I=0;(0|(A|=0)?0|(I=0|fi[A>>2]):0)&&Q(I),Q(A)}function Gg(A){fi[(A|=0)>>2]=0,fi[A+4>>2]=0,fi[A+8>>2]=0,fi[A+12>>2]=0}function Fg(A,I){return A|=0,I|=0,0|gI(A,I)}function mg(A,I){Xg(A|=0,I|=0)}function Mg(A,I){Vg(A|=0,I|=0)}function Hg(A,I,e){return A|=0,I|=0,e|=0,0|CI(A,I,e)}function Yg(A,I){return A|=0,I|=0,0|Cg(A,I)}function Sg(A,I,e){K(A|=0,32,0,I|=0,e|=0)}function Rg(A,I,e){wI(A|=0,64,0,I|=0,e|=0)}function Ng(A){1!=(-7&(A|=0)|0)&&hi()}function Ug(A,I,e){w(A|=0,I|=0,e|=0)}function Jg(A,I){return A|=0,I|=0,0|Fg(A,I)}function Pg(A,I){sA(A|=0,I|=0)}function Lg(A){$e(A|=0),$e(A+40|0),fg(A+80|0)}function xg(A,I,e){return A|=0,I|=0,e|=0,0|W(A,I,e,2)}function Xg(A,I){R(A|=0,I|=0)}function Kg(A,I,e){return A|=0,I|=0,e|=0,0|W(A,I,e,1)}function Tg(A){fg(A|=0),$e(A+40|0),$e(A+80|0)}function Vg(A,I){MA(A|=0,I|=0)}function qg(A){fi[88+(A|=0)>>2]=-1,fi[A+88+4>>2]=-1}function jg(A,I){return A|=0,I|=0,1&(0!=(0|A)|0!=(0|I))|0}function Zg(A,I){return A|=0,((255&((I|=0)^A))-1|0)>>>31&255|0}function Wg(A,I){return A|=0,I|=0,0|eI(A,I,32)}function zg(A,I){return A|=0,I|=0,0|eI(A,I,16)}function Og(A,I){T(0|(A|=0),0|(I|=0),1024)}function $g(A,I){return A|=0,I|=0,A>>>(32-I|0)|A<<I|0}function Ai(A){XI(A|=0)}function Ii(){Fe()}function ei(A){wA(0|(A|=0),0,1024)}function gi(A){pe(A|=0,32)}function ii(){Si(1)}function Bi(){return 0|Si(0)}function ti(){return 3}function ri(){return 2}function ai(){return-1}function ni(){return 1}function Ci(){return 8}function oi(){return 24}function ci(){return 16}function Qi(){return 64}function Ei(){return 32}function si(){return 0}function hi(){Yi()}var yi=new A.Int8Array(e),fi=(new A.Int16Array(e),new A.Int32Array(e)),_i=new A.Uint8Array(e),pi=(new A.Uint16Array(e),new A.Uint32Array(e),new A.Float32Array(e),new A.Float64Array(e),0|I.DYNAMICTOP_PTR),wi=(I.tempDoublePtr,I.ABORT,0|I.STACKTOP),li=0|I.STACK_MAX,ui=0|I.cttz_i8,di=0,Di=0,vi=(A.NaN,A.Infinity,0),bi=(A.Math.floor,A.Math.abs,A.Math.sqrt,A.Math.pow,A.Math.cos,A.Math.sin,A.Math.tan,A.Math.acos,A.Math.asin,A.Math.atan,A.Math.atan2,A.Math.exp,A.Math.log,A.Math.ceil,A.Math.imul),ki=(A.Math.min,A.Math.max,A.Math.clz32),Gi=(I.abort,I.assert,I.enlargeMemory),Fi=I.getTotalMemory,mi=I.abortOnCannotGrowMemory,Mi=I.___assert_fail,Hi=I.___setErrNo,Yi=I._abort,Si=I._emscripten_asm_const_i,Ri=I._emscripten_memcpy_big,Ni=I._sysconf;return{___muldi3:he,___uremdi3:ne,_bitshift64Ashr:be,_bitshift64Lshr:Ue,_bitshift64Shl:Se,_crypto_aead_chacha20poly1305_abytes:ci,_crypto_aead_chacha20poly1305_decrypt:function(A,I,e,g,i,B,t,r,a,n,C){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,A=B>>>0>0|0==(0|B)&i>>>0>15?0|nA(A,0,g,e=0|Ig(0|i,0|B,-16,-1),vi,g+i+-16|0,t,r,a,n,C):-1,0|I&&(n=0==(0|A),B=0|Ig(0|i,0|B,-16,-1),fi[I>>2]=n?B:0,fi[I+4>>2]=n?vi:0),0|A},_crypto_aead_chacha20poly1305_decrypt_detached:nA,_crypto_aead_chacha20poly1305_encrypt:function(A,I,e,g,i,B,t,r,a,n,C){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,i>>>0>0|0==(0|i)&g>>>0>4294967279&&hi(),pA(A,A+g|0,0,e,g,i,B,t,r,0,n,C),0|I&&(n=0|Ig(0|g,0|i,16,0),fi[I>>2]=n,fi[I+4>>2]=vi),0},_crypto_aead_chacha20poly1305_encrypt_detached:pA,_crypto_aead_chacha20poly1305_ietf_abytes:ci,_crypto_aead_chacha20poly1305_ietf_decrypt:function(A,I,e,g,i,B,t,r,a,n,C){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,A=B>>>0>0|0==(0|B)&i>>>0>15?0|AA(A,0,g,e=0|Ig(0|i,0|B,-16,-1),vi,g+i+-16|0,t,r,a,n,C):-1,0|I&&(n=0==(0|A),B=0|Ig(0|i,0|B,-16,-1),fi[I>>2]=n?B:0,fi[I+4>>2]=n?vi:0),0|A},_crypto_aead_chacha20poly1305_ietf_decrypt_detached:AA,_crypto_aead_chacha20poly1305_ietf_encrypt:function(A,I,e,g,i,B,t,r,a,n,C){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,i>>>0>0|0==(0|i)&g>>>0>4294967279&&hi(),tA(A,A+g|0,0,e,g,i,B,t,r,0,n,C),0|I&&(n=0|Ig(0|g,0|i,16,0),fi[I>>2]=n,fi[I+4>>2]=vi),0},_crypto_aead_chacha20poly1305_ietf_encrypt_detached:tA,_crypto_aead_chacha20poly1305_ietf_keybytes:Ei,_crypto_aead_chacha20poly1305_ietf_keygen:gi,_crypto_aead_chacha20poly1305_ietf_npubbytes:function(){return 12},_crypto_aead_chacha20poly1305_ietf_nsecbytes:si,_crypto_aead_chacha20poly1305_keybytes:Ei,_crypto_aead_chacha20poly1305_keygen:gi,_crypto_aead_chacha20poly1305_npubbytes:Ci,_crypto_aead_chacha20poly1305_nsecbytes:si,_crypto_aead_xchacha20poly1305_ietf_abytes:ci,_crypto_aead_xchacha20poly1305_ietf_decrypt:function(A,I,e,g,i,B,t,r,a,n,C){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,A=B>>>0>0|0==(0|B)&i>>>0>15?0|bA(A,0,g,e=0|Ig(0|i,0|B,-16,-1),vi,g+i+-16|0,t,r,a,n,C):-1,0|I&&(n=0==(0|A),B=0|Ig(0|i,0|B,-16,-1),fi[I>>2]=n?B:0,fi[I+4>>2]=n?vi:0),0|A},_crypto_aead_xchacha20poly1305_ietf_decrypt_detached:bA,_crypto_aead_xchacha20poly1305_ietf_encrypt:function(A,I,e,g,i,B,t,r,a,n,C){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,i>>>0>4294967295|-1==(0|i)&g>>>0>4294967279&&hi(),dA(A,A+g|0,0,e,g,i,B,t,r,0,n,C),0|I&&(n=0|Ig(0|g,0|i,16,0),fi[I>>2]=n,fi[I+4>>2]=vi),0},_crypto_aead_xchacha20poly1305_ietf_encrypt_detached:dA,_crypto_aead_xchacha20poly1305_ietf_keybytes:Ei,_crypto_aead_xchacha20poly1305_ietf_keygen:gi,_crypto_aead_xchacha20poly1305_ietf_npubbytes:oi,_crypto_aead_xchacha20poly1305_ietf_nsecbytes:si,_crypto_auth:function(A,I,e,g,i){return A|=0,I|=0,e|=0,g|=0,i|=0,xI(A,I,e,g,i),0},_crypto_auth_bytes:Ei,_crypto_auth_keybytes:Ei,_crypto_auth_keygen:gi,_crypto_auth_verify:function(A,I,e,g,i){return A|=0,I|=0,e|=0,g|=0,i|=0,0|FI(A,I,e,g,i)},_crypto_box_beforenm:_g,_crypto_box_beforenmbytes:Ei,_crypto_box_detached:uI,_crypto_box_detached_afternm:me,_crypto_box_easy:zI,_crypto_box_easy_afternm:function(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,g>>>0>0|0==(0|g)&e>>>0>4294967279?(hi(),0):(me(A+16|0,A,I,e,g,i,B),0)},_crypto_box_keypair:Yg,_crypto_box_macbytes:ci,_crypto_box_noncebytes:oi,_crypto_box_open_detached:lI,_crypto_box_open_detached_afternm:Ge,_crypto_box_open_easy:MI,_crypto_box_open_easy_afternm:function(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,0|(A=g>>>0<0|0==(0|g)&e>>>0<16?-1:0|Ge(A,I+16|0,I,g=0|Ig(0|e,0|g,-16,-1),vi,i,B))},_crypto_box_publickeybytes:Ei,_crypto_box_seal:function(A,I,e,g,i){A|=0,I|=0,e|=0,g|=0,i|=0;var B=0,t=0,r=0,a=0;if(a=wi,wi=wi+96|0,0|Yg(a+32|0,a))A=-1;else{t=a+32|0,r=(B=A)+32|0;do{yi[B>>0]=0|yi[t>>0],B=B+1|0,t=t+1|0}while((0|B)<(0|r));kI(a+64|0,a+32|0,i),A=0|zI(A+32|0,I,e,g,a+64|0,i,a),YI(a,32),YI(a+32|0,32),YI(a+64|0,24)}return wi=a,0|A},_crypto_box_seal_open:function(A,I,e,g,i,B){A|=0,I|=0,i|=0,B|=0;var t=0,r=0;return r=wi,t=wi=wi+63&-64,wi=wi+32|0,(g|=0)>>>0<0|0==(0|g)&(e|=0)>>>0<48?A=-1:(e=0|Ig(0|e,0|g,-32,-1),g=vi,kI(t,I,i),A=0|MI(A,I+32|0,e,g,t,I,B)),wi=r,0|A},_crypto_box_sealbytes:function(){return 48},_crypto_box_secretkeybytes:Ei,_crypto_box_seed_keypair:function(A,I,e){return A|=0,I|=0,e|=0,0|oI(A,I,e)},_crypto_box_seedbytes:Ei,_crypto_core_hchacha20:u,_crypto_core_hchacha20_constbytes:ci,_crypto_core_hchacha20_inputbytes:ci,_crypto_core_hchacha20_keybytes:Ei,_crypto_core_hchacha20_outputbytes:Ei,_crypto_generichash:Pe,_crypto_generichash_bytes:Ei,_crypto_generichash_bytes_max:Qi,_crypto_generichash_bytes_min:ci,_crypto_generichash_final:dg,_crypto_generichash_init:sg,_crypto_generichash_keybytes:Ei,_crypto_generichash_keybytes_max:Qi,_crypto_generichash_keybytes_min:ci,_crypto_generichash_keygen:gi,_crypto_generichash_statebytes:function(){return 384},_crypto_generichash_update:og,_crypto_hash:function(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,KI(A,I,e,g),0},_crypto_hash_bytes:Qi,_crypto_kdf_bytes_max:Qi,_crypto_kdf_bytes_min:ci,_crypto_kdf_contextbytes:Ci,_crypto_kdf_derive_from_key:function(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,0|fA(A,I,e,g,i,B)},_crypto_kdf_keybytes:Ei,_crypto_kdf_keygen:gi,_crypto_kx_client_session_keys:function(A,I,e,g,i){I|=0,e|=0,g|=0,i|=0;var B=0,t=0,r=0;if(r=wi,t=wi=wi+63&-64,wi=wi+480|0,B=0==(0|(A|=0))?I:A,I=0==(0|I)?B:I,B||hi(),0|Hg(t+448|0,g,i))A=-1;else{sg(t,0,0,64),og(t,t+448|0,32,0),YI(t+448|0,32),og(t,e,32,0),og(t,i,32,0),dg(t,t+384|0,64),YI(t,384),A=0;do{yi[B+A>>0]=0|yi[t+384+A>>0],yi[I+A>>0]=0|yi[t+384+(A+32)>>0],A=A+1|0}while(32!=(0|A));YI(t+384|0,64),A=0}return wi=r,0|A},_crypto_kx_keypair:function(A,I){return A|=0,I|=0,pe(I,32),0|Jg(A,I)},_crypto_kx_publickeybytes:Ei,_crypto_kx_secretkeybytes:Ei,_crypto_kx_seed_keypair:function(A,I,e){return A|=0,I|=0,e|=0,Pe(I,32,e,32,0,0,0),0|Jg(A,I)},_crypto_kx_seedbytes:Ei,_crypto_kx_server_session_keys:function(A,I,e,g,i){I|=0,e|=0,g|=0,i|=0;var B=0,t=0,r=0;if(r=wi,t=wi=wi+63&-64,wi=wi+480|0,B=0==(0|(A|=0))?I:A,I=0==(0|I)?B:I,B||hi(),0|Hg(t+448|0,g,i))A=-1;else{sg(t,0,0,64),og(t,t+448|0,32,0),YI(t+448|0,32),og(t,i,32,0),og(t,e,32,0),dg(t,t+384|0,64),YI(t,384),A=0;do{yi[I+A>>0]=0|yi[t+384+A>>0],yi[B+A>>0]=0|yi[t+384+(A+32)>>0],A=A+1|0}while(32!=(0|A));YI(t+384|0,64),A=0}return wi=r,0|A},_crypto_kx_sessionkeybytes:Ei,_crypto_pwhash:function(A,I,e,g,i,B,t,r,a,n,C){switch(A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,0|(C|=0)){case 1:A=0|vA(A,I,e,g,i,B,t,r,a,n);break;case 2:A=0|GA(A,I,e,g,i,B,t,r,a,n);break;default:fi[8202]=22,A=-1}return 0|A},_crypto_pwhash_alg_argon2i13:ni,_crypto_pwhash_alg_argon2id13:ri,_crypto_pwhash_alg_default:ri,_crypto_pwhash_bytes_max:ai,_crypto_pwhash_bytes_min:ci,_crypto_pwhash_memlimit_interactive:function(){return 67108864},_crypto_pwhash_memlimit_max:function(){return-2147483648},_crypto_pwhash_memlimit_min:function(){return 8192},_crypto_pwhash_memlimit_moderate:function(){return 268435456},_crypto_pwhash_memlimit_sensitive:function(){return 1073741824},_crypto_pwhash_opslimit_interactive:ri,_crypto_pwhash_opslimit_max:ai,_crypto_pwhash_opslimit_min:ni,_crypto_pwhash_opslimit_moderate:ti,_crypto_pwhash_opslimit_sensitive:function(){return 4},_crypto_pwhash_passwd_max:ai,_crypto_pwhash_passwd_min:si,_crypto_pwhash_primitive:function(){return 33778},_crypto_pwhash_saltbytes:ci,_crypto_pwhash_str:function(A,I,e,g,i,B,t){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,0|mA(A,I,e,g,i,B,t)},_crypto_pwhash_str_alg:function(A,I,e,g,i,B,t,r){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0;var a=0;switch(0|(r|=0)){case 1:a=0|FA(A,I,e,g,i,B,t);break;case 2:a=0|mA(A,I,e,g,i,B,t);break;default:hi()}return 0|a},_crypto_pwhash_str_needs_rehash:function(A,I,e,g){A|=0,I|=0,e|=0,g|=0;do{if(0|NA(A,33757,10)){if(0|NA(A,33768,9)){fi[8202]=22,A=-1;break}A=0|Eg(A,I,e,g);break}A=0|Qg(A,I,e,g)}while(0);return 0|A},_crypto_pwhash_str_verify:function(A,I,e,g){A|=0,I|=0,e|=0,g|=0;do{if(0|NA(A,33757,10)){if(0|NA(A,33768,9)){fi[8202]=22,A=-1;break}A=0|_I(A,I,e,g);break}A=0|hI(A,I,e,g)}while(0);return 0|A},_crypto_pwhash_strbytes:function(){return 128},_crypto_pwhash_strprefix:function(){return 33757},_crypto_scalarmult:Hg,_crypto_scalarmult_base:Jg,_crypto_scalarmult_bytes:Ei,_crypto_scalarmult_scalarbytes:Ei,_crypto_secretbox_detached:S,_crypto_secretbox_easy:function(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,g>>>0>0|0==(0|g)&e>>>0>4294967279?(hi(),0):(S(A+16|0,A,I,e,g,i,B),0)},_crypto_secretbox_keybytes:Ei,_crypto_secretbox_keygen:gi,_crypto_secretbox_macbytes:ci,_crypto_secretbox_noncebytes:oi,_crypto_secretbox_open_detached:X,_crypto_secretbox_open_easy:function(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,0|(A=g>>>0<0|0==(0|g)&e>>>0<16?-1:0|X(A,I+16|0,I,g=0|Ig(0|e,0|g,-16,-1),vi,i,B))},_crypto_secretstream_xchacha20poly1305_abytes:function(){return 17},_crypto_secretstream_xchacha20poly1305_headerbytes:oi,_crypto_secretstream_xchacha20poly1305_init_pull:function(A,I,e){var g=0;return u(A|=0,I|=0,e|=0,0),Ye(A),g=_i[I+16>>0]|_i[I+16+1>>0]<<8|_i[I+16+2>>0]<<16|_i[I+16+3>>0]<<24,e=_i[I+16+4>>0]|_i[I+16+4+1>>0]<<8|_i[I+16+4+2>>0]<<16|_i[I+16+4+3>>0]<<24,yi[A+36>>0]=g,yi[A+36+1>>0]=g>>8,yi[A+36+2>>0]=g>>16,yi[A+36+3>>0]=g>>24,yi[A+36+4>>0]=e,yi[A+36+4+1>>0]=e>>8,yi[A+36+4+2>>0]=e>>16,yi[A+36+4+3>>0]=e>>24,yi[A+44>>0]=0,yi[A+44+1>>0]=0,yi[A+44+2>>0]=0,yi[A+44+3>>0]=0,yi[A+44+4>>0]=0,yi[A+44+4+1>>0]=0,yi[A+44+4+2>>0]=0,yi[A+44+4+3>>0]=0,0},_crypto_secretstream_xchacha20poly1305_init_push:function(A,I,e){A|=0,e|=0;var g=0;return pe(I|=0,24),u(A,I,e,0),Ye(A),g=_i[I+16>>0]|_i[I+16+1>>0]<<8|_i[I+16+2>>0]<<16|_i[I+16+3>>0]<<24,e=_i[I+16+4>>0]|_i[I+16+4+1>>0]<<8|_i[I+16+4+2>>0]<<16|_i[I+16+4+3>>0]<<24,yi[A+36>>0]=g,yi[A+36+1>>0]=g>>8,yi[A+36+2>>0]=g>>16,yi[A+36+3>>0]=g>>24,yi[A+36+4>>0]=e,yi[A+36+4+1>>0]=e>>8,yi[A+36+4+2>>0]=e>>16,yi[A+36+4+3>>0]=e>>24,yi[A+44>>0]=0,yi[A+44+1>>0]=0,yi[A+44+2>>0]=0,yi[A+44+3>>0]=0,yi[A+44+4>>0]=0,yi[A+44+4+1>>0]=0,yi[A+44+4+2>>0]=0,yi[A+44+4+3>>0]=0,0},_crypto_secretstream_xchacha20poly1305_keybytes:Ei,_crypto_secretstream_xchacha20poly1305_keygen:gi,_crypto_secretstream_xchacha20poly1305_messagebytes_max:ai,_crypto_secretstream_xchacha20poly1305_pull:function(A,I,e,g,i,B,t,r,a,n){A|=0,I|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0;var C=0,o=0,c=0,Q=0,E=0;E=wi,Q=wi=wi+63&-64,wi=wi+352|0,0|(e|=0)&&(fi[e>>2]=0,fi[e+4>>2]=0),0|g&&(yi[g>>0]=-1);do{if(t>>>0<0|0==(0|t)&B>>>0<17)r=-1;else{o=0|Ig(0|B,0|t,-17,-1),(c=vi)>>>0>0|0==(0|c)&o>>>0>4294967295&&hi(),ag(Q+280|0,64,0,A+32|0,A),Mg(Q,Q+280|0),YI(Q+280|0,64),eg(Q,r,a,n),eg(Q,35320,15&(r=0|Ag(0,0,0|a,0|n)),0),C=63+(r=Q+280+1|0)|0;do{yi[r>>0]=0,r=r+1|0}while((0|r)<(0|C));if(yi[Q+280>>0]=0|yi[i>>0],He(Q+280|0,Q+280|0,64,0,A+32|0,1,A),r=0|yi[Q+280>>0],yi[Q+280>>0]=0|yi[i>>0],eg(Q,Q+280|0,64,0),eg(Q,i+1|0,o,c),C=0|Ig(0|B,0|t,15,0),eg(Q,35320,15&C,0),WI(Q+272|0,a,n),eg(Q,Q+272|0,8,0),n=0|Ig(0|B,0|t,47,0),WI(Q+272|0,n,vi),eg(Q,Q+272|0,8,0),mg(Q,Q+256|0),YI(Q,256),0|iI(Q+256|0,i+1+o|0,16)){YI(Q+256|0,16),r=-1;break}He(I,i+1|0,o,c,A+32|0,2,A),ke(A+36|0,Q+256|0),ae(A+32|0),(0==(2&r)?!(0|dI(A+32|0,4)):0)||V(A),0|e&&(fi[e>>2]=o,fi[e+4>>2]=c),0|g?(yi[g>>0]=r,r=0):r=0}}while(0);return wi=E,0|r},_crypto_secretstream_xchacha20poly1305_push:function(A,I,e,g,i,B,t,r,a,n){A|=0,I|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0;var C=0,o=0,c=0;o=wi,c=wi=wi+63&-64,wi=wi+336|0,0|(e|=0)&&(fi[e>>2]=0,fi[e+4>>2]=0),B>>>0>0|0==(0|B)&i>>>0>4294967295&&hi(),ag(c+264|0,64,0,A+32|0,A),Mg(c,c+264|0),YI(c+264|0,64),eg(c,t,r,a),eg(c,35320,15&(t=0|Ag(0,0,0|r,0|a)),0),C=63+(t=c+264+1|0)|0;do{yi[t>>0]=0,t=t+1|0}while((0|t)<(0|C));return yi[c+264>>0]=n,He(c+264|0,c+264|0,64,0,A+32|0,1,A),eg(c,c+264|0,64,0),yi[I>>0]=0|yi[c+264>>0],He(I+1|0,g,i,B,A+32|0,2,A),eg(c,I+1|0,i,B),eg(c,35320,15&i,0),WI(c+256|0,r,a),eg(c,c+256|0,8,0),a=0|Ig(0|i,0|B,64,0),WI(c+256|0,a,vi),eg(c,c+256|0,8,0),mg(c,I+1+i|0),YI(c,256),ke(A+36|0,I+1+i|0),ae(A+32|0),(0==(2&n)?!(0|dI(A+32|0,4)):0)||V(A),0|e&&(c=0|Ig(0|i,0|B,17,0),fi[e>>2]=c,fi[e+4>>2]=vi),wi=o,0},_crypto_secretstream_xchacha20poly1305_rekey:V,_crypto_secretstream_xchacha20poly1305_statebytes:function(){return 52},_crypto_secretstream_xchacha20poly1305_tag_final:ti,_crypto_secretstream_xchacha20poly1305_tag_message:si,_crypto_secretstream_xchacha20poly1305_tag_push:ni,_crypto_secretstream_xchacha20poly1305_tag_rekey:ri,_crypto_shorthash:function(A,I,e,g,i){return A|=0,I|=0,e|=0,g|=0,i|=0,s(A,I,e,g,i),0},_crypto_shorthash_bytes:Ci,_crypto_shorthash_keybytes:ci,_crypto_shorthash_keygen:function(A){pe(A|=0,16)},_crypto_sign:function(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,0|JA(A,I,e,g,i,B)},_crypto_sign_bytes:Qi,_crypto_sign_detached:function(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,Ke(A,I,e,g,i,B),0},_crypto_sign_ed25519_pk_to_curve25519:function(A,I){A|=0;var e=0,g=0;return g=wi,e=wi=wi+63&-64,wi=wi+240|0,((0==(0|tI(I|=0))?0==(0|gA(e+80|0,I)):0)?0!=(0|_e(e+80|0)):0)?($e(e),hA(e,e,e+80+40|0),Y(e,e),$e(e+40|0),yA(e+40|0,e+40|0,e+80+40|0),a(e+40|0,e+40|0,e),q(A,e+40|0),A=0):A=-1,wi=g,0|A},_crypto_sign_ed25519_sk_to_curve25519:function(A,I){A|=0;var e=0,g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+64|0,KI(i,I|=0,32,0),yi[i>>0]=-8&yi[i>>0],yi[i+31>>0]=63&yi[i+31>>0]|64,I=i,e=A+32|0;do{yi[A>>0]=0|yi[I>>0],A=A+1|0,I=I+1|0}while((0|A)<(0|e));return YI(i,64),wi=g,0},_crypto_sign_final_create:function(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,qI(A,I,e,g),0},_crypto_sign_final_verify:function(A,I,e){return A|=0,I|=0,e|=0,0|VI(A,I,e)},_crypto_sign_init:function(A){return A|=0,Ai(A),0},_crypto_sign_keypair:function(A,I){return A|=0,I|=0,Be(A,I),0},_crypto_sign_open:function(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,0|SA(A,I,e,g,i,B)},_crypto_sign_publickeybytes:Ei,_crypto_sign_secretkeybytes:Qi,_crypto_sign_seed_keypair:function(A,I,e){return A|=0,I|=0,e|=0,sI(A,I,e),0},_crypto_sign_seedbytes:Ei,_crypto_sign_statebytes:function(){return 208},_crypto_sign_update:function(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,yg(A,I,e,g),0},_crypto_sign_verify_detached:function(A,I,e,g,i){return A|=0,I|=0,e|=0,g|=0,i|=0,0|Ze(A,I,e,g,i)},_crypto_stream_keygen:gi,_emscripten_get_global_libc:function(){return 35224},_free:Q,_i64Add:Ig,_i64Subtract:Ag,_malloc:t,_memcpy:T,_memmove:GI,_memset:wA,_randombytes:function(A,I,e){A|=0,(e|=0)>>>0<1|1==(0|e)&(I|=0)>>>0<0?pe(A,I):Mi(34587,34607,204,34633)},_randombytes_buf:pe,_randombytes_buf_deterministic:function(A,I,e){ag(A|=0,I|=0,0,34575,e|=0)},_randombytes_close:si,_randombytes_random:Bi,_randombytes_seedbytes:Ei,_randombytes_stir:ii,_randombytes_uniform:function(A){var I=0;if((A|=0)>>>0<2)A=0;else{do{I=0|Bi()}while(I>>>0<(((0-A|0)>>>0)%(A>>>0)|0)>>>0);A=(I>>>0)%(A>>>0)|0}return 0|A},_sbrk:pI,_sodium_base642bin:v,_sodium_base64_encoded_len:function(A,I){A|=0;var e=0;return Ng(I|=0),e=(0|bi((A>>>0)/3|0,-3))+A|0,(((A>>>0)/3|0)<<2|1)+(4-(3-e&0-(I>>>1&1))&0-(1&(e>>>1|e)))|0},_sodium_bin2base64:U,_sodium_bin2hex:function(A,I,e,g){A|=0,e|=0;var i=0,B=0;if((g|=0)>>>0<2147483647&g<<1>>>0<(I|=0)>>>0||hi(),g)for(i=0,I=0;;){if(B=0|_i[e+i>>0],yi[A+I>>0]=87+(B>>>4)+((65526+(B>>>4)|0)>>>8&217),yi[A+(1|I)>>0]=(22272+((15&B)<<8)+(65526+(15&B)&55552)|0)>>>8,(0|(I=i+1|0))==(0|g)){I=g<<1;break}i=I,I<<=1}else I=0;return yi[A+I>>0]=0,0|A},_sodium_hex2bin:function(A,I,e,g,i,B,t){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0;var r=0,a=0,n=0,C=0,o=0,c=0,Q=0;A:do{if(g){a=0,C=0,n=0,c=0;I:for(;;){for(;r=0|_i[e+n>>0],!(255&((o=(65526+(201+(223&r)&255)^65520+(201+(223&r)&255))>>>8)|(65526+(48^r)|0)>>>8)|0);){if(!(0!=(0|i)&a<<24>>24==0)){r=0;break I}if(!(0|wg(i,r))){a=C,r=0;break A}if(!((n=n+1|0)>>>0<g>>>0)){a=C,r=0;break A}a=0}if(C>>>0>=I>>>0){Q=9;break}if(r=201+(223&r)&255&o|(65526+(48^r)|0)>>>8&(48^r),a<<24>>24?(yi[A+C>>0]=r|255&c,C=C+1|0,r=c):r=r<<4&255,a=~a,!((n=n+1|0)>>>0<g>>>0)){r=0;break}c=r}9==(0|Q)&&(fi[8202]=34,r=-1),a<<24>>24?(fi[8202]=22,a=C,n=n+-1|0,r=-1):a=C}else a=0,n=0,r=0}while(0);return a=0==(0|r)?a:0,t?fi[t>>2]=e+n:(0|n)!=(0|g)&&(fi[8202]=22,r=-1),0|B&&(fi[B>>2]=a),0|r},_sodium_init:function(){var A=0;return 0|fi[8680]?A=1:(Ii(),ii(),De(),fi[8680]=1,A=0),0|A},_sodium_library_minimal:ni,_sodium_library_version_major:function(){return 10},_sodium_library_version_minor:si,_sodium_pad:function(A,I,e,g,i){A|=0,I|=0,e|=0,i|=0;var B=0,t=0,r=0,a=0;if(a=wi,r=wi=wi+63&-64,wi=wi+16|0,g|=0)if(B=g+-1&g?(e>>>0)%(g>>>0)|0:g+-1&e,(t=g+-1-B|0)>>>0>=~e>>>0&&hi(),(t+e|0)>>>0<i>>>0){0|A&&(fi[A>>2]=t+e+1),yi[r>>0]=0,B=0;do{i=(65535+(B^t)|0)>>>8,yi[(A=I+(t+e)+(0-B)|0)>>0]=yi[r>>0]&yi[A>>0]&255|128&i,yi[r>>0]=0|_i[r>>0]|i,B=B+1|0}while((0|B)!=(0|g));B=0}else B=-1;else B=-1;return wi=a,0|B},_sodium_unpad:function(A,I,e,g){A|=0,I|=0,e|=0,g|=0;var i=0,B=0,t=0,r=0,a=0,n=0,C=0;if(n=wi,a=wi=wi+63&-64,wi=wi+16|0,fi[a>>2]=0,(g+-1|0)>>>0<e>>>0){for(t=0,i=0,r=0;i&=255,B=0|_i[I+(e+-1)+(0-t)>>0],C=(511+(0|fi[a>>2])&i+511&511+(128^B))>>>8,fi[a>>2]=1+(1^(-2|C))&t|fi[a>>2],t=t+1|0,r=1&C|255&r,(0|t)!=(0|g);)i|=B;fi[A>>2]=e+-1-(0|fi[a>>2]),i=r+-1|0}else i=-1;return wi=n,0|i},_sodium_version_string:function(){return 34698},establishStackSpace:function(A,I){wi=A|=0,li=I|=0},getTempRet0:function(){return 0|vi},runPostSets:function(){},setTempRet0:function(A){vi=A|=0},setThrew:function(A,I){A|=0,I|=0,di||(di=A,Di=I)},stackAlloc:function(A){var I=0;return I=wi,wi=wi+(A|=0)|0,wi=wi+15&-16,0|I},stackRestore:function(A){wi=A|=0},stackSave:function(){return 0|wi}}}(J.asmGlobalArg,J.asmLibraryArg,eA),XA=(J.___muldi3=xA.___muldi3,J.___uremdi3=xA.___uremdi3,J._bitshift64Ashr=xA._bitshift64Ashr,J._bitshift64Lshr=xA._bitshift64Lshr,J._bitshift64Shl=xA._bitshift64Shl,J._crypto_aead_chacha20poly1305_abytes=xA._crypto_aead_chacha20poly1305_abytes,J._crypto_aead_chacha20poly1305_decrypt=xA._crypto_aead_chacha20poly1305_decrypt,J._crypto_aead_chacha20poly1305_decrypt_detached=xA._crypto_aead_chacha20poly1305_decrypt_detached,J._crypto_aead_chacha20poly1305_encrypt=xA._crypto_aead_chacha20poly1305_encrypt,J._crypto_aead_chacha20poly1305_encrypt_detached=xA._crypto_aead_chacha20poly1305_encrypt_detached,J._crypto_aead_chacha20poly1305_ietf_abytes=xA._crypto_aead_chacha20poly1305_ietf_abytes,J._crypto_aead_chacha20poly1305_ietf_decrypt=xA._crypto_aead_chacha20poly1305_ietf_decrypt,J._crypto_aead_chacha20poly1305_ietf_decrypt_detached=xA._crypto_aead_chacha20poly1305_ietf_decrypt_detached,J._crypto_aead_chacha20poly1305_ietf_encrypt=xA._crypto_aead_chacha20poly1305_ietf_encrypt,J._crypto_aead_chacha20poly1305_ietf_encrypt_detached=xA._crypto_aead_chacha20poly1305_ietf_encrypt_detached,J._crypto_aead_chacha20poly1305_ietf_keybytes=xA._crypto_aead_chacha20poly1305_ietf_keybytes,J._crypto_aead_chacha20poly1305_ietf_keygen=xA._crypto_aead_chacha20poly1305_ietf_keygen,J._crypto_aead_chacha20poly1305_ietf_npubbytes=xA._crypto_aead_chacha20poly1305_ietf_npubbytes,J._crypto_aead_chacha20poly1305_ietf_nsecbytes=xA._crypto_aead_chacha20poly1305_ietf_nsecbytes,J._crypto_aead_chacha20poly1305_keybytes=xA._crypto_aead_chacha20poly1305_keybytes,J._crypto_aead_chacha20poly1305_keygen=xA._crypto_aead_chacha20poly1305_keygen,J._crypto_aead_chacha20poly1305_npubbytes=xA._crypto_aead_chacha20poly1305_npubbytes,J._crypto_aead_chacha20poly1305_nsecbytes=xA._crypto_aead_chacha20poly1305_nsecbytes,J._crypto_aead_xchacha20poly1305_ietf_abytes=xA._crypto_aead_xchacha20poly1305_ietf_abytes,J._crypto_aead_xchacha20poly1305_ietf_decrypt=xA._crypto_aead_xchacha20poly1305_ietf_decrypt,J._crypto_aead_xchacha20poly1305_ietf_decrypt_detached=xA._crypto_aead_xchacha20poly1305_ietf_decrypt_detached,J._crypto_aead_xchacha20poly1305_ietf_encrypt=xA._crypto_aead_xchacha20poly1305_ietf_encrypt,J._crypto_aead_xchacha20poly1305_ietf_encrypt_detached=xA._crypto_aead_xchacha20poly1305_ietf_encrypt_detached,J._crypto_aead_xchacha20poly1305_ietf_keybytes=xA._crypto_aead_xchacha20poly1305_ietf_keybytes,J._crypto_aead_xchacha20poly1305_ietf_keygen=xA._crypto_aead_xchacha20poly1305_ietf_keygen,J._crypto_aead_xchacha20poly1305_ietf_npubbytes=xA._crypto_aead_xchacha20poly1305_ietf_npubbytes,J._crypto_aead_xchacha20poly1305_ietf_nsecbytes=xA._crypto_aead_xchacha20poly1305_ietf_nsecbytes,J._crypto_auth=xA._crypto_auth,J._crypto_auth_bytes=xA._crypto_auth_bytes,J._crypto_auth_keybytes=xA._crypto_auth_keybytes,J._crypto_auth_keygen=xA._crypto_auth_keygen,J._crypto_auth_verify=xA._crypto_auth_verify,J._crypto_box_beforenm=xA._crypto_box_beforenm,J._crypto_box_beforenmbytes=xA._crypto_box_beforenmbytes,J._crypto_box_detached=xA._crypto_box_detached,J._crypto_box_detached_afternm=xA._crypto_box_detached_afternm,J._crypto_box_easy=xA._crypto_box_easy,J._crypto_box_easy_afternm=xA._crypto_box_easy_afternm,J._crypto_box_keypair=xA._crypto_box_keypair,J._crypto_box_macbytes=xA._crypto_box_macbytes,J._crypto_box_noncebytes=xA._crypto_box_noncebytes,J._crypto_box_open_detached=xA._crypto_box_open_detached,J._crypto_box_open_detached_afternm=xA._crypto_box_open_detached_afternm,J._crypto_box_open_easy=xA._crypto_box_open_easy,J._crypto_box_open_easy_afternm=xA._crypto_box_open_easy_afternm,J._crypto_box_publickeybytes=xA._crypto_box_publickeybytes,J._crypto_box_seal=xA._crypto_box_seal,J._crypto_box_seal_open=xA._crypto_box_seal_open,J._crypto_box_sealbytes=xA._crypto_box_sealbytes,J._crypto_box_secretkeybytes=xA._crypto_box_secretkeybytes,J._crypto_box_seed_keypair=xA._crypto_box_seed_keypair,J._crypto_box_seedbytes=xA._crypto_box_seedbytes,J._crypto_core_hchacha20=xA._crypto_core_hchacha20,J._crypto_core_hchacha20_constbytes=xA._crypto_core_hchacha20_constbytes,J._crypto_core_hchacha20_inputbytes=xA._crypto_core_hchacha20_inputbytes,J._crypto_core_hchacha20_keybytes=xA._crypto_core_hchacha20_keybytes,J._crypto_core_hchacha20_outputbytes=xA._crypto_core_hchacha20_outputbytes,J._crypto_generichash=xA._crypto_generichash,J._crypto_generichash_bytes=xA._crypto_generichash_bytes,J._crypto_generichash_bytes_max=xA._crypto_generichash_bytes_max,J._crypto_generichash_bytes_min=xA._crypto_generichash_bytes_min,J._crypto_generichash_final=xA._crypto_generichash_final,J._crypto_generichash_init=xA._crypto_generichash_init,J._crypto_generichash_keybytes=xA._crypto_generichash_keybytes,J._crypto_generichash_keybytes_max=xA._crypto_generichash_keybytes_max,J._crypto_generichash_keybytes_min=xA._crypto_generichash_keybytes_min,J._crypto_generichash_keygen=xA._crypto_generichash_keygen,J._crypto_generichash_statebytes=xA._crypto_generichash_statebytes,J._crypto_generichash_update=xA._crypto_generichash_update,J._crypto_hash=xA._crypto_hash,J._crypto_hash_bytes=xA._crypto_hash_bytes,J._crypto_kdf_bytes_max=xA._crypto_kdf_bytes_max,J._crypto_kdf_bytes_min=xA._crypto_kdf_bytes_min,J._crypto_kdf_contextbytes=xA._crypto_kdf_contextbytes,J._crypto_kdf_derive_from_key=xA._crypto_kdf_derive_from_key,J._crypto_kdf_keybytes=xA._crypto_kdf_keybytes,J._crypto_kdf_keygen=xA._crypto_kdf_keygen,J._crypto_kx_client_session_keys=xA._crypto_kx_client_session_keys,J._crypto_kx_keypair=xA._crypto_kx_keypair,J._crypto_kx_publickeybytes=xA._crypto_kx_publickeybytes,J._crypto_kx_secretkeybytes=xA._crypto_kx_secretkeybytes,J._crypto_kx_seed_keypair=xA._crypto_kx_seed_keypair,J._crypto_kx_seedbytes=xA._crypto_kx_seedbytes,J._crypto_kx_server_session_keys=xA._crypto_kx_server_session_keys,J._crypto_kx_sessionkeybytes=xA._crypto_kx_sessionkeybytes,J._crypto_pwhash=xA._crypto_pwhash,J._crypto_pwhash_alg_argon2i13=xA._crypto_pwhash_alg_argon2i13,J._crypto_pwhash_alg_argon2id13=xA._crypto_pwhash_alg_argon2id13,J._crypto_pwhash_alg_default=xA._crypto_pwhash_alg_default,J._crypto_pwhash_bytes_max=xA._crypto_pwhash_bytes_max,J._crypto_pwhash_bytes_min=xA._crypto_pwhash_bytes_min,J._crypto_pwhash_memlimit_interactive=xA._crypto_pwhash_memlimit_interactive,J._crypto_pwhash_memlimit_max=xA._crypto_pwhash_memlimit_max,J._crypto_pwhash_memlimit_min=xA._crypto_pwhash_memlimit_min,J._crypto_pwhash_memlimit_moderate=xA._crypto_pwhash_memlimit_moderate,J._crypto_pwhash_memlimit_sensitive=xA._crypto_pwhash_memlimit_sensitive,J._crypto_pwhash_opslimit_interactive=xA._crypto_pwhash_opslimit_interactive,J._crypto_pwhash_opslimit_max=xA._crypto_pwhash_opslimit_max,J._crypto_pwhash_opslimit_min=xA._crypto_pwhash_opslimit_min,J._crypto_pwhash_opslimit_moderate=xA._crypto_pwhash_opslimit_moderate,J._crypto_pwhash_opslimit_sensitive=xA._crypto_pwhash_opslimit_sensitive,J._crypto_pwhash_passwd_max=xA._crypto_pwhash_passwd_max,J._crypto_pwhash_passwd_min=xA._crypto_pwhash_passwd_min,J._crypto_pwhash_primitive=xA._crypto_pwhash_primitive,J._crypto_pwhash_saltbytes=xA._crypto_pwhash_saltbytes,J._crypto_pwhash_str=xA._crypto_pwhash_str,J._crypto_pwhash_str_alg=xA._crypto_pwhash_str_alg,J._crypto_pwhash_str_needs_rehash=xA._crypto_pwhash_str_needs_rehash,J._crypto_pwhash_str_verify=xA._crypto_pwhash_str_verify,J._crypto_pwhash_strbytes=xA._crypto_pwhash_strbytes,J._crypto_pwhash_strprefix=xA._crypto_pwhash_strprefix,J._crypto_scalarmult=xA._crypto_scalarmult,J._crypto_scalarmult_base=xA._crypto_scalarmult_base,J._crypto_scalarmult_bytes=xA._crypto_scalarmult_bytes,J._crypto_scalarmult_scalarbytes=xA._crypto_scalarmult_scalarbytes,J._crypto_secretbox_detached=xA._crypto_secretbox_detached,J._crypto_secretbox_easy=xA._crypto_secretbox_easy,J._crypto_secretbox_keybytes=xA._crypto_secretbox_keybytes,J._crypto_secretbox_keygen=xA._crypto_secretbox_keygen,J._crypto_secretbox_macbytes=xA._crypto_secretbox_macbytes,J._crypto_secretbox_noncebytes=xA._crypto_secretbox_noncebytes,J._crypto_secretbox_open_detached=xA._crypto_secretbox_open_detached,J._crypto_secretbox_open_easy=xA._crypto_secretbox_open_easy,J._crypto_secretstream_xchacha20poly1305_abytes=xA._crypto_secretstream_xchacha20poly1305_abytes,J._crypto_secretstream_xchacha20poly1305_headerbytes=xA._crypto_secretstream_xchacha20poly1305_headerbytes,J._crypto_secretstream_xchacha20poly1305_init_pull=xA._crypto_secretstream_xchacha20poly1305_init_pull,J._crypto_secretstream_xchacha20poly1305_init_push=xA._crypto_secretstream_xchacha20poly1305_init_push,J._crypto_secretstream_xchacha20poly1305_keybytes=xA._crypto_secretstream_xchacha20poly1305_keybytes,J._crypto_secretstream_xchacha20poly1305_keygen=xA._crypto_secretstream_xchacha20poly1305_keygen,J._crypto_secretstream_xchacha20poly1305_messagebytes_max=xA._crypto_secretstream_xchacha20poly1305_messagebytes_max,J._crypto_secretstream_xchacha20poly1305_pull=xA._crypto_secretstream_xchacha20poly1305_pull,J._crypto_secretstream_xchacha20poly1305_push=xA._crypto_secretstream_xchacha20poly1305_push,J._crypto_secretstream_xchacha20poly1305_rekey=xA._crypto_secretstream_xchacha20poly1305_rekey,J._crypto_secretstream_xchacha20poly1305_statebytes=xA._crypto_secretstream_xchacha20poly1305_statebytes,J._crypto_secretstream_xchacha20poly1305_tag_final=xA._crypto_secretstream_xchacha20poly1305_tag_final,J._crypto_secretstream_xchacha20poly1305_tag_message=xA._crypto_secretstream_xchacha20poly1305_tag_message,J._crypto_secretstream_xchacha20poly1305_tag_push=xA._crypto_secretstream_xchacha20poly1305_tag_push,J._crypto_secretstream_xchacha20poly1305_tag_rekey=xA._crypto_secretstream_xchacha20poly1305_tag_rekey,J._crypto_shorthash=xA._crypto_shorthash,J._crypto_shorthash_bytes=xA._crypto_shorthash_bytes,J._crypto_shorthash_keybytes=xA._crypto_shorthash_keybytes,J._crypto_shorthash_keygen=xA._crypto_shorthash_keygen,J._crypto_sign=xA._crypto_sign,J._crypto_sign_bytes=xA._crypto_sign_bytes,J._crypto_sign_detached=xA._crypto_sign_detached,J._crypto_sign_ed25519_pk_to_curve25519=xA._crypto_sign_ed25519_pk_to_curve25519,J._crypto_sign_ed25519_sk_to_curve25519=xA._crypto_sign_ed25519_sk_to_curve25519,J._crypto_sign_final_create=xA._crypto_sign_final_create,J._crypto_sign_final_verify=xA._crypto_sign_final_verify,J._crypto_sign_init=xA._crypto_sign_init,J._crypto_sign_keypair=xA._crypto_sign_keypair,J._crypto_sign_open=xA._crypto_sign_open,J._crypto_sign_publickeybytes=xA._crypto_sign_publickeybytes,J._crypto_sign_secretkeybytes=xA._crypto_sign_secretkeybytes,J._crypto_sign_seed_keypair=xA._crypto_sign_seed_keypair,J._crypto_sign_seedbytes=xA._crypto_sign_seedbytes,J._crypto_sign_statebytes=xA._crypto_sign_statebytes,J._crypto_sign_update=xA._crypto_sign_update,J._crypto_sign_verify_detached=xA._crypto_sign_verify_detached,J._crypto_stream_keygen=xA._crypto_stream_keygen,J._emscripten_get_global_libc=xA._emscripten_get_global_libc,J._free=xA._free),KA=(J._i64Add=xA._i64Add,J._i64Subtract=xA._i64Subtract,J._malloc=xA._malloc);if(J._memcpy=xA._memcpy,J._memmove=xA._memmove,J._memset=xA._memset,J._randombytes=xA._randombytes,J._randombytes_buf=xA._randombytes_buf,J._randombytes_buf_deterministic=xA._randombytes_buf_deterministic,J._randombytes_close=xA._randombytes_close,J._randombytes_random=xA._randombytes_random,J._randombytes_seedbytes=xA._randombytes_seedbytes,J._randombytes_stir=xA._randombytes_stir,J._randombytes_uniform=xA._randombytes_uniform,J._sbrk=xA._sbrk,J._sodium_base642bin=xA._sodium_base642bin,J._sodium_base64_encoded_len=xA._sodium_base64_encoded_len,J._sodium_bin2base64=xA._sodium_bin2base64,J._sodium_bin2hex=xA._sodium_bin2hex,J._sodium_hex2bin=xA._sodium_hex2bin,J._sodium_init=xA._sodium_init,J._sodium_library_minimal=xA._sodium_library_minimal,J._sodium_library_version_major=xA._sodium_library_version_major,J._sodium_library_version_minor=xA._sodium_library_version_minor,J._sodium_pad=xA._sodium_pad,J._sodium_unpad=xA._sodium_unpad,J._sodium_version_string=xA._sodium_version_string,J.establishStackSpace=xA.establishStackSpace,J.getTempRet0=xA.getTempRet0,J.runPostSets=xA.runPostSets,J.setTempRet0=xA.setTempRet0,J.setThrew=xA.setThrew,J.stackAlloc=xA.stackAlloc,J.stackRestore=xA.stackRestore,J.stackSave=xA.stackSave,j.stackAlloc=J.stackAlloc,j.stackSave=J.stackSave,j.stackRestore=J.stackRestore,j.establishStackSpace=J.establishStackSpace,j.setTempRet0=J.setTempRet0,j.getTempRet0=J.getTempRet0,J.asm=xA,YA)if("function"==typeof J.locateFile?YA=J.locateFile(YA):J.memoryInitializerPrefixURL&&(YA=J.memoryInitializerPrefixURL+YA),K||T){var TA=J.readBinary(YA);iA.set(TA,j.GLOBAL_BASE)}else{k();var VA=function(A){A.byteLength&&(A=new Uint8Array(A)),iA.set(A,j.GLOBAL_BASE),J.memoryInitializerRequest&&delete J.memoryInitializerRequest.response,G()};function qA(){J.readAsync(YA,VA,function(){throw"could not load memory initializer "+YA})}var jA=Y(YA);if(jA)VA(jA.buffer);else if(J.memoryInitializerRequest){function ZA(){var A=J.memoryInitializerRequest,I=A.response;if(200!==A.status&&0!==A.status){var e=Y(J.memoryInitializerRequestURL);if(!e)return void qA();I=e.buffer}VA(I)}J.memoryInitializerRequest.response?setTimeout(ZA,0):J.memoryInitializerRequest.addEventListener("load",ZA)}else qA()}S.prototype=new Error,S.prototype.constructor=S;var WA,zA=null,OA=!1;HA=function A(){J.calledRun||R(),J.calledRun||(HA=A)},J.callMain=J.callMain=function(A){function I(){for(var A=0;A<3;A++)g.push(0)}A=A||[],p();var e=A.length+1,g=[t(m(J.thisProgram),"i8",0)];I();for(var i=0;i<e-1;i+=1)g.push(t(m(A[i]),"i8",0)),I();g.push(0),g=t(g,"i32",0);try{N(J._main(e,g,0),!0)}catch(A){if(A instanceof S)return;if("SimulateInfiniteLoop"==A)return void(J.noExitRuntime=!0);var B=A;A&&"object"==typeof A&&A.stack&&(B=[A,A.stack]),J.printErr("exception thrown: "+B),J.quit(1,A)}finally{OA=!0}},J.run=J.run=R,J.exit=J.exit=N;var $A=[];if(J.abort=J.abort=U,J.preInit)for("function"==typeof J.preInit&&(J.preInit=[J.preInit]);J.preInit.length>0;)J.preInit.pop()();var AI=!0;J.noInitialRun&&(AI=!1),J.noExitRuntime=!0,R()}),"object"==typeof process&&process.removeAllListeners("uncaughtException"),I}"function"==typeof define&&define.amd?define(["exports"],I):"object"==typeof exports&&"string"!=typeof exports.nodeName?I(exports):A.libsodium=I(A.libsodium_mod||(A.commonJsStrict={}))}(this),function(A){function I(A,I){"use strict";function e(A){if("function"==typeof TextEncoder)return new TextEncoder("utf-8").encode(A);A=unescape(encodeURIComponent(A));for(var I=new Uint8Array(A.length),e=0;e<A.length;e++)I[e]=A.charCodeAt(e);return I}function g(A){if("function"==typeof TextDecoder)return new TextDecoder("utf-8",{fatal:!0}).decode(A);var I=Math.ceil(A.length/8192);if(I<=1)try{return decodeURIComponent(escape(String.fromCharCode.apply(null,A)))}catch(A){throw new TypeError("The encoded data was not valid.")}for(var e="",i=0,B=0;B<I;B++){var t=Array.prototype.slice.call(A,8192*B+i,8192*(B+1)+i);if(0!=t.length){var r,a=t.length,n=0;do{var C=t[--a];C>=240?(n=4,r=!0):C>=224?(n=3,r=!0):C>=192?(n=2,r=!0):C<128&&(n=1,r=!0)}while(!r);for(var o=n-(t.length-a),c=0;c<o;c++)i--,t.pop();e+=g(t)}}return e}function i(A){A=_(null,A,"input");for(var I,e,g,i="",B=0;B<A.length;B++)g=87+(e=15&A[B])+(e-10>>8&-39)<<8|87+(I=A[B]>>>4)+(I-10>>8&-39),i+=String.fromCharCode(255&g)+String.fromCharCode(g>>>8);return i}function B(A){if(void 0==A)return dI.URLSAFE_NO_PADDING;if(A!==dI.ORIGINAL&&A!==dI.ORIGINAL_NO_PADDING&&A!==dI.URLSAFE&&A!=dI.URLSAFE_NO_PADDING)throw new Error("unsupported base64 variant");return A}function t(A,I){I=B(I),A=_(i,A,"input");var e,i=[],t=0|Math.floor(A.length/3),r=A.length-3*t,a=4*t+(0!==r?0==(2&I)?4:2+(r>>>1):0),n=new o(a+1),C=c(A);return i.push(C),i.push(n.address),0===wI._sodium_bin2base64(n.address,n.length,C,A.length,I)&&h(i,"conversion failed"),n.length=a,e=g(n.to_Uint8Array()),s(i),e}function r(){return["uint8array","text","hex","base64"]}function a(A,I){var e=I||lI;if(!n(e))throw new Error(e+" output format is not available");if(A instanceof o){if("uint8array"===e)return A.to_Uint8Array();if("text"===e)return g(A.to_Uint8Array());if("hex"===e)return i(A.to_Uint8Array());if("base64"===e)return t(A.to_Uint8Array(),dI.URLSAFE_NO_PADDING);throw new Error('What is output format "'+e+'"?')}if("object"==typeof A){for(var B=Object.keys(A),r={},C=0;C<B.length;C++)r[B[C]]=a(A[B[C]],e);return r}if("string"==typeof A)return A;throw new TypeError("Cannot format output")}function n(A){for(var I=r(),e=0;e<I.length;e++)if(I[e]===A)return!0;return!1}function C(A){if(A){if("string"!=typeof A)throw new TypeError("When defined, the output format must be a string");if(!n(A))throw new Error(A+" is not a supported output format")}}function o(A){this.length=A,this.address=Q(A)}function c(A){var I=Q(A.length);return wI.HEAPU8.set(A,I),I}function Q(A){var I=wI._malloc(A);if(0===I)throw{message:"_malloc() failed",length:A};return I}function E(A){wI._free(A)}function s(A){if(A)for(var I=0;I<A.length;I++)E(A[I])}function h(A,I){throw s(A),new Error(I)}function y(A,I){throw s(A),new TypeError(I)}function f(A,I,e){void 0==I&&y(A,e+" cannot be null or undefined")}function _(A,I,g){return f(A,I,g),I instanceof Uint8Array?I:"string"==typeof I?e(I):void y(A,"unsupported input type for "+g)}function p(A,I,e,g,i,B){var t=[];C(B);var r=null;void 0!=A&&(r=c(A=_(t,A,"secret_nonce")),A.length,t.push(r));var n=c(I=_(t,I,"ciphertext")),Q=I.length;t.push(n);var E=null,f=0;void 0!=e&&(E=c(e=_(t,e,"additional_data")),f=e.length,t.push(E)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_chacha20poly1305_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_chacha20poly1305_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(Q-wI._crypto_aead_chacha20poly1305_abytes()|0),D=d.address;if(t.push(D),0===wI._crypto_aead_chacha20poly1305_decrypt(D,null,r,n,Q,0,E,f,0,p,l)){var v=a(d,B);return s(t),v}h(t,"invalid usage")}function w(A,I,e,g,i,B,t){var r=[];C(t);var n=null;void 0!=A&&(n=c(A=_(r,A,"secret_nonce")),A.length,r.push(n));var Q=c(I=_(r,I,"ciphertext")),E=I.length;r.push(Q),e=_(r,e,"mac");var f,p=0|wI._crypto_box_macbytes();e.length!==p&&y(r,"invalid mac length"),f=c(e),r.push(f);var w=null,l=0;void 0!=g&&(w=c(g=_(r,g,"additional_data")),l=g.length,r.push(w)),i=_(r,i,"public_nonce");var u,d=0|wI._crypto_aead_chacha20poly1305_npubbytes();i.length!==d&&y(r,"invalid public_nonce length"),u=c(i),r.push(u),B=_(r,B,"key");var D,v=0|wI._crypto_aead_chacha20poly1305_keybytes();B.length!==v&&y(r,"invalid key length"),D=c(B),r.push(D);var b=new o(0|E),k=b.address;if(r.push(k),0===wI._crypto_aead_chacha20poly1305_decrypt_detached(k,n,Q,E,0,f,w,l,0,u,D)){var G=a(b,t);return s(r),G}h(r,"invalid usage")}function l(A,I,e,g,i,B){var t=[];C(B);var r=c(A=_(t,A,"message")),n=A.length;t.push(r);var Q=null,E=0;void 0!=I&&(Q=c(I=_(t,I,"additional_data")),E=I.length,t.push(Q));var f=null;void 0!=e&&(f=c(e=_(t,e,"secret_nonce")),e.length,t.push(f)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_chacha20poly1305_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_chacha20poly1305_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(n+wI._crypto_aead_chacha20poly1305_abytes()|0),D=d.address;if(t.push(D),0===wI._crypto_aead_chacha20poly1305_encrypt(D,null,r,n,0,Q,E,0,f,p,l)){var v=a(d,B);return s(t),v}h(t,"invalid usage")}function u(A,I,e,g,i,B){var t=[];C(B);var r=c(A=_(t,A,"message")),n=A.length;t.push(r);var Q=null,E=0;void 0!=I&&(Q=c(I=_(t,I,"additional_data")),E=I.length,t.push(Q));var f=null;void 0!=e&&(f=c(e=_(t,e,"secret_nonce")),e.length,t.push(f)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_chacha20poly1305_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_chacha20poly1305_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(0|n),D=d.address;t.push(D);var v=new o(0|wI._crypto_aead_chacha20poly1305_abytes()),b=v.address;if(t.push(b),0===wI._crypto_aead_chacha20poly1305_encrypt_detached(D,b,null,r,n,0,Q,E,0,f,p,l)){var k=a({ciphertext:d,mac:v},B);return s(t),k}h(t,"invalid usage")}function d(A,I,e,g,i,B){var t=[];C(B);var r=null;void 0!=A&&(r=c(A=_(t,A,"secret_nonce")),A.length,t.push(r));var n=c(I=_(t,I,"ciphertext")),Q=I.length;t.push(n);var E=null,f=0;void 0!=e&&(E=c(e=_(t,e,"additional_data")),f=e.length,t.push(E)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_chacha20poly1305_ietf_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_chacha20poly1305_ietf_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(Q-wI._crypto_aead_chacha20poly1305_ietf_abytes()|0),D=d.address;if(t.push(D),0===wI._crypto_aead_chacha20poly1305_ietf_decrypt(D,null,r,n,Q,0,E,f,0,p,l)){var v=a(d,B);return s(t),v}h(t,"invalid usage")}function D(A,I,e,g,i,B,t){var r=[];C(t);var n=null;void 0!=A&&(n=c(A=_(r,A,"secret_nonce")),A.length,r.push(n));var Q=c(I=_(r,I,"ciphertext")),E=I.length;r.push(Q),e=_(r,e,"mac");var f,p=0|wI._crypto_box_macbytes();e.length!==p&&y(r,"invalid mac length"),f=c(e),r.push(f);var w=null,l=0;void 0!=g&&(w=c(g=_(r,g,"additional_data")),l=g.length,r.push(w)),i=_(r,i,"public_nonce");var u,d=0|wI._crypto_aead_chacha20poly1305_ietf_npubbytes();i.length!==d&&y(r,"invalid public_nonce length"),u=c(i),r.push(u),B=_(r,B,"key");var D,v=0|wI._crypto_aead_chacha20poly1305_ietf_keybytes();B.length!==v&&y(r,"invalid key length"),D=c(B),r.push(D);var b=new o(0|E),k=b.address;if(r.push(k),0===wI._crypto_aead_chacha20poly1305_ietf_decrypt_detached(k,n,Q,E,0,f,w,l,0,u,D)){var G=a(b,t);return s(r),G}h(r,"invalid usage")}function v(A,I,e,g,i,B){var t=[];C(B);var r=c(A=_(t,A,"message")),n=A.length;t.push(r);var Q=null,E=0;void 0!=I&&(Q=c(I=_(t,I,"additional_data")),E=I.length,t.push(Q));var f=null;void 0!=e&&(f=c(e=_(t,e,"secret_nonce")),e.length,t.push(f)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_chacha20poly1305_ietf_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_chacha20poly1305_ietf_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(n+wI._crypto_aead_chacha20poly1305_ietf_abytes()|0),D=d.address;if(t.push(D),0===wI._crypto_aead_chacha20poly1305_ietf_encrypt(D,null,r,n,0,Q,E,0,f,p,l)){var v=a(d,B);return s(t),v}h(t,"invalid usage")}function b(A,I,e,g,i,B){var t=[];C(B);var r=c(A=_(t,A,"message")),n=A.length;t.push(r);var Q=null,E=0;void 0!=I&&(Q=c(I=_(t,I,"additional_data")),E=I.length,t.push(Q));var f=null;void 0!=e&&(f=c(e=_(t,e,"secret_nonce")),e.length,t.push(f)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_chacha20poly1305_ietf_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_chacha20poly1305_ietf_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(0|n),D=d.address;t.push(D);var v=new o(0|wI._crypto_aead_chacha20poly1305_ietf_abytes()),b=v.address;if(t.push(b),0===wI._crypto_aead_chacha20poly1305_ietf_encrypt_detached(D,b,null,r,n,0,Q,E,0,f,p,l)){var k=a({ciphertext:d,mac:v},B);return s(t),k}h(t,"invalid usage")}function k(A){var I=[];C(A);var e=new o(0|wI._crypto_aead_chacha20poly1305_ietf_keybytes()),g=e.address;I.push(g),wI._crypto_aead_chacha20poly1305_ietf_keygen(g);var i=a(e,A);return s(I),i}function G(A){var I=[];C(A);var e=new o(0|wI._crypto_aead_chacha20poly1305_keybytes()),g=e.address;I.push(g),wI._crypto_aead_chacha20poly1305_keygen(g);var i=a(e,A);return s(I),i}function F(A,I,e,g,i,B){var t=[];C(B);var r=null;void 0!=A&&(r=c(A=_(t,A,"secret_nonce")),A.length,t.push(r));var n=c(I=_(t,I,"ciphertext")),Q=I.length;t.push(n);var E=null,f=0;void 0!=e&&(E=c(e=_(t,e,"additional_data")),f=e.length,t.push(E)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_xchacha20poly1305_ietf_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_xchacha20poly1305_ietf_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(Q-wI._crypto_aead_xchacha20poly1305_ietf_abytes()|0),D=d.address;if(t.push(D),0===wI._crypto_aead_xchacha20poly1305_ietf_decrypt(D,null,r,n,Q,0,E,f,0,p,l)){var v=a(d,B);return s(t),v}h(t,"invalid usage")}function m(A,I,e,g,i,B,t){var r=[];C(t);var n=null;void 0!=A&&(n=c(A=_(r,A,"secret_nonce")),A.length,r.push(n));var Q=c(I=_(r,I,"ciphertext")),E=I.length;r.push(Q),e=_(r,e,"mac");var f,p=0|wI._crypto_box_macbytes();e.length!==p&&y(r,"invalid mac length"),f=c(e),r.push(f);var w=null,l=0;void 0!=g&&(w=c(g=_(r,g,"additional_data")),l=g.length,r.push(w)),i=_(r,i,"public_nonce");var u,d=0|wI._crypto_aead_xchacha20poly1305_ietf_npubbytes();i.length!==d&&y(r,"invalid public_nonce length"),u=c(i),r.push(u),B=_(r,B,"key");var D,v=0|wI._crypto_aead_xchacha20poly1305_ietf_keybytes();B.length!==v&&y(r,"invalid key length"),D=c(B),r.push(D);var b=new o(0|E),k=b.address;if(r.push(k),0===wI._crypto_aead_xchacha20poly1305_ietf_decrypt_detached(k,n,Q,E,0,f,w,l,0,u,D)){var G=a(b,t);return s(r),G}h(r,"invalid usage")}function M(A,I,e,g,i,B){var t=[];C(B);var r=c(A=_(t,A,"message")),n=A.length;t.push(r);var Q=null,E=0;void 0!=I&&(Q=c(I=_(t,I,"additional_data")),E=I.length,t.push(Q));var f=null;void 0!=e&&(f=c(e=_(t,e,"secret_nonce")),e.length,t.push(f)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_xchacha20poly1305_ietf_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_xchacha20poly1305_ietf_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(n+wI._crypto_aead_xchacha20poly1305_ietf_abytes()|0),D=d.address;if(t.push(D),0===wI._crypto_aead_xchacha20poly1305_ietf_encrypt(D,null,r,n,0,Q,E,0,f,p,l)){var v=a(d,B);return s(t),v}h(t,"invalid usage")}function H(A,I,e,g,i,B){var t=[];C(B);var r=c(A=_(t,A,"message")),n=A.length;t.push(r);var Q=null,E=0;void 0!=I&&(Q=c(I=_(t,I,"additional_data")),E=I.length,t.push(Q));var f=null;void 0!=e&&(f=c(e=_(t,e,"secret_nonce")),e.length,t.push(f)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_xchacha20poly1305_ietf_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_xchacha20poly1305_ietf_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(0|n),D=d.address;t.push(D);var v=new o(0|wI._crypto_aead_xchacha20poly1305_ietf_abytes()),b=v.address;if(t.push(b),0===wI._crypto_aead_xchacha20poly1305_ietf_encrypt_detached(D,b,null,r,n,0,Q,E,0,f,p,l)){var k=a({ciphertext:d,mac:v},B);return s(t),k}h(t,"invalid usage")}function Y(A){var I=[];C(A);var e=new o(0|wI._crypto_aead_xchacha20poly1305_ietf_keybytes()),g=e.address;I.push(g),wI._crypto_aead_xchacha20poly1305_ietf_keygen(g);var i=a(e,A);return s(I),i}function S(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"key");var t,r=0|wI._crypto_auth_keybytes();I.length!==r&&y(g,"invalid key length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_auth_bytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_auth(Q,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function R(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"key");var t,r=0|wI._crypto_auth_hmacsha256_keybytes();I.length!==r&&y(g,"invalid key length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_auth_hmacsha256_bytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_auth_hmacsha256(Q,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function N(A){var I=[];C(A);var e=new o(0|wI._crypto_auth_hmacsha256_keybytes()),g=e.address;I.push(g),wI._crypto_auth_hmacsha256_keygen(g);var i=a(e,A);return s(I),i}function U(A,I,e){var g=[];A=_(g,A,"tag");var i,B=0|wI._crypto_auth_hmacsha256_bytes();A.length!==B&&y(g,"invalid tag length"),i=c(A),g.push(i);var t=c(I=_(g,I,"message")),r=I.length;g.push(t),e=_(g,e,"key");var a,n=0|wI._crypto_auth_hmacsha256_keybytes();e.length!==n&&y(g,"invalid key length"),a=c(e),g.push(a);var C=0==(0|wI._crypto_auth_hmacsha256_verify(i,t,r,0,a));return s(g),C}function J(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"key");var t,r=0|wI._crypto_auth_hmacsha512_keybytes();I.length!==r&&y(g,"invalid key length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_auth_hmacsha512_bytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_auth_hmacsha512(Q,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function P(A){var I=[];C(A);var e=new o(0|wI._crypto_auth_hmacsha512_keybytes()),g=e.address;I.push(g),wI._crypto_auth_hmacsha512_keygen(g);var i=a(e,A);return s(I),i}function L(A,I,e){var g=[];A=_(g,A,"tag");var i,B=0|wI._crypto_auth_hmacsha512_bytes();A.length!==B&&y(g,"invalid tag length"),i=c(A),g.push(i);var t=c(I=_(g,I,"message")),r=I.length;g.push(t),e=_(g,e,"key");var a,n=0|wI._crypto_auth_hmacsha512_keybytes();e.length!==n&&y(g,"invalid key length"),a=c(e),g.push(a);var C=0==(0|wI._crypto_auth_hmacsha512_verify(i,t,r,0,a));return s(g),C}function x(A){var I=[];C(A);var e=new o(0|wI._crypto_auth_keybytes()),g=e.address;I.push(g),wI._crypto_auth_keygen(g);var i=a(e,A);return s(I),i}function X(A,I,e){var g=[];A=_(g,A,"tag");var i,B=0|wI._crypto_auth_bytes();A.length!==B&&y(g,"invalid tag length"),i=c(A),g.push(i);var t=c(I=_(g,I,"message")),r=I.length;g.push(t),e=_(g,e,"key");var a,n=0|wI._crypto_auth_keybytes();e.length!==n&&y(g,"invalid key length"),a=c(e),g.push(a);var C=0==(0|wI._crypto_auth_verify(i,t,r,0,a));return s(g),C}function K(A,I,e){var g=[];C(e),A=_(g,A,"publicKey");var i,B=0|wI._crypto_box_publickeybytes();A.length!==B&&y(g,"invalid publicKey length"),i=c(A),g.push(i),I=_(g,I,"privateKey");var t,r=0|wI._crypto_box_secretkeybytes();I.length!==r&&y(g,"invalid privateKey length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_box_beforenmbytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_box_beforenm(Q,i,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function T(A,I,e,g,i){var B=[];C(i);var t=c(A=_(B,A,"message")),r=A.length;B.push(t),I=_(B,I,"nonce");var n,Q=0|wI._crypto_box_noncebytes();I.length!==Q&&y(B,"invalid nonce length"),n=c(I),B.push(n),e=_(B,e,"publicKey");var E,f=0|wI._crypto_box_publickeybytes();e.length!==f&&y(B,"invalid publicKey length"),E=c(e),B.push(E),g=_(B,g,"privateKey");var p,w=0|wI._crypto_box_secretkeybytes();g.length!==w&&y(B,"invalid privateKey length"),p=c(g),B.push(p);var l=new o(0|r),u=l.address;B.push(u);var d=new o(0|wI._crypto_box_macbytes()),D=d.address;if(B.push(D),0==(0|wI._crypto_box_detached(u,D,t,r,0,n,E,p))){var v=a({ciphertext:l,mac:d},i);return s(B),v}h(B,"invalid usage")}function V(A,I,e,g,i){var B=[];C(i);var t=c(A=_(B,A,"message")),r=A.length;B.push(t),I=_(B,I,"nonce");var n,Q=0|wI._crypto_box_noncebytes();I.length!==Q&&y(B,"invalid nonce length"),n=c(I),B.push(n),e=_(B,e,"publicKey");var E,f=0|wI._crypto_box_publickeybytes();e.length!==f&&y(B,"invalid publicKey length"),E=c(e),B.push(E),g=_(B,g,"privateKey");var p,w=0|wI._crypto_box_secretkeybytes();g.length!==w&&y(B,"invalid privateKey length"),p=c(g),B.push(p);var l=new o(r+wI._crypto_box_macbytes()|0),u=l.address;if(B.push(u),0==(0|wI._crypto_box_easy(u,t,r,0,n,E,p))){var d=a(l,i);return s(B),d}h(B,"invalid usage")}function q(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"message")),t=A.length;i.push(B),I=_(i,I,"nonce");var r,n=0|wI._crypto_box_noncebytes();I.length!==n&&y(i,"invalid nonce length"),r=c(I),i.push(r),e=_(i,e,"sharedKey");var Q,E=0|wI._crypto_box_beforenmbytes();e.length!==E&&y(i,"invalid sharedKey length"),Q=c(e),i.push(Q);var f=new o(t+wI._crypto_box_macbytes()|0),p=f.address;if(i.push(p),0==(0|wI._crypto_box_easy_afternm(p,B,t,0,r,Q))){var w=a(f,g);return s(i),w}h(i,"invalid usage")}function j(A){var I=[];C(A);var e=new o(0|wI._crypto_box_publickeybytes()),g=e.address;I.push(g);var i=new o(0|wI._crypto_box_secretkeybytes()),B=i.address;if(I.push(B),0==(0|wI._crypto_box_keypair(g,B))){var t={publicKey:a(e,A),privateKey:a(i,A),keyType:"x25519"};return s(I),t}h(I,"internal error")}function Z(A,I,e,g,i,B){var t=[];C(B);var r=c(A=_(t,A,"ciphertext")),n=A.length;t.push(r),I=_(t,I,"mac");var Q,E=0|wI._crypto_box_macbytes();I.length!==E&&y(t,"invalid mac length"),Q=c(I),t.push(Q),e=_(t,e,"nonce");var f,p=0|wI._crypto_box_noncebytes();e.length!==p&&y(t,"invalid nonce length"),f=c(e),t.push(f),g=_(t,g,"publicKey");var w,l=0|wI._crypto_box_publickeybytes();g.length!==l&&y(t,"invalid publicKey length"),w=c(g),t.push(w),i=_(t,i,"privateKey");var u,d=0|wI._crypto_box_secretkeybytes();i.length!==d&&y(t,"invalid privateKey length"),u=c(i),t.push(u);var D=new o(0|n),v=D.address;if(t.push(v),0==(0|wI._crypto_box_open_detached(v,r,Q,n,0,f,w,u))){var b=a(D,B);return s(t),b}h(t,"incorrect key pair for the given ciphertext")}function W(A,I,e,g,i){var B=[];C(i);var t=c(A=_(B,A,"ciphertext")),r=A.length;B.push(t),I=_(B,I,"nonce");var n,Q=0|wI._crypto_box_noncebytes();I.length!==Q&&y(B,"invalid nonce length"),n=c(I),B.push(n),e=_(B,e,"publicKey");var E,f=0|wI._crypto_box_publickeybytes();e.length!==f&&y(B,"invalid publicKey length"),E=c(e),B.push(E),g=_(B,g,"privateKey");var p,w=0|wI._crypto_box_secretkeybytes();g.length!==w&&y(B,"invalid privateKey length"),p=c(g),B.push(p);var l=new o(r-wI._crypto_box_macbytes()|0),u=l.address;if(B.push(u),0==(0|wI._crypto_box_open_easy(u,t,r,0,n,E,p))){var d=a(l,i);return s(B),d}h(B,"incorrect key pair for the given ciphertext")}function z(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"ciphertext")),t=A.length;i.push(B),I=_(i,I,"nonce");var r,n=0|wI._crypto_box_noncebytes();I.length!==n&&y(i,"invalid nonce length"),r=c(I),i.push(r),e=_(i,e,"sharedKey");var Q,E=0|wI._crypto_box_beforenmbytes();e.length!==E&&y(i,"invalid sharedKey length"),Q=c(e),i.push(Q);var f=new o(t-wI._crypto_box_macbytes()|0),p=f.address;if(i.push(p),0==(0|wI._crypto_box_open_easy_afternm(p,B,t,0,r,Q))){var w=a(f,g);return s(i),w}h(i,"incorrect secret key for the given ciphertext")}function O(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"publicKey");var t,r=0|wI._crypto_box_publickeybytes();I.length!==r&&y(g,"invalid publicKey length"),t=c(I),g.push(t);var n=new o(B+wI._crypto_box_sealbytes()|0),Q=n.address;if(g.push(Q),0==(0|wI._crypto_box_seal(Q,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function $(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"ciphertext")),t=A.length;i.push(B),I=_(i,I,"publicKey");var r,n=0|wI._crypto_box_publickeybytes();I.length!==n&&y(i,"invalid publicKey length"),r=c(I),i.push(r),e=_(i,e,"privateKey");var Q,E=0|wI._crypto_box_secretkeybytes();e.length!==E&&y(i,"invalid privateKey length"),Q=c(e),i.push(Q);var f=new o(t-wI._crypto_box_sealbytes()|0),p=f.address;if(i.push(p),0==(0|wI._crypto_box_seal_open(p,B,t,0,r,Q))){var w=a(f,g);return s(i),w}h(i,"incorrect key pair for the given ciphertext")}function AA(A,I){var e=[];C(I),A=_(e,A,"seed");var g,i=0|wI._crypto_box_seedbytes();A.length!==i&&y(e,"invalid seed length"),g=c(A),e.push(g);var B=new o(0|wI._crypto_box_publickeybytes()),t=B.address;e.push(t);var r=new o(0|wI._crypto_box_secretkeybytes()),n=r.address;if(e.push(n),0==(0|wI._crypto_box_seed_keypair(t,n,g))){var Q={publicKey:a(B,I),privateKey:a(r,I),keyType:"x25519"};return s(e),Q}h(e,"invalid usage")}function IA(A,I,e,g){var i=[];C(g),f(i,A,"hash_length"),("number"!=typeof A||(0|A)!==A||A<0)&&y(i,"hash_length must be an unsigned integer");var B=c(I=_(i,I,"message")),t=I.length;i.push(B);var r=null,n=0;void 0!=e&&(r=c(e=_(i,e,"key")),n=e.length,i.push(r));var Q=new o(A|=0),E=Q.address;if(i.push(E),0==(0|wI._crypto_generichash(E,A,B,t,0,r,n))){var p=a(Q,g);return s(i),p}h(i,"invalid usage")}function eA(A,I,e){var g=[];C(e),f(g,A,"state_address"),f(g,I,"hash_length"),("number"!=typeof I||(0|I)!==I||I<0)&&y(g,"hash_length must be an unsigned integer");var i=new o(I|=0),B=i.address;if(g.push(B),0==(0|wI._crypto_generichash_final(A,B,I))){var t=(wI._free(A),a(i,e));return s(g),t}h(g,"invalid usage")}function gA(A,I,e){var g=[];C(e);var i=null,B=0;void 0!=A&&(i=c(A=_(g,A,"key")),B=A.length,g.push(i)),f(g,I,"hash_length"),("number"!=typeof I||(0|I)!==I||I<0)&&y(g,"hash_length must be an unsigned integer");var t=new o(357).address;if(0==(0|wI._crypto_generichash_init(t,i,B,I))){var r=t;return s(g),r}h(g,"invalid usage")}function iA(A){var I=[];C(A);var e=new o(0|wI._crypto_generichash_keybytes()),g=e.address;I.push(g),wI._crypto_generichash_keygen(g);var i=a(e,A);return s(I),i}function BA(A,I,e){var g=[];C(e),f(g,A,"state_address");var i=c(I=_(g,I,"message_chunk")),B=I.length;g.push(i),0!=(0|wI._crypto_generichash_update(A,i,B))&&h(g,"invalid usage"),s(g)}function tA(A,I){var e=[];C(I);var g=c(A=_(e,A,"message")),i=A.length;e.push(g);var B=new o(0|wI._crypto_hash_bytes()),t=B.address;if(e.push(t),0==(0|wI._crypto_hash(t,g,i,0))){var r=a(B,I);return s(e),r}h(e,"invalid usage")}function rA(A,I){var e=[];C(I);var g=c(A=_(e,A,"message")),i=A.length;e.push(g);var B=new o(0|wI._crypto_hash_sha256_bytes()),t=B.address;if(e.push(t),0==(0|wI._crypto_hash_sha256(t,g,i,0))){var r=a(B,I);return s(e),r}h(e,"invalid usage")}function aA(A,I){var e=[];C(I);var g=c(A=_(e,A,"message")),i=A.length;e.push(g);var B=new o(0|wI._crypto_hash_sha512_bytes()),t=B.address;if(e.push(t),0==(0|wI._crypto_hash_sha512(t,g,i,0))){var r=a(B,I);return s(e),r}h(e,"invalid usage")}function nA(A,I,g,i,B){var t=[];C(B),f(t,A,"subkey_len"),("number"!=typeof A||(0|A)!==A||A<0)&&y(t,"subkey_len must be an unsigned integer"),f(t,I,"subkey_id"),("number"!=typeof I||(0|I)!==I||I<0)&&y(t,"subkey_id must be an unsigned integer");var r=c(g=e(g+"\0"));g.length,t.push(r),i=_(t,i,"key");var n,Q=0|wI._crypto_kdf_keybytes();i.length!==Q&&y(t,"invalid key length"),n=c(i),t.push(n);var E=new o(0|A),h=E.address;t.push(h),wI._crypto_kdf_derive_from_key(h,A,I,0,r,n);var p=a(E,B);return s(t),p}function CA(A){var I=[];C(A);var e=new o(0|wI._crypto_kdf_keybytes()),g=e.address;I.push(g),wI._crypto_kdf_keygen(g);var i=a(e,A);return s(I),i}function oA(A,I,e,g){var i=[];C(g),A=_(i,A,"clientPublicKey");var B,t=0|wI._crypto_kx_publickeybytes();A.length!==t&&y(i,"invalid clientPublicKey length"),B=c(A),i.push(B),I=_(i,I,"clientSecretKey");var r,n=0|wI._crypto_kx_secretkeybytes();I.length!==n&&y(i,"invalid clientSecretKey length"),r=c(I),i.push(r),e=_(i,e,"serverPublicKey");var Q,E=0|wI._crypto_kx_publickeybytes();e.length!==E&&y(i,"invalid serverPublicKey length"),Q=c(e),i.push(Q);var f=new o(0|wI._crypto_kx_sessionkeybytes()),p=f.address;i.push(p);var w=new o(0|wI._crypto_kx_sessionkeybytes()),l=w.address;if(i.push(l),0==(0|wI._crypto_kx_client_session_keys(p,l,B,r,Q))){var u=a({sharedRx:f,sharedTx:w},g);return s(i),u}h(i,"invalid usage")}function cA(A){var I=[];C(A);var e=new o(0|wI._crypto_kx_publickeybytes()),g=e.address;I.push(g);var i=new o(0|wI._crypto_kx_secretkeybytes()),B=i.address;if(I.push(B),0==(0|wI._crypto_kx_keypair(g,B))){var t={publicKey:a(e,A),privateKey:a(i,A),keyType:"x25519"};return s(I),t}h(I,"internal error")}function QA(A,I){var e=[];C(I),A=_(e,A,"seed");var g,i=0|wI._crypto_kx_seedbytes();A.length!==i&&y(e,"invalid seed length"),g=c(A),e.push(g);var B=new o(0|wI._crypto_kx_publickeybytes()),t=B.address;e.push(t);var r=new o(0|wI._crypto_kx_secretkeybytes()),n=r.address;if(e.push(n),0==(0|wI._crypto_kx_seed_keypair(t,n,g))){var Q={publicKey:a(B,I),privateKey:a(r,I),keyType:"x25519"};return s(e),Q}h(e,"internal error")}function EA(A,I,e,g){var i=[];C(g),A=_(i,A,"serverPublicKey");var B,t=0|wI._crypto_kx_publickeybytes();A.length!==t&&y(i,"invalid serverPublicKey length"),B=c(A),i.push(B),I=_(i,I,"serverSecretKey");var r,n=0|wI._crypto_kx_secretkeybytes();I.length!==n&&y(i,"invalid serverSecretKey length"),r=c(I),i.push(r),e=_(i,e,"clientPublicKey");var Q,E=0|wI._crypto_kx_publickeybytes();e.length!==E&&y(i,"invalid clientPublicKey length"),Q=c(e),i.push(Q);var f=new o(0|wI._crypto_kx_sessionkeybytes()),p=f.address;i.push(p);var w=new o(0|wI._crypto_kx_sessionkeybytes()),l=w.address;if(i.push(l),0==(0|wI._crypto_kx_server_session_keys(p,l,B,r,Q))){var u=a({sharedRx:f,sharedTx:w},g);return s(i),u}h(i,"invalid usage")}function sA(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"key");var t,r=0|wI._crypto_onetimeauth_keybytes();I.length!==r&&y(g,"invalid key length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_onetimeauth_bytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_onetimeauth(Q,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function hA(A,I){var e=[];C(I),f(e,A,"state_address");var g=new o(0|wI._crypto_onetimeauth_bytes()),i=g.address;if(e.push(i),0==(0|wI._crypto_onetimeauth_final(A,i))){var B=(wI._free(A),a(g,I));return s(e),B}h(e,"invalid usage")}function yA(A,I){var e=[];C(I);var g=null;void 0!=A&&(g=c(A=_(e,A,"key")),A.length,e.push(g));var i=new o(144).address;if(0==(0|wI._crypto_onetimeauth_init(i,g))){var B=i;return s(e),B}h(e,"invalid usage")}function fA(A){var I=[];C(A);var e=new o(0|wI._crypto_onetimeauth_keybytes()),g=e.address;I.push(g),wI._crypto_onetimeauth_keygen(g);var i=a(e,A);return s(I),i}function _A(A,I,e){var g=[];C(e),f(g,A,"state_address");var i=c(I=_(g,I,"message_chunk")),B=I.length;g.push(i),0!=(0|wI._crypto_onetimeauth_update(A,i,B))&&h(g,"invalid usage"),s(g)}function pA(A,I,e){var g=[];A=_(g,A,"hash");var i,B=0|wI._crypto_onetimeauth_bytes();A.length!==B&&y(g,"invalid hash length"),i=c(A),g.push(i);var t=c(I=_(g,I,"message")),r=I.length;g.push(t),e=_(g,e,"key");var a,n=0|wI._crypto_onetimeauth_keybytes();e.length!==n&&y(g,"invalid key length"),a=c(e),g.push(a);var C=0==(0|wI._crypto_onetimeauth_verify(i,t,r,0,a));return s(g),C}function wA(A,I,e,g,i,B,t){var r=[];C(t),f(r,A,"keyLength"),("number"!=typeof A||(0|A)!==A||A<0)&&y(r,"keyLength must be an unsigned integer");var n=c(I=_(r,I,"password")),Q=I.length;r.push(n),e=_(r,e,"salt");var E,p=0|wI._crypto_pwhash_saltbytes();e.length!==p&&y(r,"invalid salt length"),E=c(e),r.push(E),f(r,g,"opsLimit"),("number"!=typeof g||(0|g)!==g||g<0)&&y(r,"opsLimit must be an unsigned integer"),f(r,i,"memLimit"),("number"!=typeof i||(0|i)!==i||i<0)&&y(r,"memLimit must be an unsigned integer"),f(r,B,"algorithm"),("number"!=typeof B||(0|B)!==B||B<0)&&y(r,"algorithm must be an unsigned integer");var w=new o(0|A),l=w.address;if(r.push(l),0==(0|wI._crypto_pwhash(l,A,0,n,Q,0,E,g,0,i,B))){var u=a(w,t);return s(r),u}h(r,"invalid usage")}function lA(A,I,e,g,i,B){var t=[];C(B),f(t,A,"keyLength"),("number"!=typeof A||(0|A)!==A||A<0)&&y(t,"keyLength must be an unsigned integer");var r=c(I=_(t,I,"password")),n=I.length;t.push(r),e=_(t,e,"salt");var Q,E=0|wI._crypto_pwhash_scryptsalsa208sha256_saltbytes();e.length!==E&&y(t,"invalid salt length"),Q=c(e),t.push(Q),f(t,g,"opsLimit"),("number"!=typeof g||(0|g)!==g||g<0)&&y(t,"opsLimit must be an unsigned integer"),f(t,i,"memLimit"),("number"!=typeof i||(0|i)!==i||i<0)&&y(t,"memLimit must be an unsigned integer");var p=new o(0|A),w=p.address;if(t.push(w),0==(0|wI._crypto_pwhash_scryptsalsa208sha256(w,A,0,r,n,0,Q,g,0,i))){var l=a(p,B);return s(t),l}h(t,"invalid usage")}function uA(A,I,e,g,i,B,t){var r=[];C(t);var n=c(A=_(r,A,"password")),Q=A.length;r.push(n);var E=c(I=_(r,I,"salt")),p=I.length;r.push(E),f(r,e,"opsLimit"),("number"!=typeof e||(0|e)!==e||e<0)&&y(r,"opsLimit must be an unsigned integer"),f(r,g,"r"),("number"!=typeof g||(0|g)!==g||g<0)&&y(r,"r must be an unsigned integer"),f(r,i,"p"),("number"!=typeof i||(0|i)!==i||i<0)&&y(r,"p must be an unsigned integer"),f(r,B,"keyLength"),("number"!=typeof B||(0|B)!==B||B<0)&&y(r,"keyLength must be an unsigned integer");var w=new o(0|B),l=w.address;if(r.push(l),0==(0|wI._crypto_pwhash_scryptsalsa208sha256_ll(n,Q,E,p,e,0,g,i,l,B))){var u=a(w,t);return s(r),u}h(r,"invalid usage")}function dA(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"password")),t=A.length;i.push(B),f(i,I,"opsLimit"),("number"!=typeof I||(0|I)!==I||I<0)&&y(i,"opsLimit must be an unsigned integer"),f(i,e,"memLimit"),("number"!=typeof e||(0|e)!==e||e<0)&&y(i,"memLimit must be an unsigned integer");var r=new o(0|wI._crypto_pwhash_scryptsalsa208sha256_strbytes()).address;if(i.push(r),0==(0|wI._crypto_pwhash_scryptsalsa208sha256_str(r,B,t,0,I,0,e))){var a=wI.Pointer_stringify(r);return s(i),a}h(i,"invalid usage")}function DA(A,I,g){var i=[];C(g);var B=c(A=e(A+"\0"));A.length,i.push(B);var t=c(I=_(i,I,"password")),r=I.length;i.push(t);var a=0==(0|wI._crypto_pwhash_scryptsalsa208sha256_str_verify(B,t,r,0));return s(i),a}function vA(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"password")),t=A.length;i.push(B),f(i,I,"opsLimit"),("number"!=typeof I||(0|I)!==I||I<0)&&y(i,"opsLimit must be an unsigned integer"),f(i,e,"memLimit"),("number"!=typeof e||(0|e)!==e||e<0)&&y(i,"memLimit must be an unsigned integer");var r=new o(0|wI._crypto_pwhash_strbytes()).address;if(i.push(r),0==(0|wI._crypto_pwhash_str(r,B,t,0,I,0,e))){var a=wI.Pointer_stringify(r);return s(i),a}h(i,"invalid usage")}function bA(A,I,g){var i=[];C(g);var B=c(A=e(A+"\0"));A.length,i.push(B);var t=c(I=_(i,I,"password")),r=I.length;i.push(t);var a=0==(0|wI._crypto_pwhash_str_verify(B,t,r,0));return s(i),a}function kA(A,I,e){var g=[];C(e),A=_(g,A,"privateKey");var i,B=0|wI._crypto_scalarmult_scalarbytes();A.length!==B&&y(g,"invalid privateKey length"),i=c(A),g.push(i),I=_(g,I,"publicKey");var t,r=0|wI._crypto_scalarmult_scalarbytes();I.length!==r&&y(g,"invalid publicKey length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_scalarmult_bytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_scalarmult(Q,i,t))){var E=a(n,e);return s(g),E}h(g,"weak public key")}function GA(A,I){var e=[];C(I),A=_(e,A,"privateKey");var g,i=0|wI._crypto_scalarmult_scalarbytes();A.length!==i&&y(e,"invalid privateKey length"),g=c(A),e.push(g);var B=new o(0|wI._crypto_scalarmult_scalarbytes()),t=B.address;if(e.push(t),0==(0|wI._crypto_scalarmult_base(t,g))){var r=a(B,I);return s(e),r}h(e,"insecure scalar")}function FA(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"message")),t=A.length;i.push(B),I=_(i,I,"nonce");var r,n=0|wI._crypto_secretbox_noncebytes();I.length!==n&&y(i,"invalid nonce length"),r=c(I),i.push(r),e=_(i,e,"key");var Q,E=0|wI._crypto_secretbox_keybytes();e.length!==E&&y(i,"invalid key length"),Q=c(e),i.push(Q);var f=new o(0|t),p=f.address;i.push(p);var w=new o(0|wI._crypto_secretbox_macbytes()),l=w.address;if(i.push(l),0==(0|wI._crypto_secretbox_detached(p,l,B,t,0,r,Q))){var u=a({mac:w,cipher:f},g);return s(i),u}h(i,"invalid usage")}function mA(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"message")),t=A.length;i.push(B),I=_(i,I,"nonce");var r,n=0|wI._crypto_secretbox_noncebytes();I.length!==n&&y(i,"invalid nonce length"),r=c(I),i.push(r),e=_(i,e,"key");var Q,E=0|wI._crypto_secretbox_keybytes();e.length!==E&&y(i,"invalid key length"),Q=c(e),i.push(Q);var f=new o(t+wI._crypto_secretbox_macbytes()|0),p=f.address;if(i.push(p),0==(0|wI._crypto_secretbox_easy(p,B,t,0,r,Q))){var w=a(f,g);return s(i),w}h(i,"invalid usage")}function MA(A){var I=[];C(A);var e=new o(0|wI._crypto_secretbox_keybytes()),g=e.address;I.push(g),wI._crypto_secretbox_keygen(g);var i=a(e,A);return s(I),i}function HA(A,I,e,g,i){var B=[];C(i);var t=c(A=_(B,A,"ciphertext")),r=A.length;B.push(t),I=_(B,I,"mac");var n,Q=0|wI._crypto_secretbox_macbytes();I.length!==Q&&y(B,"invalid mac length"),n=c(I),B.push(n),e=_(B,e,"nonce");var E,f=0|wI._crypto_secretbox_noncebytes();e.length!==f&&y(B,"invalid nonce length"),E=c(e),B.push(E),g=_(B,g,"key");var p,w=0|wI._crypto_secretbox_keybytes();g.length!==w&&y(B,"invalid key length"),p=c(g),B.push(p);var l=new o(0|r),u=l.address;if(B.push(u),0==(0|wI._crypto_secretbox_open_detached(u,t,n,r,0,E,p))){var d=a(l,i);return s(B),d}h(B,"wrong secret key for the given ciphertext")}function YA(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"ciphertext")),t=A.length;i.push(B),I=_(i,I,"nonce");var r,n=0|wI._crypto_secretbox_noncebytes();I.length!==n&&y(i,"invalid nonce length"),r=c(I),i.push(r),e=_(i,e,"key");var Q,E=0|wI._crypto_secretbox_keybytes();e.length!==E&&y(i,"invalid key length"),Q=c(e),i.push(Q);var f=new o(t-wI._crypto_secretbox_macbytes()|0),p=f.address;if(i.push(p),0==(0|wI._crypto_secretbox_open_easy(p,B,t,0,r,Q))){var w=a(f,g);return s(i),w}h(i,"wrong secret key for the given ciphertext")}function SA(A,I,e){var g=[];C(e),A=_(g,A,"header");var i,B=0|wI._crypto_secretstream_xchacha20poly1305_headerbytes();A.length!==B&&y(g,"invalid header length"),i=c(A),g.push(i),I=_(g,I,"key");var t,r=0|wI._crypto_secretstream_xchacha20poly1305_keybytes();I.length!==r&&y(g,"invalid key length"),t=c(I),g.push(t);var a=new o(52).address;if(0==(0|wI._crypto_secretstream_xchacha20poly1305_init_pull(a,i,t))){var n=a;return s(g),n}h(g,"invalid usage")}function RA(A,I){var e=[];C(I),A=_(e,A,"key");var g,i=0|wI._crypto_secretstream_xchacha20poly1305_keybytes();A.length!==i&&y(e,"invalid key length"),g=c(A),e.push(g);var B=new o(52).address,t=new o(0|wI._crypto_secretstream_xchacha20poly1305_headerbytes()),r=t.address;if(e.push(r),0==(0|wI._crypto_secretstream_xchacha20poly1305_init_push(B,r,g))){var n={state:B,header:a(t,I)};return s(e),n}h(e,"invalid usage")}function NA(A){var I=[];C(A);var e=new o(0|wI._crypto_secretstream_xchacha20poly1305_keybytes()),g=e.address;I.push(g),wI._crypto_secretstream_xchacha20poly1305_keygen(g);var i=a(e,A);return s(I),i}function UA(A,I,e,g){var i=[];C(g),f(i,A,"state_address");var B=c(I=_(i,I,"cipher")),t=I.length;i.push(B);var r=null,n=0;void 0!=e&&(e=_(i,e,"ad"),r=c(e),n=e.length,i.push(r));var E=new o(t-wI._crypto_secretstream_xchacha20poly1305_abytes()|0),h=E.address;i.push(h);var y=(y=function(){var I=Q(1);return i.push(I),0===wI._crypto_secretstream_xchacha20poly1305_pull(A,h,0,I,B,t,0,r,n)&&{tag:wI.HEAPU8[I],message:E}}())&&{message:a(y.message,g),tag:y.tag};return s(i),y}function JA(A,I,e,g,i){var B=[];C(i),f(B,A,"state_address");var t=c(I=_(B,I,"message_chunk")),r=I.length;B.push(t);var n=null,Q=0;void 0!=e&&(n=c(e=_(B,e,"ad")),Q=e.length,B.push(n)),f(B,g,"tag"),("number"!=typeof g||(0|g)!==g||g<0)&&y(B,"tag must be an unsigned integer");var E=new o(r+wI._crypto_secretstream_xchacha20poly1305_abytes()|0),p=E.address;if(B.push(p),0==(0|wI._crypto_secretstream_xchacha20poly1305_push(A,p,0,t,r,0,n,Q,0,g))){var w=a(E,i);return s(B),w}h(B,"invalid usage")}function PA(A,I){var e=[];return C(I),f(e,A,"state_address"),wI._crypto_secretstream_xchacha20poly1305_rekey(A),s(e),!0}function LA(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"key");var t,r=0|wI._crypto_shorthash_keybytes();I.length!==r&&y(g,"invalid key length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_shorthash_bytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_shorthash(Q,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function xA(A){var I=[];C(A);var e=new o(0|wI._crypto_shorthash_keybytes()),g=e.address;I.push(g),wI._crypto_shorthash_keygen(g);var i=a(e,A);return s(I),i}function XA(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"key");var t,r=0|wI._crypto_shorthash_siphashx24_keybytes();I.length!==r&&y(g,"invalid key length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_shorthash_siphashx24_bytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_shorthash_siphashx24(Q,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function KA(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"privateKey");var t,r=0|wI._crypto_sign_secretkeybytes();I.length!==r&&y(g,"invalid privateKey length"),t=c(I),g.push(t);var n=new o(A.length+wI._crypto_sign_bytes()|0),Q=n.address;if(g.push(Q),0==(0|wI._crypto_sign(Q,null,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function TA(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"privateKey");var t,r=0|wI._crypto_sign_secretkeybytes();I.length!==r&&y(g,"invalid privateKey length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_sign_bytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_sign_detached(Q,null,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function VA(A,I){var e=[];C(I),A=_(e,A,"edPk");var g,i=0|wI._crypto_sign_publickeybytes();A.length!==i&&y(e,"invalid edPk length"),g=c(A),e.push(g);var B=new o(0|wI._crypto_scalarmult_scalarbytes()),t=B.address;if(e.push(t),0==(0|wI._crypto_sign_ed25519_pk_to_curve25519(t,g))){var r=a(B,I);return s(e),r}h(e,"invalid key")}function qA(A,I){var e=[];C(I),A=_(e,A,"edSk");var g,i=0|wI._crypto_sign_secretkeybytes();A.length!==i&&y(e,"invalid edSk length"),g=c(A),e.push(g);var B=new o(0|wI._crypto_scalarmult_scalarbytes()),t=B.address;if(e.push(t),0==(0|wI._crypto_sign_ed25519_sk_to_curve25519(t,g))){var r=a(B,I);return s(e),r}h(e,"invalid key")}function jA(A,I){var e=[];C(I),A=_(e,A,"privateKey");var g,i=0|wI._crypto_sign_secretkeybytes();A.length!==i&&y(e,"invalid privateKey length"),g=c(A),e.push(g);var B=new o(0|wI._crypto_sign_publickeybytes()),t=B.address;if(e.push(t),0==(0|wI._crypto_sign_ed25519_sk_to_pk(t,g))){var r=a(B,I);return s(e),r}h(e,"invalid key")}function ZA(A,I){var e=[];C(I),A=_(e,A,"privateKey");var g,i=0|wI._crypto_sign_secretkeybytes();A.length!==i&&y(e,"invalid privateKey length"),g=c(A),e.push(g);var B=new o(0|wI._crypto_sign_seedbytes()),t=B.address;if(e.push(t),0==(0|wI._crypto_sign_ed25519_sk_to_seed(t,g))){var r=a(B,I);return s(e),r}h(e,"invalid key")}function WA(A,I,e){var g=[];C(e),f(g,A,"state_address"),I=_(g,I,"privateKey");var i,B=0|wI._crypto_sign_secretkeybytes();I.length!==B&&y(g,"invalid privateKey length"),i=c(I),g.push(i);var t=new o(0|wI._crypto_sign_bytes()),r=t.address;if(g.push(r),0==(0|wI._crypto_sign_final_create(A,r,null,i))){var n=(wI._free(A),a(t,e));return s(g),n}h(g,"invalid usage")}function zA(A,I,e,g){var i=[];C(g),f(i,A,"state_address"),I=_(i,I,"signature");var B,t=0|wI._crypto_sign_bytes();I.length!==t&&y(i,"invalid signature length"),B=c(I),i.push(B),e=_(i,e,"publicKey");var r,a=0|wI._crypto_sign_publickeybytes();e.length!==a&&y(i,"invalid publicKey length"),r=c(e),i.push(r);var n=0==(0|wI._crypto_sign_final_verify(A,B,r));return s(i),n}function OA(A){var I=[];C(A);var e=new o(208).address;if(0==(0|wI._crypto_sign_init(e))){var g=e;return s(I),g}h(I,"internal error")}function $A(A){var I=[];C(A);var e=new o(0|wI._crypto_sign_publickeybytes()),g=e.address;I.push(g);var i=new o(0|wI._crypto_sign_secretkeybytes()),B=i.address;if(I.push(B),0==(0|wI._crypto_sign_keypair(g,B))){var t={publicKey:a(e,A),privateKey:a(i,A),keyType:"ed25519"};return s(I),t}h(I,"internal error")}function AI(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"signedMessage")),B=A.length;g.push(i),I=_(g,I,"publicKey");var t,r=0|wI._crypto_sign_publickeybytes();I.length!==r&&y(g,"invalid publicKey length"),t=c(I),g.push(t);var n=new o(B-wI._crypto_sign_bytes()|0),Q=n.address;if(g.push(Q),0==(0|wI._crypto_sign_open(Q,null,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"incorrect signature for the given public key")}function II(A,I){var e=[];C(I),A=_(e,A,"seed");var g,i=0|wI._crypto_sign_seedbytes();A.length!==i&&y(e,"invalid seed length"),g=c(A),e.push(g);var B=new o(0|wI._crypto_sign_publickeybytes()),t=B.address;e.push(t);var r=new o(0|wI._crypto_sign_secretkeybytes()),n=r.address;if(e.push(n),0==(0|wI._crypto_sign_seed_keypair(t,n,g))){var Q={publicKey:a(B,I),privateKey:a(r,I),keyType:"ed25519"};return s(e),Q}h(e,"invalid usage")}function eI(A,I,e){var g=[];C(e),f(g,A,"state_address");var i=c(I=_(g,I,"message_chunk")),B=I.length;g.push(i),0!=(0|wI._crypto_sign_update(A,i,B))&&h(g,"invalid usage"),s(g)}function gI(A,I,e){var g=[];A=_(g,A,"signature");var i,B=0|wI._crypto_sign_bytes();A.length!==B&&y(g,"invalid signature length"),i=c(A),g.push(i);var t=c(I=_(g,I,"message")),r=I.length;g.push(t),e=_(g,e,"publicKey");var a,n=0|wI._crypto_sign_publickeybytes();e.length!==n&&y(g,"invalid publicKey length"),a=c(e),g.push(a);var C=0==(0|wI._crypto_sign_verify_detached(i,t,r,0,a));return s(g),C}function iI(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"input_message")),t=A.length;i.push(B),I=_(i,I,"nonce");var r,n=0|wI._crypto_stream_chacha20_ietf_noncebytes();I.length!==n&&y(i,"invalid nonce length"),r=c(I),i.push(r),e=_(i,e,"key");var Q,E=0|wI._crypto_stream_chacha20_ietf_keybytes();e.length!==E&&y(i,"invalid key length"),Q=c(e),i.push(Q);var f=new o(0|t),p=f.address;if(i.push(p),0===wI._crypto_stream_chacha20_ietf_xor(p,B,t,0,r,Q)){var w=a(f,g);return s(i),w}h(i,"invalid usage")}function BI(A,I,e,g,i){var B=[];C(i);var t=c(A=_(B,A,"input_message")),r=A.length;B.push(t),I=_(B,I,"nonce");var n,Q=0|wI._crypto_stream_chacha20_ietf_noncebytes();I.length!==Q&&y(B,"invalid nonce length"),n=c(I),B.push(n),f(B,e,"nonce_increment"),("number"!=typeof e||(0|e)!==e||e<0)&&y(B,"nonce_increment must be an unsigned integer"),g=_(B,g,"key");var E,p=0|wI._crypto_stream_chacha20_ietf_keybytes();g.length!==p&&y(B,"invalid key length"),E=c(g),B.push(E);var w=new o(0|r),l=w.address;if(B.push(l),0===wI._crypto_stream_chacha20_ietf_xor_ic(l,t,r,0,n,e,0,E)){var u=a(w,i);return s(B),u}h(B,"invalid usage")}function tI(A){var I=[];C(A);var e=new o(0|wI._crypto_stream_chacha20_keybytes()),g=e.address;I.push(g),wI._crypto_stream_chacha20_keygen(g);var i=a(e,A);return s(I),i}function rI(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"input_message")),t=A.length;i.push(B),I=_(i,I,"nonce");var r,n=0|wI._crypto_stream_chacha20_noncebytes();I.length!==n&&y(i,"invalid nonce length"),r=c(I),i.push(r),e=_(i,e,"key");var Q,E=0|wI._crypto_stream_chacha20_keybytes();e.length!==E&&y(i,"invalid key length"),Q=c(e),i.push(Q);var f=new o(0|t),p=f.address;if(i.push(p),0===wI._crypto_stream_chacha20_xor(p,B,t,0,r,Q)){var w=a(f,g);return s(i),w}h(i,"invalid usage")}function aI(A,I,e,g,i){var B=[];C(i);var t=c(A=_(B,A,"input_message")),r=A.length;B.push(t),I=_(B,I,"nonce");var n,Q=0|wI._crypto_stream_chacha20_noncebytes();I.length!==Q&&y(B,"invalid nonce length"),n=c(I),B.push(n),f(B,e,"nonce_increment"),("number"!=typeof e||(0|e)!==e||e<0)&&y(B,"nonce_increment must be an unsigned integer"),g=_(B,g,"key");var E,p=0|wI._crypto_stream_chacha20_keybytes();g.length!==p&&y(B,"invalid key length"),E=c(g),B.push(E);var w=new o(0|r),l=w.address;if(B.push(l),0===wI._crypto_stream_chacha20_xor_ic(l,t,r,0,n,e,0,E)){var u=a(w,i);return s(B),u}h(B,"invalid usage")}function nI(A){var I=[];C(A);var e=new o(0|wI._crypto_stream_keybytes()),g=e.address;I.push(g),wI._crypto_stream_keygen(g);var i=a(e,A);return s(I),i}function CI(A){var I=[];C(A);var e=new o(0|wI._crypto_stream_xchacha20_keybytes()),g=e.address;I.push(g),wI._crypto_stream_xchacha20_keygen(g);var i=a(e,A);return s(I),i}function oI(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"input_message")),t=A.length;i.push(B),I=_(i,I,"nonce");var r,n=0|wI._crypto_stream_xchacha20_noncebytes();I.length!==n&&y(i,"invalid nonce length"),r=c(I),i.push(r),e=_(i,e,"key");var Q,E=0|wI._crypto_stream_xchacha20_keybytes();e.length!==E&&y(i,"invalid key length"),Q=c(e),i.push(Q);var f=new o(0|t),p=f.address;if(i.push(p),0===wI._crypto_stream_xchacha20_xor(p,B,t,0,r,Q)){var w=a(f,g);return s(i),w}h(i,"invalid usage")}function cI(A,I,e,g,i){var B=[];C(i);var t=c(A=_(B,A,"input_message")),r=A.length;B.push(t),I=_(B,I,"nonce");var n,Q=0|wI._crypto_stream_xchacha20_noncebytes();I.length!==Q&&y(B,"invalid nonce length"),n=c(I),B.push(n),f(B,e,"nonce_increment"),("number"!=typeof e||(0|e)!==e||e<0)&&y(B,"nonce_increment must be an unsigned integer"),g=_(B,g,"key");var E,p=0|wI._crypto_stream_xchacha20_keybytes();g.length!==p&&y(B,"invalid key length"),E=c(g),B.push(E);var w=new o(0|r),l=w.address;if(B.push(l),0===wI._crypto_stream_xchacha20_xor_ic(l,t,r,0,n,e,0,E)){var u=a(w,i);return s(B),u}h(B,"invalid usage")}function QI(A,I){var e=[];C(I),f(e,A,"length"),("number"!=typeof A||(0|A)!==A||A<0)&&y(e,"length must be an unsigned integer");var g=new o(0|A),i=g.address;e.push(i),wI._randombytes_buf(i,A);var B=a(g,I);return s(e),B}function EI(A,I,e){var g=[];C(e),f(g,A,"length"),("number"!=typeof A||(0|A)!==A||A<0)&&y(g,"length must be an unsigned integer"),I=_(g,I,"seed");var i,B=0|wI._randombytes_seedbytes();I.length!==B&&y(g,"invalid seed length"),i=c(I),g.push(i);var t=new o(0|A),r=t.address;g.push(r),wI._randombytes_buf_deterministic(r,A,0,I);var n=a(t,e);return s(g),n}function sI(A){C(A),wI._randombytes_close()}function hI(A){C(A);var I=wI._randombytes_random()>>>0;return s([]),I}function yI(A,I){var e=[];C(I);for(var g=wI._malloc(24),i=0;i<6;i++)wI.setValue(g+4*i,wI.Runtime.addFunction(A[["implementation_name","random","stir","uniform","buf","close"][i]]),"i32");0!=(0|wI._randombytes_set_implementation(g))&&h(e,"unsupported implementation"),s(e)}function fI(A){C(A),wI._randombytes_stir()}function _I(A,I){var e=[];C(I),f(e,A,"upper_bound"),("number"!=typeof A||(0|A)!==A||A<0)&&y(e,"upper_bound must be an unsigned integer");var g=wI._randombytes_uniform(A)>>>0;return s(e),g}function pI(){var A=wI._sodium_version_string(),I=wI.Pointer_stringify(A);return s([]),I}var wI,lI="uint8array",uI=I.ready.then(function(){if(0!==(wI=I)._sodium_init())throw new Error("libsodium was not correctly initialized.");for(var e=["crypto_aead_chacha20poly1305_decrypt","crypto_aead_chacha20poly1305_decrypt_detached","crypto_aead_chacha20poly1305_encrypt","crypto_aead_chacha20poly1305_encrypt_detached","crypto_aead_chacha20poly1305_ietf_decrypt","crypto_aead_chacha20poly1305_ietf_decrypt_detached","crypto_aead_chacha20poly1305_ietf_encrypt","crypto_aead_chacha20poly1305_ietf_encrypt_detached","crypto_aead_chacha20poly1305_ietf_keygen","crypto_aead_chacha20poly1305_keygen","crypto_aead_xchacha20poly1305_ietf_decrypt","crypto_aead_xchacha20poly1305_ietf_decrypt_detached","crypto_aead_xchacha20poly1305_ietf_encrypt","crypto_aead_xchacha20poly1305_ietf_encrypt_detached","crypto_aead_xchacha20poly1305_ietf_keygen","crypto_auth","crypto_auth_hmacsha256","crypto_auth_hmacsha256_keygen","crypto_auth_hmacsha256_verify","crypto_auth_hmacsha512","crypto_auth_hmacsha512_keygen","crypto_auth_hmacsha512_verify","crypto_auth_keygen","crypto_auth_verify","crypto_box_beforenm","crypto_box_detached","crypto_box_easy","crypto_box_easy_afternm","crypto_box_keypair","crypto_box_open_detached","crypto_box_open_easy","crypto_box_open_easy_afternm","crypto_box_seal","crypto_box_seal_open","crypto_box_seed_keypair","crypto_generichash","crypto_generichash_final","crypto_generichash_init","crypto_generichash_keygen","crypto_generichash_update","crypto_hash","crypto_hash_sha256","crypto_hash_sha512","crypto_kdf_derive_from_key","crypto_kdf_keygen","crypto_kx_client_session_keys","crypto_kx_keypair","crypto_kx_seed_keypair","crypto_kx_server_session_keys","crypto_onetimeauth","crypto_onetimeauth_final","crypto_onetimeauth_init","crypto_onetimeauth_keygen","crypto_onetimeauth_update","crypto_onetimeauth_verify","crypto_pwhash","crypto_pwhash_scryptsalsa208sha256","crypto_pwhash_scryptsalsa208sha256_ll","crypto_pwhash_scryptsalsa208sha256_str","crypto_pwhash_scryptsalsa208sha256_str_verify","crypto_pwhash_str","crypto_pwhash_str_verify","crypto_scalarmult","crypto_scalarmult_base","crypto_secretbox_detached","crypto_secretbox_easy","crypto_secretbox_keygen","crypto_secretbox_open_detached","crypto_secretbox_open_easy","crypto_secretstream_xchacha20poly1305_init_pull","crypto_secretstream_xchacha20poly1305_init_push","crypto_secretstream_xchacha20poly1305_keygen","crypto_secretstream_xchacha20poly1305_pull","crypto_secretstream_xchacha20poly1305_push","crypto_secretstream_xchacha20poly1305_rekey","crypto_shorthash","crypto_shorthash_keygen","crypto_shorthash_siphashx24","crypto_sign","crypto_sign_detached","crypto_sign_ed25519_pk_to_curve25519","crypto_sign_ed25519_sk_to_curve25519","crypto_sign_ed25519_sk_to_pk","crypto_sign_ed25519_sk_to_seed","crypto_sign_final_create","crypto_sign_final_verify","crypto_sign_init","crypto_sign_keypair","crypto_sign_open","crypto_sign_seed_keypair","crypto_sign_update","crypto_sign_verify_detached","crypto_stream_chacha20_ietf_xor","crypto_stream_chacha20_ietf_xor_ic","crypto_stream_chacha20_keygen","crypto_stream_chacha20_xor","crypto_stream_chacha20_xor_ic","crypto_stream_keygen","crypto_stream_xchacha20_keygen","crypto_stream_xchacha20_xor","crypto_stream_xchacha20_xor_ic","randombytes_buf","randombytes_buf_deterministic","randombytes_close","randombytes_random","randombytes_set_implementation","randombytes_stir","randombytes_uniform","sodium_version_string"],g=[p,w,l,u,d,D,v,b,k,G,F,m,M,H,Y,S,R,N,U,J,P,L,x,X,K,T,V,q,j,Z,W,z,O,$,AA,IA,eA,gA,iA,BA,tA,rA,aA,nA,CA,oA,cA,QA,EA,sA,hA,yA,fA,_A,pA,wA,lA,uA,dA,DA,vA,bA,kA,GA,FA,mA,MA,HA,YA,SA,RA,NA,UA,JA,PA,LA,xA,XA,KA,TA,VA,qA,jA,ZA,WA,zA,OA,$A,AI,II,eI,gI,iI,BI,tI,rI,aI,nI,CI,oI,cI,QI,EI,sI,hI,yI,fI,_I,pI],i=0;i<g.length;i++)"function"==typeof wI["_"+e[i]]&&(A[e[i]]=g[i]);for(var B=["SODIUM_LIBRARY_VERSION_MAJOR","SODIUM_LIBRARY_VERSION_MINOR","crypto_aead_chacha20poly1305_ABYTES","crypto_aead_chacha20poly1305_KEYBYTES","crypto_aead_chacha20poly1305_MESSAGEBYTES_MAX","crypto_aead_chacha20poly1305_NPUBBYTES","crypto_aead_chacha20poly1305_NSECBYTES","crypto_aead_chacha20poly1305_ietf_ABYTES","crypto_aead_chacha20poly1305_ietf_KEYBYTES","crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX","crypto_aead_chacha20poly1305_ietf_NPUBBYTES","crypto_aead_chacha20poly1305_ietf_NSECBYTES","crypto_aead_xchacha20poly1305_ietf_ABYTES","crypto_aead_xchacha20poly1305_ietf_KEYBYTES","crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX","crypto_aead_xchacha20poly1305_ietf_NPUBBYTES","crypto_aead_xchacha20poly1305_ietf_NSECBYTES","crypto_auth_BYTES","crypto_auth_KEYBYTES","crypto_auth_hmacsha256_BYTES","crypto_auth_hmacsha256_KEYBYTES","crypto_auth_hmacsha512_BYTES","crypto_auth_hmacsha512_KEYBYTES","crypto_box_BEFORENMBYTES","crypto_box_MACBYTES","crypto_box_MESSAGEBYTES_MAX","crypto_box_NONCEBYTES","crypto_box_PUBLICKEYBYTES","crypto_box_SEALBYTES","crypto_box_SECRETKEYBYTES","crypto_box_SEEDBYTES","crypto_core_hchacha20_CONSTBYTES","crypto_core_hchacha20_INPUTBYTES","crypto_core_hchacha20_KEYBYTES","crypto_core_hchacha20_OUTPUTBYTES","crypto_generichash_BYTES","crypto_generichash_BYTES_MAX","crypto_generichash_BYTES_MIN","crypto_generichash_KEYBYTES","crypto_generichash_KEYBYTES_MAX","crypto_generichash_KEYBYTES_MIN","crypto_hash_BYTES","crypto_hash_sha256_BYTES","crypto_hash_sha512_BYTES","crypto_kdf_BYTES_MAX","crypto_kdf_BYTES_MIN","crypto_kdf_CONTEXTBYTES","crypto_kdf_KEYBYTES","crypto_kx_PUBLICKEYBYTES","crypto_kx_SECRETKEYBYTES","crypto_kx_SEEDBYTES","crypto_kx_SESSIONKEYBYTES","crypto_onetimeauth_BYTES","crypto_onetimeauth_KEYBYTES","crypto_pwhash_ALG_ARGON2I13","crypto_pwhash_ALG_ARGON2ID13","crypto_pwhash_ALG_DEFAULT","crypto_pwhash_BYTES_MAX","crypto_pwhash_BYTES_MIN","crypto_pwhash_MEMLIMIT_INTERACTIVE","crypto_pwhash_MEMLIMIT_MAX","crypto_pwhash_MEMLIMIT_MIN","crypto_pwhash_MEMLIMIT_MODERATE","crypto_pwhash_MEMLIMIT_SENSITIVE","crypto_pwhash_OPSLIMIT_INTERACTIVE","crypto_pwhash_OPSLIMIT_MAX","crypto_pwhash_OPSLIMIT_MIN","crypto_pwhash_OPSLIMIT_MODERATE","crypto_pwhash_OPSLIMIT_SENSITIVE","crypto_pwhash_PASSWD_MAX","crypto_pwhash_PASSWD_MIN","crypto_pwhash_SALTBYTES","crypto_pwhash_STRBYTES","crypto_pwhash_STR_VERIFY","crypto_pwhash_scryptsalsa208sha256_BYTES_MAX","crypto_pwhash_scryptsalsa208sha256_BYTES_MIN","crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE","crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX","crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN","crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE","crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE","crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX","crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN","crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE","crypto_pwhash_scryptsalsa208sha256_SALTBYTES","crypto_pwhash_scryptsalsa208sha256_STRBYTES","crypto_pwhash_scryptsalsa208sha256_STR_VERIFY","crypto_scalarmult_BYTES","crypto_scalarmult_SCALARBYTES","crypto_secretbox_KEYBYTES","crypto_secretbox_MACBYTES","crypto_secretbox_MESSAGEBYTES_MAX","crypto_secretbox_NONCEBYTES","crypto_secretstream_xchacha20poly1305_ABYTES","crypto_secretstream_xchacha20poly1305_HEADERBYTES","crypto_secretstream_xchacha20poly1305_KEYBYTES","crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX","crypto_secretstream_xchacha20poly1305_MESSAGESBYTES_MAX","crypto_secretstream_xchacha20poly1305_NPUBBYTES","crypto_secretstream_xchacha20poly1305_TAG_FINAL","crypto_secretstream_xchacha20poly1305_TAG_MESSAGE","crypto_secretstream_xchacha20poly1305_TAG_PUSH","crypto_secretstream_xchacha20poly1305_TAG_REKEY","crypto_shorthash_BYTES","crypto_shorthash_KEYBYTES","crypto_shorthash_siphashx24_BYTES","crypto_shorthash_siphashx24_KEYBYTES","crypto_sign_BYTES","crypto_sign_MESSAGEBYTES_MAX","crypto_sign_PUBLICKEYBYTES","crypto_sign_SECRETKEYBYTES","crypto_sign_SEEDBYTES","crypto_stream_KEYBYTES","crypto_stream_MESSAGEBYTES_MAX","crypto_stream_NONCEBYTES","crypto_stream_chacha20_KEYBYTES","crypto_stream_chacha20_NONCEBYTES","crypto_stream_chacha20_ietf_KEYBYTES","crypto_stream_chacha20_ietf_MESSAGEBYTES_MAX","crypto_stream_chacha20_ietf_NONCEBYTES","crypto_stream_xchacha20_KEYBYTES","crypto_stream_xchacha20_MESSAGEBYTES_MAX","crypto_stream_xchacha20_NONCEBYTES","randombytes_SEEDBYTES"],i=0;i<B.length;i++)"function"==typeof(r=wI["_"+B[i].toLowerCase()])&&(A[B[i]]=r());for(var t=["SODIUM_VERSION_STRING","crypto_pwhash_STRPREFIX","crypto_pwhash_scryptsalsa208sha256_STRPREFIX"],i=0;i<t.length;i++){var r=wI["_"+t[i].toLowerCase()];"function"==typeof r&&(A[t[i]]=wI.Pointer_stringify(r()))}}),dI={ORIGINAL:1,ORIGINAL_NO_PADDING:3,URLSAFE:5,URLSAFE_NO_PADDING:7};return o.prototype.to_Uint8Array=function(){var A=new Uint8Array(this.length);return A.set(wI.HEAPU8.subarray(this.address,this.address+this.length)),A},A.add=function(A,I){if(!(A instanceof Uint8Array&&I instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can added");var e=A.length,g=0,i=0;if(I.length!=A.length)throw new TypeError("Arguments must have the same length");for(i=0;i<e;i++)g>>=8,g+=A[i]+I[e],A[i]=255&g},A.base64_variants=dI,A.compare=function(A,I){if(!(A instanceof Uint8Array&&I instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be compared");if(A.length!==I.length)throw new TypeError("Only instances of identical length can be compared");for(var e=0,g=1,i=A.length;i-- >0;)e|=I[i]-A[i]>>8&g,g&=(I[i]^A[i])-1>>8;return e+e+g-1},A.from_base64=function(A,I){I=B(I);var e,g=[],i=new o(3*(A=_(g,A,"input")).length/4),t=c(A),r=Q(4),a=Q(4);return g.push(t),g.push(i.address),g.push(i.result_bin_len_p),g.push(i.b64_end_p),0!==wI._sodium_base642bin(i.address,i.length,t,A.length,0,r,a,I)&&h(g,"invalid input"),wI.getValue(a,"i32")-t!==A.length&&h(g,"incomplete input"),i.length=wI.getValue(r,"i32"),e=i.to_Uint8Array(),s(g),e},A.from_hex=function(A){var I,e=[],g=new o((A=_(e,A,"input")).length/2),i=c(A),B=Q(4);return e.push(i),e.push(g.address),e.push(g.hex_end_p),0!==wI._sodium_hex2bin(g.address,g.length,i,A.length,0,0,B)&&h(e,"invalid input"),wI.getValue(B,"i32")-i!==A.length&&h(e,"incomplete input"),I=g.to_Uint8Array(),s(e),I},A.from_string=e,A.increment=function(A){if(!(A instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be incremented");for(var I=256,e=0,g=A.length;e<g;e++)I>>=8,I+=A[e],A[e]=255&I},A.is_zero=function(A){if(!(A instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be checked");for(var I=0,e=0,g=A.length;e<g;e++)I|=A[e];return 0===I},A.libsodium=I,A.memcmp=function(A,I){if(!(A instanceof Uint8Array&&I instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be compared");if(A.length!==I.length)throw new TypeError("Only instances of identical length can be compared");for(var e=0,g=0,i=A.length;g<i;g++)e|=A[g]^I[g];return 0===e},A.memzero=function(A){if(!(A instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be wiped");for(var I=0,e=A.length;I<e;I++)A[I]=0},A.output_formats=r,A.pad=function(A,I){if(!(A instanceof Uint8Array))throw new TypeError("buffer must be a Uint8Array");if((I|=0)<=0)throw new Error("block size must be > 0");var e,g=[],i=Q(4),B=1,t=0,r=0|A.length,a=new o(r+I);g.push(i),g.push(a.address);for(var n=a.address,C=a.address+r+I;n<C;n++)wI.HEAPU8[n]=A[t],t+=B=1&~((65535&((r-=B)>>>48|r>>>32|r>>>16|r))-1>>16);return 0!==wI._sodium_pad(i,a.address,A.length,I,a.length)&&h(g,"internal error"),a.length=wI.getValue(i,"i32"),e=a.to_Uint8Array(),s(g),e},A.unpad=function(A,I){if(!(A instanceof Uint8Array))throw new TypeError("buffer must be a Uint8Array");if((I|=0)<=0)throw new Error("block size must be > 0");var e=[],g=c(A),i=Q(4);return e.push(g),e.push(i),0!==wI._sodium_unpad(i,g,A.length,I)&&h(e,"unsupported/invalid padding"),A=new Uint8Array(A),A=A.subarray(0,wI.getValue(i,"i32")),s(e),A},A.ready=uI,A.symbols=function(){return Object.keys(A).sort()},A.to_base64=t,A.to_hex=i,A.to_string=g,A}var e="object"==typeof A.sodium&&"function"==typeof A.sodium.onload?A.sodium.onload:null;"function"==typeof define&&define.amd?define(["exports","libsodium"],I):"object"==typeof exports&&"string"!=typeof exports.nodeName?I(exports,require("libsodium")):A.sodium=I(A.commonJsStrict={},A.libsodium),e&&A.sodium.ready.then(function(){e(A.sodium)})}(this);

/**
 * The exposed API from jiff-client.js (The client side library of JIFF).
 * Wraps the jiff API. Internal members can be accessed with jiff.&lt;member-name&gt;.
 * @namespace jiff
 * @version 1.0
 */
(function (exports, node) {
  var crypto_, io_, sodium_;
  if (node) {
    io_ = require('socket.io-client');
    sodium_ = require('libsodium-wrappers');

    crypto_ = require('crypto');
    crypto_.__randomBytesWrapper = crypto_.randomBytes;
  } else { // Browser: sodium (and other dependencies) should be available in global scope from including sodium.js
    io_ = window.io;
    sodium_ = window.sodium;

    crypto_ = window.crypto || window.msCrypto;
    crypto_.__randomBytesWrapper = function (bytesNeeded) {
      var randomBytes = new Uint8Array(bytesNeeded);
      crypto_.getRandomValues(randomBytes);
      return randomBytes;
    };
  }

  /**
   * Provides the needed dependencies in case where they are not global variable (e.g. using AMD define)
   * @memberof jiff
   * @function dependencies
   * @param {object} dependencies - contains any of these two attributes: "io", "sodium"
   *                                unprovided dependencies will be expected to exist as global variables
   *                                in the browser, or are fetched using require() in node.
   */
  exports.dependencies = function (dependencies) {
    io_ = dependencies['io'] != null ? dependencies['io'] : io_;
    sodium_ = dependencies['sodium'] != null ? dependencies['sodium'] : sodium_;
  };

  /**
   * The default mod to be used in a jiff instance if a custom mod was not provided.
   */
  var gZp = 15485867;

  /** Return the maximum of two numbers */
  function max(x, y) {
    return x > y ? x : y;
  }

  /**
   * Check that an integer is prime. Used to safely set the modulus Zp.
   * @memberof jiff.utils
   * @param {number} p - the prime number candidate.
   * @returns {boolean} true if p is prime, false otherwise.
   */
  function is_prime(p) {
    // AKS Primality Test

    if (p === 2) {
      return true;
    } else if (p === 3) {
      return true;
    } else if (p % 2 === 0) {
      return false;
    } else if (p % 3 === 0) {
      return false;
    }

    var i = 5;
    var n = 2;
    while (i * i <= p) {
      if (p % i === 0) {
        return false;
      }
      i += n;
      n = 6 - n;
    }

    return true;
  }

  /** Doubly linked list with add and remove functions and pointers to head and tail **/
  var linked_list = function () {
    // attributes: list.head and list.tail
    // functions: list.add(object) (returns pointer), list.remove(pointer)
    // list.head/list.tail/any element contains:
    //    next: pointer to next,
    //    previous: pointer to previous,
    //    object: stored object.
    var list = {head: null, tail: null};
    list.add = function (obj) {
      var node = { object: obj, next: null, previous: null };
      if (list.head == null) {
        list.head = node;
        list.tail = node;
      } else {
        list.tail.next = node;
        node.previous = list.tail;
        list.tail = node;
      }
      return node;
    };
    list.remove = function (ptr) {
      var prev = ptr.previous;
      var next = ptr.next;

      if (prev == null && list.head !== ptr) {
        return;
      } else if (next == null && list.tail !== ptr) {
        return;
      }

      if (prev == null) { // ptr is head (or both head and tail)
        list.head = next;
        if (list.head != null) {
          list.head.previous = null;
        } else {
          list.tail = null;
        }
      } else if (next == null) { // ptr is tail (and not head)
        list.tail = prev;
        prev.next = null;
      } else { // ptr is inside
        prev.next = next;
        next.previous = prev;
      }
    };
    return list;
  };

  /**
   * Encrypts and signs the given message.
   * @memberof jiff.utils
   * @param {number/string} message - the message to encrypt.
   * @param {Uint8Array} encryption_public_key - ascii-armored public key to encrypt with.
   * @param {Uint8Array} signing_private_key - the private key of the encrypting party to sign with.
   * @returns {object} the signed cipher, includes two properties: 'cipher' and 'nonce'.
   */
  function encrypt_and_sign(jiff, message, encryption_public_key, signing_private_key) {
    var nonce = sodium_.randombytes_buf(sodium_.crypto_box_NONCEBYTES);
    var cipher = sodium_.crypto_box_easy(message, nonce, encryption_public_key, signing_private_key);

    var result = { nonce: '[' + nonce.toString() + ']', cipher: '[' + cipher.toString() + ']' };
    return result;
  }

  /**
   * Decrypts and checks the signature of the given cipher text.
   * @memberof jiff.utils
   * @param {object} cipher_text - the cipher text to decrypt, includes two properties: 'cipher' and 'nonce'.
   * @param {Uint8Array} decryption_secret_key - the secret key to decrypt with.
   * @param {Uint8Array} signing_public_key - ascii-armored public key to verify against signature.
   * @returns {number/string} the decrypted message if the signature was correct, the decrypted message type should
   *                          the type of operation, such that the returned value has the appropriate type and does
   *                          not need any type modifications.
   * @throws error if signature or nonce was forged/incorrect.
   */
  function decrypt_and_sign(jiff, cipher_text, decryption_secret_key, signing_public_key) {
    var nonce = new Uint8Array(JSON.parse(cipher_text.nonce));
    cipher_text = new Uint8Array(JSON.parse(cipher_text.cipher));

    try {
      return sodium_.crypto_box_open_easy(cipher_text, nonce, signing_public_key, decryption_secret_key, 'text');
    } catch (_) {
      throw new Error('Bad signature or Bad nonce: Cipher: ' + cipher_text + '.  DecSKey: ' + decryption_secret_key + '.  SignPKey: ' + signing_public_key);
    }
  }

  /**
   * Create an array of secret shares and associated deferred.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {number} count - number of secret shares.
   * @param {Array} holders - the parties that hold all the corresponding shares (must be sorted).
   * @param {number} threshold - the min number of parties needed to reconstruct the secret.
   * @param {number} Zp - the mod under which this share was created.
   * @return {object} the secret share object containing the give value.
   *
   */
  function many_secret_shares(jiff, count, holders, threshold, Zp) {
    var deferreds = [];
    var shares = [];
    for (var i = 0; i < count; i++) {
      var deferred = new jiff.helpers.Deferred;
      shares.push(jiff.secret_share(jiff, false, deferred.promise, undefined, holders, threshold, Zp));
      deferreds.push(deferred);
    }

    return { shares: shares, deferreds: deferreds };
  }

  /**
   * Resolve the array of deferreds with the values of the given shares when ready, matched by index.
   * @param {Deferred[]} deferreds - the deferred to resolve.
   * @param {SecretShare[]} shares - the shares to resolve with.
   */
  function resolve_many_secrets(deferreds, shares) {
    for (var i = 0; i < deferreds.length; i++) {
      shares[i].wThen(deferreds[i].resolve);
    }
  }

  /**
   * A high level combinator for iteration of bit arrays.
   * It executes a round of (func) starting from index 0 to the length.
   * Every round is blocked until the previous one finishes and the promise produced by it
   * is resolved.
   * The final value is used to resolve deferred.
   */
  function bit_combinator(deferred, start, length, initial, func, promisify, valufy) {
    if (promisify == null) {
      promisify = function (share) {
        return { then: share.wThen };
      }
    }

    if (valufy == null) {
      valufy = function (share) {
        return share.value;
      }
    }

    var next = start <= length ? 1 : -1;
    var __bit_combinator = function (start, val) {
      if (start === length) {
        // done
        deferred.resolve(valufy(val));
        return;
      }

      // execute func once
      val = func(start, val);

      // when done, do next iteration
      promisify(val).then(function () {
        __bit_combinator(start + next, val);
      });
    };

    // start combinator
    if (initial == null) {
      __bit_combinator(start, initial);
    } else {
      promisify(initial).then(function () {
        __bit_combinator(start, initial);
      });
    }
  }

  /**
   * Share given secret to the participating parties.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {number} secret - the secret to share.
   * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
   * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
   * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
   * @param {number} [Zp=jiff.Zp] - the mod (if null then the default Zp for the instance is used).
   * @param {string|number} [share_id=auto_gen()] - the tag used to tag the messages sent by this share operation, this tag is used
   *                                   so that parties distinguish messages belonging to this share operation from other
   *                                   share operations between the same parties (when the order of execution is not
   *                                   deterministic). An automatic id is generated by increasing a local counter, default
   *                                   ids suffice when all parties execute all sharing operations with the same senders
   *                                   and receivers in the same order.
   * @returns {object} a map where the key is the sender party id
   *          and the value is the share object that wraps
   *          what was sent from that party (the internal value maybe deferred).
   *          if the party that calls this function is not a receiver then the map
   *          will be empty.
   */
  function jiff_share(jiff, secret, threshold, receivers_list, senders_list, Zp, share_id) {
    var i, p_id;

    // defaults
    if (Zp == null) {
      Zp = jiff.Zp;
    }
    if (receivers_list == null) {
      receivers_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        receivers_list.push(i);
      }
    }
    if (senders_list == null) {
      senders_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        senders_list.push(i);
      }
    }
    if (threshold == null) {
      threshold = receivers_list.length;
    }
    if (threshold < 0) {
      threshold = 2;
    }
    if (threshold > receivers_list.length) {
      threshold = receivers_list.length;
    }

    // if party is uninvolved in the share, do nothing
    if (receivers_list.indexOf(jiff.id) === -1 && senders_list.indexOf(jiff.id) === -1) {
      return {};
    }

    // compute operation id
    if (share_id == null) {
      share_id = jiff.counters.gen_op_id2('share', receivers_list, senders_list);
    }

    // stage sending of shares
    if (senders_list.indexOf(jiff.id) > -1) {
      // Call hook
      secret = jiff.execute_array_hooks('beforeShare', [jiff, secret, threshold, receivers_list, senders_list, Zp], 1);

      // compute shares
      var shares = jiff.hooks.computeShares(jiff, secret, receivers_list, threshold, Zp);

      // Call hook
      shares = jiff.execute_array_hooks('afterComputeShare', [jiff, shares, threshold, receivers_list, senders_list, Zp], 1);

      // send shares
      for (i = 0; i < receivers_list.length; i++) {
        p_id = receivers_list[i];
        if (p_id === jiff.id) {
          continue;
        }

        // send encrypted and signed shares_id[p_id] to party p_id
        var msg = { party_id: p_id, share: shares[p_id], op_id: share_id };
        msg = jiff.execute_array_hooks('beforeOperation', [jiff, 'share', msg], 2);

        msg['share'] = jiff.hooks.encryptSign(jiff, msg['share'].toString(10), jiff.keymap[msg['party_id']], jiff.secret_key);
        jiff.socket.safe_emit('share', JSON.stringify(msg));
      }
    }

    // stage receiving of shares
    var result = {};
    if (receivers_list.indexOf(jiff.id) > -1) {
      // setup a map of deferred for every received share
      if (jiff.deferreds[share_id] == null) {
        jiff.deferreds[share_id] = {};
      }

      var _remaining = senders_list.length;
      for (i = 0; i < senders_list.length; i++) {
        p_id = senders_list[i];
        if (p_id === jiff.id) { // Keep party's own share
          var my_share = jiff.execute_array_hooks('receiveShare', [jiff, p_id, shares[p_id]], 2);
          result[p_id] = jiff.secret_share(jiff, true, null, my_share, receivers_list, threshold, Zp);
          _remaining--;
          continue;
        }

        // check if a deferred is set up (maybe the message was previously received)
        if (jiff.deferreds[share_id][p_id] == null) { // not ready, setup a deferred
          jiff.deferreds[share_id][p_id] = new jiff.helpers.Deferred;
        }

        var promise = jiff.deferreds[share_id][p_id].promise;
        // destroy deferred when done
        (function (promise, p_id) { // p_id is modified in a for loop, must do this to avoid scoping issues.
          promise.then(function () {
            delete jiff.deferreds[share_id][p_id];
            _remaining--;
            if (_remaining === 0) {
              delete jiff.deferreds[share_id];
            }
          });
        })(promise, p_id);

        // receive share_i[id] from party p_id
        result[p_id] = jiff.secret_share(jiff, false, promise, undefined, receivers_list, threshold, Zp);
      }
    }

    return result;
  }

  /**
   * Default way of computing shares (can be overridden using hooks).
   * Compute the shares of the secret (as many shares as parties) using Shamir secret sharing
   * @memberof jiff.sharing_schemes
   * @method shamir_share
   * @param {jiff-instance} jiff - the jiff instance
   * @param {number} secret - the secret to share.
   * @param {Array} parties_list - array of party ids to share with.
   * @param {number} threshold - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
   * @param {number} Zp - the mod.
   * @returns {object} a map between party number and its share, this means that (party number, share) is a
   *          point from the polynomial.
   *
   */
  function jiff_compute_shares(jiff, secret, parties_list, threshold, Zp) {
    var shares = {}; // Keeps the shares
    var i;

    // Each player's random polynomial f must have
    // degree threshold - 1, so that threshold many points are needed
    // to interpolate/reconstruct.
    var t = threshold - 1;
    var polynomial = Array(t + 1); // stores the coefficients

    // Each players's random polynomial f must be constructed
    // such that f(0) = secret
    polynomial[0] = secret;

    // Compute the random polynomial f's coefficients
    for (i = 1; i <= t; i++) {
      polynomial[i] = jiff.helpers.random(Zp);
    }

    // Compute each players share such that share[i] = f(i)
    for (i = 0; i < parties_list.length; i++) {
      var p_id = parties_list[i];
      shares[p_id] = polynomial[0];
      var power = jiff.helpers.get_party_number(p_id);

      for (var j = 1; j < polynomial.length; j++) {
        var tmp = jiff.helpers.mod((polynomial[j] * power), Zp);
        shares[p_id] = jiff.helpers.mod((shares[p_id] + tmp), Zp);
        power = jiff.helpers.mod(power * jiff.helpers.get_party_number(p_id), Zp);
      }
    }

    return shares;
  }

  /**
   * Store the received share and resolves the corresponding
   * deferred if needed.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {object} json_msg - the parsed json message as received.
   *
   */
  function receive_share(jiff, json_msg) {
    // Decrypt share
    json_msg['share'] = jiff.hooks.decryptSign(jiff, json_msg['share'], jiff.secret_key, jiff.keymap[json_msg['party_id']]);
    json_msg = jiff.execute_array_hooks('afterOperation', [jiff, 'share', json_msg], 2);

    var sender_id = json_msg['party_id'];
    var op_id = json_msg['op_id'];
    var share = json_msg['share'];

    // Call hook
    share = jiff.execute_array_hooks('receiveShare', [jiff, sender_id, share], 2);

    // check if a deferred is set up (maybe the share was received early)
    if (jiff.deferreds[op_id] == null) {
      jiff.deferreds[op_id] = {};
    }
    if (jiff.deferreds[op_id][sender_id] == null) {
      // Share is received before deferred was setup, store it.
      jiff.deferreds[op_id][sender_id] = new jiff.helpers.Deferred;
    }

    // Deferred is already setup, resolve it.
    jiff.deferreds[op_id][sender_id].resolve(share);
  }

  /**
   * Open up the given share to the participating parties.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {SecretShare} share - the share of the secret to open that belongs to this party.
   * @param {Array<number|string>} [parties=all_parties] - an array with party ids of receiving parties.
   * @param {string|number} [op_id=auto_gen()] - the operation id to be used to tag outgoing messages.
   * @returns {promise} a (JQuery) promise to the open value of the secret, null if the calling party is not a receiving party.
   * @throws error if share does not belong to the passed jiff instance.
   *
   */
  function jiff_open(jiff, share, parties, op_id) {
    var i;

    if (!(share.jiff === jiff)) {
      throw 'share does not belong to given instance';
    }

    // Default values
    if (parties == null || parties === []) {
      parties = [];
      for (i = 1; i <= jiff.party_count; i++) {
        parties.push(i);
      }
    }

    // If not a receiver nor holder, do nothing
    if (share.holders.indexOf(jiff.id) === -1 && parties.indexOf(jiff.id) === -1) {
      return null;
    }

    // Compute operation ids (one for each party that will receive a result
    if (op_id == null) {
      op_id = jiff.counters.gen_op_id2('open', parties, share.holders);
    }

    // Party is a holder
    if (share.holders.indexOf(jiff.id) > -1) {
      // Call hook
      share = jiff.execute_array_hooks('beforeOpen', [jiff, share, parties], 1);

      // refresh/reshare, so that the original share remains secret, instead
      // a new share is sent/open without changing the actual value.
      share = share.refresh(op_id + ':refresh');

      // The given share has been computed, broadcast it to all parties
      jiff.counters.pending_opens++;
      share.wThen(function () {
        jiff_broadcast(jiff, share, parties, op_id);
        jiff.counters.pending_opens--;
      }, share.error);
    }

    // Party is a receiver
    if (parties.indexOf(jiff.id) > -1) {
      var final_deferred = new jiff.helpers.Deferred; // will be resolved when the final value is reconstructed
      var final_promise = final_deferred.promise;

      if (jiff.deferreds[op_id] == null) {
        jiff.deferreds[op_id] = {};
      }

      jiff.deferreds[op_id].deferred = final_deferred;
      jiff.deferreds[op_id].threshold = share.threshold;
      jiff.deferreds[op_id].total = share.holders.length;
      if (jiff.deferreds[op_id].shares != null && jiff.deferreds[op_id].shares.length >= share.threshold) {
        final_deferred.resolve();
      }

      return final_promise.then(function () {
        var shares = jiff.deferreds[op_id].shares;

        if (shares.length === jiff.deferreds[op_id].total) {
          delete jiff.deferreds[op_id];
        } else {
          jiff.deferreds[op_id].deferred = 'CLEAN';
        }

        var recons_secret = jiff.hooks.reconstructShare(jiff, shares);
        recons_secret = jiff.execute_array_hooks('afterReconstructShare', [jiff, recons_secret], 1);
        return recons_secret;
      });
    }

    return null;
  }

  /**
   * Share the given share to all the parties in the jiff instance.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {SecretShare} share - the share.
   * @param {Array} parties - the parties to broadcast the share to.
   * @param {number|string} op_id - a unique operation id, used to tag outgoing messages.
   *
   */
  function jiff_broadcast(jiff, share, parties, op_id) {
    for (var index = 0; index < parties.length; index++) {
      var i = parties[index]; // Party id
      if (i === jiff.id) {
        receive_open(jiff, { party_id: i, share: share.value, op_id: op_id, Zp: share.Zp });
        continue;
      }

      // encrypt, sign and send
      var msg = {party_id: i, share: share.value, op_id: op_id, Zp: share.Zp};
      msg = jiff.execute_array_hooks('beforeOperation', [jiff, 'open', msg], 2);

      msg['share'] = jiff.hooks.encryptSign(jiff, msg['share'].toString(), jiff.keymap[msg['party_id']], jiff.secret_key);
      jiff.socket.safe_emit('open', JSON.stringify(msg));
    }
  }

  /**
   * Resolves the deferred corresponding to operation_id and sender_id.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {object} json_msg - the json message as received with the open event.
   *
   */
  function receive_open(jiff, json_msg) {
    // Decrypt share
    if (json_msg['party_id'] !== jiff.id) {
      json_msg['share'] = jiff.hooks.decryptSign(jiff, json_msg['share'], jiff.secret_key, jiff.keymap[json_msg['party_id']]);
      json_msg = jiff.execute_array_hooks('afterOperation', [jiff, 'open', json_msg], 2);
    }

    var sender_id = json_msg['party_id'];
    var op_id = json_msg['op_id'];
    var share = json_msg['share'];
    var Zp = json_msg['Zp'];

    // call hook
    share = jiff.execute_array_hooks('receiveOpen', [jiff, sender_id, share, Zp], 2);

    // Ensure deferred is setup
    if (jiff.deferreds[op_id] == null) {
      jiff.deferreds[op_id] = {};
    }
    if (jiff.deferreds[op_id].shares == null) {
      jiff.deferreds[op_id].shares = [];
    }

    // Accumulate received shares
    jiff.deferreds[op_id].shares.push({value: share, sender_id: sender_id, Zp: Zp});

    // Resolve when ready
    if (jiff.deferreds[op_id].shares.length === jiff.deferreds[op_id].threshold) {
      jiff.deferreds[op_id].deferred.resolve();
    }

    // Clean up if done
    if (jiff.deferreds[op_id] != null && jiff.deferreds[op_id].deferred === 'CLEAN' && jiff.deferreds[op_id].shares.length === jiff.deferreds[op_id].total) {
      delete jiff.deferreds[op_id];
    }
  }

  /**
   * Uses Lagrange polynomials to interpolate the polynomial
   * described by the given shares (points).
   * @memberof jiff.sharing_schemes
   * @method shamir_reconstruct
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {Array} shares - an array of objects representing shares to reconstruct, every object has 3 attributes: value, sender_id, Zp.
   * @returns {number} the value of the polynomial at x=0 (the secret value).
   *
   */
  function jiff_lagrange(jiff, shares) {
    var lagrange_coeff = []; // will contain shares.length many elements.

    // Compute the Langrange coefficients at 0.
    for (var i = 0; i < shares.length; i++) {
      var pi = jiff.helpers.get_party_number(shares[i].sender_id);
      lagrange_coeff[pi] = 1;

      for (var j = 0; j < shares.length; j++) {
        var pj = jiff.helpers.get_party_number(shares[j].sender_id);
        if (pj !== pi) {
          var inv = jiff.helpers.extended_gcd(pi - pj, shares[i].Zp)[0];
          lagrange_coeff[pi] = jiff.helpers.mod(lagrange_coeff[pi] * (0 - pj), shares[i].Zp) * inv;
          lagrange_coeff[pi] = jiff.helpers.mod(lagrange_coeff[pi], shares[i].Zp);
        }
      }
    }

    // Reconstruct the secret via Lagrange interpolation
    var recons_secret = 0;
    for (var p = 0; p < shares.length; p++) {
      var party = jiff.helpers.get_party_number(shares[p].sender_id);
      var tmp = jiff.helpers.mod((shares[p].value * lagrange_coeff[party]), shares[p].Zp);
      recons_secret = jiff.helpers.mod((recons_secret + tmp), shares[p].Zp);
    }

    return recons_secret;
  }

  /**
   * Requests secret(s) from the server (crypto provider) of type matching the given label.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {string} label - the type of secret(s) being requested from crypto_provider (e.g. triplet, bit, etc)
   * @param {Array} [receivers_list=all_parties] - array of party ids that want to receive the secret(s), by default, this includes all parties.
   * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret(s).
   * @param {number} [Zp=jiff_instance.Zp] - the mod, defaults to the Zp of the instance.
   * @param {string} [op_id=auto_Gen()] - an id which is used to identify the secret requested, so that every party
   *                              gets a share from the same secret for every matching instruction. An automatic id
   *                              is generated by increasing a local counter per label, default ids suffice when all
   *                              parties execute all instructions in the same order.
   * @param {object} [params={}] - any additional parameters specific to the label, these are defined by the label handler at the server side.
   *                               some of these parameters may be optional, while others may be required.
   * @returns {promise} a promise to the secret(s) provided by the server/crypto provider, the promise returns an object with the given format:
   *                               { values: <any values returned by the server side>, shares: <array of secret share objects matching shares returned by server by index>}
   */
  function from_crypto_provider(jiff, label, receivers_list, threshold, Zp, op_id, params) {
    // defaults
    if (Zp == null) {
      Zp = jiff.Zp;
    }
    if (receivers_list == null) {
      receivers_list = [];
      for (var i = 1; i <= jiff.party_count; i++) {
        receivers_list.push(i);
      }
    }
    if (threshold == null) {
      threshold = receivers_list.length;
    }
    if (op_id == null) {
      op_id = jiff.counters.gen_op_id('crypto_provider:' + label, receivers_list);
    }
    if (params == null) {
      params = {};
    }

    // Send a request to the server
    var msg = { label: label, op_id: op_id, receivers: receivers_list, threshold: threshold, Zp: Zp, params: params };
    msg = jiff.execute_array_hooks('beforeOperation', [jiff, 'crypto_provider', msg], 2);
    msg = JSON.stringify(msg);

    // Setup deferred to handle receiving the result later.
    jiff.deferreds[op_id] = new jiff.helpers.Deferred;
    var result = jiff.deferreds[op_id].promise;

    // send a request to the server.
    jiff.socket.safe_emit('crypto_provider', msg);
    return result;
  }

  /**
   * Parse server response and resolve associated promise.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {object} json_msg - the parsed json message as received by the crypto_provider event, contains 'values' and 'shares' attributes.
   *
   */
  function receive_crypto_provider(jiff, json_msg) {
    // Hook
    json_msg = jiff.execute_array_hooks('afterOperation', [jiff, 'crypto_provider', json_msg], 2);

    var op_id = json_msg['op_id'];
    if (jiff.deferreds[op_id] == null) {
      return;
    }

    // parse msg
    var receivers_list = json_msg['receivers'];
    var threshold = json_msg['threshold'];
    var Zp = json_msg['Zp'];

    // construct secret share objects
    var result = {};
    if (json_msg['values'] != null) {
      result.values = json_msg['values'];
    }
    if (json_msg['shares'] != null) {
      result.shares = [];
      for (var i = 0; i < json_msg['shares'].length; i++) {
        result.shares.push(jiff.secret_share(jiff, true, null, json_msg['shares'][i], receivers_list, threshold, Zp));
      }
    }

    // resolve deferred
    jiff.deferreds[op_id].resolve(result);
    delete jiff.deferreds[op_id];
  }

  /**
   * Can be used to generate shares of a random number, or shares of zero.
   * For a random number, every party generates a local random number and secret share it,
   * then every party sums its share, resulting in a single share of an unknown random number for every party.
   * The same approach is followed for zero, but instead, all the parties know that the total number is zero, but they
   * do not know the value of any resulting share (except their own).
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {number} n - the number to share.
   * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
   * @param {Array} [receivers_list=all_parties] - array of party ids to receive the result, by default, this includes all parties.
   * @param {Array} [compute_list=all_parties] - array of party ids to perform the protocol, by default, this includes all parties.
   * @param {number} [Zp=jiff.Zp] - the mod.
   * @param {object} [params={}] - an object containing extra parameters passed by the user.
   *                                 Expects:
   *                               - op_id: the base id to use for operation during the execution of this protocol, defaults to auto generated.
   *                               - compute_threshold: the threshold to use during computation: defaults to compute_list.length
   * @return {Object} contains 'share' (this party's share of the result) and 'promise'.
   */
  function jiff_share_all_number(jiff, n, threshold, receivers_list, compute_list, Zp, params) {
    var isSender = compute_list.indexOf(jiff.id) > -1;
    var isReceiver = receivers_list.indexOf(jiff.id) > -1;

    if (!isSender && !isReceiver) {
      return {};
    }

    if (params.compute_threshold == null) {
      params.compute_threshold = Math.min(threshold, compute_list.length);
    }

    var result, promise;
    if (isSender) {
      var shares = jiff.internal_share(n, params.compute_threshold, compute_list, compute_list, Zp, params.op_id + ':share');
      result = shares[compute_list[0]];
      for (var i = 1; i < compute_list.length; i++) {
        result = result.isadd(shares[compute_list[i]]);
      }
      promise = result.promise;
    }

    result = jiff.protocols.reshare(result, threshold, receivers_list, compute_list, Zp, params.op_id + ':reshare');
    if (receivers_list.indexOf(jiff.id) > -1) {
      promise = result.promise;
    }

    return {share: result, promise: promise};
  }

  /**
   * Share an array of values. Each sender may have an array of different length. This is handled by the lengths parameter.
   * This function will reveal the lengths of the shared array.
   * If parties would like to keep the lengths of their arrays secret, they should agree on some "max" length apriori (either under MPC
   * or as part of the logistics of the computation), all their arrays should be padded to that length by using appropriate default/identity
   * values.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {Array} array - the array to be shared.
   * @param {null|number|object} lengths - the lengths of the arrays to be shared, has the following options:
   *                                       1. null: lengths are unknown, each sender will publicly reveal the lengths of its own array.
   *                                       2. number: all arrays are of this length
   *                                       3. object: { <sender_party_id>: length }: must specify the length of the array for each sender.
   * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
   * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
   * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
   * @param {number} [Zp=jiff.Zp] - the mod.
   * @param {string|number} [share_id=auto_gen()] - the base tag used to tag the messages sent by this share operation, every element of the array
   *                                   will get a unique id based on the concatenation of base_share_id and the index of the element.
   *                                   This tag is used so that parties distinguish messages belonging to this share operation from
   *                                   other share operations between the same parties (when the order of execution is not
   *                                   deterministic). An automatic id is generated by increasing a local counter, default
   *                                   ids suffice when all parties execute all sharing operations with the same senders
   *                                   and receivers in the same order.
   * @return {promise} if the calling party is a receiver then a promise to the shared arrays is returned, the promise will provide an object
   *                    formatted as follows: { <party_id>: [ <1st_share>, <2nd_share>, ..., <(lengths[party_id])th_share> ] }
   *                    where the party_ids are those of the senders.
   *                    if the calling party is not a receiver, then null is returned.
   */
  function jiff_share_array(jiff, array, lengths, threshold, receivers_list, senders_list, Zp, share_id) {
    var i;

    // Check format of lengths
    if (lengths != null && typeof(lengths) !== 'number' && typeof(lengths) !== 'object') {
      throw new Error('share_array: unrecognized lengths');
    }

    // Default values
    if (receivers_list == null) {
      receivers_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        receivers_list.push(i);
      }
    }
    if (senders_list == null) {
      senders_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        senders_list.push(i);
      }
    }

    var isReceiving = receivers_list.indexOf(jiff.id) > -1;
    if (senders_list.indexOf(jiff.id) === -1 && !isReceiving) {
      return null;
    } // This party is neither a sender nor a receiver, do nothing!

    // compute operation id
    if (share_id == null) {
      share_id = jiff.counters.gen_op_id2('share_array', receivers_list, senders_list);
    }

    // wrap around result of share_array
    var share_array_deferred = new jiff.helpers.Deferred;
    var share_array_promise = share_array_deferred.promise;

    // figure out lengths by having each party emit their length publicly
    if (lengths == null) {
      lengths = {};
      var total = 0;
      if (senders_list.indexOf(jiff.id) > -1) {
        lengths[jiff.id] = array.length;

        // send the length of this party's array to all receivers
        jiff.emit(share_id + 'length', receivers_list, array.length.toString(10));
      }

      jiff.listen(share_id + 'length', function (sender, message) {
        lengths[sender] = parseInt(message, 10);
        total++;
        if (total === senders_list.length) {
          jiff.remove_listener(share_id + 'length');
          share_array_deferred.resolve(lengths);
        }
      });
    } else if (typeof(lengths) === 'number') {
      // All arrays are of the same length
      var l = lengths;
      lengths = {};
      for (i = 0; i < senders_list.length; i++) {
        lengths[senders_list[i]] = l;
      }

      share_array_deferred.resolve(lengths);
    } else {
      // Lengths of the different arrays are all provided
      for (i = 0; i < senders_list.length; i++) {
        if (lengths[senders_list[i]] == null) {
          throw new Error('share_array: missing length');
        }
      }

      share_array_deferred.resolve(lengths);
    }

    // lengths are now set, start sharing
    share_array_promise = share_array_promise.then(function (lengths) {
      // compute the number of sharing rounds
      var max = 0;
      for (i = 0; i < senders_list.length; i++) {
        var l = lengths[senders_list[i]];
        max = l > max ? l : max;
      }

      // Store results here
      var results = {};
      if (isReceiving) {
        for (i = 0; i < senders_list.length; i++) {
          results[senders_list[i]] = [];
        }
      }

      // share every round
      for (var r = 0; r < max; r++) {
        var round_senders = [];
        for (i = 0; i < senders_list.length; i++) {
          if (lengths[senders_list[i]] > r) {
            round_senders.push(senders_list[i]);
          }
        }

        var value = (senders_list.indexOf(jiff.id) > -1) && (r < array.length) ? array[r] : null;
        var round_results = jiff.share(value, threshold, receivers_list, round_senders, Zp, share_id + 'round:' + r);

        for (var sender_id in round_results) {
          if (round_results.hasOwnProperty(sender_id)) {
            results[sender_id].push(round_results[sender_id]);
          }
        }
      }

      return results;
    });

    return isReceiving ? share_array_promise : null;
  }

  /**
   * Share an array of values. Each sender may have an array of different length. This is handled by the lengths parameter.
   * This function will reveal the lengths of the shared array.
   * If parties would like to keep the lengths of their arrays secret, they should agree on some "max" length apriori (either under MPC
   * or as part of the logistics of the computation), all their arrays should be padded to that length by using appropriate default/identity
   * values.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {Array} array - the array to be shared.
   * @param {null|number|object} lengths - the lengths of the arrays to be shared. For this to work successfully, the
   *                                       same exact value must be used in the calling code for each party. Any missing
   *                                       lengths for a row will be automatically publicly revealed by this function.
   *                                       Must have the following format:
   *                                       1. null: lengths are unknown, each sender will publicly reveal the lengths of its own array.
   *                                       2. { rows: <number>, cols: <number>, 0: <number>, 1: <number>, ...}: all parties have arrays
   *                                          with the given number of rows and cols. In case of jagged 2D arrays, different rows
   *                                          can have a different number of cols specified by using <row_index>: <col_size>.
   *                                          rows is mandatory, cols and any other number matching a specific row are optional.
   *                                       3. { <sender_party_id>: <length_object> }: must specify the lengths for each party by using
   *                                          an object with the same format as 2. Must include every party.
   * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
   * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
   * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
   * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
   * @param {string|number} [share_id=auto_gen()] - the base tag used to tag the messages sent by this share operation, every element of the array
   *                                   will get a unique id based on the concatenation of base_share_id and the index of the element.
   *                                   This tag is used so that parties distinguish messages belonging to this share operation from
   *                                   other share operations between the same parties (when the order of execution is not
   *                                   deterministic). An automatic id is generated by increasing a local counter, default
   *                                   ids suffice when all parties execute all sharing operations with the same senders
   *                                   and receivers in the same order.
   * @returns {promise} if the calling party is a receiver then a promise to the shared arrays is returned, the promise will provide an object
   *                    formatted as follows: { <party_id>: [ [ <1st_row_shares> ], [<2nd_row_share> ], ..., [ <(lengths[party_id])th_row_shares> ] ] }
   *                    where the party_ids are those of the senders.
   *                    if the calling party is not a receiver, then null is returned.
   */
  function jiff_share_2D_array(jiff, array, lengths, threshold, receivers_list, senders_list, Zp, share_id) {
    var i;

    // Check format of lengths
    if (lengths != null && typeof(lengths) !== 'object') {
      throw new Error('share_array: unrecognized lengths');
    }

    // Default values
    if (receivers_list == null) {
      receivers_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        receivers_list.push(i);
      }
    }
    if (senders_list == null) {
      senders_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        senders_list.push(i);
      }
    }

    var isReceiving = receivers_list.indexOf(jiff.id) > -1;
    if (senders_list.indexOf(jiff.id) === -1 && !isReceiving) {
      // This party is neither a sender nor a receiver, do nothing!
      return null;
    }

    // compute operation id
    if (share_id == null) {
      share_id = jiff.counters.gen_op_id2('share_2D_array', receivers_list, senders_list);
    }

    // wrap around result of share_array
    var lengths_deferred = new jiff.helpers.Deferred;
    var lengths_promise = lengths_deferred.promise;

    // figure out lengths by having each party emit their length publicly
    if (lengths == null) {
      lengths = {};
      var total = 0;
      if (senders_list.indexOf(jiff.id) > -1) {
        lengths[jiff.id] = array.length;

        // send the length of this party's array to all receivers
        jiff.emit(share_id + 'length', receivers_list, array.length.toString(10));
      }

      jiff.listen(share_id + 'length', function (sender, message) {
        lengths[sender] = { rows: parseInt(message, 10) };
        total++;
        if (total === senders_list.length) {
          jiff.remove_listener(share_id + 'length');
          lengths_deferred.resolve(lengths);
        }
      });
    } else if (typeof(lengths.rows) === 'number') {
      // All arrays are of the same length
      var l = lengths;
      lengths = {};
      for (i = 0; i < senders_list.length; i++) {
        lengths[senders_list[i]] = l;
      }

      lengths_deferred.resolve(lengths);
    } else {
      // Lengths of the different arrays are all provided
      for (i = 0; i < senders_list.length; i++) {
        if (lengths[senders_list[i]] == null || lengths[senders_list[i]].rows == null) {
          throw new Error('share_2D_array: missing rows length');
        }
      }

      lengths_deferred.resolve(lengths);
    }

    // Final results
    var share_array_deferred = new jiff.helpers.Deferred;
    var share_array_promise = share_array_deferred.promise;

    // lengths are now set, start sharing
    lengths_promise.then(function (lengths) {
      // compute the number of sharing rounds
      var max = 0;
      for (i = 0; i < senders_list.length; i++) {
        var l = lengths[senders_list[i]].rows;
        max = l > max ? l : max;
      }

      // share every round
      var promises = [];
      for (var r = 0; r < max; r++) {
        var round_senders = [];
        for (i = 0; i < senders_list.length; i++) {
          if (lengths[senders_list[i]].rows > r) {
            round_senders.push(senders_list[i]);
          }
        }

        var row_lengths = {};
        var empty = false;
        for (var p = 0; p < round_senders.length; p++) {
          var pid = round_senders[p];
          row_lengths[pid] = lengths[pid].cols;
          if (lengths[pid][r] != null) {
            row_lengths[pid] = lengths[pid][r];
          }
          if (row_lengths[pid] == null) {
            empty = true;
          }
        }

        var row = r < array.length ? array[r] : [];
        row_lengths = empty ? null : row_lengths;
        var round_results = jiff.share_array(row, row_lengths, threshold, receivers_list, round_senders, Zp, share_id + 'row' + r + ':');
        promises.push(round_results);
      }

      // Wait for every promises corresponding to every row
      return Promise.all(promises).then(function (intermediate_results) {
        // Store results here
        var results = {};
        if (isReceiving) {
          for (i = 0; i < senders_list.length; i++) {
            results[senders_list[i]] = [];
          }
        }

        for (i = 0; i < intermediate_results.length; i++) {
          var round = intermediate_results[i];
          for (var sender_id in round) {
            if (round.hasOwnProperty(sender_id)) {
              results[sender_id].push(round[sender_id]);
            }
          }
        }

        share_array_deferred.resolve(results);
      });
    });

    return isReceiving ? share_array_promise : null;
  }

  /**
   * Opens a bunch of secret shares.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {SecretShare[]} shares - an array containing this party's shares of the secrets to reconstruct.
   * @param {Array} [parties=all_parties] - an array with party ids (1 to n) of receiving parties.
   * @param {string|number} [op_id=auto_gen()] - same as jiff_instance.open
   * @returns {promise} a (JQuery) promise to ALL the open values of the secret, the promise will yield
   *                    an array of values matching the corresponding given secret share by index.
   * @throws error if some shares does not belong to the passed jiff instance.
   */
  function jiff_open_array(jiff, shares, parties, op_id) {
    // Default values
    if (parties == null || parties === []) {
      parties = [];
      for (i = 1; i <= jiff.party_count; i++) {
        parties.push(i);
      }
    }

    // Compute operation ids (one for each party that will receive a result
    if (op_id == null) {
      op_id = jiff.counters.gen_op_id2('open_array', parties, shares[0].holders);
    }

    var promises = [];
    for (var i = 0; i < shares.length; i++) {
      var promise = jiff.open(shares[i], parties, op_id + ':' + i);
      if (promise != null) {
        promises.push(promise);
      }
    }

    if (promises.length === 0) {
      return null;
    }

    return Promise.all(promises);
  }

  /**
   * Called when this party receives a custom tag message from any party (including itself).
   * If a custom listener was setup to listen to the tag, the message is passed to the listener.
   * Otherwise, the message is stored until such a listener is provided.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {object} json_msg - the parsed json message as received by the custom event.
   *
   */
  function receive_custom(jiff, json_msg) {
    if (json_msg['encrypted'] === true) {
      json_msg['message'] = jiff.hooks.decryptSign(jiff, json_msg['message'], jiff.secret_key, jiff.keymap[json_msg['party_id']]);
    }

    if (json_msg['party_id'] !== jiff.id) {
      json_msg = jiff.execute_array_hooks('afterOperation', [jiff, 'custom', json_msg], 2);
    }

    var sender_id = json_msg['party_id'];
    var tag = json_msg['tag'];
    var message = json_msg['message'];

    if (jiff.listeners[tag] != null) {
      jiff.listeners[tag](sender_id, message);
    } else { // Store message until listener is provided
      var stored_messages = jiff.custom_messages_mailbox[tag];
      if (stored_messages == null) {
        stored_messages = [];
        jiff.custom_messages_mailbox[tag] = stored_messages;
      }

      stored_messages.push({sender_id: sender_id, message: message});
    }
  }

  /**
   * Secret share objects: provides API to perform operations on shares securly, wrap promises
   * and communication primitives to ensure operations are executed when shares are available (asynchronously)
   * without requiring the user to perform promise management/synchronization.
   * @namespace SecretShare
   */

  /**
   * Create a new share.
   * A share is a value wrapper with a share object, it has a unique id
   * (per computation instance), and a pointer to the instance it belongs to.
   * A share also has methods for performing operations.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {boolean} ready - whether the value of the share is ready or deferred.
   * @param {promise} promise - a promise to the value of the share.
   * @param {number} value - the value of the share (null if not ready).
   * @param {Array} holders - the parties that hold all the corresponding shares (must be sorted).
   * @param {number} threshold - the min number of parties needed to reconstruct the secret.
   * @param {number} Zp - the mod under which this share was created.
   * @return {SecretShare} the secret share object containing the give value.
   *
   */
  function secret_share(jiff, ready, promise, value, holders, threshold, Zp) {
    /**
     * Internal helpers for operations inside/on a share. This is not exposed to the external code,
     * except through the createSecretShare hook. Modify existing helpers or add more in your extensions
     * to avoid having to re-write and duplicate the code for primitives.
     */
    var share_helpers = {
      '+': function (v1, v2) {
        return v1 + v2;
      },
      '-': function (v1, v2) {
        return v1 - v2;
      },
      '*': function (v1, v2) {
        return v1 * v2;
      },
      '/': function (v1, v2) {
        return v1 / v2;
      },
      '<': function (v1, v2) {
        return v1 < v2;
      },
      '<=': function (v1, v2) {
        return v1 <= v2;
      },
      'floor': function (v) {
        return Math.floor(v);
      },
      'ceil': function (v) {
        return Math.ceil(v);
      },
      'floor/': function (v1, v2) {
        return Math.floor(v1 / v2);
      },
      'pow': function (v1, v2) {
        return Math.pow(v1, v2);
      },
      'binary': function (v) {
        return v === 1 || v === 0;
      },
      'abs': function (v) {
        return Math.abs(v);
      },
      '==': function (v1, v2) {
        return v1 === v2;
      }
    };

    var self = {};

    /**
     * @member {jiff-instance} jiff
     * @memberof SecretShare
     * @instance
     */
    self.jiff = jiff;

    /**
     * @member {boolean} ready
     * @memberof SecretShare
     * @instance
     */
    self.ready = ready;

    /**
     * @member {promise} promise
     * @memberof SecretShare
     * @instance
     */
    self.promise = promise;
    /**
     * @member {number} value
     * @memberof SecretShare
     * @instance
     */
    self.value = value;
    /**
     * @member {Array} holders
     * @memberof SecretShare
     * @instance
     */
    self.holders = holders;
    /**
     * @member {Array} threshold
     * @memberof SecretShare
     * @instance
     */
    self.threshold = threshold;
    /**
     * @member {number} Zp
     * @memberof SecretShare
     * @instance
     */
    self.Zp = Zp;

    /**
     * Gets the value of this share.
     * @method valueOf
     * @returns {number} the value (undefined if not ready yet).
     * @memberof SecretShare
     * @instance
     */
    self.valueOf = function () {
      if (ready) {
        return self.value;
      } else {
        return undefined;
      }
    };

    /**
     * Gets a string representation of this share.
     * @method toString
     * @returns {string} the id and value of the share as a string.
     * @memberof SecretShare
     * @instance
     */
    self.toString = function () {
      var val = self.ready ? self.value : '<deferred>';
      return 'share: ' + val + '. Holders: ' + JSON.stringify(self.holders) + '. Threshold: ' + self.threshold + '. Zp: ' + self.Zp.toString() + '.';
    };

    /**
     * Logs an error.
     * @method error
     * @memberof SecretShare
     * @instance
     */
    self.error = self.jiff.error.bind(null, 'secret-share');

    /**
     * Logs the value represented by this share to the console.
     * WARNING: THIS LEAKS INFORMATION AND MUST BE USED ONLY TO DEBUG ON FAKE DATA.
     * @method logLEAK
     * @memberof SecretShare
     * @instance
     * @param {string} tag - accompanying tag to display in the console.
     * @param {Array<number|string>} [parties=[holders[0]] - the parties which will display the log.
     * @return {promise} a promise to the value represented by this share after logging it, null if party is not in parties.
     */
    self.logLEAK = function (tag, parties) {
      if (parties == null) {
        parties = [self.holders[0]];
      }
      var promise = self.open(parties, tag);
      if (promise != null) {
        promise = promise.then(function (result) {
          console.log(tag, result.toString());
          return result;
        });
      }
      return promise;
    };

    /**
     * Receives the value of this share when ready.
     * @method receive_share
     * @param {number} value - the value of the share.
     * @memberof SecretShare
     * @instance
     */
    self.receive_share = function (value) {
      self.value = value;
      self.ready = true;
      self.promise = null;
    };

    /**
     * Joins the pending promises of this share and the given share.
     * @method pick_promise
     * @param {SecretShare} o - the other share object.
     * @returns {promise} the joined promise for both shares (or whichever is pending).
     * @memberof SecretShare
     * @instance
     */
    self.pick_promise = function (o) {
      if (self.ready && o.ready) {
        return null;
      }

      if (self.ready) {
        return o.promise;
      } else if (o.ready) {
        return self.promise;
      } else {
        return Promise.all([self.promise, o.promise]);
      }
    };

    /**
     * Checks if the given parameter is a constant, used to determine whether constant or secret
     * operations should be executed.
     * @param {number/object} o - the parameter to determine.
     * @return {boolean} true if o is a valid constant, false otherwise.
     */
    self.isConstant = function (o) {
      return typeof(o) === 'number';
    };

    /**
     * Reshares/refreshes the sharing of this number, used before opening to keep the share secret.
     * @method refresh
     * @param {string} [op_id=auto_gen()] - the operation id with which to tag the messages sent by this refresh, by default
     *                         an automatic operation id is generated by increasing a local counter, default operation ids
     *                         suffice when all parties execute the instructions in the same order.
     * @returns {SecretShare} a new share of the same number.
     * @memberof SecretShare
     * @instance
     */
    self.refresh = function (op_id) {
      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('refresh', self.holders);
      }

      // final result
      var final_deferred = new self.jiff.helpers.Deferred;
      var final_promise = final_deferred.promise;
      var result = self.jiff.secret_share(self.jiff, false, final_promise, undefined, self.holders, self.threshold, self.Zp);

      // refresh
      var ready_number = function (zero) {
        self.isadd(zero).wThen(final_deferred.resolve);
      };

      // get shares of zero
      var zero = self.jiff.get_preprocessing(op_id);
      if (zero == null) {
        var promise = self.jiff.from_crypto_provider('numbers', self.holders, self.threshold, self.Zp, op_id, {number: 0, count: 1});
        promise.then(function (msg) {
          ready_number(msg['shares'][0]);
        });
      } else {
        ready_number(zero);
      }

      return result;
    };

    /**
     * Shortcut for opening/revealing the value of this share. Alias for open in jiff-instance.
     * @see jiff-instance#open
     * @method open
     * @memberof SecretShare
     * @instance
     * @param {Array} [parties=all_parties] - an array with party ids (1 to n) of receiving parties.
     * @param {string|number|object} [op_id=auto_gen()] - same as jiff_instance.open
     * @returns {promise|null} a (JQuery) promise to the open value of the secret, null if the party is not specified in the parties array as a receiver.
     */
    self.open = function (parties, op_id) {
      return self.jiff.open(self, parties, op_id);
    };

    /**
     * Generic Addition.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method add
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     * @example
     * var shares = jiff_instance.share(input);
     * // this will add two secret shared values together
     * var result = shares[1].add(shares[2]);
     * // this will add 3 to the secret input from party 1
     * var constant_sum = shares[1].add(3);
     */
    self.add = function (o) {
      if (self.isConstant(o)) {
        return self.cadd(o);
      }
      return self.sadd(o);
    };


    /**
     * Generic Subtraction.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method sub
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.sub = function (o) {
      if (self.isConstant(o)) {
        return self.csub(o);
      }
      return self.ssub(o);
    };


    /**
     * Generic Multiplication.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method mult
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this multiplication (and internally, the corresponding beaver triplet).
     *                         This id must be unique, and must be passed by all parties to the same instruction.
     *                         this ensures that every party gets a share from the same triplet for every matching instruction. An automatic id
     *                         is generated by increasing a local counter, default ids suffice when all parties execute the
     *                         instructions in the same order. Only used if secret multiplication is used.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.mult = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.cmult(o);
      }
      return self.smult(o, op_id);
    };


    /**
     * Generic XOR for bits (both this and o have to be bits to work correctly).
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method xor_bit
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     *                         Only used if secret xor is used..
     * @return {SecretShare} this party's share of the result, the final result is 1 if this < o, and 0 otherwise.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.xor_bit = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.cxor_bit(o);
      }
      return self.sxor_bit(o, op_id);
    };

    /**
     * Generic OR for bits (both this and o have to be bits to work correctly).
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method or_bit
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     *                         Only used if secret or is used..
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.or_bit = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.cor_bit(o);
      }
      return self.sor_bit(o, op_id);
    };

    /**
     * Generic Greater or equal.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method gteq
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.gteq = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.cgteq(o, op_id);
      }
      return self.sgteq(o);
    };


    /**
     * Generic Greater than.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method gt
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.gt = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.cgt(o, op_id);
      }
      return self.sgt(o, op_id);
    };


    /**
     * Generic Less or equal.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method lteq
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.lteq = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.clteq(o, op_id);
      }
      return self.slteq(o, op_id);
    };


    /**
     * Generic Less than.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method lt
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.lt = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.clt(o, op_id);
      }
      return self.slt(o, op_id);
    };


    /**
     * Generic Equals.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method eq
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.eq = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.ceq(o, op_id);
      }
      return self.seq(o, op_id);
    };


    /**
     * Generic Not Equals.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method neq
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.neq = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.cneq(o, op_id);
      }
      return self.sneq(o, op_id);
    };


    /**
     * Generic Integer Divison.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method div
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {number} l - the maximum bit length of the two shares.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.div = function (o, l, op_id) {
      if (self.isConstant(o)) {
        return self.cdiv(o, l, op_id);
      }
      return self.sdiv(o, l, op_id);
    };

    /**
     * Addition with a constant.
     * @method cadd
     * @param {number} cst - the constant to add.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.cadd = function (cst) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (+)');
      }

      if (self.ready) {
        // if share is ready
        return self.jiff.secret_share(self.jiff, true, null, self.jiff.helpers.mod(share_helpers['+'](self.value, cst), self.Zp), self.holders, self.threshold, self.Zp);
      }

      var promise = self.promise.then(function () {
        return self.jiff.helpers.mod(share_helpers['+'](self.value, cst), self.Zp);
      }, self.error);
      return self.jiff.secret_share(self.jiff, false, promise, undefined, self.holders, self.threshold, self.Zp);
    };

    /**
     * Subtraction with a constant.
     * @method csub
     * @param {number} cst - the constant to subtract from this share.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.csub = function (cst) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (-)');
      }

      if (self.ready) {
        // if share is ready
        return self.jiff.secret_share(self.jiff, true, null, self.jiff.helpers.mod(share_helpers['-'](self.value, cst), self.Zp), self.holders, self.threshold, self.Zp);
      }

      var promise = self.promise.then(function () {
        return self.jiff.helpers.mod(share_helpers['-'](self.value, cst), self.Zp);
      }, self.error);
      return self.jiff.secret_share(self.jiff, false, promise, undefined, self.holders, self.threshold, self.Zp);
    };

    /**
     * Multiplication by a constant.
     * @method cmult
     * @param {number} cst - the constant to multiply to this share.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.cmult = function (cst) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (*)');
      }

      if (self.ready) {
        // if share is ready
        return self.jiff.secret_share(self.jiff, true, null, self.jiff.helpers.mod(share_helpers['*'](self.value, cst), self.Zp), self.holders, self.threshold, self.Zp);
      }

      var promise = self.promise.then(function () {
        return self.jiff.helpers.mod(share_helpers['*'](self.value, cst), self.Zp);
      }, self.error);
      return self.jiff.secret_share(self.jiff, false, promise, undefined, self.holders, self.threshold, self.Zp);
    };

    /**
     * Division by a constant factor of the number represented by the share.
     * @method cdivfac
     * @param {number} cst - the constant by which to divide the share.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.cdivfac = function (cst) {
      if (!(self.isConstant(cst))) {
        throw new Error('Parameter should be a number (cdivfac)');
      }

      var inv = self.jiff.helpers.extended_gcd(cst, self.Zp)[0];

      if (self.ready) {
        // If share is ready.
        return self.jiff.secret_share(self.jiff, true, null, self.jiff.helpers.mod(share_helpers['*'](self.value, inv), self.Zp), self.holders, self.threshold, self.Zp);
      }

      var promise = self.promise.then(function () {
        return self.jiff.helpers.mod(share_helpers['*'](self.value, inv), self.Zp);
      }, self.error);
      return self.jiff.secret_share(self.jiff, false, promise, undefined, self.holders, self.threshold, self.Zp);
    };

    /**
     * Addition of two secret shares.
     * @method sadd
     * @param {SecretShare} o - the share to add to this share.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     *
     * @example
     * // share a value with all parties, and sum the values of all shares
     * var shares = jiff_instance.share(x);
     * var sum = shares[1];
     * for (var i = 2; i <= jiff_instance.party_count; i++) {
     *  sum = sum.sadd(shares[i]);
     * }
     *
     */
    self.sadd = function (o) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (+)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (+)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (+)');
      }

      // add the two shares when ready locally
      var ready_add = function () {
        return self.jiff.helpers.mod(share_helpers['+'](self.value, o.value), self.Zp);
      };

      if (self.ready && o.ready) {
        // both shares are ready
        return self.jiff.secret_share(self.jiff, true, null, ready_add(), self.holders, max(self.threshold, o.threshold), self.Zp);
      }

      // promise to execute ready_add when both are ready
      var promise = self.pick_promise(o).then(ready_add, self.error);
      return self.jiff.secret_share(self.jiff, false, promise, undefined, self.holders, max(self.threshold, o.threshold), self.Zp);
    };

    /**
     * Subtraction of two secret shares.
     * @method ssub
     * @param {SecretShare} o - the share to subtract from this share.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.ssub = function (o) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (-)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (-)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (-)');
      }

      // add the two shares when ready locally
      var ready_sub = function () {
        return self.jiff.helpers.mod(share_helpers['-'](self.value, o.value), self.Zp);
      };

      if (self.ready && o.ready) {
        // both shares are ready
        return self.jiff.secret_share(self.jiff, true, null, ready_sub(), self.holders, max(self.threshold, o.threshold), self.Zp);
      }

      // promise to execute ready_add when both are ready
      var promise = self.pick_promise(o).then(ready_sub, self.error);
      return self.jiff.secret_share(self.jiff, false, promise, undefined, self.holders, max(self.threshold, o.threshold), self.Zp);
    };

    /**
     * Multiplication of two secret shares through Beaver Triplets.
     * @method smult
     * @param {SecretShare} o - the share to multiply with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this multiplication (and internally, the corresponding beaver triplet).
     *                         This id must be unique, and must be passed by all parties to the same instruction.
     *                         this ensures that every party gets a share from the same triplet for every matching instruction. An automatic id
     *                         is generated by increasing a local counter, default ids suffice when all parties execute the
     *                         instructions in the same order.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.smult = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (*)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (*)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (*)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('smult', self.holders);
      }

      // final result
      var final_deferred = new self.jiff.helpers.Deferred;
      var final_promise = final_deferred.promise;
      var result = self.jiff.secret_share(self.jiff, false, final_promise, undefined, self.holders, max(self.threshold, o.threshold), self.Zp);

      // called when triplet is ready
      var ready_triplet = function (triplet) {
        var a = triplet[0];
        var b = triplet[1];
        var c = triplet[2];

        // d = s - a. e = o - b.
        var d = self.isadd(a.icmult(-1));
        var e = o.isadd(b.icmult(-1));

        // Open d and e.
        // The only communication cost.
        var e_promise = self.jiff.internal_open(e, e.holders, op_id + ':open1');
        var d_promise = self.jiff.internal_open(d, d.holders, op_id + ':open2');
        Promise.all([e_promise, d_promise]).then(function (arr) {
          var e_open = arr[0];
          var d_open = arr[1];

          // result_share = d_open * e_open + d_open * b_share + e_open * a_share + c.
          var t1 = self.jiff.helpers.mod(share_helpers['*'](d_open, e_open), self.Zp);
          var t2 = b.icmult(d_open);
          var t3 = a.icmult(e_open);

          // All this happens locally.
          var final_result = t2.icadd(t1);
          final_result = final_result.isadd(t3);
          final_result = final_result.isadd(c);

          final_result.wThen(final_deferred.resolve);
        });
      };

      // Get shares of triplets.
      var triplet = self.jiff.get_preprocessing(op_id + ':triplet');
      if (triplet == null) {
        var promise = jiff.from_crypto_provider('triplet', self.holders, max(self.threshold, o.threshold), self.Zp, op_id + ':triplet');
        promise.then(function (msg) {
          ready_triplet(msg['shares']);
        });
      } else {
        ready_triplet(triplet);
      }

      return result;
    };

    /**
     * Multiplication of two secret shares through BGW protocol.
     * @method smult_bgw
     * @param {SecretShare} o - the share to multiply with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this multiplication (and internally, the corresponding beaver triplet).
     *                         This id must be unique, and must be passed by all parties to the same instruction.
     *                         this ensures that every party gets a share from the same triplet for every matching instruction. An automatic id
     *                         is generated by increasing a local counter, default ids suffice when all parties execute the
     *                         instructions in the same order.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.smult_bgw = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (bgw*)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (bgw*)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (bgw*)');
      }
      if ((self.threshold - 1) + (o.threshold - 1) > self.holders.length - 1) {
        throw new Error('threshold too high for BGW (*)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('smult_bgw', self.holders);
      }

      var new_threshold = (self.threshold - 1) + (o.threshold - 1) + 1;
      if (new_threshold > self.holders) {
        var errorMsg = 'Threshold too large for smult_bgw: ' + new_threshold;
        errorMsg += '. Shares: ' + self.toString() + ', ' + o.toString();
        throw new Error(errorMsg);
      }

      var final_deferred = new self.jiff.helpers.Deferred;
      var final_promise = final_deferred.promise;
      var result = self.jiff.secret_share(self.jiff, false, final_promise, undefined, self.holders, new_threshold, self.Zp);

      Promise.all([self.promise, o.promise]).then(
        function () {
          // Get Shares  of z
          var zi = self.jiff.helpers.mod(share_helpers['*'](self.value, o.value), self.Zp);
          final_deferred.resolve(zi);
        });

      return self.jiff.protocols.reshare(result, max(self.threshold, o.threshold), result.holders, result.holders, result.Zp, op_id + ':threshold');
    };

    /**
     * bitwise-XOR with a constant (BOTH BITS).
     * @method cxor_bit
     * @param {number} cst - the constant bit to XOR with (0 or 1).
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.cxor_bit = function (cst) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (^)');
      }
      if (!share_helpers['binary'](cst)) {
        throw new Error('parameter should be binary (^)');
      }

      return self.icadd(cst).issub(self.icmult(cst).icmult(2));
    };

    /**
     * bitwise-OR with a constant (BOTH BITS).
     * @method cor_bit
     * @param {number} cst - the constant bit to OR with (0 or 1).
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.cor_bit = function (cst) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (|)');
      }
      if (!share_helpers['binary'](cst)) {
        throw new Error('parameter should be binary (|)');
      }

      return self.icadd(cst).issub(self.icmult(cst));
    };

    /**
     * bitwise-XOR of two secret shares OF BITS.
     * @method sxor_bit
     * @param {SecretShare} o - the share to XOR with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this < o, and 0 otherwise.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.sxor_bit = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (^)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (^)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (^)');
      }
      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('sxor_bit', self.holders);
      }

      return self.isadd(o).issub(self.ismult(o, op_id + ':smult1').icmult(2));
    };

    /**
     * OR of two secret shares OF BITS.
     * @method sor_bit
     * @param {SecretShare} o - the share to OR with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this < o, and 0 otherwise.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.sor_bit = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (|)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (|)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (|)');
      }
      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('sor_bit', self.holders);
      }

      return self.isadd(o).issub(self.ismult(o, op_id + ':smult1'));
    };

    /**
     * Greater than or equal with another share.
     * @method sgteq
     * @param {SecretShare} o - the other share.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this >= o, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.sgteq = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (>=)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (>=)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (>=)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('sgteq',self.holders);
      }

      return self.islt(o, op_id).inot();
    };

    /**
     * Greater than with another share.
     * @method sgt
     * @param {SecretShare} o - the other share.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this > o, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.sgt = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (>)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (>)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (>)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('sgt', self.holders);
      }

      return o.islt(self, op_id);
    };

    /**
     * Less than or equal with another share.
     * @method slteq
     * @param {SecretShare} o - the other share.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this <= o, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.slteq = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (<=)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (<=)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (<=)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('slteq', self.holders);
      }

      return o.islt(self, op_id).inot();
    };

    /**
     * Less than with another share.
     * @method slt
     * @param {SecretShare} o - the other share.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this < o, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.slt = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (<)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (<)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (<)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('slt', self.holders);
      }

      var final_deferred = new self.jiff.helpers.Deferred;
      var final_promise = final_deferred.promise;
      var result = self.jiff.secret_share(self.jiff, false, final_promise, undefined, self.holders, max(self.threshold, o.threshold), self.Zp);

      var w = self.ilt_halfprime(op_id + ':halfprime:1');
      Promise.all([w.promise]).then(function () {
        var x = o.ilt_halfprime(op_id + ':halfprime:2');
        Promise.all([x.promise]).then(function () {
          var y = self.issub(o).ilt_halfprime(op_id + ':halfprime:3');
          Promise.all([y.promise]).then(function () {
            var xy = x.ismult(y, op_id + ':smult1');
            var answer = x.icmult(-1).icadd(1).issub(y).isadd(xy).isadd(w.ismult(x.isadd(y).issub(xy.icmult(2)), op_id + ':smult2'));
            answer.wThen(final_deferred.resolve);
          });
        });
      });

      return result;
    };

    /**
     * Greater than or equal with a constant.
     * @method cgteqn
     * @param {number} cst - the constant to compare with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this >= cst, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.cgteq = function (cst, op_id) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (>=)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('cgteq', self.holders);
      }

      return self.iclt(cst, op_id).inot();
    };

    /**
     * Greater than with a constant.
     * @method cgt
     * @param {number} cst - the constant to compare with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.default ids suffice when all parties execute the
     *                         instructions in the same order.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this > cst, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.cgt = function (cst, op_id) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (>)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('cgt', self.holders);
      }

      var final_deferred = new self.jiff.helpers.Deferred;
      var final_promise = final_deferred.promise;
      var result = self.jiff.secret_share(self.jiff, false, final_promise, undefined, self.holders, self.threshold, self.Zp);

      var w = share_helpers['<'](cst, share_helpers['/'](self.Zp, 2)) ? 1 : 0;
      var x = self.ilt_halfprime(op_id + ':halfprime:1');
      Promise.all([x.promise]).then(function () {
        var y = self.icmult(-1).icadd(cst).ilt_halfprime(op_id + ':halfprime:2');
        Promise.all([y.promise]).then(function () {
          var xy = y.ismult(x, op_id + ':smult1');
          var answer = x.icmult(-1).icadd(1).issub(y).isadd(xy).isadd(x.isadd(y).issub(xy.icmult(2)).icmult(w));
          answer.wThen(final_deferred.resolve);
        });
      });

      return result;
    };

    /**
     * Less than or equal with a constant.
     * @method clteq
     * @param {number} cst - the constant to compare with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this <= cst, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.clteq = function (cst, op_id) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (<=)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('clteq', self.holders);
      }

      return self.icgt(cst, op_id).inot();
    };

    /**
     * Less than with a constant.
     * @method clt
     * @param {number} cst - the constant to compare with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this < cst, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.clt = function (cst, op_id) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (<)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('clt', self.holders);
      }

      var final_deferred = new self.jiff.helpers.Deferred;
      var final_promise = final_deferred.promise;
      var result = self.jiff.secret_share(self.jiff, false, final_promise, undefined, self.holders, self.threshold, self.Zp);

      var w = self.ilt_halfprime(op_id + ':halfprime:1');
      Promise.all([w.promise]).then(function () {
        var x = share_helpers['<'](cst, share_helpers['/'](self.Zp, 2)) ? 1 : 0;
        var y = self.icsub(cst).ilt_halfprime(op_id + ':halfprime:2');
        Promise.all([y.promise]).then(function () {
          var xy = y.icmult(x);
          var answer = y.icmult(-1).icadd(1 - x).isadd(xy).isadd(w.ismult(y.icadd(x).issub(xy.icmult(2)), op_id + ':smult1'));
          answer.wThen(final_deferred.resolve);
        });
      });

      return result;
    };

    /**
     * Equality test with two shares.
     * @method seq
     * @param {SecretShare} o - the share to compare with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this = o, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.seq = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (==)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (==)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (==)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('seq', self.holders);
      }

      return self.issub(o).iclteq(0, op_id);
    };

    /**
     * Unequality test with two shares.
     * @method sneq
     * @param {SecretShare} o - the share to compare with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 0 if this = o, and 1 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.sneq = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (!=)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (!=)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (!=)');
      }
      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('sneq', self.holders);
      }
      return self.iseq(o, op_id).inot();
    };

    /**
     * Equality test with a constant.
     * @method ceq
     * @param {number} cst - the constant to compare with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 0 if this = o, and 1 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.ceq = function (cst, op_id) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (==)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('ceq', self.holders);
      }

      return self.icsub(cst).iclteq(0, op_id);
    };

    /**
     * Unequality test with a constant.
     * @method cneq
     * @param {number} cst - the constant to compare with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 0 if this = o, and 1 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.cneq = function (cst, op_id) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (!=)');
      }
      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('cneq', self.holders);
      }
      return self.iceq(cst, op_id).inot();
    };

    /**
     * Negation of a bit.
     * This has to be a share of a BIT in order for this to work properly.
     * @method not
     * @return {SecretShare} this party's share of the result (negated bit).
     * @memberof SecretShare
     * @instance
     */
    self.not = function () {
      return self.icmult(-1).icadd(1);
    };

    /**
     * Integer divison with two shares (self / o)
     * @method sdiv
     * @param {SecretShare} o - the share to divide by.
     * @param {number} [l=log_2(self.Zp)] - the maximum bit length of the answer.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.sdiv = function (o, l, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (!=)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (!=)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (!=)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('sdiv', self.holders);
      }

      var lZp = share_helpers['ceil'](self.jiff.helpers.bLog(self.Zp, 2));
      if (l == null) {
        l = lZp;
      } else {
        l = l < lZp ? l : lZp;
      }

      // Convert to bits
      var dividend_bits = self.bit_decomposition(op_id + ':decomposition1').slice(0, l);
      var divisor_bits = o.bit_decomposition(op_id + ':decomposition2').slice(0, l);

      // Compute by long division
      var quotient_bits = self.jiff.protocols.bits.sdiv(dividend_bits, divisor_bits, op_id + ':bits.sdiv').quotient;
      var quotient = self.jiff.protocols.bits.bit_composition(quotient_bits);
      return quotient;
    };

    /**
     * Integer divison with a share and a constant (self / cst).
     * @method cdiv
     * @param {SecretShare} cst - the constant to divide by.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.cdiv = function (cst, op_id) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (/)');
      }

      if (share_helpers['<='](cst, 0)) {
        throw new Error('divisor must be > 0 (cst/): ' + cst);
      }

      if (share_helpers['<='](self.Zp, cst)) {
        throw new Error('divisor must be < share.Zp (' + self.Zp + ') in (cst/): ' + cst);
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('cdiv', self.holders);
      }

      // Allocate share for result to which the answer will be resolved once available
      var final_deferred = new self.jiff.helpers.Deferred;
      var final_promise = final_deferred.promise;
      var result = self.jiff.secret_share(self.jiff, false, final_promise, undefined, self.holders, self.threshold, self.Zp);

      // Execute protocol when random in noise in [0, Zp) and quotient floor(noise/constant) is ready!
      var ready_quotient = function (noise, nOVERc) {
        // Use noise
        var noisyX = self.isadd(noise);
        self.jiff.internal_open(noisyX, noisyX.holders, op_id + ':open').then(function (noisyX) {
          var wrapped = self.icgt(noisyX, op_id + ':wrap_cgt'); // 1 => x + noise wrapped around Zp, 0 otherwise

          // if we did not wrap
          var noWrapDiv = share_helpers['floor/'](noisyX, cst);
          var unCorrectedQuotient = nOVERc.icmult(-1).icadd(noWrapDiv).icsub(1);
          var verify = self.issub(unCorrectedQuotient.icmult(cst));
          var isNotCorrect = verify.icgteq(cst, op_id + ':cor1');
          var noWrapAnswer = unCorrectedQuotient.isadd(isNotCorrect); // if incorrect => isNotCorrect = 1 => quotient = unCorrectedQuotient - 1

          // if we wrapped
          var wrapDiv = share_helpers['floor/'](share_helpers['+'](noisyX, self.Zp), cst);
          unCorrectedQuotient = nOVERc.icmult(-1).icadd(wrapDiv).icsub(1);
          verify = self.issub(unCorrectedQuotient.icmult(cst));
          isNotCorrect = verify.icgteq(cst, op_id + ':cor2');
          var wrapAnswer = unCorrectedQuotient.isadd(isNotCorrect); // if incorrect => isNotCorrect = 1 => quotient = unCorrectedQuotient - 1

          var answer = noWrapAnswer.isadd(wrapped.ismult(wrapAnswer.issub(noWrapAnswer), op_id + ':smult'));
          answer.wThen(final_deferred.resolve);
        });
      };

      // Preprocessing cases
      var quotient = self.jiff.get_preprocessing(op_id + ':quotient');
      if (quotient == null) { // case 1: no preprocessing with crypto provider!
        var promise = self.jiff.from_crypto_provider('quotient', self.holders, self.threshold, self.Zp, op_id + ':quotient', {constant: cst});
        promise.then(function (msg) {
          ready_quotient(msg['shares'][0], msg['shares'][1]);
        });
      } else if (quotient.ondemand === true) { // case 2: constant was not available at preprocessing time, must do it now!
        var ondemand = self.jiff.protocols.generate_random_and_quotient(threshold, self.holders, self.holders, self.Zp, {
          op_id: op_id + ':quotient',
          constant: cst,
          ondemand: true
        });
        ondemand.promise.then(function () {
          ready_quotient(ondemand.share.r, ondemand.share.q);
        });
      } else { // case 3: preprocessing is completed!
        ready_quotient(quotient.r, quotient.q);
      }

      // special case, if result is zero, sometimes we will get to -1 due to how correction happens above (.csub(1) and then compare)
      var zeroIt = self.iclt(cst, op_id + ':zero_check').inot();
      return result.ismult(zeroIt, op_id + ':zero_it');
    };

    /**
     * Remainder with two shares (self % o)
     * @method smod
     * @param {SecretShare} o - the modulus to apply
     * @param {number} [l=log_2(self.Zp)] - the maximum bit length of the answer.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.smod = function (o, l, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (!=)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (!=)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (!=)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('smod', self.holders);
      }

      var lZp = share_helpers['ceil'](self.jiff.helpers.bLog(self.Zp, 2));
      if (l == null) {
        l = lZp;
      } else {
        l = l < lZp ? l : lZp;
      }

      // Convert to bits
      var dividend_bits = self.bit_decomposition(op_id + ':decomposition1').slice(0, l);
      var divisor_bits = o.bit_decomposition(op_id + ':decomposition2').slice(0, l);

      // Compute by long division
      var remainder_bits = self.jiff.protocols.bits.sdiv(dividend_bits, divisor_bits, op_id + ':bits.sdiv').remainder;
      var remainder = self.jiff.protocols.bits.bit_composition(remainder_bits);
      return remainder;
    };

    /**
     * Checks whether the share is less than half the field size.
     * @method lt_halfprime
     * @memberof SecretShare
     * @instance
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     */
    self.lt_halfprime = function (op_id) {
      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('lt_halfprime', self.holders);
      }

      // if share is even, then self is less than half the prime, otherwise, share is greater than half the prime
      var share = self.icmult(2);

      // to check if share is even, we will use pre-shared bits as some form of a bit mask
      var bitLength = share_helpers['ceil'](self.jiff.helpers.bLog(share.Zp, 2));

      // Create result share
      var final_deferred = new self.jiff.helpers.Deferred;
      var final_promise = final_deferred.promise;
      var result = self.jiff.secret_share(self.jiff, false, final_promise, undefined, self.holders, self.threshold, self.Zp);

      // Execute protocol when randomly sampled bit-wise random number is ready
      var ready_sampling = function (bits) {
        // if 2*self is even, then self is less than half prime, otherwise self is greater or equal to half prime
        if (bits.length !== bitLength) {
          throw new Error('Preprocessed bits sequence has incorrect length, expected: ' + bitLength + ' actual: ' + bits.length);
        }

        // bit composition: r = (rl ... r1 r0)_10
        var r = self.jiff.protocols.bits.bit_composition(bits);
        // open share + noise, and utilize opened value with shared bit representation of noise to check the least significant digit of share.
        share.jiff.internal_open(r.isadd(share), share.holders, op_id + ':open').then(function (result) {
          var wrapped = self.jiff.protocols.bits.cgt(bits, result, op_id + ':bits.cgt');
          var isOdd = self.jiff.helpers.mod(result, 2);
          isOdd = bits[0].icxor_bit(isOdd);
          isOdd = isOdd.isxor_bit(wrapped, op_id + ':sxor_bit');

          var answer = isOdd.inot();
          answer.wThen(final_deferred.resolve);
        });
      };

      // generate the bits of a random number less than our prime
      var bits = self.jiff.get_preprocessing(op_id + ':sampling');
      if (bits == null) {
        var promise = self.jiff.from_crypto_provider('numbers', self.holders, self.threshold, self.Zp, op_id + ':sampling', {bitLength: bitLength, count: 1, max: self.Zp});
        promise.then(function (msg) {
          ready_sampling(msg['shares']);
        });
      } else {
        ready_sampling(bits);
      }

      return result;
    };

    /**
     * Bit Decomposition: Transform existing share to an array of bit shares.
     * @method bit_decomposition
     * @memberof SecretShare
     * @instance
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @returns {SecretShare[]} an array of secret shares of bits of length [ceil(self.Zp)], where
     *   index 0 represents the least significant bit.
     */
    self.bit_decomposition = function (op_id) {
      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('bit_decomposition', self.holders);
      }

      var bitLength = self.Zp.toString(2).length;

      // Create deferred shares to resolve to later when the computation completes
      var many_shares = many_secret_shares(jiff, bitLength, self.holders, self.threshold, self.Zp);
      var deferreds = many_shares.deferreds;
      var result = many_shares.shares;

      // Execute protocol when randomly sampled bit-wise random number is ready
      var ready_sampling = function (bits) {
        var r = self.jiff.protocols.bits.bit_composition(bits);
        // add and reveal random number to self
        self.jiff.internal_open(r.isadd(self), self.holders, op_id + ':open').then(function (result) {
          // compute bits assuming r+self < Zp
          var noWrap = self.jiff.protocols.bits.csubr(result, bits, op_id + ':bits.csubr:1');
          var didWrap = noWrap.pop();

          // compute bits assuming r+self >= Zp
          var withWrap = self.jiff.protocols.bits.csubr(share_helpers['+'](result, self.Zp), bits, op_id + ':bits.csubr:2');
          withWrap.pop(); // withWrap cannot underflow!

          // choose noWrap if first subtraction does not overflow (sign bit is zero), otherwise choose withWrap.
          for (var i = 0; i < bitLength; i++) {
            withWrap[i] = didWrap.iif_else(withWrap[i], noWrap[i], op_id + ':if_else:' + i);
          }
          resolve_many_secrets(deferreds, withWrap);
        });
      };

      // generate the bits of a random number less than our prime
      var bits = self.jiff.get_preprocessing(op_id + ':sampling');
      if (bits == null) {
        var promise = self.jiff.from_crypto_provider('numbers', self.holders, self.threshold, self.Zp, op_id + ':sampling', {bitLength: bitLength, count: 1, max: self.Zp});
        promise.then(function (msg) {
          ready_sampling(msg['shares']);
        });
      } else {
        ready_sampling(bits);
      }

      return result;
    };

    /**
     * Simulate an oblivious If-else statement with a single return value.
     * Should be called on a secret share of a bit: 0 representing false, and 1 representing true
     * If this is a share of 1, a new sharing of the element represented by the first parameter is returned,
     * otherwise, a new sharing of the second is returned.
     * @method if_else
     * @memberof SecretShare
     * @instance
     * @param {SecretShare|constant} trueVal - the value/share to return if this is a sharing of 1.
     * @param {SecretShare|constant} falseVal - the value/share to return if this is a sharing of 0.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} a new sharing of the result of the if.
     *
     * @example
     * // a and b are secret shares
     * // cmp will be a secret share of either 1 or 0, depending on whether a or b is greater
     * var cmp = a.gt(b);
     *
     * // max is set to the greater value, without revealing the value or the result of the inequality
     * var max = cmp.if_else(a, b);
     */
    self.if_else = function (trueVal, falseVal, op_id) {
      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('if_else', self.holders);
      }

      var const1 = self.isConstant(trueVal);
      var const2 = self.isConstant(falseVal);
      if (const1 && const2) {
        return self.icmult(trueVal).isadd(self.inot().icmult(falseVal));
      } else if (const1) {
        return self.inot().ismult(falseVal.icsub(trueVal), op_id + ':smult').icadd(trueVal);
      } else if (const2) {
        return self.ismult(trueVal.icsub(falseVal), op_id + ':smult').icadd(falseVal);
      } else {
        return self.ismult(trueVal.issub(falseVal), op_id + ':smult').isadd(falseVal);
      }
    };

    // when the promise is resolved, acquire the value of the share and set ready to true
    if (!ready) {
      self.promise.then(self.receive_share, self.error);
      self.jiff.add_to_barriers(self.promise);
    }

    /**
     * Wrapper around share.promise.then
     * In case share is ready (its promise is resolved and cleared)
     * The callback is executed immediately.
     * Does not support chaining.
     * @method wThen
     * @memberof SecretShare
     * @instance
     * @param {function} onFulfilled - callback for success, called with self.value as parameter.
     * @param {function} [onRejected] - callback for errors.
     */
    self.wThen = function (onFulfilled, onRejected) {
      if (self.value != null) {
        onFulfilled(self.value);
      } else {
        if (onRejected == null) {
          onRejected = self.error;
        }
        self.promise.then(onFulfilled, onRejected);
      }
    };

    // internal variant of primitives, to use internally by other primitives
    var internals = ['cadd', 'csub', 'cmult', 'sadd', 'ssub', 'smult', 'smult_bgw',
      'cxor_bit', 'sxor_bit', 'cor_bit', 'sor_bit',
      'slt', 'slteq', 'sgt', 'sgteq', 'seq', 'sneq',
      'clt', 'clteq', 'cgt', 'cgteq', 'ceq', 'cneq',
      'sdiv', 'cdiv', 'not', 'lt_halfprime', 'if_else'];
    for (var i = 0; i < internals.length; i++) {
      var key = internals[i];
      self['i' + key] = self[key];
    }

    // return the share
    return jiff.execute_array_hooks('createSecretShare', [jiff, self, share_helpers], 1);
  }

  /**
   * The interface defined by an instance of jiff.
   * You can get an instance of jiff by calling function {@link jiff.make_jiff}.
   * You can access any of the specified members of function with &lt;jiff-instance&gt;.&lt;member-name&gt;.
   * @namespace jiff-instance
   * @version 1.0
   */

  /**
   * Create a new jiff instance.
   * @memberof jiff
   * @function make_jiff
   * @param {string} hostname - server hostname/ip and port.
   * @param {string} computation_id - the id of the computation of this instance.
   * @param {object} [options={}] - javascript object with additional options.
   *                           all parameters are optional, However, private and public key must either be both provided or neither of them provided.
     <pre>
     {
       "party_id": number,
       "party_count": number,
       "secret_key": Uint8Array to be used with libsodium-wrappers [(check Library Specs)]{@link https://download.libsodium.org/doc/public-key_cryptography/authenticated_encryption.html},
       "public_key": Uint8Array to be used with libsodium-wrappers [(check Library Specs)]{@link https://download.libsodium.org/doc/public-key_cryptography/authenticated_encryption.html},
       "public_keys": { 1: "Uint8Array PublicKey", 2: "Uint8Array PublicKey", ... },
       "Zp": default mod to use (prime number),
       "autoConnect": true/false,
       "hooks": { 'check out <a href="hooks.html">hooks documentation</a>' },
       "listeners" : A map from custom tags to listeners (of type function(sender_id, message_string)) that handle custom messages with that tag.
       "onConnect": function(jiff_instance),
       "onError": function(label, error): called when errors occured in client code or during handling requests from this client at the server side
                                          label is a string indicating where the error occured, and error is a string or an exception object.
       "safemod": boolean (whether or not to check if provided Zp is prime, may be slow for big primes, defaults to false),
       "crypto_provider": a boolean that flags whether to get beaver triplets and other preprocessing entities from the server (defaults to false),
       "socketOptions": an object, passed directly to socket.io constructor,
       "maxInitializationRetries": how many consecutive times to retry to initialize with the server if initialization fails, defaults to 2.
     }
     </pre>
   *
   * @return {jiff-instance} the jiff instance for the described computation.
   *                          The Jiff instance contains the socket, number of parties, functions
   *                          to share and perform operations, as well as synchronization flags.
   *
   * @example
   * // build a jiff instance which will connect to a server running on the local machine
   * var instance = jiff.make_jiff('http://localhost:8080', 'compuation-1', {party_count: 2});
   */
  function make_jiff(hostname, computation_id, options) {
    if (options == null) {
      options = {};
    }

    var jiff = {};

    /**
     * The server hostname, ends with a slash, includes port and protocol (http/https).
     * @member {string} hostname
     * @memberof jiff-instance
     * @instance
     */
    jiff.hostname = hostname.trim();
    if (!jiff.hostname.endsWith('/')) {
      jiff.hostname = jiff.hostname + '/';
    }

    /**
     * An array containing the names (jiff-client-[name].js) of extensions
     * applied to this instance.
     * @member {string[]} extensions
     * @memberof jiff-instance
     * @instance
     */
    jiff.extensions = ['base'];

    /**
     * Checks if the given extension is applied.
     * @method has_extension
     * @memberof jiff-instance
     * @instance
     * @param {string} name - the extension name (found in the filename at jiff-client-[name].js).
     * @return {boolean} true if the extension was applied, false otherwise.
     */
    jiff.has_extension = function (name) {
      return jiff.extensions.indexOf(name) > -1;
    };

    /**
     * Checks if a given extension can be safely applied to the instance
     * @method can_apply_extension
     * @memberof jiff-instance
     * @instance
     * @param {string} name - the extension name (found in the filename at jiff-client[name].js)
     * @return {boolean|string} true if the extension can be safely applied, otherwise returns an error message.
     */
    jiff.can_apply_extension = function (name) {
      return true;
    };

    /**
     * Safely applies the given extension, if the extension is safe, it will be applied succesfully.
     * If the extension is not safe to be applied, an exception will be thrown with an appropriate error message.
     * @method apply_extension
     * @memberof jiff-instance
     * @instance
     * @param {object} ext - the namespace of the extension acquired when the extension is imported, should contain a make_jiff function.
     * @param {object} [options={}] - optional options to be passed to the extension.
     */
    jiff.apply_extension = function (ext, options) {
      if (options == null) {
        options = {};
      }

      var name = ext.name;
      var status = jiff.can_apply_extension(name);

      if (status === true) {
        ext.make_jiff(jiff, options);

        jiff.extensions.push(name);
        jiff.extension_applied(name, options);
      } else {
        throw status;
      }
    };

    /**
     * Called when an extension was applied successfully. Override to change behavior based on future extensions.
     * @param {string} name - the name of the applied extension.
     * @param {object} [options={}] - the options passed by the user to the newly applied extension.
     */
    jiff.extension_applied = function (name, options) {};

    /**
     * The id of this party. [Do not modify]
     * @member {number} id
     * @memberof jiff-instance
     * @instance
     */
    jiff.id = options.party_id;

    /**
     * Stores the computation id. [Do not modify]
     * @member {string} computation_id
     * @memberof jiff-instance
     * @instance
     */
    jiff.computation_id = computation_id;

    /**
     * Flags whether this instance is capable of starting the computation.
     * In other words, the public keys for all parties and servers are known,
     * and the server is connected. [Do not use directly externally; use isReady() instead]
     * @member {boolean} __ready
     * @memberof jiff-instance
     * @instance
     */
    jiff.__ready = false;

    /**
     * Flags whether this instance has been initialized (the server responded successfully to the initialization message)
     * @member {boolean} __initialized
     * @memberof jiff-instance
     * @instance
     */
    jiff.__initialized = false;

    /**
     * Checks whether this instance is connected and the server signaled the start of computation.
     * @method isReady
     * @memberof jiff-instance
     * @instance
     * @return {boolean} true if the instance is ready, false otherwise.
     */
    jiff.isReady = function () {
      return jiff.__ready;
    };

    if (options.sodium !== false) {
      /**
       * A promise for when the sodium wrappers are ready. This will be undefined if options.sodium is false.
       * @method {Promise} sodium
       * @memberof jiff-instance
       * @instance
       */
      jiff.sodium_ready = sodium_.ready;
    }

    /**
     * The default Zp for this instance.
     * @memberof jiff-instance
     * @member {number} Zp
     * @instance
     */
    jiff.Zp = options.Zp == null ? gZp : options.Zp;
    if (options.Zp != null && options.safemod === true) {
      // bignumber primes are checked by the bignumber extension
      if (typeof(options.Zp) !== 'string' && options.Zp.isBigNumber !== true) {
        if (!is_prime(options.Zp)) {
          throw new Error('Zp = ' + options.Zp + ' is not prime.  Please use a prime number for the modulus or set safemod to false.');
        }
      }
    }

    // Setup sockets.
    var guard_socket = function (socket) {
      // Outgoing messages mailbox (linked list)
      socket.mailbox = linked_list();

      // Store message in the mailbox until acknowledgment is received
      socket.safe_emit = function (label, msg) {
        // add message to mailbox
        var mailbox_pointer = socket.mailbox.add({label: label, msg: msg});
        if (socket.connected) {
          // emit the message, if an acknowledgment is received, remove it from mailbox
          socket.emit(label, msg, function (status) {
            if (status) {
              socket.mailbox.remove(mailbox_pointer);
              if (socket.mailbox.head == null && socket.empty_deferred != null) {
                socket.empty_deferred.resolve();
              }

              if (label === 'free' && socket === jiff.socket) {
                jiff.execute_array_hooks('afterOperation', [jiff, 'free', msg], 2);
              }
            }
          });
        }
      };

      // Resend all pending messages
      socket.resend_mailbox = function () {
        // Create a new mailbox, since the current mailbox will be resent and
        // will contain new backups.
        var old_mailbox = socket.mailbox;
        socket.mailbox = linked_list();

        // loop over all stored messages and emit them
        var current_node = old_mailbox.head;
        while (current_node != null) {
          var label = current_node.object.label;
          var msg = current_node.object.msg;
          socket.safe_emit(label, msg);
          current_node = current_node.next;
        }
      };

      var old_disconnect = socket.disconnect;
      socket.disconnect = function () {
        jiff.execute_array_hooks('beforeOperation', [jiff, 'disconnect', {}], -1);
        old_disconnect.apply(socket, arguments);
      };

      // Safe disconnect: only after all messages were acknowledged
      socket.safe_disconnect = function (free, callback) {
        (function ready() {
          if (socket.mailbox.head == null && jiff.counters.pending_opens === 0) {
            if (free) {
              jiff.free();

              // disconnect after free has been delivered
              free = false;
              return ready();
            }

            socket.disconnect();
            if (callback != null) {
              callback();
            }
          } else {
            socket.empty_deferred = new jiff.helpers.Deferred;
            socket.empty_deferred.promise.then(ready);
          }
        }());
      };

      return socket;
    };

    // setup main socket
    var socketOptions = {
      reconnectionDelay: 25000,
      reconnectionDelayMax: 27500,
      randomizationFactor: 0.1,
      autoConnect: false
    };
    socketOptions = Object.assign({}, socketOptions, options.socketOptions);
    jiff.socket = options.__internal_socket;
    if (jiff.socket == null) {
      jiff.socket = io_(hostname, socketOptions);
    }

    if (options.__internal_socket == null) {
      guard_socket(jiff.socket);
    } else {
      jiff.socket.safe_emit = jiff.socket.emit;
      jiff.socket.resend_mailbox = function () {};

      jiff.socket.disconnect = function () {
        jiff.execute_array_hooks('beforeOperation', [jiff, 'disconnect', {}], -1);
      };
      jiff.socket.safe_disconnect = function (free, callback) {
        if (free) {
          jiff.free();
        }
        jiff.socket.disconnect();
        if (callback != null) {
          callback();
        }
      };
    }

    if (options.maxInitializationRetries == null) {
      options.maxInitializationRetries = 2;
    }

    jiff.error = function (label, error) {
      console.log(jiff.id, ':', 'Error from server:', label, '---', error);
      if (label === 'initialization') {
        jiff.socket.disconnect();

        if (jiff.initialization_counter < options.maxInitializationRetries) {
          console.log(jiff.id, ':', 'reconnecting..');
          setTimeout(jiff.connect, socketOptions.reconnectionDelay);
        }
      }
    };
    if (options.onError != null) {
      jiff.error = options.onError;
    }

    // Parse options
    if (options.public_keys != null) {
      /**
       * A map from party id to public key. Where key is the party id (number), and
       * value is the public key (Uint8Array).
       * @member {object} keymap
       * @memberof jiff-instance
       * @instance
       */
      jiff.keymap = options.public_keys;
    } else if (options.secret_key != null && options.public_key != null) {
      /**
       * The secret key of this party [(check Library Specs)]{@link https://download.libsodium.org/doc/public-key_cryptography/authenticated_encryption.html}. [Do not modify]
       * @member {Uint8Array} secret_key
       * @memberof jiff-instance
       * @instance
       */
      jiff.secret_key = options.secret_key;
      /**
       * The public key of this party [(check Library Specs)]{@link https://download.libsodium.org/doc/public-key_cryptography/authenticated_encryption.html}. [Do not modify]
       * @member {Uint8Array} public_key
       * @memberof jiff-instance
       * @instance
       */
      jiff.public_key = options.public_key;
    }

    if (jiff.keymap == null) {
      jiff.keymap = {};
    }

    /**
     * For the case when messages from some party is received before its public key is known.
     * { 'party_id': [ { 'label': 'share/open', <other attributes of the message> } ] }
     * @member {object} messagesWaitingKeys
     * @memberof jiff-instance
     * @instance
     */
    jiff.messagesWaitingKeys = {};

    if (options.party_count != null) {
      /**
       * Total party count in the computation, parties will take ids between 1 to party_count (inclusive).
       * @member {number} party_count
       * @memberof jiff-instance
       * @instance
       */
      jiff.party_count = options.party_count;
    }

    if (options.listeners == null) {
      options.listeners = {};
    }

    /**
     * A map from tags to listeners (functions that take a sender_id and a string message).
     * Stores listeners that are attached to this JIFF instance, listeners listen to custom messages sent by other parties
     * with a corresponding tag to the tag provided with the listener.
     * @member {object} listeners
     * @memberof jiff-instance
     * @instance
     */
    jiff.listeners = options.listeners;

    /**
     * Stores custom messages that are received before their listeners are set. Messages are stored in order.
     * Once a listener has been set, the corresponding messages are sent to it in order.
     * This object has this format: { 'tag' => [ { "sender_id": <sender_id>, "message": <message> }, ... ] }
     * @member {object} custom_messages_mailbox
     * @memberof jiff-instance
     * @instance
     */
    jiff.custom_messages_mailbox = {};

    /**
     * Stores all secret shares' promises belonging to a specific barrier.
     * @member {promise[][]} barriers
     * @memberOf jiff-instance
     * @instance
     */
    jiff.barriers = [];

    if (options.hooks == null) {
      options.hooks = {};
    }

    /**
     * The hooks for this instance.
     * Checkout the <a href="hooks.html">hooks documentation</a>
     * @member {object} hooks
     * @memberof jiff-instance
     * @instance
     */
    jiff.hooks = Object.assign({}, options.hooks);

    // Default hooks:
    if (jiff.hooks.computeShares == null) {
      jiff.hooks.computeShares = jiff_compute_shares;
    }
    if (jiff.hooks.reconstructShare == null) {
      jiff.hooks.reconstructShare = jiff_lagrange;
    }

    // Crypto hooks:
    if (jiff.hooks.encryptSign == null) {
      if (options.sodium !== false) {
        jiff.hooks.encryptSign = encrypt_and_sign;
      } else {
        jiff.hooks.encryptSign = function (jiff, message, encryption_public_key, signing_private_key) {
          return message;
        }
      }
    }
    if (jiff.hooks.decryptSign == null) {
      if (options.sodium !== false) {
        jiff.hooks.decryptSign = decrypt_and_sign;
      } else {
        jiff.hooks.decryptSign = function (jiff, cipher_text, decryption_secret_key, signing_public_key) {
          return cipher_text;
        }
      }
    }
    if (jiff.hooks.generateKeyPair == null) {
      if (options.sodium !== false) {
        jiff.hooks.generateKeyPair = function (jiff) {
          var key = sodium_.crypto_box_keypair(); // this party's public and secret key
          return { public_key: key.publicKey, secret_key: key.privateKey }
        };
      } else {
        jiff.hooks.generateKeyPair = function (jiff) {
          return { public_key: '', secret_key: ''};
        }
      }
    }
    if (jiff.hooks.parseKey == null) {
      if (options.sodium !== false) {
        jiff.hooks.parseKey = function (jiff, keyString) {
          return new Uint8Array(JSON.parse(keyString));
        };
      } else {
        jiff.hooks.parseKey = function (jiff, keyString) {
          return '';
        }
      }
    }
    if (jiff.hooks.dumpKey == null) {
      if (options.sodium !== false) {
        jiff.hooks.dumpKey = function (jiff, key) {
          return '[' + key.toString() + ']';
        };
      } else {
        jiff.hooks.dumpKey = function (jiff, key) {
          return '';
        }
      }
    }

    // Array hooks should have empty array by default:
    if (jiff.hooks.beforeShare == null) {
      jiff.hooks.beforeShare = [];
    }
    if (jiff.hooks.afterComputeShare == null) {
      jiff.hooks.afterComputeShare = [];
    }
    if (jiff.hooks.receiveShare == null) {
      jiff.hooks.receiveShare = [];
    }
    if (jiff.hooks.beforeOpen == null) {
      jiff.hooks.beforeOpen = [];
    }
    if (jiff.hooks.receiveOpen == null) {
      jiff.hooks.receiveOpen = [];
    }
    if (jiff.hooks.afterReconstructShare == null) {
      jiff.hooks.afterReconstructShare = [];
    }
    if (jiff.hooks.receiveTriplet == null) {
      jiff.hooks.receiveTriplet = [];
    }
    if (jiff.hooks.receiveNumbers == null) {
      jiff.hooks.receiveNumbers = [];
    }
    if (jiff.hooks.createSecretShare == null) {
      jiff.hooks.createSecretShare = [];
    }
    if (jiff.hooks.beforeOperation == null) {
      jiff.hooks.beforeOperation = [];
    }
    if (jiff.hooks.afterOperation == null) {
      jiff.hooks.afterOperation = [];
    }

    // parse content of share/open messages to be integers (instead of strings due to encryption/decryption)
    jiff.hooks.afterOperation.unshift(function (jiff, label, msg) {
      if (label === 'share' || label === 'open') {
        msg['share'] = parseInt(msg['share'], 10);
      }
      return msg;
    });

    /**
     * Execute all hooks attached to the given name in order.
     * Hooks are executed sequentially such that the first hook's return value is passed into the second and so on.
     * @method execute_array_hooks
     * @memberof jiff-instance
     * @instance
     * @param {string} hook_name - the name of the hook
     * @param {Array} params - parameters to pass to the hooks
     * @param {number} acc_index - the index in params in which the result of the hooks must be saved, if no hooks
     *                             exist for the name, then params[acc_index] is returned.
     * @return {object} returns the result of the last hook.
     */
    jiff.execute_array_hooks = function (hook_name, params, acc_index) {
      var arr = jiff.hooks[hook_name];
      arr = (arr == null ? [] : arr);

      for (var i = 0; i < arr.length; i++) {
        params[acc_index] = arr[i].apply(jiff, params);
      }
      return params[acc_index];
    };

    /**
     * Stores the parties and callbacks for every .wait_for() registered.
     * @member {Array} wait_callbacks
     * @memberof jiff-instance
     * @instance
     */
    jiff.wait_callbacks = [];

    /**
     * Wait until the public keys of these parties are known.
     * The public keys may be known before the parties connect (if provided in the options),
     * or they could be sent by the server after the parties connect.
     * Computation specified in the callback may assume that these parties are connected,
     * if they are not, the server will handle storing and relaying the needed messages
     * to them when they connect.
     * @memberof jiff-instance
     * @instance
     * @param {Array} parties - an array of party ids to wait for, must explicitly include 's1' if callback must wait for the server.
     * @param {function(jiff-instance)} callback - the function to execute when these parties are known.
     * @param {boolean} [wait_for_initialization=true] - specifies whether to wait for initialization to be complete
     *                                                   before executing the callback (even if parties are available).
     *                                                   Set this to false if you do not need the party count and this
     *                                                   party's id, or if you already have them, and you are certain
     *                                                   they will be accepted by the server on initialization.
     */
    jiff.wait_for = function (parties, callback, wait_for_initialization) {
      if (wait_for_initialization == null) {
        wait_for_initialization = true;
      }

      jiff.wait_callbacks.push({parties: parties, callback: callback, initialization: wait_for_initialization});
      jiff.execute_wait_callbacks(); // See if the callback can be executed immediately
    };

    /**
     * Executes all callbacks for which the wait condition has been satisfied.
     * Remove all executed callbacks so that they would not be executed in the future.
     * @memberof jiff-instance
     * @instance
     */
    jiff.execute_wait_callbacks = function () {
      var new_waits = [];
      for (var i = 0; i < jiff.wait_callbacks.length; i++) {
        var wait = jiff.wait_callbacks[i];
        var parties = wait.parties;
        var callback = wait.callback;
        var initialization = wait.initialization;

        // Check if the parties to wait for are now known
        var parties_satisfied = true;
        for (var j = 0; j < parties.length; j++) {
          var party_id = parties[j];
          if (jiff.keymap == null || jiff.keymap[party_id] == null) {
            parties_satisfied = false;
            break;
          }
        }

        if (initialization) {
          parties_satisfied = parties_satisfied && jiff.__initialized;
        }

        if (parties_satisfied) {
          callback(jiff);
        } else {
          new_waits.push(wait);
        }
      }

      jiff.wait_callbacks = new_waits;
    };

    /**
     * Resolves all messages that were pending because their senders primary key was previously unknown.
     * These messages are decrypted and verified and handled appropriatly before being removed from the wait queue.
     * @memberof jiff-instance
     * @instance
     */
    jiff.resolve_messages_waiting_for_keys = function () {
      for (var party_id in jiff.keymap) {
        if (!jiff.keymap.hasOwnProperty(party_id)) {
          continue;
        }

        var messageQueue = jiff.messagesWaitingKeys[party_id];
        if (messageQueue == null) {
          continue;
        }
        for (var i = 0; i < messageQueue.length; i++) {
          var msg = messageQueue[i];
          if (msg.label === 'share') {
            receive_share(jiff, msg.msg);
          } else if (msg.label === 'open') {
            receive_open(jiff, msg.msg);
          } else if (msg.label === 'custom') {
            receive_custom(jiff, msg.msg);
          } else {
            throw new Error('Error resolving pending message: unknown label ' + msg.label);
          }
        }

        jiff.messagesWaitingKeys[party_id] = null;
      }
    };

    /**
     * Total server count in the computation, servers will take ids between "s1" to "s<server_count>" (inclusive).
     * @member {number} server_count
     * @memberof jiff-instance
     * @instance
     */
    jiff.server_count = 1;

    /**
     * Counts how many times JIFF attempted to initialize with the server
     * without success consecutively.
     * @member {number} initialization_counter
     * @memberof jiff-instance
     * @instance
     *
     */
    jiff.initialization_counter = 0;

    /**
     * Connect to the server and starts listening.
     * @method connect
     * @memberof jiff-instance
     * @instance
     */
    jiff.connect = function () {
      // Ask socket to connect, which will automatically trigger a call to 'initialize()' when connection is established!
      if (options.sodium === false) {
        jiff.socket.connect();
      } else {
        jiff.sodium_ready.then(function () {
          jiff.socket.connect();
        });
      }
    };

    // responsible for building the initialization message
    jiff.build_initialization_message = function (public_key) {
      var msg = {
        computation_id: computation_id,
        party_id: jiff.id,
        party_count: jiff.party_count,
        public_key: public_key
      };
      msg = Object.assign(msg, options.initialization);

      // Initialization Hook
      return jiff.execute_array_hooks('beforeOperation', [jiff, 'initialization', msg], 2);
    };

    /**
     * Initializes this instance by sending the initialization message to the server.
     * Should only be called after connection is established.
     * Do not call this manually unless you know what you are doing, use <jiff_instance>.connect() instead!
     */
    jiff.initialize = function () {
      console.log('Connected!', jiff.id);
      jiff.initialization_counter++;

      if (jiff.secret_key == null && jiff.public_key == null) {
        var key = jiff.hooks.generateKeyPair(jiff);
        jiff.secret_key = key.secret_key;
        jiff.public_key = key.public_key;
      }

      // Initialization message
      var msg = jiff.build_initialization_message(jiff.hooks.dumpKey(jiff, jiff.public_key));

      // Emit initialization message to server
      jiff.socket.emit('initialization', JSON.stringify(msg));
    };

    // set on('connect') handler once!
    jiff.socket.on('connect', jiff.initialize);

    /**
     * Store the public keys given in the keymap
     * @param {object} keymap - map party id to public key.
     */
    jiff.store_public_keys = function (keymap) {
      var i;
      for (i in keymap) {
        if (keymap.hasOwnProperty(i) && jiff.keymap[i] == null) {
          jiff.keymap[i] = jiff.hooks.parseKey(jiff, keymap[i]);
        }
      }

      // Resolve any pending messages that were received before the sender's public key was known
      jiff.resolve_messages_waiting_for_keys();

      // Resolve any pending waits that have satisfied conditions
      jiff.execute_wait_callbacks();

      // Check if all keys have been received
      if (jiff.keymap['s1'] == null) {
        return;
      }
      for (i = 1; i <= jiff.party_count; i++) {
        if (jiff.keymap[i] == null) {
          return;
        }
      }

      // all parties are connected; execute callback
      if (jiff.__ready !== true && jiff.__initialized) {
        jiff.__ready = true;
        if (options.onConnect != null) {
          options.onConnect(jiff);
        }
      }
    };

    /**
     * Send a custom message to a subset of parties.
     * @memberof jiff-instance
     * @function emit
     * @instance
     * @param {string} tag - the tag to attach to the message.
     * @param {Array} receivers - contains the party ids to receive the message, all non-server parties if null.
     * @param {string} message - the message to send.
     * @param {boolean} [encrypt=true] - if true, messages will be encrypted.
     */
    jiff.emit = function (tag, receivers, message, encrypt) {
      if (typeof(message) !== 'string') {
        throw new Error('Emit: message must be a string');
      }

      if (receivers == null) {
        receivers = [];
        for (var i = 1; i <= jiff.party_count; i++) {
          receivers.push(i);
        }
      } else {
        receivers = receivers.slice();
      }

      // Remove own index from receivers
      var index = receivers.indexOf(jiff.id);
      if (index > -1) {
        receive_custom(jiff, { tag: tag, party_id: jiff.id, message: message, encrypted: false });
      }

      for (var p = 0; p < receivers.length; p++) {
        if (receivers[p] === jiff.id) {
          continue;
        }

        var message_to_send = { tag: tag, party_id: receivers[p], message: message, encrypted: encrypt };
        message_to_send = jiff.execute_array_hooks('beforeOperation', [jiff, 'custom', message_to_send], 2);

        if (message_to_send['encrypted'] !== false) {
          message_to_send['message'] = jiff.hooks.encryptSign(jiff, message_to_send['message'], jiff.keymap[message_to_send['party_id']], jiff.secret_key);
          message_to_send['encrypted'] = true;
        }

        jiff.socket.safe_emit('custom', JSON.stringify(message_to_send));
      }
    };

    /**
     * Registers the given function as a listener for messages with the given tag.
     * Removes any previously set listener for this tag.
     * @memberof jiff-instance
     * @function listen
     * @instance
     * @param {string} tag - the tag to listen for.
     * @param {function(party_id, string)} handler - the function that handles the received message: takes the sender id and the message as parameters.
     */
    jiff.listen = function (tag, handler) {
      jiff.listeners[tag] = handler;

      var stored_messages = jiff.custom_messages_mailbox[tag];
      if (stored_messages == null) {
        return;
      }

      for (var i = 0; i < stored_messages.length; i++) {
        var sender_id = stored_messages[i].sender_id;
        var message = stored_messages[i].message;
        handler(sender_id, message);
      }

      delete jiff.custom_messages_mailbox[tag];
    };

    /**
     * Removes the custom message listener attached to the given tag.
     * @param {string} tag - the tag of the listener to remove.
     */
    jiff.remove_listener = function (tag) {
      delete jiff.listeners[tag];
    };

    /**
     * Helper functions [DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING].
     * @type object
     * @memberof jiff-instance
     * @namespace helpers
     */
    jiff.helpers = {};

    /**
     * Polyfill for jQuery Deferred
     * From https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred
     * @memberof jiff-instance.helpers
     * @constructor Deferred
     * @instance
     * @return {Deferred} a new Deferred.
     */
    jiff.helpers.Deferred = function () {
      // Polyfill for jQuery Deferred
      // From https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred
      this.resolve = null;

      /* A method to reject the associated Promise with the value passed.
       * If the promise is already settled it does nothing.
       *
       * @param {anything} reason: The reason for the rejection of the Promise.
       * Generally its an Error object. If however a Promise is passed, then the Promise
       * itself will be the reason for rejection no matter the state of the Promise.
       */
      this.reject = null;

      /* A newly created Promise object.
       * Initially in pending state.
       */
      this.promise = new Promise(function (resolve, reject) {
        this.resolve = resolve;
        this.reject = reject;
      }.bind(this));
      Object.freeze(this);
    };

    /**
     * Correct Mod instead of javascript's remainder (%).
     * @memberof jiff-instance.helpers
     * @function mod
     * @instance
     * @param {number} x - the number.
     * @param {number} y - the mod.
     * @return {number} x mod y.
     */
    jiff.helpers.mod = function (x, y) {
      if (x < 0) {
        return (x % y) + y;
      }
      return x % y;
    };

    /**
     * Ceil of a number.
     * @memberof jiff-instance.helpers
     * @function ceil
     * @instance
     * @param {number} x - the number to ceil.
     * @return {number} ceil of x.
     */
    jiff.helpers.ceil = Math.ceil;

    /**
     * Floor of a number
     * @memberof jiff-instance.helpers
     * @function floor
     * @instance
     * @param {number} x - the number to floor.
     * @return {number} floor of x.
     */
    jiff.helpers.floor = Math.floor;

    /**
     * Fast Exponentiation Mod.
     * @memberof jiff-instance.helpers
     * @function pow_mod
     * @instance
     * @param {number} a - the base number.
     * @param {number} b - the power.
     * @param {number} n - the mod.
     * @return {number} (base^pow) mod m.
     */
    jiff.helpers.pow_mod = function (a, b, n) {
      a = jiff.helpers.mod(a, n);
      var result = 1;
      var x = a;
      while (b > 0) {
        var leastSignificantBit = jiff.helpers.mod(b, 2);
        b = Math.floor(b / 2);
        if (leastSignificantBit === 1) {
          result = result * x;
          result = jiff.helpers.mod(result, n);
        }
        x = x * x;
        x = jiff.helpers.mod(x, n);
      }
      return result;
    };

    /**
     * Extended Euclidean for finding inverses.
     * @method extended_gcd
     * @memberof jiff-instance.helpers
     * @instance
     * @param {number} a - the number to find inverse for.
     * @param {number} b - the mod.
     * @return {number[]} [inverse of a mod b, coefficient for a, coefficient for b].
     */
    jiff.helpers.extended_gcd = function (a, b) {
      if (b === 0) {
        return [1, 0, a];
      }

      var temp = jiff.helpers.extended_gcd(b, jiff.helpers.mod(a, b));
      var x = temp[0];
      var y = temp[1];
      var d = temp[2];
      return [y, x - y * Math.floor(a / b), d];
    };

    /**
     * Compute Log to a given base.
     * @method bLog
     * @memberof jiff-instance.helpers
     * @instance
     * @param {number} value - the number to find log for.
     * @param {number} [base=2] - the base (2 by default).
     * @return {number} log(value) with the given base.
     */
    jiff.helpers.bLog = function (value, base) {
      if (base == null) {
        base = 2;
      }
      return Math.log(value) / Math.log(base);
    };

    /**
     * Check that two sorted arrays are equal.
     * @method array_equals
     * @memberof jiff-instance.helpers
     * @instance
     * @param {Array} arr1 - the first array.
     * @param {Array} arr2 - the second array.
     * @return {boolean} true if arr1 is equal to arr2, false otherwise.
     */
    jiff.helpers.array_equals = function (arr1, arr2) {
      if (arr1.length !== arr2.length) {
        return false;
      }

      for (var i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) {
          return false;
        }
      }

      return true;
    };

    /**
     * Check that two Zps are equal. Used to determine if shares can be computed on or not.
     * @method Zp_equals
     * @memberof jiff-instance.helpers
     * @instance
     * @param {SecretShare} s1 - the first share.
     * @param {SecretShare} s2 - the second share.
     * @return {boolean} true both shares have the same Zp, false otherwise.
     */
    jiff.helpers.Zp_equals = function (s1, s2) {
      return s1.Zp === s2.Zp;
    };

    /**
     * Generate a random integer between 0 and max-1 [inclusive].
     * Modify this to change the source of randomness and how it is generated.
     * @method random
     * @memberof jiff-instance.helpers
     * @instance
     * @param {number} max - the maximum number.
     * @return {number} the random number.
     */
    jiff.helpers.random = function (max) {
      // Use rejection sampling to get random value within bounds
      // Generate random Uint8 values of 1 byte larger than the max parameter
      // Reject if random is larger than quotient * max (remainder would cause biased distribution), then try again
      if (max == null) {
        max = jiff.Zp;
      }
      // Values up to 2^53 should be supported, but log2(2^49) === log2(2^49+1), so we lack the precision to easily
      // determine how many bytes are required
      if (max > 562949953421312) {
        throw new RangeError('Max value should be smaller than or equal to 2^49');
      }

      var bitsNeeded = Math.ceil(jiff.helpers.bLog(max, 2));
      var bytesNeeded = Math.ceil(bitsNeeded / 8);
      var maxValue = Math.pow(256, bytesNeeded);

      // Keep trying until we find a random value within a normal distribution
      while (true) { // eslint-disable-line
        var randomBytes = crypto_.__randomBytesWrapper(bytesNeeded);
        var randomValue = 0;

        for (var i = 0; i < bytesNeeded; i++) {
          randomValue = randomValue * 256 + randomBytes[i];
        }

        // randomValue should be smaller than largest multiple of max within maxBytes
        if (randomValue < maxValue - maxValue % max) {
          return randomValue % max;
        }
      }
    };

    /**
     * Get the party number from the given party_id, the number is used to compute/open shares.
     * If party id was a number (regular party), that number is returned,
     * If party id refers to the ith server, then party_count + i is returned (i > 0).
     * @memberof jiff-instance.helpers
     * @instance
     * @param {number/string} party_id - the party id from which to compute the number.
     * @return {number} the party number (> 0).
     */
    jiff.helpers.get_party_number = function (party_id) {
      if (typeof(party_id) === 'number') {
        return party_id;
      }
      if (party_id.startsWith('s')) {
        return -1 * parseInt(party_id.substring(1), 10);
      }
      return parseInt(party_id, 10);
    };

    /**
     * Transforms the given number to an array of bits (numbers).
     * Lower indices in the returned array corresponding to less significant bits.
     * @memberof jiff-instance.helpers
     * @instance
     * @param {number} number - the number to transform to binary
     * @param {length} [length=ceil(log2(number))] - if provided, then the given array will be padded with zeros to the length.
     * @return {number[]} the array of bits.
     */
    jiff.helpers.number_to_bits = function (number, length) {
      number = number.toString(2);
      var bits = [];
      for (var i = 0; i < number.length; i++) {
        bits[i] = parseInt(number.charAt(number.length - 1 - i));
      }
      while (length != null && bits.length < length) {
        bits.push(0);
      }
      return bits;
    };

    /**
     * Transforms the given array of bits to a number.
     * @memberof jiff-instance.helpers
     * @instance
     * @param {bits} number[] - the array of bits to compose as a number, starting from least to most significant bits.
     * @param {length} [length = bits.length] - if provided, only the first 'length' bits will be used
     * @return {number} the array of bits.
     */
    jiff.helpers.bits_to_number = function (bits, length) {
      if (length == null || length > bits.length) {
        length = bits.length;
      }
      return parseInt(bits.slice(0, length).reverse().join(''), 2);
    };

    /**
     * The function used by JIFF to create a new share. This can be used by extensions to create custom shares.
     * Modifying this will modify how shares are generated in the BASE JIFF implementation.
     * A share is a value wrapper with a share object, it has a unique id
     * (per computation instance), and a pointer to the instance it belongs to.
     * A share also has methods for performing operations.
     * @memberof jiff-instance
     * @method secret_share
     * @instance
     * @param {jiff-instance} jiff - the jiff instance.
     * @param {boolean} ready - whether the value of the share is ready or deferred.
     * @param {promise} promise - a promise to the value of the share.
     * @param {number} value - the value of the share (null if not ready).
     * @param {Array} holders - the parties that hold all the corresponding shares (must be sorted).
     * @param {number} threshold - the min number of parties needed to reconstruct the secret.
     * @param {number} Zp - the mod under which this share was created.
     * @returns {SecretShare} the secret share object containing the give value.
     *
     */
    jiff.secret_share = secret_share;

    /**
     * Share a secret input.
     * @method share
     * @memberof jiff-instance
     * @instance
     * @param {number} secret - the number to share (this party's input).
     * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
     * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
     * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
     * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
     * @param {string|number} [share_id=auto_gen()] - the tag used to tag the messages sent by this share operation, this tag is used
     *                                   so that parties distinguish messages belonging to this share operation from other
     *                                   share operations between the same parties (when the order of execution is not
     *                                   deterministic). An automatic id is generated by increasing a local counter, default
     *                                   ids suffice when all parties execute all sharing operations with the same senders
     *                                   and receivers in the same order.
     * @returns {object} a map (of size equal to the number of sending parties)
     *          where the key is the party id (from 1 to n)
     *          and the value is the share object that wraps
     *          the value sent from that party (the internal value maybe deferred).
     * @example
     * // share an input value with all parties, and receive all other parties' inputs
     * var shares = jiff_instance.share(input);
     * // my party id is '1', so the first share is mine (technically my share of my input value)
     * var my_share = shares[1];
     *
     * // my share of party 2's input
     * var p2_share = shares[2];
     */
    jiff.share = function (secret, threshold, receivers_list, senders_list, Zp, share_id) {
      // type check to confirm the secret to be shared is a number
      // for fixed-point extension it should allow non-ints
      if (secret != null && (typeof(secret) !== 'number' || Math.floor(secret) !== secret || secret < 0)) {
        throw new Error('secret must be a non-negative whole number');
      }
      if (secret != null && (secret >= (Zp == null ? jiff.Zp : Zp))) {
        throw new Error('secret must fit inside Zp');
      }
      return jiff.internal_share(secret, threshold, receivers_list, senders_list, Zp, share_id);
    };

    /**
     * Same as jiff-instance.share, but used by internal JIFF primitives/protocols (bgw).
     */
    jiff.internal_share = function (secret, threshold, receivers_list, senders_list, Zp, share_id) {
      return jiff_share(jiff, secret, threshold, receivers_list, senders_list, Zp, share_id);
    };

    /**
     * Share an array of values. Each sender may have an array of different length. This is handled by the lengths parameter.
     * This function will reveal the lengths of the shared array.
     * If parties would like to keep the lengths of their arrays secret, they should agree on some "max" length apriori (either under MPC
     * or as part of the logistics of the computation), all their arrays should be padded to that length by using appropriate default/identity
     * values.
     * @method share_array
     * @memberof jiff-instance
     * @instance
     * @param {Array} array - the array to be shared.
     * @param {null|number|object} [lengths] - the lengths of the arrays to be shared, has the following options: <br>
     *                                       1. null: lengths are unknown, each sender will publicly reveal the lengths of its own array. <br>
     *                                       2. number: all arrays are of this length <br>
     *                                       3. object: { <sender_party_id>: length }: must specify the length of the array for each sender. <br>
     * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
     * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
     * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
     * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
     * @param {string|number} [share_id=auto_gen()] - the base tag used to tag the messages sent by this share operation, every element of the array
     *                                   will get a unique id based on the concatenation of base_share_id and the index of the element.
     *                                   This tag is used so that parties distinguish messages belonging to this share operation from
     *                                   other share operations between the same parties (when the order of execution is not
     *                                   deterministic). An automatic id is generated by increasing a local counter, default
     *                                   ids suffice when all parties execute all sharing operations with the same senders
     *                                   and receivers in the same order.
     * @returns {promise} if the calling party is a receiver then a promise to the shared arrays is returned, the promise will provide an object
     *                    formatted as follows: { <party_id>: [ <1st_share>, <2nd_share>, ..., <(lengths[party_id])th_share> ] }
     *                    where the party_ids are those of the senders.
     *                    if the calling party is not a receiver, then null is returned.
     */
    jiff.share_array = function (array, lengths, threshold, receivers_list, senders_list, Zp, share_id) {
      return jiff_share_array(jiff, array, lengths, threshold, receivers_list, senders_list, Zp, share_id);
    };

    /**
     * Share a 2D array of values. Each sender may have a 2D array of different length (possibily jagged). This is handled by the lengths parameter.
     * This function will reveal the lengths of the shared array.
     * If parties would like to keep the lengths of their arrays secret, they should agree on some "max" length apriori (either under MPC
     * or as part of the logistics of the computation), all their arrays should be padded to that length by using appropriate default/identity
     * values.
     * @method share_2D_array
     * @memberof jiff-instance
     * @instance
     * @param {Array[]} array - the 2D array to be shared.
     * @param {null|number|object} [lengths] - the lengths of the arrays to be shared. For this to work successfully, the
     *                                       same exact value must be used in the calling code for each party. Any missing
     *                                       lengths for a row will be automatically publicly revealed by this function.
     *                                       Must have the following format: <br>
     *                                       1. null: lengths are unknown, each sender will publicly reveal the lengths of its own array. <br>
     *                                       2. { rows: <number>, cols: <number>, 0: <number>, 1: <number>, ...}: all parties have arrays
     *                                          with the given number of rows and cols. In case of jagged 2D arrays, different rows
     *                                          can have a different number of cols specified by using <row_index>: <col_size>.
     *                                          rows is mandatory, cols and any other number matching a specific row are optional. <br>
     *                                       3. { <sender_party_id>: <length_object> }: must specify the lengths for each party by using
     *                                          an object with the same format as 2. Must include every party. <br>
     * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
     * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
     * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
     * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
     * @param {string|number} [share_id=auto_gen()] - the base tag used to tag the messages sent by this share operation, every element of the array
     *                                   will get a unique id based on the concatenation of base_share_id and the index of the element.
     *                                   This tag is used so that parties distinguish messages belonging to this share operation from
     *                                   other share operations between the same parties (when the order of execution is not
     *                                   deterministic). An automatic id is generated by increasing a local counter, default
     *                                   ids suffice when all parties execute all sharing operations with the same senders
     *                                   and receivers in the same order.
     * @returns {promise} if the calling party is a receiver then a promise to the shared arrays is returned, the promise will provide an object
     *                    formatted as follows: { <party_id>: [ [ <1st_row_shares> ], [<2nd_row_share> ], ..., [ <(lengths[party_id])th_row_shares> ] ] }
     *                    where the party_ids are those of the senders.
     *                    if the calling party is not a receiver, then null is returned.
     */
    jiff.share_2D_array = function (array, lengths, threshold, receivers_list, senders_list, Zp, share_id) {
      return jiff_share_2D_array(jiff, array, lengths, threshold, receivers_list, senders_list, Zp, share_id);
    };

    /**
     * Open a secret share to reconstruct secret.
     * @method open
     * @memberof jiff-instance
     * @instance
     * @param {SecretShare} share - this party's share of the secret to reconstruct.
     * @param {Array} [parties=all_parties] - an array with party ids (1 to n) of receiving parties.
     * @param {string|number} [op_id=auto_gen()] - the operation id to be used to tag outgoing messages.
     * @returns {promise|null} a (JQuery) promise to the open value of the secret, null if the party is not specified in the parties array as a receiver.
     * @throws error if share does not belong to the passed jiff instance.
     * @example
     * var shares = jiff_instance.share(input);
     * //multiply the inputs of party 1 and 2 together
     * var result = shares[1].mult(shares[2]);
     * // reveal the result of the multiplication to all parties
     * return jiff_instance.open(result);
     */
    jiff.open = function (share, parties, op_id) {
      return jiff.internal_open(share, parties, op_id);
    };

    /**
     * Same as jiff-instance.open, but used by internal JIFF primitives/protocols (comparisons and secret multiplication).
     */
    jiff.internal_open = function (share, parties, op_id) {
      return jiff_open(jiff, share, parties, op_id);
    };

    /**
     * Opens an array of secret shares.
     * @method open_array
     * @memberof jiff-instance
     * @instance
     * @param {SecretShare[]} shares - an array containing this party's shares of the secrets to reconstruct.
     * @param {Array} [parties=all_parties] - an array with party ids (1 to n) of receiving parties.
     * @param {string|number} [op_id=auto_gen()] - same as jiff_instance.open
     * @returns {promise} a (JQuery) promise to ALL the open values of the secret, the promise will yield
     *                    an array of values matching the corresponding given secret share by index.
     * @throws error if some shares does not belong to the passed jiff instance.
     */
    jiff.open_array = function (shares, parties, op_id) {
      return jiff_open_array(jiff, shares, parties, op_id);
    };

    /**
     * Opens a 2D array of secret shares.
     * @method open_2D_array
     * @memberof jiff-instance
     * @instance
     * @param {SecretShare[][]} shares - an array containing this party's shares of the secrets to reconstruct.
     * @param {jiff-instance} jiff - the jiff instance.
     * @param {SecretShare[]} shares - an array containing this party's shares of the secrets to reconstruct.
     * @param {Array} [parties=all_parties] - an array with party ids (1 to n) of receiving parties.
     * @param {string|number} [op_id=auto_gen()] - same as jiff_instance.open
     * @returns {promise} a (JQuery) promise to ALL the open values of the secret, the promise will yield
     *                    a 2D array of values matching the corresponding given secret share by indices.
     * @throws error if some shares does not belong to the passed jiff instance.
     */
    jiff.open_2D_array = function (shares, parties, op_id) {
      // Default values
      if (parties == null || parties === []) {
        parties = [];
        for (i = 1; i <= jiff.party_count; i++) {
          parties.push(i);
        }
      }

      // Compute operation ids (one for each party that will receive a result
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id2('open_2D_array', parties, shares[0].holders);
      }

      var promises = [];
      for (var i = 0; i < shares.length; i++) {
        var row = shares[i];

        // share
        var promise = jiff.open_array(row, parties, op_id + ':' + i);
        if (promise != null) {
          promises.push(promise);
        }
      }

      if (promises.length === 0) {
        return null;
      }

      return Promise.all(promises);
    };

    /**
     * Receive shares from the specified parties and reconstruct their secret.
     * Use this function in a party that will receive some answer/value but does not have a share of it.
     * @method receive_open
     * @memberof jiff-instance
     * @instance
     * @param {Array} senders - an array with party ids (1 to n) specifying the parties sending the shares.
     * @param {Array} [receivers=all_parties] - an array with party ids (1 to n) specifying the parties receiving the result.
     * @param {number} [threshold=senders.length] - the min number of parties needed to reconstruct the secret, defaults to all the senders.
     * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
     * @param {string|number} [op_id=auto_Gen()] - same as jiff-instance.open
     * @returns {promise} a (JQuery) promise to the open value of the secret.
     */
    jiff.receive_open = function (senders, receivers, threshold, Zp, op_id) {
      if (senders == null) {
        throw new Error('Must provide "senders" parameter in receive_open');
      }
      if (Zp == null) {
        Zp = jiff.Zp;
      }
      return jiff_open(jiff, jiff.secret_share(jiff, true, null, null, senders, (threshold == null ? senders.length : threshold), Zp), receivers, op_id);
    };

    /**
     * Requests secret(s) from the server (crypto provider) of type matching the given label.
     * @method from_crypto_provider
     * @memberof jiff-instance
     * @instance
     * @param {string} label - the type of secret(s) being requested from crypto_provider (e.g. triplet, bit, etc)
     * @param {Array} [receivers_list=all_parties] - array of party ids that want to receive the secret(s), by default, this includes all parties.
     * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret(s).
     * @param {number} [Zp=jiff_instance.Zp] - the mod, defaults to the Zp of the instance.
     * @param {string} [op_id=auto_Gen()] - an id which is used to identify the secret requested, so that every party
     *                              gets a share from the same secret for every matching instruction. An automatic id
     *                              is generated by increasing a local counter per label, default ids suffice when all
     *                              parties execute all instructions in the same order.
     * @returns {promise} a promise to the secret(s) provided by the server/crypto provider, the promise returns an object with the given format:
     *                               { values: <any values returned by the server side>, shares: <array of secret share objects matching shares returned by server by index>}
     */
    jiff.from_crypto_provider = function (label, receivers_list, threshold, Zp, op_id, params) {
      return from_crypto_provider(jiff, label, receivers_list, threshold, Zp, op_id, params);
    };

    /**
     * A collection of useful protocols to be used during computation or preprocessing: extensions are encouraged to add useful
     * common protocols here, under a sub namespace corresponding to the extension name.
     * @memberof jiff-instance
     * @namespace protocols
     */
    jiff.protocols = {};

    /**
     * share an existing share (value) under a new threshold or to a new set of parties. Should not be used to refresh a share (use share.refresh() instead).
     * @method reshare
     * @instance
     * @memberof jiff-instance.protocols
     * @param {secret_share} [share=null] - the share you would like to reshare (null if you are a receiver but not a sender).
     * @param {number} [threshold=receivers_list.length] - the new threshold, defaults to the length of receivers_list param
     * @param {Array} [receivers_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
     * @param {Array} [senders_list=all_parties] - array of party ids that posses the share and will reshare it with the receivers, by default, this includes all parties.
     * @param {number} [Zp=jiff.Zp] - the Zp of the existing share.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this multiplication (and internally, the corresponding beaver triplet).
     *                         This id must be unique, and must be passed by all parties to the same instruction.
     *                         this ensures that every party gets a share from the same triplet for every matching instruction. An automatic id
     *                         is generated by increasing a local counter, default ids suffice when all parties execute the
     *                         instructions in the same order.
     * @return {SecretShare} this party's share of the result under the new threshold, or null if this party is not a receiver.
     */
    jiff.protocols.reshare = function (share, threshold, receivers_list, senders_list, Zp, op_id) {
      var i;

      // default values
      if (receivers_list == null) {
        receivers_list = [];
        for (i = 1; i <= jiff.party_count; i++) {
          receivers_list.push(i);
        }
      }
      if (senders_list == null) {
        senders_list = [];
        for (i = 1; i <= jiff.party_count; i++) {
          senders_list.push(i);
        }
      }

      if (threshold == null) {
        threshold = receivers_list.length;
      }
      if (Zp == null) {
        Zp = jiff.Zp;
      }

      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('reshare', senders_list);
      }

      // Check if this party is a sender or receiver
      var isSender = senders_list.indexOf(jiff.id) > -1;
      var isReceiver = receivers_list.indexOf(jiff.id) > -1;
      if (!isSender && !isReceiver) {
        return null;
      }

      // optimization, if nothing changes, keep share
      if (share != null && JSON.stringify(receivers_list) === JSON.stringify(senders_list) && threshold === share.threshold) {
        return share;
      }

      // Setup the result
      var final_deferred;
      var result = null;
      if (isReceiver) {
        final_deferred = new jiff.helpers.Deferred;
        result = jiff.secret_share(jiff, false, final_deferred.promise, undefined, receivers_list, threshold, Zp);
      }

      // This function is called when the share is ready: the value of the share has been received.
      var ready_share = function () {
        var intermediate_shares = jiff.internal_share(isSender ? share.value : null, threshold, receivers_list, senders_list, Zp, op_id);

        if (isReceiver) {
          var promises = [];
          for (var i = 0; i < senders_list.length; i++) {
            var party_id = senders_list[i];
            promises.push(intermediate_shares[party_id].promise);
          }

          // Reconstruct share under new threshold
          Promise.all(promises).then(function () {
            var reconstruct_parts = [];
            for (var i = 0; i < senders_list.length; i++) {
              var party_id = senders_list[i];
              //shamir reconstruct takes an array of objects
              //has attributes: {value: x, sender_id: y, Zp: jiff_instance.Zp}
              reconstruct_parts[i] = {value: intermediate_shares[party_id].value, sender_id: party_id, Zp: Zp};
            }
            var value = jiff.hooks.reconstructShare(jiff, reconstruct_parts);
            final_deferred.resolve(value);
          });
        }
      };

      if (isSender && !share.ready) {
        share.promise.then(ready_share);
      } else { // either a receiver or share is ready
        ready_share();
      }

      return result;
    };

    /**
     * Creates shares of an unknown random number. Every party comes up with its own random number and shares it.
     * Then every party combines all the received shares to construct one share of the random unknown number.
     * @method generate_random_number
     * @memberof jiff-instance.protocols
     * @instance
     * @param {number} threshold - the min number of parties needed to reconstruct the secret after it is computed.
     * @param {Array} receivers_list - array of party ids to receive the result.
     * @param {Array} compute_list - array of party ids to perform the protocol.
     * @param {number} Zp - the mod.
     * @param {object} params - an object containing extra parameters passed by the user.
     *                                 Expects:
     *                               - op_id: the base id to use for operation during the execution of this protocol, defaults to auto generated.
     *                               - compute_threshold: the threshold to use during computation: defaults to compute_list.length
     * @return {Object} contains 'share' (this party's share of the result) and 'promise'.
     */
    jiff.protocols.generate_random_number = function (threshold, receivers_list, compute_list, Zp, params) {
      if (params.op_id == null) {
        params.op_id = jiff.counters.gen_op_id2('generate_random_number', receivers_list, compute_list);
      }
      return jiff_share_all_number(jiff, jiff.helpers.random(Zp), threshold, receivers_list, compute_list, Zp, params);
    };

    /**
     * Creates shares of 0, such that no party knows the other parties' shares.
     * Every party secret shares 0, then every party sums all the shares they received, resulting
     * in a new share of 0 for every party.
     * @method generate_zero
     * @memberof jiff-instance.protocols
     * @instance
     * @param {number} threshold - the min number of parties needed to reconstruct the secret after it is computed.
     * @param {Array} receivers_list - array of party ids to receive the result.
     * @param {Array} compute_list - array of party ids to perform the protocol.
     * @param {number} Zp - the mod.
     * @param {object} params - an object containing extra parameters passed by the user.
     *                                 Expects:
     *                               - op_id: the base id to use for operation during the execution of this protocol, defaults to auto generated.
     *                               - compute_threshold: the threshold to use during computation: defaults to compute_list.length
     * @return {Object} contains 'share' (this party's share of the result) and 'promise'.
     */
    jiff.protocols.generate_zero = function (threshold, receivers_list, compute_list, Zp, params) {
      if (params.op_id == null) {
        params.op_id = jiff.counters.gen_op_id2('generate_random_number', receivers_list, compute_list);
      }
      return jiff_share_all_number(jiff, 0, threshold, receivers_list, compute_list, Zp, params);
    };

    /**
     * Creates shares of r and x, such that r is a uniform random number between 0 and Zp, and x is floor(r/constant)
     * where constant is provided by the extra params.
     * @method generate_random_and_quotient
     * @memberof jiff-instance.protocols
     * @instance
     * @param {number} threshold - the min number of parties needed to reconstruct the secret after it is computed.
     * @param {Array} receivers_list - array of party ids to receive the result.
     * @param {Array} compute_list - array of party ids to perform the protocol.
     * @param {number} Zp - the mod.
     * @param {object} params - an object containing extra parameters passed by the user.
     *                                 Expects:
     *                               - op_id: the base id to use for operation during the execution of this protocol, defaults to auto generated.
     *                               - compute_threshold: the threshold to use during computation: defaults to compute_list.length
     *                               - constant: the constant to divide the random number by.
     *                               - output_op_id: the set op id of the output quotient and noise.
     * @return {Object} contains 'share' (this party's share of the result) and 'promise'.
     */
    jiff.protocols.generate_random_and_quotient = function (threshold, receivers_list, compute_list, Zp, params, protocols) {
      // consistent and unique op_id for compute and receiver parties
      if (params.op_id == null) {
        params.op_id = jiff.counters.gen_op_id2('generate_random_and_quotient', receivers_list, compute_list);
      }
      if (params.compute_threshold == null) {
        params.compute_threshold = Math.floor((compute_list.length + 1) / 2); // honest majority BGW
      }

      // read only copy
      var _params = params;

      var promise = null;
      // do preprocessing for this function
      if (params.ondemand !== true) {
        var intermediate_output_op_id = params.constant != null ? params.op_id : params.output_op_id;
        params = Object.assign({}, _params);
        params.op_id = params.op_id + ':preprocessing';
        params.output_op_id = intermediate_output_op_id;
        promise = jiff.__preprocessing('__generate_random_and_quotient', 1, protocols, params.compute_threshold, compute_list, compute_list, Zp, [intermediate_output_op_id], params);
      }

      // execute the actual function
      if (_params.constant == null) {
        return {share: { ondemand: true }, promise: promise};
      }

      var constant = _params.constant;
      var op_id = _params.op_id;

      // stores the result
      var r, q;

      // for compute parties
      var promise;
      if (compute_list.indexOf(jiff.id) > -1) {
        var largest_quotient, largest_multiple;
        if (Zp.isBigNumber === true) {
          largest_quotient = Zp.div(constant).floor();
          largest_multiple = largest_quotient.times(constant);
        } else {
          largest_quotient = Math.floor(Zp / constant);
          largest_multiple = largest_quotient * constant;
        }

        // Uniform random number between 0 and Zp
        var r_bits = jiff.get_preprocessing(op_id + ':rejection1');
        var cmp = jiff.protocols.bits.cgteq(r_bits, largest_multiple, op_id + ':bits_cgteq');
        var r1 = jiff.protocols.bits.bit_composition(r_bits); // assume cmp = 1

        // assume cmp = 0
        params = Object.assign({}, _params);
        params.op_id = op_id + ':rejection2';
        params.upper_bound = largest_quotient;
        var div = jiff.protocols.bits.rejection_sampling(params.compute_threshold, compute_list, compute_list, Zp, params, protocols).share;
        div = jiff.protocols.bits.bit_composition(div);

        params = Object.assign({}, params);
        params.op_id = op_id + ':rejection3';
        params.upper_bound = constant;
        var mod = jiff.protocols.bits.rejection_sampling(params.compute_threshold, compute_list, compute_list, Zp, params, protocols).share;
        mod = jiff.protocols.bits.bit_composition(mod);
        var r2 = div.icmult(constant).isadd(mod);

        // choose either (r1, largest_quotient) or (r2, div) based on cmp result
        r = cmp.iif_else(r1, r2, op_id + ':ifelse1');
        q = cmp.iif_else(largest_quotient, div, op_id + ':ifelse2');
        promise = Promise.all([r.promise, q.promise]);
      }

      // reshare the result with the designated receivers
      r = jiff.protocols.reshare(r, threshold, receivers_list, compute_list, Zp, op_id + ':reshare1');
      q = jiff.protocols.reshare(q, threshold, receivers_list, compute_list, Zp, op_id + ':reshare2');

      // return result
      if (receivers_list.indexOf(jiff.id) > -1) {
        promise = Promise.all([r.promise, q.promise]);
      }
      return {share: {r: r, q: q}, promise: promise};
    };

    /**
     * generation of beaver triplet via MPC, uses the server for communication channels, but not for generation.
     * @method generate_beaver_bgw
     * @memberof jiff-instance.protocols
     * @instance
     * @param {number} threshold - the threshold of the triplets when stored by receivers after generation.
     * @param {Array} receivers_list - array of party ids that want to receive the triplet shares.
     * @param {Array} compute_list - array of party ids that will perform this protocol.
     * @param {number} Zp - the mod.
     * @param {object} params - an object containing extra parameters passed by the user.
     *                               Expects:
     *                               - op_id: the base id to use for operation during the execution of this protocol, defaults to auto generated.
     *                               - an optional number compute_threshold parameter, which specifies threshold used
     *                               during the protocol execution. By default, this is the length of the (compute_list+1)/2.
     * @param {object} protocols - the sub protocols to use for preprocessing.
     * @return {object} all pre-processing protocols must return an object with these keys:
     *  {
     *    'share': the share(s)/value(s) to store attached to op_id for later use by the computation (i.e. the result of preprocessing),
     *    'promise': a promise for when this protocol is fully completed (could be null if the protocol was already completed)
     *  }
     *  In this case, 'share' is an array of this party's shares of the resulting triplet, a,b,c such that a*b=c.
     */
    jiff.protocols.generate_beaver_bgw = function (threshold, receivers_list, compute_list, Zp, params, protocols) {
      if (params.compute_threshold == null) {
        params.compute_threshold = Math.floor((compute_list.length + 1) / 2); // honest majority BGW
      }
      if (params.op_id == null) {
        params.op_id = jiff.counters.gen_op_id2('generate_beaver_bgw', receivers_list, compute_list);
      }
      var op_id = params.op_id;
      var _params = params;

      var a, b, c, promises;
      if (compute_list.indexOf(jiff.id) > -1) {
        params = Object.assign({}, _params);
        params.op_id = op_id + ':share_a';
        a = protocols.generate_random_number(params.compute_threshold, compute_list, compute_list, Zp, params, protocols).share;

        params = Object.assign({}, _params);
        params.op_id = op_id + ':share_b';
        b = protocols.generate_random_number(params.compute_threshold, compute_list, compute_list, Zp, params, protocols).share;

        c = a.ismult_bgw(b, op_id + ':smult_bgw');
        promises = [a.promise, b.promise, c.promise];
      }

      a = jiff.protocols.reshare(a, threshold, receivers_list, compute_list, Zp, op_id + ':reshare_a');
      b = jiff.protocols.reshare(b, threshold, receivers_list, compute_list, Zp, op_id + ':reshare_b');
      c = jiff.protocols.reshare(c, threshold, receivers_list, compute_list, Zp, op_id + ':reshare_c');
      if (receivers_list.indexOf(jiff.id) > -1) {
        promises = [a.promise, b.promise, c.promise];
      }

      return { share: [a, b, c], promise: Promise.all(promises) };
    };

    /**
     * generates a random bit under MPC by xoring all bits sent by participating parties
     * @method generate_random_bit_bgw
     * @memberof jiff-instance.protocols
     * @instance
     * @param {number} threshold - the min number of parties needed to reconstruct the secret after it is computed.
     * @param {Array} receivers_list - array of party ids to receive the result.
     * @param {Array} compute_list - array of party ids to perform the protocol.
     * @param {number} Zp - the mod.
     * @param {object} params - an object containing extra parameters passed by the user.
     *                                 Expects:
     *                               - op_id: the base id to use for operation during the execution of this protocol, defaults to auto generated.
     *                               - compute_threshold: the threshold to use during computation: defaults to compute_list.length
     * @return {Object} contains 'share' (this party's share of the generated bit) and 'promise'.
     */
    jiff.protocols.generate_random_bit_bgw  = function (threshold, receivers_list, compute_list, Zp, params) {
      if (params.op_id == null) {
        params.op_id = jiff.counters.gen_op_id2('generate_random_bit_bgw', receivers_list, compute_list);
      }
      if (params.compute_threshold == null) {
        params.compute_threshold = Math.floor((compute_list.length + 1) / 2); // honest majority BGW
      }

      var op_id = params.op_id;

      // Generate random bit
      var random_bit, promise;
      if (compute_list.indexOf(jiff.id) > -1) {
        var bit = jiff.helpers.random(2);
        var bit_shares = jiff.internal_share(bit, params.compute_threshold, compute_list, compute_list, Zp, op_id + ':share');

        random_bit = bit_shares[compute_list[0]];
        for (var i = 1; i < compute_list.length; i++) {
          var party_id = compute_list[i];
          var obit = bit_shares[party_id];
          random_bit = random_bit.isadd(obit).issub(random_bit.ismult_bgw(obit, op_id + ':smult' + i).icmult(2));
        }

        promise = random_bit.promise;
      }

      // Reshare
      random_bit = jiff.protocols.reshare(random_bit, threshold, receivers_list, compute_list, Zp, op_id+':reshare');
      if (receivers_list.indexOf(jiff.id) > -1) {
        promise = random_bit.promise;
      }
      return { share: random_bit, promise: promise };
    };

    /**
     * generates a sequence of random bits under MPC.
     * @method generate_random_bits
     * @memberof jiff-instance.protocols
     * @instance
     * @param {number} [threshold=receivers_list.length] - the threshold of the bit when stored by receivers after generation.     * @param {number} threshold - the min number of parties needed to reconstruct the secret after it is computed.
     * @param {Array} receivers_list - array of party ids to receive the result.
     * @param {Array} compute_list - array of party ids to perform the protocol.
     * @param {number} Zp - the mod.
     * @param {object} params - an object containing extra parameters passed by the user.
     *                                 Expects:
     *                               - op_id: the base id to use for operation during the execution of this protocol, defaults to auto generated.
     *                               - count: how many random bits to generate.
     *                               - compute_threshold: the threshold to use during computation: defaults to compute_list.length
     * @param {object} protocols - the protocols to use for preprocessing.
     * @return {Object} contains 'share' (array of secret shares bits) and 'promise'.
     */
    jiff.protocols.generate_random_bits = function (threshold, receivers_list, compute_list, Zp, params, protocols) {
      if (params.count == null) {
        params.count = 1;
      }
      if (params.op_id == null) {
        params.op_id = jiff.counters.gen_op_id2('generate_random_bits', receivers_list, compute_list);
      }

      var op_id = params.op_id;
      var _params = params;

      var promises = [];
      var bits = [];
      for (var i = 0; i < params.count; i++) {
        params = Object.assign({}, _params);
        params.op_id = op_id + ':' + i;

        var bit = protocols.generate_random_bit(threshold, receivers_list, compute_list, Zp, params, protocols);

        promises.push(bit.promise);
        if (bit.share != null) {
          bits.push(bit.share);
        }
      }

      if (bits.length === 0) {
        bits = null;
      }
      return {share: bits, promise: Promise.all(promises)};
    };

    /**
     * A collection of useful protocols for manipulating bitwise shared numbers, and transforming them from and to regular numeric shares.
     * @memberof jiff-instance.protocols
     * @namespace bits
     */
    jiff.protocols.bits = {};

    /**
     * Creates a secret share of the number represented by the given array of secret shared bits.
     * Requires no communication, only local operations.
     * @method bit_composition
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - an array of the secret shares of bits, starting from least to most significant bits.
     * @returns {SecretShare} a secret share of the number represented by bits.
     */
    jiff.protocols.bits.bit_composition = function (bits) {
      var result = bits[0];
      var pow = 1;
      for (var i = 1; i < bits.length; i++) {
        pow = pow * 2;
        result = result.isadd(bits[i].icmult(pow));
      }
      return result;
    };

    /**
     * Share a number as an array of secret bits
     * This takes the same parameters as jiff-instance.share, but returns an array of secret bit shares per sending party.
     * Each bit array starts with the least significant bit at index 0, and most significant bit at index length-1.
     * @method share_bits
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {number} secret - the number to share (this party's input)
     * @param {number} [bit_length=jiff_instance.Zp] - the number of generated bits, if the secret has less bits, it will be
     *                                                 padded with zeros.
     * @param {number} [threshold=receivers_list.length] - threshold of each shared bit.
     * @param {Array} [receivers_list=all_parties] - receivers of every bits.
     * @param {Array} [senders_list=all_parties] - senders of evey bit.
     * @param {number} [Zp=jiff_instance.Zp] - the field of sharing for every bit.
     * @param {string|number} [share_id=auto_gen()] - synchronization id.
     * @returns {object} a map (of size equal to the number of parties)
     *          where the key is the party id (from 1 to n)
     *          and the value is an array of secret shared bits.
     */
    jiff.protocols.bits.share_bits = function (secret, bit_length, threshold, receivers_list, senders_list, Zp, share_id) {
      var i;
      if (Zp == null) {
        Zp = jiff.Zp;
      }
      if (receivers_list == null) {
        receivers_list = [];
        for (i = 1; i <= jiff.party_count; i++) {
          receivers_list.push(i);
        }
      }
      if (senders_list == null) {
        senders_list = [];
        for (i = 1; i <= jiff.party_count; i++) {
          senders_list.push(i);
        }
      }

      if (share_id == null) {
        share_id = jiff.counters.gen_op_id2('share_bits', receivers_list, senders_list);
      }

      if (bit_length == null) {
        bit_length = Zp.toString(2).length;
      }

      // to allow for secret=null when party is not a sender
      var local_bits = [];
      if (secret != null) {
        local_bits = jiff.helpers.number_to_bits(secret, bit_length);
      }

      var shared_bits = {};
      for (i = 0; i < senders_list.length; i++) {
        shared_bits[senders_list[i]] = [];
      }

      for (i = 0; i < bit_length; i++) {
        var round = jiff.internal_share(local_bits[i], threshold, receivers_list, senders_list, Zp, share_id + ':' + i);
        for (var si = 0; si < senders_list.length; si++) {
          var pid = senders_list[si];
          shared_bits[pid].push(round[pid]);
        }
      }

      return shared_bits;
    };

    /**
     * Opens the given array of secret shared bits.
     * This works regardless of whether the represented value fit inside the corresponding field or not.
     * @method open
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - an array of the secret shares of bits, starting from least to most significant bits.
     * @param {number[]} parties - parties to open (same as jiff_instance.open)
     * @param {string|number} [op_id=auto_gen()] - same as jiff_instance.open
     * @returns {promise} a promise to the number represented by bits.
     */
    jiff.protocols.bits.open = function (bits, parties, op_id) {
      // Default values
      if (parties == null || parties === []) {
        parties = [];
        for (var p = 1; p <= jiff.party_count; p++) {
          parties.push(p);
        }
      }

      // Compute operation ids (one for each party that will receive a result
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id2('bits.open', parties, bits[0].holders);
      }

      var opened_bits = [];
      for (var i = 0; i < bits.length; i++) {
        opened_bits[i] = jiff.internal_open(bits[i], parties, op_id + ':' + i);
      }

      return Promise.all(opened_bits).then(function (bits) {
        return jiff.helpers.bits_to_number(bits, bits.length);
      });
    };

    /**
     * Receives an opening of an array of secret bits without owning shares of the underlying value.
     * Similar to jiff.receive_open() but for bits.
     * This works regardless of whether the represented value fit inside the corresponding field or not.
     * @method receive_open
     * @memberOf jiff-instance.protocols.bits
     * @instance
     * @param {Array} senders - an array with party ids (1 to n) specifying the parties sending the shares.
     * @param {Array} [receivers=all_parties] - an array with party ids (1 to n) specifying the parties receiving the result.
     * @param {number} [count=ceil(log2(Zp))] - the number of bits being opened.
     * @param {number} [threshold=parties.length] - the min number of parties needed to reconstruct the secret, defaults to all the senders.
     * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
     * @param {string|number|object} [op_id=auto_gen()] - unique and consistent synchronization id between all parties.
     * @returns {promise} a (JQuery) promise to the open value of the secret.
     */
    jiff.protocols.bits.receive_open = function (senders, receivers, count, threshold, Zp, op_id) {
      if (senders == null) {
        throw new Error('Must provide "senders" parameter in receive_open');
      }
      // Default values
      if (receivers == null) {
        receivers = [];
        for (i = 1; i <= jiff.party_count; i++) {
          receivers.push(i);
        }
      }

      if (op_id == null) {
        op_id = jiff.counters.gen_op_id2('bits.open', receivers, senders);
      }

      if (count == null) {
        if (Zp == null) {
          Zp = jiff.Zp;
        }
        count = Zp.toString(2).length;
      }

      var opened_bits = [];
      for (var i = 0; i < count; i++) {
        opened_bits[i] = jiff.receive_open(senders, receivers, threshold, Zp, op_id + ':' + i);
      }

      return Promise.all(opened_bits).then(function (bits) {
        return jiff.helpers.bits_to_number(bits, bits.length);
      });
    };

    /**
     * Checks whether the given bitwise secret shared number and numeric constant are equal.
     * @method ceq
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - an array of secret shares of bits, starting from least to most significant bits.
     * @param {number} constant - the constant number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare|boolean} a secret share of 1 if parameters are equal, 0 otherwise. If result is known
     *                                (e.g. constant has a greater non-zero bit than bits' most significant bit), the result is
     *                                returned immediately as a boolean.
     */
    jiff.protocols.bits.ceq = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.ceq)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.ceq', bits[0].holders);
      }
      var result = jiff.protocols.bits.cneq(bits, constant, op_id);
      if (result === true || result === false) {
        return !result;
      }
      return result.inot();
    };

    /**
     * Checks whether the given bitwise secret shared number and numeric constant are not equal.
     * @method cneq
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - an array of secret shares of bits, starting from least to most significant bits.
     * @param {number} constant - the constant number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare|boolean} a secret share of 1 if parameters are not equal, 0 otherwise. If result is known
     *                                (e.g. constant has a greater non-zero bit than bits' most significant bit), the result is
     *                                returned immediately as a boolean.
     */
    jiff.protocols.bits.cneq = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.cneq)');
      }

      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.cneq', bits[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits = bits.slice();

      var constant_bits = jiff.helpers.number_to_bits(constant, bits.length);
      if (constant_bits.length > bits.length) {
        // Optimization: if constant has more bits, one of them must be 1, constant must be greater than bits.
        return true;
      }

      var deferred = new jiff.helpers.Deferred();
      var result = jiff.secret_share(jiff, false, deferred.promise, undefined, bits[0].holders, bits[0].threshold, bits[0].Zp);

      // big or of bitwise XORs
      var initial = bits[0].icxor_bit(constant_bits[0]);
      bit_combinator(deferred, 1, bits.length, initial, function (i, prev) {
        var xor = bits[i].icxor_bit(constant_bits[i]);
        xor = prev.isor_bit(xor, op_id + ':sor_bit:' + (i - 1));
        return xor;
      });

      return result;
    };

    /**
     * Checks whether given secret shared bits are greater than the given constant.
     * @method cgt
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - an array of the secret shares of bits, starting from least to most significant bits.
     * @param {number} constant - the constant number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare|boolean} a secret share of 1 if bits are greater than constant, 0 otherwise, if result is known
     *                                (e.g. constant has greater non-zero bit than bits' most significant bit), the result is
     *                                returned immediately as a boolean.
     */
    jiff.protocols.bits.cgt = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.cgt)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.cgt', bits[0].holders);
      }
      return jiff.protocols.bits.cgteq(bits, constant+1, op_id);
    };

    /**
     * Checks whether given secret shared bits are greater or equal to the given constant.
     * @method cgteq
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - an array of the secret shares of bits, starting from least to most significant bits.
     * @param {number} constant - the constant number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare|boolean} a secret share of 1 if bits are greater or equal to constant, 0 otherwise, if result is known
     *                                (e.g. constant has greater non-zero bit than bits' most significant bit or constant is zero), the result is
     *                                returned immediately as a boolean.
     */
    jiff.protocols.bits.cgteq = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.cgteq)');
      }

      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.cgteq', bits[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits = bits.slice();

      // Optimization: the bits are a share of non-negative number, if constant <= 0, return true
      if (constant.toString().startsWith('-') || constant.toString() === '0') {
        return true;
      }

      // decompose result into bits
      var constant_bits = jiff.helpers.number_to_bits(constant, bits.length);
      if (constant_bits.length > bits.length) {
        // Optimization: if constant has more bits, one of them must be 1, constant must be greater than bits.
        return false;
      }

      // initialize result
      var deferred = new jiff.helpers.Deferred();
      var result = jiff.secret_share(jiff, false, deferred.promise, undefined, bits[0].holders, bits[0].threshold, bits[0].Zp);

      // Subtract bits2 from bits1, only keeping track of borrow
      var borrow = bits[0].inot().icmult(constant_bits[0]);

      // compute one bit at a time, propagating borrow
      bit_combinator(deferred, 1, bits.length, borrow, function (i, borrow) {
        var xor = bits[i].icxor_bit(constant_bits[i]);
        var andNot = bits[i].inot().icmult(constant_bits[i]);

        // save and update borrow
        borrow = xor.inot().ismult(borrow, op_id + ':smult:' + (i - 1));
        return borrow.isadd(andNot);
      });

      return result.inot();
    };

    /**
     * Checks whether given secret shared bits are less than the given constant.
     * @method clt
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - an array of the secret shares of bits, starting from least to most significant bits.
     * @param {number} constant - the constant number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare|boolean} a secret share of 1 if bits are less than the constant, 0 otherwise, if result is known
     *                                (e.g. constant has greater non-zero bit than bits' most significant bit), the result is
     *                                returned immediately as a boolean.
     */
    jiff.protocols.bits.clt = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.clt)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.clt', bits[0].holders);
      }
      var result = jiff.protocols.bits.cgteq(bits, constant, op_id);
      if (result === true || result === false) {
        return !result;
      }
      return result.inot();
    };

    /**
     * Checks whether given secret shared bits are less or equal to the given constant.
     * @method clteq
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - an array of the secret shares of bits, starting from least to most significant bits.
     * @param {number} constant - the constant number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare|boolean} a secret share of 1 if bits are less or equal to constant, 0 otherwise, if result is known
     *                                (e.g. constant has greater non-zero bit than bits' most significant bit), the result is
     *                                returned immediately as a boolean.
     */
    jiff.protocols.bits.clteq = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.clteq)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.clteq', bits[0].holders);
      }
      var result = jiff.protocols.bits.cgt(bits, constant, op_id);
      if (result === true || result === false) {
        return !result;
      }
      return result.inot();
    };

    // private
    var __rejection_sampling = function (lower_bound, upper_bound, compute_list, Zp, params, protocols) {
      // Figure out sampling range
      var range;
      if (upper_bound.isBigNumber === true) {
        range = upper_bound.minus(lower_bound);
      } else {
        range = upper_bound - lower_bound;
      }

      // Figure out final bit size (after adding back lower)
      var finalLength = jiff.helpers.ceil(jiff.helpers.bLog(upper_bound, 2));
      finalLength = parseInt(finalLength.toString(), 10);
      finalLength = Math.max(finalLength, 1); // special case: when upper_bound is 1!

      // Special cases
      if (range.toString() === '0') {
        throw new Error('rejection sampling called with range 0, no numbers to sample!');
      }
      if (range.toString() === '1') {
        var zero = protocols.generate_zero(params.compute_threshold, compute_list, compute_list, Zp, params, protocols).share;
        // special case: cadd can be performed locally on bit arrays of length 1!
        var resultOne = jiff.protocols.bits.cadd([zero], lower_bound);
        while (resultOne.length > finalLength) {
          resultOne.pop();
        }
        return resultOne;
      }

      // Transform sampling range into bit size
      var bitLength = jiff.helpers.ceil(jiff.helpers.bLog(range, 2));
      bitLength = parseInt(bitLength.toString(), 10);

      // Create output array of bit shares
      var many_shares = many_secret_shares(jiff, finalLength, compute_list, params.compute_threshold, Zp);
      var deferreds = many_shares.deferreds;
      var result = many_shares.shares;

      // Sample and resample output
      (function resample(reject_count) {
        var paramsCopy = Object.assign({}, params);
        paramsCopy['count'] = bitLength;
        paramsCopy['op_id'] = params.op_id + ':sampling:' + reject_count;
        var bits = protocols.generate_random_bits(params.compute_threshold, compute_list, compute_list, Zp, paramsCopy, protocols).share;

        // Rejection protocol
        var online_resample = function () {
          var bits_add = bits;
          if (lower_bound.toString() !== '0') {
            bits_add = jiff.protocols.bits.cadd(bits, lower_bound, params.op_id + ':bits.cadd:' + reject_count);
          }

          var cmp = jiff.protocols.bits.clt(bits, range, params.op_id + ':bits.clt:' + reject_count);
          if (cmp === true) { // need to resample
            return resolve_many_secrets(deferreds, bits_add);
          } else if (cmp === false) {
            return resample(reject_count+1);
          }

          var promise = jiff.internal_open(cmp, compute_list, params.op_id + ':open:' + reject_count);
          promise.then(function (cmp) {
            if (cmp.toString() === '1') {
              return resolve_many_secrets(deferreds, bits_add);
            }
            resample(reject_count+1);
          });
        };

        // if run with pre-processing, do the pre-processing on demand
        if (jiff.crypto_provider === true) {
          online_resample();
        } else {
          // Request pre-processing during the protocol, since this protocol is meant to run in pre-processing itself,
          // and because we cannot know ahead of time how many rejections are needed to be pre-processed.
          paramsCopy = Object.assign({}, params);
          paramsCopy['namespace'] = 'base';
          paramsCopy['bitLength'] = bits.length;
          paramsCopy['op_id'] = params.op_id + ':preprocessing:bits.clt';

          var promises = [];
          if (jiff.helpers.bLog(range, 2).toString().indexOf('.') > -1) { // this is ok since range > 1 here.
            // we do not need to really do a comparison when range is a power of 2, we know the result is true!
            var promise1 = jiff.__preprocessing('bits.clt', 1, protocols, params.compute_threshold, compute_list, compute_list, Zp, [params.op_id + ':bits.clt:' + reject_count], paramsCopy);
            var promise2 = jiff.__preprocessing('open', 1, protocols, params.compute_threshold, compute_list, compute_list, Zp, [params.op_id + ':open:' + reject_count], paramsCopy);
            promises = [promise1, promise2];
          }

          if (lower_bound.toString() !== '0' && bitLength > 1) {
            // bits.cadd is free for arrays of length 1!
            paramsCopy['op_id'] = params.op_id + ':preprocessing:bits.cadd';
            var promise3 = jiff.__preprocessing('bits.cadd', 1, protocols, params.compute_threshold, compute_list, compute_list, Zp, [params.op_id + ':bits.cadd:' + reject_count], paramsCopy);
            promises.push(promise3);
          }
          Promise.all(promises).then(online_resample);
        }
      })(0);

      return result;
    };

    /**
     * Wrapper for when doing rejection sampling during pre processing.
     * @method rejection_sampling
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {number} [threshold=receivers_list.length] - the threshold of the resulting shares after sampling.
     * @param {Array} [receivers_list=all_parties] - array of party ids that want to receive the sampling shares, by default, this includes all parties.
     * @param {Array} [compute_list=all_parties] - array of party ids that will perform this protocol, by default, this includes all parties.
     * @param {number} [Zp=jiff-instance.Zp] - the mod (if null then the default Zp for the instance is used).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @param {object} [params={}] - an object containing extra parameters passed by the user.
     *                               Expects:
     *                               - an optional number compute_threshold parameter, which specifies threshold used
     *                               during the protocol execution. By default, this is (|compute_list|+1)/2.
     *                               - optional 'lower_bound' and 'upper_bound' numeric parameters, default to 0 and Zp respectively.
     *                               - op_id, the base op_id to tag operations inside this protocol with, defaults to auto generated.
     * @param {object} [protocols=defaults] - the protocols to use for preprocessing, any protocol(s) not provided will be replaced with defaults.
     * @returns {Object} an object containing keys: 'share', and 'promise'. The promise is resolved when the rejection sampling is completed.
     *                   The object is consumed by <jiff_instance>.preprocessing:
     *                        - 'share' attribute contains the resulting array of secret shared bits representing the sampled value, and is stored in the preprocessing table internally.
     *                        - The promise is consumed and a new promise is returned by <jiff_instance>.preprocessing that is resolved after this returned promise (and all other promise generated by that .preprocessing call) are resolved.
     */
    jiff.protocols.bits.rejection_sampling = function (threshold, receivers_list, compute_list, Zp, params, protocols) {
      // rejection sampling is both an internal preprocessing function and also user facing
      // must have defaults for simplicity of user-facing API!
      protocols = Object.assign({}, jiff.default_preprocessing_protocols, protocols);

      // Defaults (only for user facing case)
      if (compute_list == null) {
        compute_list = [];
        for (var p = 1; p <= jiff.party_count; p++) {
          compute_list.push(p);
        }
      }
      if (receivers_list == null) {
        receivers_list = [];
        for (p = 1; p <= jiff.party_count; p++) {
          receivers_list.push(p);
        }
      }
      threshold = threshold != null ? threshold : receivers_list.length;
      Zp = Zp != null ? Zp : jiff.Zp;
      params = params != null ? params : {};

      // If not a compute nor receiver party, return null (only for user facing case)
      if (compute_list.indexOf(jiff.id) === -1 && receivers_list.indexOf(jiff.id) === -1) {
        return null;
      }

      // More defaults (both user-facing and internal preprocessing)
      var lower_bound = params.lower_bound != null ? params.lower_bound : 0;
      var upper_bound = params.upper_bound != null ? params.upper_bound : Zp;
      if (params.compute_threshold == null) { // honest majority BGW
        params.compute_threshold = Math.floor((compute_list.length + 1) / 2);
      }
      if (params.op_id == null) { // op_id must be unique to both compute and receivers
        params.op_id = jiff.counters.gen_op_id2('rejection_sampling', receivers_list, compute_list);
      }
      var op_id = params.op_id;

      // execute protocol
      var result = [];
      var promises = [];
      if (compute_list.indexOf(jiff.id) > -1) {
        result = __rejection_sampling(lower_bound, upper_bound, compute_list, Zp, params, protocols);
        for (var j = 0; j < result.length; j++) {
          promises.push(result[j].promise);
        }
      }

      // fix threshold
      for (var i = 0; i < result.length; i++) {
        result[i] = jiff.protocols.reshare(result[i], threshold, receivers_list, compute_list, Zp, op_id + ':reshare:' + i);
        if (receivers_list.indexOf(jiff.id) > -1) {
          promises[i] = result[i].promise;
        }
      }

      // return output
      if (receivers_list.indexOf(jiff.id) === -1) {
        result = null;
      }
      return { share: result, promise: Promise.all(promises) };
    };

    /**
     * Compute sum of bitwise secret shared number and a constant.
     * @method cadd
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - the bit wise secret shares.
     * @param {number} constant - the constant.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for communication.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare[]} bitwise sharing of the result. Note that the length here will be max(|bits|, |constant|) + 1
     *                          in case of potential overflow / carry.
     */
    jiff.protocols.bits.cadd = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.cadd)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.cadd', bits[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits = bits.slice();

      // decompose constant into bits
      var constant_bits = jiff.helpers.number_to_bits(constant, bits.length); // pads with zeros to bits.length

      // initialize results
      var result = many_secret_shares(jiff, Math.max(constant_bits.length, bits.length), bits[0].holders, bits[0].threshold, bits[0].Zp);
      var deferreds = result.deferreds;
      result = result.shares;

      var sum = bits[0].icxor_bit(constant_bits[0]);
      var carry = bits[0].icmult(constant_bits[0]);

      // put initial bit at head of result array
      result.unshift(sum);
      deferreds.unshift(null);

      // compute sum one bit at a time, propagating carry
      bit_combinator(deferreds[deferreds.length-1], 1, deferreds.length-1, carry, function (i, carry) {
        var sum;
        if (i < bits.length) {
          var and = bits[i].icmult(constant_bits[i]);
          var xor = bits[i].icxor_bit(constant_bits[i]);
          var xorAndCarry = xor.ismult(carry, op_id + ':smult:' + (i - 1));

          sum = xor.isxor_bit(carry, op_id + ':sxor_bit:' + (i - 1));
          carry = and.isadd(xorAndCarry); // cheap or, xor and and cannot both be true!
        } else {
          // bits.length <= i < constant_bits.length
          // and is zero, xor is constant_bits[i]
          sum = carry.icxor_bit(constant_bits[i]);
          carry = carry.icmult(constant_bits[i]);
        }

        sum.wThen(deferreds[i].resolve);
        return carry;
      });

      return result;
    };

    /**
     * Compute [secret bits] - [constant bits].
     * @method csubl
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {number} constant - the constant.
     * @param {SecretShare[]} bits - the bit wise secret shares.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for communication.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare[]} bitwise sharing of the result. Note that the length of the returned result is |bits|+1, where
     *                          the bit at index 0 is the least significant bit. The bit at index 1 is the most significant bit,
     *                          and the bit at index |bits| is 1 if the result overflows, or 0 otherwise.
     */
    jiff.protocols.bits.csubl = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.csubl)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.csubl', bits[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits = bits.slice();

      // decompose constant into bits
      var constant_bits = jiff.helpers.number_to_bits(constant, bits.length); // pads with zeros to bits.length

      // initialize results
      var result = many_secret_shares(jiff, Math.max(constant_bits.length, bits.length), bits[0].holders, bits[0].threshold, bits[0].Zp);
      var deferreds = result.deferreds;
      result = result.shares;

      var diff = bits[0].icxor_bit(constant_bits[0]);
      var borrow = bits[0].inot().icmult(constant_bits[0]);

      // put initial bit at head of result array
      result.unshift(diff);
      deferreds.unshift(null);

      // compute diff one bit at a time, propagating borrow
      bit_combinator(deferreds[deferreds.length-1], 1, deferreds.length-1, borrow, function (i, borrow) {
        var diff;
        if (i < bits.length) {
          var xor = bits[i].icxor_bit(constant_bits[i]);
          var andNot = bits[i].inot().icmult(constant_bits[i]);

          // save and update borrow
          diff = xor.isxor_bit(borrow, op_id + ':sxor_bit:' + (i - 1));
          borrow = xor.inot().ismult(borrow, op_id + ':smult:' + (i - 1));
          borrow = borrow.isadd(andNot);
        } else {
          // bits.length <= i < constant_bits.length
          // xor and andNot are equal to the constant bit value since secret bit is always zero here
          diff = borrow.icxor_bit(constant_bits[i]);
          borrow = borrow.issub(borrow.icmult(constant_bits[i]));
          borrow = borrow.icadd(constant_bits[i]);
        }

        diff.wThen(deferreds[i].resolve);
        return borrow;
      });

      return result;
    };

    /**
     * Compute [constant bits] - [secret bits].
     * @method csubr
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {number} constant - the constant.
     * @param {SecretShare[]} bits - the bit wise secret shares.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for communication.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare[]} bitwise sharing of the result. Note that the length of the returned result is |bits|+1, where
     *                          the bit at index 0 is the least significant bit. The bit at index 1 is the most significant bit,
     *                          and the bit at index |bits| is 1 if the result overflows, or 0 otherwise.
     */
    jiff.protocols.bits.csubr = function (constant, bits, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.csubr)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.csubr', bits[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits = bits.slice();

      // decompose constant into bits
      var constant_bits = jiff.helpers.number_to_bits(constant, bits.length); // pads with zeros to bits.length

      // initialize results
      var result = many_secret_shares(jiff, Math.max(constant_bits.length, bits.length), bits[0].holders, bits[0].threshold, bits[0].Zp);
      var deferreds = result.deferreds;
      result = result.shares;

      var diff = bits[0].icxor_bit(constant_bits[0]);
      var borrow = bits[0].issub(bits[0].icmult(constant_bits[0]));

      // put initial bit at head of result array
      result.unshift(diff);
      deferreds.unshift(null);

      // compute diff one bit at a time, propagating borrow
      bit_combinator(deferreds[deferreds.length-1], 1, deferreds.length-1, borrow, function (i, borrow) {
        var diff;
        if (i < bits.length) {
          var xor = bits[i].icxor_bit(constant_bits[i]);
          var andNot = bits[i].issub(bits[i].icmult(constant_bits[i]));

          // save and update borrow
          diff = xor.isxor_bit(borrow, op_id + ':sxor_bit:' + (i - 1));
          borrow = xor.inot().ismult(borrow, op_id + ':smult:' + (i - 1));
          borrow = borrow.isadd(andNot);
        } else {
          // andNot is zero and xor is equal to the constant bit since secret bit is always zero here.
          diff = borrow.icxor_bit(constant_bits[i]);
          borrow = borrow.icmult(constant_bits[i] === 1 ? 0 : 1);
        }

        diff.wThen(deferreds[i].resolve);
        return borrow;
      });

      return result;
    };

    /**
     *
     * Compute [secret bits1] + [secret bits2].
     * @method sadd
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - the first bitwise shared number: array of secrets with index 0 being least significant bit.
     * @param {SecretShare[]} bits2 - the second bitwise shared number (length may be different).
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for communication.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare[]} bitwise sharing of the result. Note that the length of the returned result is |bits|+1, where
     *                          the bit at index 0 is the least significant bit.
     */
    jiff.protocols.bits.sadd = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.sadd', bits1[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits1 = bits1.slice();
      bits2 = bits2.slice();

      var tmp = bits1.length > bits2.length ? bits1 : bits2;
      bits2 = bits1.length > bits2.length ? bits2 : bits1; // shortest array
      bits1 = tmp; // longest array

      // initialize results
      var result = many_secret_shares(jiff, bits1.length, bits1[0].holders, Math.max(bits1[0].threshold, bits2[0].threshold), bits1[0].Zp);
      var deferreds = result.deferreds;
      result = result.shares;

      var sum = bits1[0].isxor_bit(bits2[0], op_id + ':sxor_bit:initial');
      var carry = bits1[0].ismult(bits2[0], op_id + ':smult:initial');

      // put initial bit at head of result array
      result.unshift(sum);
      deferreds.unshift(null);

      // compute sum one bit at a time, propagating carry
      bit_combinator(deferreds[deferreds.length-1], 1, deferreds.length-1, carry, function (i, carry) {
        var sum;
        if (i < bits2.length) {
          var and = bits1[i].ismult(bits2[i], op_id + ':smult1:' + (i - 1));
          var xor = bits1[i].isxor_bit(bits2[i], op_id + ':sxor_bit1:' + (i - 1));
          var xorAndCarry = xor.ismult(carry, op_id + ':smult2:' + (i - 1));

          sum = xor.isxor_bit(carry, op_id + ':sxor_bit2:' + (i - 1));
          carry = and.isadd(xorAndCarry); // cheap or, xor and and cannot both be true!
        } else {
          // and is always zero, xor is equal to bits1[i]
          sum = bits1[i].isxor_bit(carry, op_id + ':sxor_bit1:' + (i - 1));
          carry = bits1[i].ismult(carry, op_id + ':smult1:' + (i - 1));
        }

        sum.wThen(deferreds[i].resolve);
        return carry;
      });

      return result;
    };

    /**
     * Compute [secret bits1] - [secret bits2].
     * @method ssub
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - first bitwise secret shared number: lower indices represent less significant bits.
     * @param {SecretShare[]} bits2 - second bitwise secret shared number (length may be different).
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for communication.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare[]} bitwise sharing of the result. Note that the length of the returned result is |bits|+1, where
     *                          the bit at index 0 is the least significant bit. The bit at index 1 is the most significant bit,
     *                          and the bit at index |bits| is 1 if the result overflows, or 0 otherwise.
     */
    jiff.protocols.bits.ssub = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.ssub', bits1[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits1 = bits1.slice();
      bits2 = bits2.slice();

      // initialize results
      var result = many_secret_shares(jiff, Math.max(bits1.length, bits2.length), bits1[0].holders, Math.max(bits1[0].threshold, bits2[0].threshold), bits1[0].Zp);
      var deferreds = result.deferreds;
      result = result.shares;

      var diff = bits1[0].isxor_bit(bits2[0], op_id + ':sxor_bit:initial');
      var borrow = bits1[0].inot().ismult(bits2[0], op_id + ':smult:initial');

      // put initial bit at head of result array
      result.unshift(diff);
      deferreds.unshift(null);

      // compute diff one bit at a time, propagating borrow
      bit_combinator(deferreds[deferreds.length-1], 1, deferreds.length-1, borrow, function (i, borrow) {
        var diff;
        if (i < bits1.length && i < bits2.length) {
          var xor = bits1[i].isxor_bit(bits2[i], op_id + ':sxor_bit1:' + (i - 1));
          var andNot = bits1[i].inot().ismult(bits2[i], op_id + ':smult1:' + (i - 1));

          // save and update borrow
          diff = xor.isxor_bit(borrow, op_id + ':sxor_bit2:' + (i - 1));
          borrow = xor.inot().ismult(borrow, op_id + ':smult2:' + (i - 1));
          borrow = borrow.isadd(andNot);
        } else if (i < bits1.length) {
          // xor is equal to the value of bits1[i], andNot is equal to 0, since bits[2] is all zeros here
          diff = bits1[i].isxor_bit(borrow, op_id + ':sxor_bit1:' + (i - 1));
          borrow = bits1[i].inot().ismult(borrow, op_id + ':smult1:' + (i - 1));
        } else { // i < bits2.length
          // xor and andNot are equal to the value of bits2[i]
          diff = bits2[i].isxor_bit(borrow, op_id + ':sxor_bit1:' + (i - 1));
          borrow = bits2[i].inot().ismult(borrow, op_id + ':smult1:' + (i - 1));
          borrow = borrow.isadd(bits2[i]);
        }

        diff.wThen(deferreds[i].resolve);
        return borrow;
      });

      return result;
    };

    /**
     * Compute [secret bits] * constant.
     * @method cmult
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - bitwise shared secret to multiply: lower indices represent less significant bits.
     * @param {number} constant - constant to multiply with.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for communication.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare[]} bitwise sharing of the result, the length of the result will be bits.length + ceil(log2(constant)), except
     *                          if constant is zero, the result will then be [ zero share ].
     */
    jiff.protocols.bits.cmult = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.cmult)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.cmult', bits[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits = bits.slice();

      // decompose constant into bits
      var constant_bits = jiff.helpers.number_to_bits(constant); // do not pad

      // Initialize the result
      var result = many_secret_shares(jiff, bits.length + constant_bits.length, bits[0].holders, bits[0].threshold, bits[0].Zp);
      var deferreds = result.deferreds;
      result = result.shares;

      // Resolve result when ready
      var final_deferred = new jiff.helpers.Deferred();
      final_deferred.promise.then(resolve_many_secrets.bind(null, deferreds));

      // get useless share of zero (just for padding)
      var zero = jiff.secret_share(jiff, true, null, 0, bits[0].holders, bits[0].threshold, bits[0].Zp);
      var initial = [ zero ];

      // special case
      if (constant.toString() === '0') {
        return initial;
      }

      // main function
      bit_combinator(final_deferred, 0, constant_bits.length, initial, function (i, intermediate) {
        // Shift bits to create the intermediate values,
        // and sum if the corresponding bit in a is 1
        if (constant_bits[i].toString() === '1') {
          intermediate = jiff.protocols.bits.sadd(intermediate, bits, op_id + ':bits.sadd:' + i);
        }

        bits.unshift(zero);
        return intermediate;
      }, function (intermediate) {
        // promise-ify an array of intermediate results
        var promises = [];
        for (var i = 0; i < intermediate.length; i++) {
          promises.push(intermediate[i].promise);
        }
        return Promise.all(promises);
      }, function (result) {
        // identity
        return result;
      });

      return result;
    };

    /**
     * Compute [secret bits1] * [secret bits2].
     * @method smult
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - bitwise shared secret to multiply: lower indices represent less significant bits.
     * @param {SecretShare[]} bits2 - bitwise shared secret to multiply.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for communication.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare[]} bitwise sharing of the result, the length of the result will be bits1.length + bits2.length.
     */
    jiff.protocols.bits.smult = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.smult', bits1[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits1 = bits1.slice();
      bits2 = bits2.slice();

      // bits1 will be the longest array, bits2 will be the shortest
      var tmp = bits1.length > bits2.length ? bits1 : bits2;
      bits2 = bits1.length > bits2.length ? bits2 : bits1;
      bits1 = tmp;

      // Initialize the result
      var offset = bits2.length === 1 ? -1 : 0;
      var result = many_secret_shares(jiff, bits1.length + bits2.length + offset, bits1[0].holders, Math.max(bits1[0].threshold, bits2[0].threshold), bits1[0].Zp);
      var deferreds = result.deferreds;
      result = result.shares;

      // Resolve result when ready
      var final_deferred = new jiff.helpers.Deferred();
      final_deferred.promise.then(resolve_many_secrets.bind(null, deferreds));

      // Loop over *shortest* array one bit at a time
      bit_combinator(final_deferred, 0, bits2.length, bits2, function (i, intermediate) {
        var this_bit = bits2[i];
        var bit_mult = []; // add bits1 or 0 to the result according to this bit
        for (var j = 0; j < bits1.length; j++) {
          bit_mult[j] = this_bit.iif_else(bits1[j], 0, op_id + ':if_else:' + i + ':' + j);
        }
        bits1.unshift(0); // increase magnitude

        if (i === 0) {
          return bit_mult;
        }

        return jiff.protocols.bits.sadd(intermediate, bit_mult, op_id + ':bits.sadd:' + i);
      }, function (intermediate) {
        // promise-ify an array of intermediate results
        var promises = [];
        for (var i = 0; i < intermediate.length; i++) {
          promises.push(intermediate[i].promise);
        }
        return Promise.all(promises);
      }, function (result) {
        // identity
        return result;
      });

      return result;
    };

    /**
     * Checks whether the two given bitwise secret shared numbers are equal.
     * @method seq
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - an array of secret shares of bits, starting from least to most significant bits.
     * @param {SecretShare[]} bits2 - the second bitwise shared number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare} a secret share of 1 if bits are equal, 0 otherwise.
     */
    jiff.protocols.bits.seq = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.seq', bits1[0].holders);
      }
      return jiff.protocols.bits.sneq(bits1, bits2, op_id).inot();
    };

    /**
     * Checks whether the two given bitwise secret shared numbers are not equal.
     * @method sneq
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - an array of secret shares of bits, starting from least to most significant bits.
     * @param {SecretShare[]} bits2 - the second bitwise shared number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare} a secret share of 1 if bits are not equal, 0 otherwise.
     */
    jiff.protocols.bits.sneq = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.sneq', bits1[0].holders);
      }

      var tmp = bits1.length > bits2.length ? bits1 : bits2;
      bits2 = bits1.length > bits2.length ? bits2 : bits1; // shortest array
      bits1 = tmp; // longest array

      // copy to avoid aliasing problems during execution
      bits1 = bits1.slice();
      bits2 = bits2.slice();

      // initialize result
      var deferred = new jiff.helpers.Deferred();
      var result = jiff.secret_share(jiff, false, deferred.promise, undefined, bits1[0].holders, Math.max(bits1[0].threshold, bits2[0].threshold), bits1[0].Zp);

      // big or of bitwise XORs
      var initial = bits1[0].isxor_bit(bits2[0], op_id + ':sxor_bit:initial');
      bit_combinator(deferred, 1, bits1.length, initial, function (i, prev) {
        var next;
        if (i < bits2.length) {
          var xor = bits1[i].isxor_bit(bits2[i], op_id + ':sxor_bit:' + (i - 1));
          next = prev.isor_bit(xor, op_id + ':sor_bit:' + (i - 1));
        } else {
          // xor is equal to bits1[i] since bits2[i] is zero
          next = prev.isor_bit(bits1[i], op_id + ':sor_bit:' + (i - 1));
        }
        return next;
      });

      return result;
    };

    /**
     * Checks whether the first given bitwise secret shared number is greater than the second bitwise secret shared number.
     * @method sgt
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - an array of secret shares of bits, starting from least to most significant bits.
     * @param {SecretShare[]} bits2 - the second bitwise shared number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare} a secret share of 1 if the first number is greater than the second, 0 otherwise.
     */
    jiff.protocols.bits.sgt = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.sgt', bits1[0].holders);
      }

      var gteq = jiff.protocols.bits.sgteq(bits1, bits2, op_id + ':bits.sgteq');
      var neq = jiff.protocols.bits.sneq(bits1, bits2, op_id + ':bits.sneq');
      return gteq.ismult(neq, op_id + ':smult');
    };

    /**
     * Checks whether the first given bitwise secret shared number is greater than or equal to the second bitwise secret shared number.
     * @method sgteq
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - an array of secret shares of bits, starting from least to most significant bits.
     * @param {SecretShare[]} bits2 - the second bitwise shared number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare} a secret share of 1 if the first number is greater or equal to the second, 0 otherwise.
     */
    jiff.protocols.bits.sgteq = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.sgteq', bits1[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits1 = bits1.slice();
      bits2 = bits2.slice();

      // initialize result
      var deferred = new jiff.helpers.Deferred();
      var result = jiff.secret_share(jiff, false, deferred.promise, undefined, bits1[0].holders, Math.max(bits1[0].threshold, bits2[0].threshold), bits1[0].Zp);

      // Subtract bits2 from bits1, only keeping track of borrow
      var borrow = bits1[0].inot().ismult(bits2[0], op_id + ':smult:initial');
      var n = Math.max(bits1.length, bits2.length);
      bit_combinator(deferred, 1, n, borrow, function (i, borrow) {
        if (i < bits1.length && i < bits2.length) {
          var xor = bits1[i].isxor_bit(bits2[i], op_id + ':sxor_bit1:' + (i - 1));
          var andNot = bits1[i].inot().ismult(bits2[i], op_id + ':smult1:' + (i - 1));

          // save and update borrow
          borrow = xor.inot().ismult(borrow, op_id + ':smult2:' + (i - 1));
          borrow = borrow.isadd(andNot);
        } else if (i < bits1.length) {
          // xor is equal to the value of bits1[i], andNot is equal to 0, since bits[2] is all zeros here
          borrow = bits1[i].inot().ismult(borrow, op_id + ':smult1:' + (i - 1));
        } else { // i < bits2.length
          // xor and andNot are equal to the value of bits2[i]
          borrow = bits2[i].inot().ismult(borrow, op_id + ':smult1:' + (i - 1));
          borrow = borrow.isadd(bits2[i]);
        }

        return borrow;
      });

      return result.inot();
    };

    /**
     * Checks whether the first given bitwise secret shared number is less than the second bitwise secret shared number.
     * @method slt
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - an array of secret shares of bits, starting from least to most significant bits.
     * @param {SecretShare[]} bits2 - the second bitwise shared number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare} a secret share of 1 if the first number is less than the second, 0 otherwise.
     */
    jiff.protocols.bits.slt = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.slt', bits1[0].holders);
      }
      var result = jiff.protocols.bits.sgteq(bits1, bits2, op_id);
      return result.inot();
    };

    /**
     * Checks whether the first given bitwise secret shared number is less or equal to the second bitwise secret shared number.
     * @method slteq
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - an array of secret shares of bits, starting from least to most significant bits.
     * @param {SecretShare[]} bits2 - the second bitwise shared number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare} a secret share of 1 if the first number is less than or equal to the second, 0 otherwise.
     */
    jiff.protocols.bits.slteq = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.slteq', bits1[0].holders);
      }
      var result = jiff.protocols.bits.sgt(bits1, bits2, op_id);
      return result.inot();
    };

    /**
     * Computes integer division of [secret bits 1] / [secret bits 2].
     * @method sdiv
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - an array of secret shares of bits, starting from least to most significant bits.
     * @param {SecretShare[]} bits2 - the second bitwise shared number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {{quotient: SecretShare[], remainder: SecretShare[]}} the quotient and remainder bits arrays, note that
     *                                                                the quotient array has the same length as bits1,
     *                                                                and the remainder array has the same length as bits2 or bits1, whichever is smaller.
     *                                                                Note: if bits2 represent 0, the returned result is the maximum
     *                                                                number that fits in the number of bits (all 1), and the remainder
     *                                                                is equal to bits1.
     */
    jiff.protocols.bits.sdiv = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.sdiv', bits1[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits1 = bits1.slice();
      bits2 = bits2.slice();

      // Initialize the result
      var quotient = many_secret_shares(jiff, bits1.length, bits1[0].holders, Math.max(bits1[0].threshold, bits2[0].threshold), bits1[0].Zp);
      var quotientDeferreds = quotient.deferreds;
      quotient = quotient.shares;

      var remainder = many_secret_shares(jiff, Math.min(bits1.length, bits2.length), bits1[0].holders, Math.max(bits1[0].threshold, bits2[0].threshold), bits1[0].Zp);
      var remainderDeferreds = remainder.deferreds;
      remainder = remainder.shares;

      // Resolve result when ready
      var final_deferred = new jiff.helpers.Deferred();
      final_deferred.promise.then(function (result) {
        resolve_many_secrets(remainderDeferreds, result);
      });

      var initial = []; // initial remainder
      bit_combinator(final_deferred, bits1.length-1, -1, initial, function (i, _remainder) {
        var iterationCounter = (bits1.length - i - 1);

        // add bit i to the head of remainder (least significant bit)
        _remainder.unshift(bits1[i]);

        // Get the next bit of the quotient
        // and conditionally subtract b from the
        // intermediate remainder to continue
        var sub = jiff.protocols.bits.ssub(_remainder, bits2, op_id + ':bits.ssub:' + iterationCounter);
        var noUnderflow = sub.pop().inot(); // get the overflow bit, sub is now the result of subtraction

        // Get next bit of quotient
        noUnderflow.wThen(quotientDeferreds[i].resolve);

        // Update remainder
        for (var j = 0; j < _remainder.length; j++) {
          // note, if noUnderflow, then |# bits in sub| <= |# bits in remainder|
          _remainder[j] = noUnderflow.iif_else(sub[j], _remainder[j], op_id + ':if_else:' + iterationCounter + ':' + j);
        }

        // Remainder cannot be greater than divisor at this point
        while (_remainder.length > remainder.length) {
          _remainder.pop();
        }

        return _remainder;
      }, function (intermediate) {
        // promise-ify an array of intermediate results
        var promises = [];
        for (var i = 0; i < intermediate.length; i++) {
          promises.push(intermediate[i].promise);
        }
        return Promise.all(promises);
      }, function (result) {
        // identity
        return result;
      });

      return {quotient: quotient, remainder: remainder}
    };

    /**
     * Computes integer division of [secret bits] / constant.
     * @method cdivl
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - numerator: an array of secret shares of bits, starting from least to most significant bits.
     * @param {number} constant - the denominator number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {{quotient: SecretShare[], remainder: SecretShare[]}} the quotient and remainder bits arrays, note that
     *                                                                the quotient array has the same length as bits,
     *                                                                and the remainder array has the same length as
     *                                                                constant or bits, whichever is smaller.
     * @throws if constant is 0.
     */
    jiff.protocols.bits.cdivl = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.cdivl)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.cdivl', bits[0].holders);
      }

      if (constant.toString() === '0') {
        throw new Error('constant cannot be 0 in bits.cdiv');
      }

      // copy to avoid aliasing problems during execution
      bits = bits.slice();

      // special case, divide by 1
      if (constant.toString() === '1') {
        return {
          quotient: bits,
          remainder: [jiff.secret_share(jiff, true, null, 0, bits[0].holders, bits[0].threshold, bits[0].Zp)]
        }
      }

      // Initialize the result
      var quotient = many_secret_shares(jiff, bits.length, bits[0].holders, bits[0].threshold, bits[0].Zp);
      var quotientDeferreds = quotient.deferreds;
      quotient = quotient.shares;

      var constantLessBits = jiff.helpers.ceil(jiff.helpers.bLog(constant, 2));
      constantLessBits = parseInt(constantLessBits.toString(), 10);
      var remainder = many_secret_shares(jiff, Math.min(constantLessBits, bits.length), bits[0].holders, bits[0].threshold, bits[0].Zp);
      var remainderDeferreds = remainder.deferreds;
      remainder = remainder.shares;

      // Resolve result when ready
      var final_deferred = new jiff.helpers.Deferred();
      final_deferred.promise.then(resolve_many_secrets.bind(null, remainderDeferreds));

      var initial = []; // initial remainder
      bit_combinator(final_deferred, bits.length-1, -1, initial, function (i, _remainder) {
        var iterationCounter = (bits.length - i - 1);

        // add bit i to the head of remainder (least significant bit)
        _remainder.unshift(bits[i]);

        // Get the next bit of the quotient
        // and conditionally subtract b from the
        // intermediate remainder to continue
        var sub = jiff.protocols.bits.csubl(_remainder, constant, op_id + ':bits.csubl:' + iterationCounter);
        var noUnderflow = sub.pop().inot(); // get the overflow bit, sub is now the result of subtraction

        // Get next bit of quotient
        noUnderflow.wThen(quotientDeferreds[i].resolve);

        // Update remainder
        for (var j = 0; j < _remainder.length; j++) {
          // note, if noUnderflow, then |# bits in sub| <= |# bits in remainder|
          _remainder[j] = noUnderflow.iif_else(sub[j], _remainder[j], op_id + ':if_else:' + iterationCounter + ':' + j);
        }

        // Remainder cannot be greater than constant at this point
        while (_remainder.length > remainder.length) {
          _remainder.pop();
        }

        return _remainder;
      }, function (intermediate) {
        // promise-ify an array of intermediate results
        var promises = [];
        for (var i = 0; i < intermediate.length; i++) {
          promises.push(intermediate[i].promise);
        }
        return Promise.all(promises);
      }, function (result) {
        // identity
        return result;
      });

      return {quotient: quotient, remainder: remainder};
    };

    /**
     * Computes integer division of constant / [secret bits].
     * @method cdivr
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {number} constant - the numerator number.
     * @param {SecretShare[]} bits - denominator: an array of secret shares of bits, starting from least to most significant bits.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {{quotient: SecretShare[], remainder: SecretShare[]}} the quotient and remainder bits arrays, note that
     *                                                                the quotient array has the same length as the number of bits in constant.
     *                                                                and the remainder array has the same length as bits or constant, whichever is smaller.
     *                                                                Note: if bits represent 0, the returned result is the maximum
     *                                                                number that fits in its bits (all 1), and the remainder
     *                                                                is equal to constant.
     */
    jiff.protocols.bits.cdivr = function (constant, bits, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.cdivr)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.cdivr', bits[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits = bits.slice();

      // do not pad
      var constant_bits = jiff.helpers.number_to_bits(constant);

      // Initialize the result
      var quotient = many_secret_shares(jiff, constant_bits.length, bits[0].holders, bits[0].threshold, bits[0].Zp);
      var quotientDeferreds = quotient.deferreds;
      quotient = quotient.shares;

      var remainder = many_secret_shares(jiff, Math.min(constant_bits.length, bits.length), bits[0].holders, bits[0].threshold, bits[0].Zp);
      var remainderDeferreds = remainder.deferreds;
      remainder = remainder.shares;

      // Resolve result when ready
      var final_deferred = new jiff.helpers.Deferred();
      final_deferred.promise.then(resolve_many_secrets.bind(null, remainderDeferreds));

      var initial = []; // initial remainder
      bit_combinator(final_deferred, constant_bits.length-1, -1, initial, function (i, _remainder) {
        var iterationCounter = (constant_bits.length - i - 1);

        // add bit i to the head of remainder (least significant bit)
        // turn into a secret without communication, just for typing
        var cbit_share = jiff.secret_share(jiff, true, null, constant_bits[i], bits[0].holders, bits[0].threshold, bits[0].Zp);
        _remainder.unshift(cbit_share);

        // Get the next bit of the quotient
        // and conditionally subtract b from the
        // intermediate remainder to continue
        var sub = jiff.protocols.bits.ssub(_remainder, bits, op_id + ':bits.ssub:' + iterationCounter);
        var noUnderflow = sub.pop().inot(); // get the overflow bit, sub is now the result of subtraction

        // Get next bit of quotient
        noUnderflow.wThen(quotientDeferreds[i].resolve);

        // Update remainder
        for (var j = 0; j < _remainder.length; j++) {
          // note, if noUnderflow, then |# bits in sub| <= |# bits in remainder|
          _remainder[j] = noUnderflow.iif_else(sub[j], _remainder[j], op_id + ':if_else:' + iterationCounter + ':' + j);
        }

        // cannot be bigger than divisor at this point
        while (_remainder.length > remainder.length) {
          _remainder.pop();
        }

        return _remainder;
      }, function (intermediate) {
        // promise-ify an array of intermediate results
        var promises = [];
        for (var i = 0; i < intermediate.length; i++) {
          promises.push(intermediate[i].promise);
        }
        return Promise.all(promises);
      }, function (result) {
        // identity
        return result;
      });

      return {quotient: quotient, remainder: remainder};
    };

    /**
     * Flags whether to use the server as a fallback for objects that were not pre-processed properly
     * @member {boolean} barriers
     * @memberOf jiff-instance
     * @instance
     */
    jiff.crypto_provider = (options.crypto_provider === true);

    /**
     * Stores pre-computed values (beaver triples, random bits, etc) used to aid/speed up the main processes.
     * @member {Object} preprocessing_table
     * @memberof jiff-instance
     * @instance
     */
    jiff.preprocessing_table = {};

    // internal functions for use in preprocessing function map
    var bits_count = function (threshold, receivers_list, compute_list, Zp, op_id, params) {
      var bitLength = params.bitLength;
      if (bitLength == null) {
        bitLength = Zp.toString(2).length;
      }
      return bitLength;
    };
    var constant_bits_count = function () {
      return bits_count.apply(null, arguments) - 1;
    };
    var dynamic_bits_cmult = function (dependent_op, count, protocols, threshold, receivers_list, compute_list, Zp, id_list, params) {
      // constant bit length
      var constantBits = Zp.toString(2).length;
      if (params.constantBits != null) {
        constantBits = params.constantBits;
      }
      // secret bit length
      var bitLength = params.bitLength;
      if (bitLength == null) {
        bitLength = Zp.toString(2).length;
      }
      // for every bit from constant, pre-process for one bits.sadd of the right size
      var ops = [];
      for (var i = 0; i < constantBits; i++) {
        var accLength = i === 0 ? 1 : (bitLength + i);
        ops.push({ op: 'bits.sadd', op_id: ':bits.sadd:' + i, params: {bitLengthLeft: accLength, bitLengthRight: bitLength + i}});
      }
      return ops;
    };
    var dynamic_bits_smult = function (dependent_op, count, protocols, threshold, receivers_list, compute_list, Zp, id_list, params) {
      var bitLength = params.bitLength;
      if (bitLength == null) {
        bitLength = Zp.toString(2).length;
      }

      var left = params.bitLengthLeft;
      var right = params.bitLengthRight;
      left = left != null ? left : bitLength;
      right = right != null ? right : bitLength;
      var max = Math.max(left, right);
      var min = Math.max(left, right);

      var ops = [];
      for (var i = 0; i < min; i++) {
        for (var j = 0; j < max + i; j++) {
          ops.push({ op: 'if_else', op_id: ':if_else:' + i + ':' + j });
        }
        var accLength = i === 0 ? min : (max + i);
        ops.push({ op: 'bits.sadd', op_id: ':bits.sadd:'+i, params: {bitLengthLeft: accLength, bitLengthRight: max + i}});
      }
      return ops;
    };
    var choice_bits_count = function (choice, offset) {
      if (offset == null) {
        offset = 0;
      }
      return function (threshold, receivers_list, compute_list, Zp, op_id, params) {
        var bitLength = params.bitLength;
        if (bitLength == null) {
          bitLength = Zp.toString(2).length;
        }

        var left = params.bitLengthLeft;
        var right = params.bitLengthRight;
        left = left != null ? left : bitLength;
        right = right != null ? right : bitLength;

        return choice(left, right) + offset;
      };
    };
    var decomposition_ifelse_count = function (threshold, receivers_list, compute_list, Zp, op_id, params) {
      return Zp.toString(2).length;
    };
    var dynamic_bits_sdiv = function (dependent_op, count, protocols, threshold, receivers_list, compute_list, Zp, id_list, params) {
      var bitLength = params.bitLength;
      if (bitLength == null) {
        bitLength = Zp.toString(2).length;
      }

      var left = params.bitLengthLeft;
      var right = params.bitLengthRight;
      left = left != null ? left : bitLength;
      right = right != null ? right : bitLength;
      var min = Math.min(left, right);

      var ops = [];
      for (var i = 0; i < left; i++) {
        var accLength = Math.min(i+1, min+1);
        ops.push({ op: 'bits.ssub', op_id: ':bits.ssub:'+i, params: {bitLengthLeft: accLength, bitLengthRight: right}});
        for (var j = 0; j < accLength; j++) {
          ops.push({ op: 'if_else', op_id: ':if_else:' + i + ':' + j });
        }
      }
      return ops;
    };
    var dynamic_bits_cdiv = function (dir) {
      return function (dependent_op, count, protocols, threshold, receivers_list, compute_list, Zp, id_list, params) {
        var constantBits = Zp.toString(2).length;
        if (params.constantBits != null) {
          constantBits = params.constantBits;
        }
        var bitLength = params.bitLength;
        if (bitLength == null) {
          bitLength = Zp.toString(2).length;
        }
        var min = Math.min(bitLength, constantBits);

        var ops = [];
        var loopCounter = (dir === 'left') ? bitLength : constantBits;
        for (var i = 0; i < loopCounter; i++) {
          var accLength = Math.min(i+1, min+1);
          if (dir === 'left') {
            ops.push({ op: 'bits.csubl', op_id: ':bits.csubl:' + i, params: {bitLength: accLength, constantBits: constantBits} });
          } else {
            ops.push({ op: 'bits.ssub', op_id: ':bits.ssub:' + i, params: {bitLengthLeft: accLength, bitLengthRight: bitLength} });
          }

          for (var j = 0; j < accLength; j++) {
            ops.push({ op: 'if_else', op_id: ':if_else:' + i + ':' + j });
          }
        }
        return ops;
      }
    };

    /**
     * the default preprocessing protocols for each type of value
     * @member {Object} default_preprocessing_protocols
     * @memberof jiff-instance
     * @instance
     */
    jiff.default_preprocessing_protocols = {
      generate_beaver: jiff.protocols.generate_beaver_bgw,
      generate_random_number: jiff.protocols.generate_random_number,
      sampling: jiff.protocols.bits.rejection_sampling,
      generate_random_bits: jiff.protocols.generate_random_bits,
      generate_random_bit: jiff.protocols.generate_random_bit_bgw,
      generate_zero: jiff.protocols.generate_zero,
      generate_random_and_quotient: jiff.protocols.generate_random_and_quotient
    };

    /**
     * maps all primitive operations to the other operations they are dependent on, to be traversed during preprocessing
     * @member {Object} preprocessing_function_map
     * @memberof jiff-instance
     * @instance
     */
    jiff.preprocessing_function_map = {
      base: {
        // arithmetic sharing protocols
        'smult': [
          { op: 'generate_beaver', op_id: ':triplet' },
          { op: 'open', op_id: ':open1' },
          { op: 'open', op_id: ':open2' }
        ],
        'sxor_bit': [
          { op: 'smult', op_id: ':smult1' }
        ],
        'slt': [
          { op: 'lt_halfprime', op_id: ':halfprime:1' },
          { op: 'lt_halfprime', op_id: ':halfprime:2' },
          { op: 'lt_halfprime', op_id: ':halfprime:3' },
          { op: 'smult', op_id: ':smult1' },
          { op: 'smult', op_id: ':smult2' }
        ],
        'cgt': [
          { op: 'lt_halfprime', op_id: ':halfprime:1' },
          { op: 'lt_halfprime', op_id: ':halfprime:2' },
          { op: 'smult', op_id: ':smult1' }
        ],
        'clt': [
          { op: 'lt_halfprime', op_id: ':halfprime:1' },
          { op: 'lt_halfprime', op_id: ':halfprime:2' },
          { op: 'smult', op_id: ':smult1' }
        ],
        'lt_halfprime': [
          { op: 'sampling', op_id: ':sampling' },
          { op: 'smult', op_id: ':smult1' },
          { op: 'bits.cgt', op_id: ':bits.cgt' },
          { op: 'sxor_bit', op_id: ':sxor_bit' },
          { op: 'open', op_id: ':open' }
        ],
        'cdiv': [
          { op: 'cgt', op_id: ':wrap_cgt' },
          { op: 'cgteq', op_id: ':cor1' },
          { op: 'cgteq', op_id: ':cor2' },
          { op: 'smult', op_id: ':smult' },
          { op: 'clt', op_id: ':zero_check' },
          { op: 'smult', op_id: ':zero_it' },
          { op: 'open', op_id: ':open' },
          { op: 'generate_random_and_quotient', op_id: ':quotient' }
        ],
        'sdiv': [
          { op: 'bit_decomposition', op_id: ':decomposition1' },
          { op: 'bit_decomposition', op_id: ':decomposition2' },
          { op: 'bits.sdiv', op_id: ':bits.sdiv' }
        ],
        'if_else': [
          { op: 'smult', op_id: ':smult' }
        ],
        // bits protocols
        'bit_decomposition': [
          { op: 'sampling', op_id: ':sampling' },
          { op: 'bits.csubr', op_id: ':bits.csubr:1' },
          { op: 'bits.csubr', op_id: ':bits.csubr:2' },
          { op: 'if_else', op_id: ':if_else:', count: decomposition_ifelse_count },
          { op: 'open', op_id: ':open' }
        ],
        // comparisons
        'bits.cgteq': [
          { op: 'smult', op_id: ':smult:', count: constant_bits_count }
        ],
        'bits.cneq': [
          { op: 'sor_bit', op_id: ':sor_bit:', count: constant_bits_count }
        ],
        'bits.sneq': [
          { op: 'sxor_bit', op_id: ':sxor_bit:initial' },
          { op: 'sxor_bit', op_id: ':sxor_bit:', count: choice_bits_count(Math.min, -1) },
          { op: 'sor_bit', op_id: ':sor_bit:', count: choice_bits_count(Math.max, -1) }
        ],
        'bits.sgteq': [
          { op: 'smult', op_id: ':smult:initial' },
          { op: 'smult', op_id: ':smult1:', count: choice_bits_count(Math.max, -1) },
          { op: 'sxor_bit', op_id: ':sxor_bit1:', count: choice_bits_count(Math.min, -1) },
          { op: 'smult', op_id: ':smult2:', count: choice_bits_count(Math.min, -1) }
        ],
        'bits.sgt': [
          { op: 'bits.sgteq', op_id: ':bits.sgteq'},
          { op: 'bits.sneq', op_id: ':bits.sneq'},
          { op: 'smult', op_id: ':smult'}
        ],
        // constant arithmetic
        'bits.cadd': [
          { op: 'smult', op_id: ':smult:', count: constant_bits_count },
          { op: 'sxor_bit', op_id: ':sxor_bit:', count: constant_bits_count }
        ],
        'bits.cmult': dynamic_bits_cmult,
        'bits.cdivl': dynamic_bits_cdiv('left'),
        'bits.cdivr': dynamic_bits_cdiv('right'),
        // secret arithmetic
        'bits.sadd': [
          { op: 'sxor_bit', op_id: ':sxor_bit:initial' },
          { op: 'smult', op_id: ':smult:initial' },
          { op: 'smult', op_id: ':smult1:', count: choice_bits_count(Math.max, -1) },
          { op: 'sxor_bit', op_id: ':sxor_bit1:', count: choice_bits_count(Math.max, -1) },
          { op: 'smult', op_id: ':smult2:', count: choice_bits_count(Math.min, -1) },
          { op: 'sxor_bit', op_id: ':sxor_bit2:', count: choice_bits_count(Math.min, -1) }
        ],
        'bits.smult': dynamic_bits_smult,
        'bits.sdiv': dynamic_bits_sdiv,
        'bits.open': [
          { op: 'open', op_id: ':', count: bits_count }
        ],
        // refresh/open
        'refresh': [
          { op: 'generate_zero', op_id: '' }
        ],
        'open': [
          { op: 'refresh', op_id: ':refresh' }
        ],
        // generating a random number and its quotient / constant
        '__generate_random_and_quotient': [
          { op: 'bits.cgteq', op_id: ':bits_cgteq' },
          { op: 'if_else', op_id: ':ifelse1' },
          { op: 'if_else', op_id: ':ifelse2' },
          { op: 'sampling', op_id: ':rejection1' }
        ]
      }
    };

    // arithmetic protocols
    jiff.preprocessing_function_map['base']['sor_bit'] = jiff.preprocessing_function_map['base']['sxor_bit'];
    jiff.preprocessing_function_map['base']['smod'] = jiff.preprocessing_function_map['base']['sdiv'];
    jiff.preprocessing_function_map['base']['slteq'] = jiff.preprocessing_function_map['base']['slt'];
    jiff.preprocessing_function_map['base']['sgteq'] = jiff.preprocessing_function_map['base']['slt'];
    jiff.preprocessing_function_map['base']['sgt'] = jiff.preprocessing_function_map['base']['slt'];
    jiff.preprocessing_function_map['base']['clteq'] = jiff.preprocessing_function_map['base']['cgt'];
    jiff.preprocessing_function_map['base']['cgteq'] = jiff.preprocessing_function_map['base']['clt'];
    jiff.preprocessing_function_map['base']['seq'] = jiff.preprocessing_function_map['base']['clteq'];
    jiff.preprocessing_function_map['base']['sneq'] = jiff.preprocessing_function_map['base']['seq'];
    jiff.preprocessing_function_map['base']['ceq'] = jiff.preprocessing_function_map['base']['clteq'];
    jiff.preprocessing_function_map['base']['cneq'] = jiff.preprocessing_function_map['base']['ceq'];

    // bits protocols
    jiff.preprocessing_function_map['base']['bits.clt'] = jiff.preprocessing_function_map['base']['bits.cgteq'];
    jiff.preprocessing_function_map['base']['bits.clteq'] = jiff.preprocessing_function_map['base']['bits.cgteq'];
    jiff.preprocessing_function_map['base']['bits.cgt'] = jiff.preprocessing_function_map['base']['bits.cgteq'];
    jiff.preprocessing_function_map['base']['bits.ceq'] = jiff.preprocessing_function_map['base']['bits.cneq'];
    jiff.preprocessing_function_map['base']['bits.slt'] = jiff.preprocessing_function_map['base']['bits.sgteq'];
    jiff.preprocessing_function_map['base']['bits.slteq'] = jiff.preprocessing_function_map['base']['bits.sgt'];
    jiff.preprocessing_function_map['base']['bits.seq'] = jiff.preprocessing_function_map['base']['bits.sneq'];
    jiff.preprocessing_function_map['base']['bits.csubl'] = jiff.preprocessing_function_map['base']['bits.cadd'];
    jiff.preprocessing_function_map['base']['bits.csubr'] = jiff.preprocessing_function_map['base']['bits.cadd'];
    jiff.preprocessing_function_map['base']['bits.ssub'] = jiff.preprocessing_function_map['base']['bits.sadd'];

    /**
     * Checks if the given operation uses preprocessed values.
     * @method has_preprocessing
     * @memberof jiff-instance
     * @instance
     * @param {string} op - name of the operation to check.
     * @return {boolean} true if the op uses preprocessing, false otherwise.
     */
    jiff.has_preprocessing = function (op) {
      for (var i = 0; i < jiff.extensions.length; i++) {
        if (jiff.preprocessing_function_map[jiff.extensions[i]][op] != null) {
          return true;
        }
      }

      return false;
    };

    /**
     * Get a preprocessed share/value by associated op_id. If value does not exist
     * Fallback to some user specified way for creating it.
     * @method get_preprocessing
     * @memberof jiff-instance
     * @instance
     * @param {string} op_id - the op_id associated with the preprocessed value/share.
     * @return {object} the preprocessed share(s).
     */
    jiff.get_preprocessing = function (op_id) {
      var values = jiff.preprocessing_table[op_id];
      if (values != null) {
        return values;
      }
      if (jiff.crypto_provider === true) {
        return null;
      }
      throw new Error('No preprocessed value(s) that correspond to the op_id "' + op_id + '"');
    };

    /**
     * Store a pair of op_id and associated pre-processed value/share.
     * The value/share can be accessed later during the computation through jiff.get_preprocessing(op_id).
     * @method store_preprocessing
     * @memberof jiff-instance
     * @instance
     * @param {string} op_id - the op_id associated with the preprocessed value/share.
     * @param {SecretShare} share - the share/value to store.
     */
    jiff.store_preprocessing = function (op_id, share) {
      jiff.preprocessing_table[op_id] = share;
    };

    /**
     * Generate values used for jiff operations in advance of the general computation
     * @method __preprocessing
     * @memberof jiff-instance
     * @instance
     * @param {string} dependent_op - name of the operation that will later use the pre_processed values
     * @param {Number} count - number of times the protocol should be performed, number of values that will be generated
     * @param {Object} [protocols=defaults] - a mapping from base preprocessing elements (triplets, bit arrays) to functions that can pre-process them
     *                               the function must implement the same interface as the JIFF provided protocols (e.g. jiff.protocols.generate_beaver_bgw).
     *                               missing mappings indicate that JIFF must use the default protocols.
     * @param {Number} [threshold=receivers_list.length] - the threshold of the preprocessed shares.
     * @param {Array} [receivers_list=all_parties] - the parties that will receive the preprocsssed shares.
     * @param {Array} [compute_list=all_parties] - the parties that will compute the preprocsssed shares.
     * @param {Array} [Zp=jiff.Zp] - the Zp of the preprocessed shares.
     * @param {Array} [id_list=auto_gen()] - array of ids to be used sequentially to identify the pre_processed values. Optional.
     * @param {Object} params - any additional protocol-specific parameters.
     * @return {promise} a promise that is resolved when preprocessing is completed.
     */
    jiff.__preprocessing = function (dependent_op, count, protocols, threshold, receivers_list, compute_list, Zp, id_list, params) {
      var find_closest_namespace = function (op, starting_namespace) {
        var namespace_index = jiff.extensions.indexOf(starting_namespace);
        while (namespace_index >= 0) {
          var namespace = jiff.extensions[namespace_index];
          if (jiff.preprocessing_function_map[namespace] != null && jiff.preprocessing_function_map[namespace][op] != null) {
            return namespace;
          }
          namespace_index--;
        }

        return null;
      };

      // read only copy of params
      var _params = params;

      // Recursively follow jiff.preprocessing_function_map
      // to figure out the sub-components/nested primitives of the given operation
      // and pre-process those with the right op_ids.
      var promises = [];
      for (var i = 0; i < count; i++) {
        params = Object.assign({}, _params);
        if (params.op_id != null) {
          params.op_id = params.op_id + i;
        }

        var id = id_list[i];
        if (id == null) {
          // Two kinds of operations: one that relies on different sets of senders and receivers, and one that has a set of holders
          if (dependent_op === 'open' || dependent_op === 'bits.open') {
            var open_parties = params['open_parties'] != null ? params['open_parties'] : receivers_list;
            id = jiff.counters.gen_op_id2(dependent_op, open_parties, receivers_list);
          } else {
            id = jiff.counters.gen_op_id(dependent_op, receivers_list);
          }
        }

        var namespace = find_closest_namespace(dependent_op, params['namespace']);
        if (namespace == null) {
          var protocol = protocols[dependent_op];
          params.output_op_id = id;
          var result = protocol(threshold, receivers_list, compute_list, Zp, params, protocols);
          promises.push(result.promise);
          if (receivers_list.indexOf(jiff.id) > -1) {
            jiff.store_preprocessing(id, result.share);
          }
        } else {
          var preprocessing_dependencies = jiff.preprocessing_function_map[namespace][dependent_op];
          if (typeof(preprocessing_dependencies) === 'function') {
            preprocessing_dependencies = preprocessing_dependencies(dependent_op, count, protocols, threshold, receivers_list, compute_list, Zp, id_list, params);
          }
          for (var k = 0; k < preprocessing_dependencies.length; k++) {
            var dependency = preprocessing_dependencies[k];
            var next_op = dependency['op'];

            // copy both the originally given extra_params and the extra params of the dependency and merge them
            // together, dependency params overwrite duplicate keys.
            // If params are ever needed in non-leaf operations, this must be changed to accommodate
            var extra_params = Object.assign({}, params, dependency['params']);
            extra_params['namespace'] = dependency['namespace'] != null ? dependency['namespace'] : 'base';
            if (dependency.handler != null) {
              extra_params = dependency.handler(threshold, receivers_list, compute_list, Zp, id, extra_params);
            }
            if (extra_params.ignore === true) {
              continue;
            }

            // compose ids similar to how the actual operation is implemented
            var next_id_list = [];
            var next_count = dependency['count'];

            if (next_count == null) {
              next_count = 1;
              next_id_list[0] = id + dependency['op_id'];
            } else {
              next_count = next_count(threshold, receivers_list, compute_list, Zp, id, extra_params);
              for (var j = 0; j < next_count; j++) {
                next_id_list.push(id + dependency['op_id'] + j);
              }
            }

            if (extra_params['op_id'] != null) {
              extra_params['op_id'] = extra_params['op_id'] + dependency['op_id'];
            }

            promises.push(jiff.__preprocessing(next_op, next_count, protocols, threshold, receivers_list, compute_list, Zp, next_id_list, extra_params));
          }
        }
      }

      return Promise.all(promises);
    };

    /**
     * Stores all submitted and pending preprocessing tasks.
     * @member {Array} preprocessingTasks
     * @memberof jiff-instance
     * @instance
     */
    jiff.preprocessingTasks = [];

    /**
     * Callback to execute when preprocessing is done!
     * @member {function} preprocessingCallback
     * @memberof jiff-instance
     * @instance
     */
    jiff.preprocessingCallback = null;

    /**
     * Generate values used for jiff operations in advance of the general computation
     * @method preprocessing
     * @memberof jiff-instance
     * @instance
     * @param {string} dependent_op - name of the operation that will later use the pre_processed values
     * @param {Number} [count=1] - number of times the protocol should be performed, number of values that will be generated
     * @param {Number} [batch=count] - maximum number of parallel preprocessing tasks to execute in a single batch.
     * @param {Object} [protocols=defaults] - a mapping from base preprocessing elements ('beaver', 'bits', 'sampling') to functions that can pre-process them
     *                               the function must implement the same interface as the JIFF provided protocols (e.g. jiff.protocols.generate_beaver_bgw).
     *                               missing mappings indicate that JIFF must use the default protocols.
     * @param {Number} [threshold=receivers_list.length] - the threshold of the preprocessed shares.
     * @param {Array} [receivers_list=all_parties] - the parties that will receive the preprocsssed shares.
     * @param {Array} [compute_list=all_parties] - the parties that will compute the preprocsssed shares.
     * @param {Array} [Zp=jiff.Zp] - the Zp of the preprocessed shares.
     * @param {Array} [id_list=auto_gen()] - array of ids to be used sequentially to identify the pre_processed values. Optional.
     * @param {Object} [params={}] - any additional protocol-specific parameters.
     * @return {promise} a promise that is resolved when preprocessing is completed, null if this is called by a party that is neither a compute nor receiver party.
     */
    jiff.preprocessing = function (dependent_op, count, batch, protocols, threshold, receivers_list, compute_list, Zp, id_list, params) {
      var start = jiff.preprocessingTasks.length === 0;

      // defaults!
      if (receivers_list == null) {
        receivers_list = [];
        for (var p = 1; p <= jiff.party_count; p++) {
          receivers_list.push(p);
        }
      }
      if (compute_list == null) {
        compute_list = [];
        for (var c = 1; c <= jiff.party_count; c++) {
          compute_list.push(c);
        }
      }

      // not a receiver nor a sender
      if (receivers_list.indexOf(jiff.id) === -1 && compute_list.indexOf(jiff.id) === -1) {
        return null;
      }

      // more defaults
      if (params == null) {
        params = {};
      }
      if (Zp == null) {
        Zp = jiff.Zp;
      }
      if (threshold == null) {
        threshold = receivers_list.length;
      }
      if (id_list == null) {
        id_list = [];
      }
      protocols = Object.assign({}, jiff.default_preprocessing_protocols, protocols);

      // actual preprocessing
      if (count == null || count <= 0) {
        count = 1;
      }
      if (params == null) {
        params = {};
      }
      if (params['namespace'] == null) {
        params['namespace'] = jiff.extensions[jiff.extensions.length - 1];
      }
      batch = batch == null ? count : batch;

      // Create preprocessing tasks
      for (var i = 0; i < count; i += batch) {
        jiff.preprocessingTasks.push([dependent_op, Math.min(batch, count - i), protocols, threshold, receivers_list, compute_list, Zp, id_list, params]);
      }

      // Start daemon if not running!
      if (start) {
        jiff.preprocessingDaemon();
      }
    };

    /**
     * Preprocessing Daemon that executes all currently scheduled preprocessing tasks (entries in jiff.preprocessingTasks array) in order.
     * @method preprocessingDaemon
     * @memberof jiff-instance
     * @instance
     */
    jiff.preprocessingDaemon = function () {
      if (jiff.preprocessingTasks.length === 0) {
        if (jiff.preprocessingCallback != null) {
          jiff.counters.reset();

          var callback = jiff.preprocessingCallback;
          jiff.preprocessingCallback = null;
          callback(jiff);
        }
        return;
      }

      // execute a single preprocessing task!
      (function () {
        var args = arguments;
        console.log(jiff.id, 'Batch starting', args[0], args[1]);
        var promise = jiff.__preprocessing.apply(jiff, arguments);
        promise.then(function () {
          console.log(jiff.id, 'Batch done', args[0], args[1]);
          if (jiff.inspectDebug != null) {
            jiff.inspectDebug(Number.MAX_VALUE);
          }
          jiff.preprocessingTasks.shift();
          jiff.preprocessingDaemon();
        });
      }).apply(jiff, jiff.preprocessingTasks[0]);
    };

    /**
     * Calls the given callback when all preprocessing tasks have finished!
     * @method onFinishPreprocessing
     * @memberof jiff-instance
     * @instance
     */
    jiff.onFinishPreprocessing = function (callback) {
      if (jiff.preprocessingTasks.length === 0) {
        jiff.counters.reset();
        callback(jiff);
      } else {
        jiff.preprocessingCallback = callback;
      }
    };

    /**
     * Starts a new barrier, all promises and secret shares created between this call and the corresponding start_barrier
     * call will be part of this barrier. start_barrier may be called before previous barriers are resolved, in which
     * case promises / secret shares created will be part of the new barrier as well as any previous barriers.
     * @returns {number} a barrier id that identifies this barrier.
     */
    jiff.start_barrier = function () {
      jiff.barriers.push([]);
      return jiff.barriers.length - 1;
    };

    /**
     * Adds given promise to all active barriers.
     * @param {promise} promise - the promise to add.
     */
    jiff.add_to_barriers = function (promise) {
      for (var i = 0; i < jiff.barriers.length; i++) {
        jiff.barriers[i].push(promise);
      }
    };

    /**
     * Executes the callback only after all promises / secret shares in the barrier were resolved.
     * @param {number} [barrier_id=jiff.barriers.length - 1] - identifies the barrier, should be returned by start_barrier.
     *                                                         by default, barrier_id will refer to the last barrier.
     * @returns {promise} a promise that resolves after the secret shares are resolved.
     */
    jiff.end_barrier = function (barrier_id) {
      var barrier;
      if (barrier_id == null) {
        barrier = jiff.barriers.pop();
      } else {
        barrier = jiff.barriers[barrier_id];
        jiff.barriers.splice(barrier_id, 1);
      }

      return Promise.all(barrier);
    };


    /**
     * Disconnects from the computation.
     * Allows the client program to exit.
     * @method disconnect
     * @memberof jiff-instance
     * @instance
     * @param {boolean} [safe=false] - if true, jiff will disconnect safely (i.e. after ensuring all
     *                                 outgoing pending messages were delivered).
     * @param {boolean} [free=false] - if set to true, it means this party's disconnection is final, and all resources
     *                                 associated with this party must be freed.
     *                                 If all parties in a computation are freed, then all resources associated with the
     *                                 computation are freed, and any subsequent reconnection to the computation is as
     *                                 if a the connection is for a fresh new computation.
     * @param {function()} [callback] - executed after the instance safely disconnects, if safe is set to false, this
     *                                  parameter is ignored.
     */
    jiff.disconnect = function (safe, free, callback) {
      if (safe) {
        jiff.socket.safe_disconnect(free, callback);
      } else {
        if (free) {
          jiff.free();
        }
        jiff.socket.disconnect();
      }
    };

    /**
     * Emits event to free up all the resources allocated for this party on the server.
     * Best not to call this function directly, as it can break things if resources still need to be used.
     * Instead, use jiff.disconnect(safe, free, callback) to free after safely disconnecting.
     * @param {io.socket} socket - the socket through which to free.
     */
    jiff.free = function () {
      var msg = jiff.execute_array_hooks('beforeOperation', [jiff, 'free', {}], 2);
      if (options.__internal_socket == null) {
        jiff.socket.safe_emit('free', JSON.stringify(msg));
      } else {
        jiff.execute_array_hooks('afterOperation', [jiff, 'free', msg], 2);
      }
    };

    // Store the id when server sends it back
    jiff.socket.on('initialization', function (msg) {
      jiff.__initialized = true;
      jiff.initialization_counter = 0;

      msg = JSON.parse(msg);
      msg = jiff.execute_array_hooks('afterOperation', [jiff, 'initialization', msg], 2);

      if (jiff.id == null) {
        jiff.id = msg.party_id;
      }

      if (jiff.party_count == null) {
        jiff.party_count = msg.party_count;
      }

      // Now: (1) this party is connect (2) server (and other parties) know this public key
      // Resend all pending messages
      jiff.socket.resend_mailbox();

      // store the received public keys and resolve wait callbacks
      jiff.store_public_keys(msg.public_keys);
    });

    // Public keys were updated on the server, and it sent us the updates
    jiff.socket.on('public_keys', function (msg, callback) {
      callback(true);

      msg = JSON.parse(msg);
      msg = jiff.execute_array_hooks('afterOperation', [jiff, 'public_keys', msg], 2);

      jiff.store_public_keys(msg.public_keys);
    });

    // Store sharing and shares counter which keeps track of the count of
    // sharing operations (share and open) and the total number of shares
    // respectively (used to get a unique id for each share operation and
    // share object).
    jiff.counters = {};

    jiff.counters.reset = function () {
      jiff.counters.triplet_op_count = {};
      jiff.counters.number_op_count = {};
      jiff.counters.op_count = {};

      if (jiff.counters.pending_opens == null) {
        jiff.counters.pending_opens = 0;
      }

      //stores a seed for generating unique op_ids.
      jiff.op_id_seed = '';
    };

    // initialize counters
    jiff.counters.reset();

    /**
     * Shorthand for generating unique operation ids.
     * All primitives called after this seed will use their usual default ids prefixed by the seed.
     * Helpful when we have nested callbacks/functions (e.g. share_arrays) that may be executed in arbitrary order,
     * using this function as a the first call inside such callbacks with an appropriate deterministic unique base_op_id
     * ensures that regardless of the order of execution, operations in the same callback are matched correctly across
     * all parties.
     * Check out demos/graph-pip/mpc.js for an example on using this.
     * @method seed_ids
     * @memberof jiff-instance
     * @instance
     * @param {string|number} base_op_id - the base seed to use as a prefix for all future op_ids.
     */
    jiff.seed_ids = function (base_op_id) {
      if (base_op_id == null || base_op_id === '') {
        jiff.op_id_seed = '';
      } else {
        jiff.op_id_seed = base_op_id.toString() + ':';
      }
    };

    /**
     * Generate a unique operation id for a new operation object.
     * The returned op_id will be unique with respect to other operations, and identifies the same
     * operation across all parties, as long as all parties are executing instructions in the same order.
     * @param {string} op - the type/name of operation performed.
     * @param {Array} holders - an array containing the ids of all the parties carrying out the operation.
     * @return {string} the op_id for the operation.
     */
    jiff.counters.gen_op_id = function (op, holders) {
      var label = jiff.op_id_seed + op + ':' + holders.join(',');
      if (jiff.counters.op_count[label] == null) {
        jiff.counters.op_count[label] = 0;
      }
      return label + ':' + (jiff.counters.op_count[label]++);
    };

    /**
     * Generate a unique operation id for a new operation object given two distinct executing parties lists.
     * For example, when sharing, this is given two potentially different lists of senders and receivers.
     * The returned op_id will be unique with respect to other operations, and identifies the same
     * operation across all parties, as long as all parties are executing instructions in the same order.
     * @param {string} op - the type/name of operation performed.
     * @param {Array} receivers - an array containing the ids of all the parties carrying out the receiving portion of the operation.
     * @param {Array} senders - an array containing the ids of all the parties carrying out the sending portion of the operation.
     * @return {string} the op_id for the operation.
     */
    jiff.counters.gen_op_id2 = function (op, receivers, senders) {
      var label = jiff.op_id_seed + op + ':' + senders.join(',') + ':' + receivers.join(',');
      if (jiff.counters.op_count[label] == null) {
        jiff.counters.op_count[label] = 0;
      }
      return label + ':' + (jiff.counters.op_count[label]++);
    };

    // For logging / debugging
    jiff.logs = [];

    // Store a map from a sharing id (which share operation) to the
    // corresponding deferred and shares array.
    jiff.shares = {}; // Stores receive shares for open purposes.
    jiff.deferreds = {}; // Stores deferred that are resolved when required messages arrive.

    // Setup receiving matching shares
    jiff.socket.on('share', function (msg, callback) {
      callback(true); // send ack to server

      // parse message
      var json_msg = JSON.parse(msg);
      var sender_id = json_msg['party_id'];

      if (jiff.keymap[sender_id] != null) {
        receive_share(jiff, json_msg);
      } else {
        if (jiff.messagesWaitingKeys[sender_id] == null) {
          jiff.messagesWaitingKeys[sender_id] = [];
        }
        jiff.messagesWaitingKeys[sender_id].push({label: 'share', msg: json_msg});
      }
    });

    jiff.socket.on('open', function (msg, callback) {
      callback(true); // send ack to server

      // parse message
      var json_msg = JSON.parse(msg);
      var sender_id = json_msg['party_id'];

      if (jiff.keymap[sender_id] != null) {
        receive_open(jiff, json_msg);
      } else {
        if (jiff.messagesWaitingKeys[sender_id] == null) {
          jiff.messagesWaitingKeys[sender_id] = [];
        }
        jiff.messagesWaitingKeys[sender_id].push({ label: 'open', msg: json_msg });
      }
    });

    // handle custom messages
    jiff.socket.on('custom', function (msg, callback) {
      callback(true); // send ack to server

      var json_msg = JSON.parse(msg);
      var sender_id = json_msg['party_id'];
      var encrypted = json_msg['encrypted'];

      if (jiff.keymap[sender_id] != null || encrypted !== true) {
        receive_custom(jiff, json_msg);
      } else {
        // key must not exist yet for sender_id, and encrypted must be true
        if (jiff.messagesWaitingKeys[sender_id] == null) {
          jiff.messagesWaitingKeys[sender_id] = [];
        }
        jiff.messagesWaitingKeys[sender_id].push({ label: 'custom', msg: json_msg });
      }
    });

    jiff.socket.on('crypto_provider', function (msg, callback) {
      callback(true); // send ack to server

      msg = JSON.parse(msg);
      receive_crypto_provider(jiff, msg);
    });

    jiff.socket.on('error', function (msg) {
      try {
        msg = JSON.parse(msg);
        jiff.error(msg['label'], msg['error']);
      } catch (error) {
        jiff.error('socket.io', msg);
      }
    });

    jiff.socket.on('disconnect', function (reason) {
      if (reason !== 'io client disconnect') {
        // check that the reason is an error and not a user initiated disconnect
        console.log('Disconnected!', jiff.id, reason);
      }

      jiff.execute_array_hooks('afterOperation', [jiff, 'disconnect', reason], -1);
    });

    // Connect when all is done
    if (!(options.autoConnect === false)) {
      jiff.connect();
    }

    return jiff;
  }

  // Exported API
  exports.make_jiff = make_jiff;

  /**
   * Contains utility functions that may be useful outside of the instance code.
   * @memberof jiff
   * @type {object}
   * @namespace jiff.utils
   */
  exports.utils = {
    encrypt_and_sign: encrypt_and_sign,
    decrypt_and_sign: decrypt_and_sign,
    is_prime: is_prime
  };

  /**
   * Contains builtin sharing schemes provided by jiff.
   * @memberof jiff
   * @type {object}
   * @namespace jiff.sharing_schemes
   */
  exports.sharing_schemes = {
    shamir_share: jiff_compute_shares,
    shamir_reconstruct: jiff_lagrange
  };
}((typeof exports === 'undefined' ? this.jiff = {} : exports), typeof exports !== 'undefined'));
/**
 * This defines a library extension for for bignumbers in JIFF.
 * This wraps and exposes the jiff-client-bignumber API. Exposed members can be accessed with jiff_bignumber.&lt;member-name&gt;
 * in browser JS, or by using require('<path>/lib/ext/jiff-client-bignumber').&lt;member-name&gt; as usual in nodejs.
 * @namespace jiff_bignumber
 * @version 1.0
 *
 * FEATURES: supports all of the regular JIFF API.
 *
 * EXTENSION DESIGN INSTRUCTIONS AND EXPLANATION:
 *     1) write a top-level function like the one here: [i.e. (function(exports, node) { .... })(typeof(exports) ....)]
 *        this function acts as the scope for the extension, which forbids name conflicts as well as forbid others from
 *        modifying or messing around with the functions and constants inside. Additionally, it makes the code useable
 *        from the browsers and nodejs.
 *
 *     2) In the very last line replace this.jiff_bignumber = {} with this.jiff_<extension_name> = {}. This is the defacto
 *        name space for this extension. Calling code on the user-side will use that name (jiff_<extension_name>) to access the
 *        functions you choose to expose. For nodejs the name space will be ignored and calling code can use the object
 *        returned by the require() call corresponding to this extension.
 *
 *     3) Inside the top-level function, create a function called make_jiff. The function should take two parameters:
 *            (a) base_instance, (b) options.
 *        base_instance: the base instance to wrap the extension around, it can be a basic jiff-client.js instance or
 *            an instance of another extension, you can use this instance to perform the basic operation that build
 *            your extensions (sharing of integers, simple operations on ints, etc)
 *        options: should be an object that provides your extension with whatever options it requires. The options for
 *            the base_instance will be passed to it prior to calling your extensions and may not be inside the options
 *            object, but you can access them using base_instance.
 *
 *     4) If your extension requires other extensions be applied to the base instance, you can force this by performing a
 *        a check, by calling <base_instance>.has_extension(<extension_name>).
 *
 *     5) Adding functionality: You have two options:
 *            (A) use hooks to modify the functionality of the base instance "in place"
 *                and then return the base instance.
 *            (B) Create a new object that contains the base_instance (perhaps as an attribute named "base"), you will
 *                need to recreate the JIFF API at the new object level. The implementation of this API can use functionality
 *                from base_instance. Return the new object.
 *
 *     6) If you need to override any feature in jiff (change how share work, or how open work, or how some primitive
 *        work etc), look at the hooks documentation to see if it is available as a hook. If it is, your best bet would
 *        be to use hooks on top of the base_instance. Another approach could be to override functions inside the base_instance
 *        or to create a new object with brand new functions (that may or may not refer to base_instance). These approaches
 *        can be mixed.
 *
 *     7) If you want to add additional feature that does not override any other feature in jiff, implement that in a
 *        function under a new appropriate name, make sure to document the function properly.
 *
 *     8) at the end of the top-level function and after make_jiff is done, make sure to have an
 *        if(node) { ... } else { ... } block, in which you expose the make_jiff function.
 *
 *     9) do not forget to export the name of the extension.
 *
 * Keep in mind that others may base extensions on your extension, or that clients may want to combine functionality from two extensions
 * together. If you have specific dependencies or if you know that the extension will be incompatible with other extensions, make sure
 * to enforce it by performing checks and throwing errors, as well as potentially overriding the can_apply_extension function
 * which will be called when future extensions are applied after your extension.
 */
(function (exports, node) {
  /**
   * The name of this extension: 'bignumber'
   * @type {string}
   * @memberOf jiff_bignumber
   */
  exports.name = 'bignumber';

  var BigNumber_;
  if (node) {
    // has to be global to make sure BigNumber library sees it.
    global.crypto = require('crypto');
    BigNumber_ = require('bignumber.js');
  } else {
    window.crypto = window.crypto || window.msCrypto;
    BigNumber_ = window.BigNumber;
  }

  // dependencies = { 'BigNumber': <BigNumber.js> }
  exports.dependencies = function (dependencies) {
    BigNumber_ = dependencies['BigNumber'] != null ? dependencies['BigNumber'] : BigNumber_;
  };

  /**
   * Check that an integer is prime. Used to safely set the modulus Zp.
   * @memberof jiff_bignumber.utils
   * @param {number} p - the prime number candidate.
   * @returns {boolean} true if p is prime, false otherwise.
   */
  function is_prime(p) {
    // AKS Primality Test
    p = new BigNumber_(p);

    if (p.eq(2)) {
      return true;
    } else if (p.eq(3)) {
      return true;
    } else if (p.mod(2).eq(0)) {
      return false;
    } else if (p.mod(3).eq(0)) {
      return false;
    }

    var i = new BigNumber_(5);
    var n = new BigNumber_(2);
    var six6 = new BigNumber_(6);
    while (i.times(i).lte(p)) {
      if (p.mod(i).eq(0)) {
        return false;
      }
      i = i.plus(n);
      n = six6.minus(n);
    }

    return true;
  }

  /* Equivalent Shamir Sharing for BigNumbers */
  function jiff_compute_shares(jiff, secret, parties_list, threshold, Zp) {
    var shares = {}; // Keeps the shares
    var i;

    secret = jiff.helpers.BigNumber(secret);
    Zp = jiff.helpers.BigNumber(Zp);

    // Each player's random polynomial f must have
    // degree threshold - 1, so that threshold many points are needed
    // to interpolate/reconstruct.
    var t = threshold - 1;
    var polynomial = Array(t + 1); // stores the coefficients

    // Each players's random polynomial f must be constructed
    // such that f(0) = secret
    polynomial[0] = secret;

    // Compute the random polynomial f's coefficients
    for (i = 1; i <= t; i++) {
      polynomial[i] = jiff.helpers.random(Zp);
    }

    // Compute each players share such that share[i] = f(i)
    for (i = 0; i < parties_list.length; i++) {
      var p_id = parties_list[i];
      shares[p_id] = polynomial[0];
      var power = jiff.helpers.BigNumber(jiff.helpers.get_party_number(p_id));

      for (var j = 1; j < polynomial.length; j++) {
        var tmp = jiff.helpers.mod(polynomial[j].times(power), Zp);
        shares[p_id] = jiff.helpers.mod(shares[p_id].plus(tmp), Zp);
        power = jiff.helpers.mod(power.times(jiff.helpers.get_party_number(p_id)), Zp);
      }
    }

    return shares;
  }

  /* Equivalent lagrange interpolation for BigNumbers */
  function jiff_lagrange(jiff, shares) {
    var lagrange_coeff = []; // will contain shares.length many elements.
    var i, pi;

    // Compute the Lagrange coefficients at 0.
    for (i = 0; i < shares.length; i++) {
      shares[i].Zp = jiff.helpers.BigNumber(shares[i].Zp);

      pi = jiff.helpers.get_party_number(shares[i].sender_id);
      lagrange_coeff[pi] = jiff.helpers.BigNumber(1);

      for (var j = 0; j < shares.length; j++) {
        var pj = jiff.helpers.get_party_number(shares[j].sender_id);
        if (pj !== pi) {
          var inv = jiff.helpers.extended_gcd(pi - pj, shares[i].Zp)[0];
          lagrange_coeff[pi] = jiff.helpers.mod(lagrange_coeff[pi].times(0 - pj), shares[i].Zp).times(inv);
          lagrange_coeff[pi] = jiff.helpers.mod(lagrange_coeff[pi], shares[i].Zp);
        }
      }
    }

    // Reconstruct the secret via Lagrange interpolation
    var recons_secret = jiff.helpers.BigNumber(0);
    for (i = 0; i < shares.length; i++) {
      pi = jiff.helpers.get_party_number(shares[i].sender_id);
      var tmp = jiff.helpers.mod(shares[i].value.times(lagrange_coeff[pi]), shares[i].Zp);
      recons_secret = jiff.helpers.mod(recons_secret.plus(tmp), shares[i].Zp);
    }

    return recons_secret;
  }

  // modify secret share implementations to use BigNumber
  function createSecretShare(jiff, share, share_helpers) {
    var self = share;

    var oldIsConstant = self.isConstant;
    self.isConstant = function (o) {
      return oldIsConstant(o) || o.isBigNumber === true;
    };

    // Avoid having to rewrite all the primitives: just override the helpers with bignumber equivalent!
    share_helpers['+'] = function (v1, v2) {
      return v1.plus(v2);
    };
    share_helpers['-'] = function (v1, v2) {
      return v1.minus(v2);
    };
    share_helpers['*'] = function (v1, v2) {
      return v1.times(v2);
    };
    share_helpers['/'] = function (v1, v2) {
      return v1.div(v2);
    };
    share_helpers['<'] = function (v1, v2) {
      return jiff.helpers.BigNumber(v1).lt(v2);
    };
    share_helpers['<='] = function (v1, v2) {
      return jiff.helpers.BigNumber(v1).lte(v2);
    };
    share_helpers['=='] = function (v1, v2) {
      return jiff.helpers.BigNumber(v1).eq(v2);
    };
    share_helpers['floor/'] = function (v1, v2) {
      return v1.div(v2).floor();
    };
    share_helpers['pow'] = function (v1, v2) {
      return self.jiff.helpers.BigNumber(v1).pow(v2);
    };
    share_helpers['binary'] = function (v) {
      return v.toString() === '1' || v.toString() === '0';
    };
    share_helpers['floor'] = function (v) {
      if (typeof(v) === 'number') {
        return Math.floor(v);
      }
      return v.floor();
    };
    share_helpers['ceil'] = function (v) {
      if (typeof(v) === 'number') {
        return Math.ceil(v);
      }
      return v.ceil();
    };
    share_helpers['abs'] = function (v) {
      return v.abs();
    };

    return self;
  }

  // Take the jiff-client base instance and options for this extension, and use them
  // to construct an instance for this extension.
  function make_jiff(base_instance, options) {
    var jiff = base_instance;

    // Parse options
    if (options == null) {
      options = {};
    }
    if (options.Zp != null) {
      jiff.Zp = options.Zp;
      if (options.safemod === true && !is_prime(options.Zp)) {
        throw new Error('Zp = ' + options.Zp.toString() + ' is not prime.  Please use a prime number for the modulus or set safemod to false.');
      }
    }

    if (jiff.has_extension('negativenumber')) {
      throw new Error('Please apply bignumber before negative number extensions');
    }
    if (jiff.has_extension('fixedpoint')) {
      throw new Error('Please apply bignumber before negative number extensions');
    }

    // Turn things into their BigNumber equivalent

    /* HELPERS */
    jiff.helpers._BigNumber = BigNumber_;
    jiff.helpers._BigNumber.config({CRYPTO: true});
    jiff.helpers.BigNumber = function (n) {
      // eslint-disable-next-line no-undef
      return new jiff.helpers._BigNumber(n);
    };

    jiff.helpers.mod = function (x, y) {
      x = jiff.helpers.BigNumber(x);
      y = jiff.helpers.BigNumber(y);
      if (x.isNeg()) {
        return x.mod(y).plus(y);
      }
      return x.mod(y);
    };

    jiff.helpers.pow_mod = function (a, b, n) {
      a = jiff.helpers.BigNumber(a);
      return a.pow(b, n);
    };

    jiff.helpers.extended_gcd = function (a, b) {
      a = jiff.helpers.BigNumber(a);
      b = jiff.helpers.BigNumber(b);
      return (
        function recursive_helper(a, b) {
          if (b.isZero()) {
            return [jiff.helpers.BigNumber(1), jiff.helpers.BigNumber(0), a];
          }

          var temp = recursive_helper(b, jiff.helpers.mod(a, b));
          var x = temp[0];
          var y = temp[1];
          var d = temp[2];
          return [y, x.minus(y.times(a.div(b).floor())), d];
        }
      )(a, b);
    };

    jiff.helpers.bLog = function (value, base) {
      // Not really log, but good enough since all we need is either floor or ceil of log.
      if (base == null) {
        base = 2;
      }
      var blog = value.toString(base).length;
      var test = jiff.helpers.BigNumber(base).pow(blog - 1);
      if (test.eq(value)) {
        return blog - 1;
      }
      return blog - 0.5;
    };

    jiff.helpers.Zp_equals = function (s1, s2) {
      return s1.Zp.eq(s2.Zp);
    };

    jiff.helpers.random = function (max) {
      if (max == null) {
        max = jiff.Zp;
      }

      var precision = max.toString().length;
      // eslint-disable-next-line no-undef
      var magnitude = jiff.helpers.BigNumber(10).pow(precision);
      var multiple = magnitude.div(max).floor().times(max);

      var rand;
      do {
        // eslint-disable-next-line no-undef
        rand = jiff.helpers._BigNumber.random(precision).times(magnitude).floor();
      } while (rand.gte(multiple));

      return rand.mod(max);
    };

    // eslint-disable-next-line no-undef
    jiff.Zp = jiff.helpers.BigNumber(jiff.Zp);

    /* SUB-PROTOCOLS */
    jiff.protocols.bit_composition = function (bits) {
      var result = bits[0];
      var pow = jiff.helpers.BigNumber(1);
      for (var i = 1; i < bits.length; i++) {
        pow = pow.times(2);
        result = result.isadd(bits[i].icmult(pow));
      }
      return result;
    };

    jiff.protocols.bits.cgt = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.cgt)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.cgt', bits[0].holders);
      }
      constant = jiff.helpers.BigNumber(constant);
      return jiff.protocols.bits.cgteq(bits, constant.plus(1), op_id);
    };

    /* SHARE CHECKS */
    jiff.share = function (secret, threshold, receivers_list, senders_list, Zp, share_id) {
      secret = secret != null ? jiff.helpers.BigNumber(secret) : secret;
      if (secret != null && (!secret.floor().eq(secret) || secret.lt(0))) {
        throw new Error('secret must be a non-negative whole number');
      }
      if (secret != null && (secret.gte(Zp == null ? jiff.Zp : Zp))) {
        throw new Error('secret must fit inside Zp');
      }
      return jiff.internal_share(secret, threshold, receivers_list, senders_list, Zp, share_id);
    };

    /* PREPROCESSING IS THE SAME */
    jiff.preprocessing_function_map[exports.name] = {};

    /* HOOKS */
    jiff.hooks.computeShares = jiff_compute_shares;
    jiff.hooks.reconstructShare = jiff_lagrange;

    jiff.hooks.createSecretShare.push(createSecretShare);
    // parse content of share/open messages to be bigNumbers (instead of strings due to encryption/decryption)
    jiff.hooks.afterOperation[0] = function (jiff, label, msg) {
      if (label === 'share' || label === 'open') {
        msg['share'] = jiff.helpers.BigNumber(msg['share']);
      } else if (label === 'crypto_provider' && msg['shares'] != null) {
        msg['Zp'] = jiff.helpers.BigNumber(msg['Zp']);
        for (var i = 0; i < msg['shares'].length; i++) {
          msg['shares'][i] = jiff.helpers.BigNumber(msg['shares'][i]);
        }
      }
      return msg;
    };

    return jiff;
  }

  // Expose the API for this extension.
  exports.make_jiff = make_jiff;
  exports.sharing_schemes = {shamir_share: jiff_compute_shares, shamir_reconstruct: jiff_lagrange};
  exports.utils = {is_prime: is_prime};
}((typeof exports === 'undefined' ? this.jiff_bignumber = {} : exports), typeof exports !== 'undefined'));

/**
 * This defines a library extension for for fixed point arithmetic in JIFF.
 * This wraps and exposes the jiff_fixedpoint API. Exposed members can be accessed with jiff_fixedpoint.&lt;member-name&gt;
 * in browser JS, or by using require('<path>/lib/ext/jiff-client-fixedpoint').&lt;member-name&gt; as usual in nodejs.
 *
 * @namespace jiff_fixedpoint
 * @version 1.0
 */
(function (exports, node) {
  /**
   * The name of this extension: 'fixedpoint'
   * @type {string}
   * @memberOf jiff_fixedpoint
   */
  exports.name = 'fixedpoint';

  function createFixedpointSecretShare(jiff_instance, share, share_helpers) {
    share.legacy = {};
    var internals = ['cadd', 'csub', 'cmult',
      'sadd', 'ssub', 'smult', 'smult_bgw',
      'cdivfac', 'cdiv', 'sdiv', 'smod',
      'cxor_bit', 'sxor_bit', 'cor_bit', 'sor_bit', 'not',
      'slt', 'slteq', 'sgt', 'sgteq', 'seq', 'sneq',
      'clt', 'clteq', 'cgt', 'cgteq', 'ceq', 'cneq',
      'lt_halfprime', 'if_else' ];
    for (var i = 0; i < internals.length; i++) {
      var key = internals[i];
      share.legacy[key] = share[key];
    }

    var magnitude = share.jiff.helpers.magnitude(share.jiff.decimal_digits);

    // Modify generic mult function to pass op_id to both cmult and smult
    share.mult = function (o, op_id) {
      if (share.isConstant(o)) {
        return share.cmult(o, op_id);
      }
      return share.smult(o, op_id);
    };

    // Constant arithmetic operations
    share.cadd = function (cst) {
      if (!(share.isConstant(cst))) {
        throw new Error('parameter should be a number (+)');
      }

      cst = share.jiff.helpers.BigNumber(cst);
      cst = share_helpers['floor'](share_helpers['*'](cst, magnitude));
      return share.legacy.cadd(cst);
    };
    share.csub = function (cst) {
      if (!(share.isConstant(cst))) {
        throw new Error('parameter should be a number (-)');
      }

      cst = share.jiff.helpers.BigNumber(cst);
      cst = share_helpers['floor'](share_helpers['*'](cst, magnitude));
      return share.legacy.csub(cst);
    };
    share.cmult = function (cst, op_id, div) {
      if (!(share.isConstant(cst))) {
        throw new Error('parameter should be a number (-)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('cmult', share.holders);
      }

      // turn to big number and multiply by magnitude
      cst = share.jiff.helpers.BigNumber(cst);
      var isInteger = cst.toString().indexOf('.') === -1;
      var cstDecimal = share_helpers['floor'](share_helpers['*'](cst, magnitude));

      // Different offset fixes if negative number is applied
      if (!share.jiff.has_extension('negativenumber')) {
        // Regular fixedpoint
        if (isInteger && div !== false) {
          return share.legacy.cmult(cst);
        }

        // multiply and move fixed point back
        var result = share.legacy.cmult(cstDecimal);
        if (div !== false) {
          result = result.legacy.cdiv(magnitude, op_id);
        }
        return result;
      } else {
        // With negative number
        var mOffset = magnitude.times(share.jiff.offset);
        if (isInteger && div !== false) {
          var tmp = share.legacy.cmult(cst);
          tmp = tmp.legacy.csub(mOffset.times(cst));
          tmp = tmp.legacy.cadd(mOffset);
          return tmp;
        }

        var resultNegative = share.legacy.cmult(cstDecimal);
        resultNegative = resultNegative.legacy.csub(mOffset.times(cstDecimal));
        resultNegative = resultNegative.legacy.cadd(mOffset.times(magnitude));
        if (div !== false) {
          resultNegative = resultNegative.legacy.cdiv(magnitude, op_id);
        }
        return resultNegative;
      }
    };

    share.cdivfac = function (cst) {
      if (!(share.isConstant(cst))) {
        throw new Error('Parameter should be a number (cdivfac)');
      }

      cst = share.jiff.helpers.BigNumber(cst).times(magnitude);
      var result = share.legacy.cdivfac(cst);
      return result.legacy.cmult(magnitude);
    };

    // secret arithmetic operations
    share.smult = function (o, op_id, div) {
      if (!(o.jiff === share.jiff)) {
        throw new Error('shares do not belong to the same instance (*)');
      }
      if (!share.jiff.helpers.Zp_equals(share, o)) {
        throw new Error('shares must belong to the same field (*)');
      }
      if (!share.jiff.helpers.array_equals(share.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (*)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('smult', share.holders);
      }

      var result = share.legacy.smult(o, op_id);

      // Negative number composing
      if (share.jiff.has_extension('negativenumber')) {
        var offset = share_helpers['*'](magnitude, share.jiff.offset);

        // Subtract x*offset*mag^2, y*offset*mag^2, offset^2*mag^2
        var subshare1 = share.icsub(offset).icmult(offset);
        var subshare2 = o.icsub(offset).icmult(offset);

        result = result.icsub(offset.pow(2));
        result = result.issub(subshare1).issub(subshare2);

        // Add offset term back on before dividing
        if (div === false) {
          result = result.icadd(offset);
        } else {
          result = result.icadd(offset.times(magnitude));
        }
      }

      if (div === false) {
        return result;
      }
      return result.legacy.cdiv(magnitude, op_id + ':reduce');
    };

    // BGW based secret multiplication
    share.smult_bgw = function (o, op_id, reshare, div) {
      if (!(o.jiff === share.jiff)) {
        throw new Error('shares do not belong to the same instance (bgw*)');
      }
      if (!share.jiff.helpers.Zp_equals(share, o)) {
        throw new Error('shares must belong to the same field (bgw*)');
      }
      if (!share.jiff.helpers.array_equals(share.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (bgw*)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('smult_bgw', share.holders);
      }

      var result = share.legacy.smult_bgw(o, op_id, reshare);

      // Negative number composing
      if (share.jiff.has_extension('negativenumber')) {
        var offset = share_helpers['*'](magnitude, share.jiff.offset);

        // Subtract x*offset*mag^2, y*offset*mag^2, offset^2*mag^2
        var subshare1 = share.icsub(offset).icmult(offset);
        var subshare2 = o.icsub(offset).icmult(offset);

        result = result.icsub(offset.pow(2));
        result = result.issub(subshare1).issub(subshare2);

        // Add offset term back on before dividing
        if (div === false) {
          result = result.icadd(offset);
        } else {
          result = result.icadd(offset.times(magnitude));
        }
      }

      if (div === false) {
        return result;
      }
      return result.legacy.cdiv(magnitude, op_id + ':reduce');
    };

    share.floor = function (o, op_id) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('floor', share.holders);
      }

      return share.legacy.cdiv(magnitude, op_id).legacy.cmult(magnitude);
    };

    // boolean operations on BINARY shares
    share.cxor_bit = function (cst) {
      if (!(share.isConstant(cst))) {
        throw new Error('parameter should be a number (^)');
      }
      if (!share_helpers['binary'](cst)) {
        throw new Error('parameter should be binary (^)');
      }

      // share should be both binary integers => our representation of it should be either 0 or 1 * 10^{decimal_digits}
      // In both cases, multiplying by the inverse of 10^{decimal_digits} should be enough to reduce it to either 0 or 1.
      var reduced_share = share.legacy.cdivfac(magnitude);
      var reduced_xor = reduced_share.legacy.cadd(cst).legacy.ssub(reduced_share.legacy.cmult(cst).legacy.cmult(2));
      return reduced_xor.legacy.cmult(magnitude);
    };
    share.cor_bit = function (cst) {
      if (!(share.isConstant(cst))) {
        throw new Error('parameter should be a number (|)');
      }
      if (!share_helpers['binary'](cst)) {
        throw new Error('parameter should be binary (|)');
      }

      // share should be both binary integers => our representation of it should be either 0 or 1 * 10^{decimal_digits}
      // In both cases, multiplying by the inverse of 10^{decimal_digits} should be enough to reduce it to either 0 or 1.
      var reduced_share = share.legacy.cdivfac(magnitude);
      var reduced_xor = reduced_share.legacy.cadd(cst).legacy.ssub(reduced_share.legacy.cmult(cst));
      return reduced_xor.legacy.cmult(magnitude);
    };
    share.sxor_bit = function (o, op_id) {
      if (!(o.jiff === share.jiff)) {
        throw new Error('shares do not belong to the same instance (^)');
      }
      if (!share.jiff.helpers.Zp_equals(share, o)) {
        throw new Error('shares must belong to the same field (^)');
      }
      if (!share.jiff.helpers.array_equals(share.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (^)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('sxor_bit', share.holders);
      }

      // share and o should be both binary integers => our representation of them should be either 0 or 1 * 10^{decimal_digits}
      // In both cases, multiplying by the inverse of 10^{decimal_digits} should be enough to reduce it to either 0 or 1.
      var reduced_share = share.legacy.cdivfac(magnitude);
      var reduced_o = o.legacy.cdivfac(magnitude);
      var reduced_xor = reduced_share.legacy.sadd(reduced_o).legacy.ssub(reduced_share.legacy.smult(reduced_o, op_id + ':smult1').legacy.cmult(2));
      return reduced_xor.legacy.cmult(magnitude);
    };
    share.sor_bit = function (o, op_id) {
      if (!(o.jiff === share.jiff)) {
        throw new Error('shares do not belong to the same instance (|)');
      }
      if (!share.jiff.helpers.Zp_equals(share, o)) {
        throw new Error('shares must belong to the same field (|)');
      }
      if (!share.jiff.helpers.array_equals(share.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (|)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('sor_bit', share.holders);
      }

      // share and o should be both binary integers => our representation of them should be either 0 or 1 * 10^{decimal_digits}
      // In both cases, multiplying by the inverse of 10^{decimal_digits} should be enough to reduce it to either 0 or 1.
      var reduced_share = share.legacy.cdivfac(magnitude);
      var reduced_o = o.legacy.cdivfac(magnitude);
      var reduced_or = reduced_share.legacy.sadd(reduced_o).legacy.ssub(reduced_share.legacy.smult(reduced_o, op_id + ':smult1'));
      return reduced_or.legacy.cmult(magnitude);
    };
    share.not = function () {
      return share.legacy.cmult(-1).legacy.cadd(magnitude);
    };

    // secret and constant comparisons
    var comparisons = [
      'slt', 'slteq', 'sgt', 'sgteq', 'seq', 'sneq',
      'clt', 'clteq', 'cgt', 'cgteq', 'ceq', 'cneq',
      'lt_halfprime'
    ];
    for (i = 0; i < comparisons.length; i++) {
      key = comparisons[i];
      share[key] = (function (key, i) {
        return function () {
          if (i > 5 && i < 12) {
            if (!(share.isConstant(arguments[0]))) {
              throw new Error('Parameter should be a number (' + key + ')');
            }
            arguments[0] = share.jiff.helpers.BigNumber(arguments[0]);
            arguments[0] = share_helpers['floor'](share_helpers['*'](arguments[0], magnitude));
          }
          var result = share.legacy[key].apply(share, arguments);
          return result.legacy.cmult(magnitude);
        };
      })(key, i);
    }

    // Fixedpoint division
    share.sdiv = function (o, l, op_id) {
      if (!(o.jiff === share.jiff)) {
        throw new Error('shares do not belong to the same instance (/)');
      }
      if (!share.jiff.helpers.Zp_equals(share, o)) {
        throw new Error('shares must belong to the same field (/)');
      }
      if (!share.jiff.helpers.array_equals(share.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (/)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('sdiv', share.holders);
      }

      var increased = share.legacy.cmult(magnitude);

      if (l != null) {
        l = l + share_helpers['ceil'](share.jiff.helpers.bLog(magnitude));
      }
      return increased.legacy.sdiv(o, l, op_id);
    };
    share.cdiv = function (cst, op_id) {
      if (!(share.isConstant(cst))) {
        throw new Error('parameter should be a number (/)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('cdiv', share.holders);
      }

      // if cst is an integer, do same old constant division
      if (cst.toString().indexOf('.') === -1) {
        return share.legacy.cdiv(cst, op_id);
      }

      cst = share.jiff.helpers.BigNumber(cst);
      cst = share_helpers['floor'](share_helpers['*'](cst, magnitude));

      var increased = share.legacy.cmult(magnitude);
      return increased.legacy.cdiv(cst, op_id);
    };

    // optimized if_else
    share.if_else = function (val1, val2, op_id) {
      if (share.isConstant(val1)) {
        val1 = magnitude.times(val1).floor();
      }
      if (share.isConstant(val2)) {
        val2 = magnitude.times(val2).floor();
      }

      var reduce_share = share.legacy.cdivfac(magnitude);
      return reduce_share.legacy.if_else(val1, val2, op_id);
    };

    return share;
  }

  // Take the jiff-client base instance and options for this extension, and use them
  // to construct an instance for this extension.
  function make_jiff(base_instance, options) {
    if (!base_instance.has_extension('bignumber')) {
      throw new Error('Fixedpoint extension must be applied on top of bignumber extension.');
    }

    if (base_instance.has_extension('negativenumber')) {
      throw new Error('Fixedpoint extension must be applied before negativenumber extension.');
    }

    /*
     * PARSE OPTIONS
     */
    if (options == null) {
      options = {};
    }
    if (options.Zp != null) {
      base_instance.Zp = base_instance.helpers.BigNumber(options.Zp);
    }

    // Determine the digits allocation, produce errors or warnings if not enough digits exists in Zp
    base_instance.total_digits = Math.floor(base_instance.helpers.bLog(base_instance.Zp, 10));
    if (options.decimal_digits == null && options.integer_digits == null) {
      options.decimal_digits = Math.floor(base_instance.total_digits / 3);
      options.integer_digits = Math.floor(base_instance.total_digits / 3);
    } else if (options.decimal_digits == null) {
      options.decimal_digits = Math.floor((base_instance.total_digits - options.integer_digits) / 2);
    } else if (options.integer_digits == null) {
      options.integer_digits = base_instance.total_digits - 2 * options.decimal_digits;
    }

    if (options.free_digits == null) {
      options.free_digits = Math.min(base_instance.total_digits - options.decimal_digits - options.integer_digits, options.decimal_digits);
    }

    base_instance.decimal_digits = options.decimal_digits;
    base_instance.integer_digits = options.integer_digits;
    base_instance.free_digits = options.free_digits;
    if (base_instance.free_digits + base_instance.decimal_digits + base_instance.integer_digits > base_instance.total_digits || base_instance.free_digits < 0) {
      throw new Error('Fixedpoint: Zp is not large enough to fit given integer, decimal, and free parts size');
    }
    if (base_instance.free_digits < options.decimal_digits) {
      if (!(options.warn === false)) {
        console.log('Warning: Fixedpoint extension: not enough free_digits to perform secret multiplications/divisions/mod or constant multiplications/divisions against non-integer constants safely. Need ' + (options.decimal_digits - base_instance.free_digits) + ' more digits in Zp.');
      }
      base_instance.free_digits = 0;
    }

    /* HELPERS */
    base_instance.helpers.magnitude = function (m) {
      return base_instance.helpers.BigNumber(10).pow(m).floor();
    };
    base_instance.helpers.fits_in_digits = function (num) {
      var magnitude = base_instance.helpers.magnitude(base_instance.decimal_digits + base_instance.integer_digits);
      return magnitude.gt(num);
    };
    base_instance.helpers.format_as_float = function (v) {
      /* if (!(options.warn === false)) {
        var max_value = base_instance.helpers.magnitude(base_instance.decimal_digits + base_instance.integer_digits);
        if (v.gte(max_value)) {
          console.log('warning: Fixedpoint extension: open result is not accurate: integer part grew too big.');
        }
      } */
      var magnitude = base_instance.helpers.magnitude(base_instance.decimal_digits);
      return v.div(magnitude);
    };
    base_instance.helpers.format_as_fixed = function (v) {
      if (!base_instance.helpers.fits_in_digits(v)) {
        throw new Error('Fixedpoint share: integer part is too big');
      }
      var magnitude = base_instance.helpers.magnitude(base_instance.decimal_digits);
      return magnitude.times(v).floor();
    };
    base_instance.helpers.to_fixed = function (v) {
      v = base_instance.helpers.BigNumber(v);
      var str = v.toFixed(base_instance.decimal_digits, base_instance.helpers._BigNumber.ROUND_FLOOR);
      return base_instance.helpers.BigNumber(str);

    };

    // Speed up calculating certain popular inverses by pre-computing
    var stored_magnitude = base_instance.helpers.magnitude(base_instance.decimal_digits);
    var stored_maginv = base_instance.helpers.extended_gcd(stored_magnitude, base_instance.Zp);
    var old_extended_gcd = base_instance.helpers.extended_gcd;
    base_instance.helpers.extended_gcd = function (a, b) {
      if (stored_magnitude.eq(a) && base_instance.Zp.eq(b)) {
        return stored_maginv;
      }
      return old_extended_gcd(a, b);
    };

    /* OPEN */
    var old_open = base_instance.open;
    base_instance.open = function () {
      var promise = old_open.apply(base_instance, arguments);
      if (promise == null) {
        return null;
      }
      return promise.then(base_instance.helpers.format_as_float);
    };
    var old_receive_open = base_instance.receive_open;
    base_instance.receive_open = function () {
      var promise = old_receive_open.apply(base_instance, arguments);
      return promise.then(base_instance.helpers.format_as_float);
    };

    /* SHARE */
    var old_share = base_instance.share;
    base_instance.share = function (secret, threshold, receivers_list, senders_list, Zp, share_id) {
      if (secret != null) {
        secret = base_instance.helpers.format_as_fixed(secret);
      }
      return old_share(secret, threshold, receivers_list, senders_list, Zp, share_id);
    };

    /* changes to preprocessing */
    var previous_namespace = base_instance.extensions[base_instance.extensions.indexOf(exports.name)-1];
    var optional_div = function (threshold, receivers_list, compute_list, Zp, op_id, params) {
      if (params.div === false) {
        params.ignore = true;
      } else {
        params = cdiv_constant(threshold, receivers_list, compute_list, Zp, op_id, params);
      }
      return params;
    };
    var cdiv_constant = function (threshold, receivers_list, compute_list, Zp, op_id, params) {
      if (params.constant == null) {
        params.constant = base_instance.helpers.magnitude(base_instance.decimal_digits);
      }
      return params;
    };

    base_instance.preprocessing_function_map[exports.name] = {
      cmult: [
        { op: 'cdiv', op_id: '', namespace: previous_namespace, handler: optional_div }
      ],

      smult: [
        { op: 'smult', op_id: '', namespace: previous_namespace },
        { op: 'cdiv', op_id: ':reduce', namespace: previous_namespace, handler: optional_div }
      ],

      smult_bgw: [
        { op: 'cdiv', op_id: ':reduce', namespace: previous_namespace, handler: optional_div }
      ],

      floor: [
        { op: 'cdiv', op_id: '', namespace: previous_namespace, handler: cdiv_constant }
      ]
    };

    /* HOOKS */
    base_instance.hooks.createSecretShare.push(createFixedpointSecretShare);

    return base_instance;
  }

  // Expose API
  exports.make_jiff = make_jiff;
}((typeof exports === 'undefined' ? this.jiff_fixedpoint = {} : exports), typeof exports !== 'undefined'));

/**
 * This defines a library extension for for negativenumber in JIFF.
 * This wraps and exposes the jiff-client-negativenumber API. Exposed members can be accessed with jiff_negativenumber.&lt;member-name&gt;
 * in browser JS, or by using require('<path>/lib/ext/jiff-client-negativenumber').&lt;member-name&gt; as usual in nodejs.
 * @namespace jiff_negativenumber
 * @version 1.0
 *
 * FEATURES: supports all of the regular JIFF API.
 * COMPOSITION: composes with bignumber and fixedpoint extensions.
 *
 */

(function (exports, node) {
  /**
   * The name of this extension: 'negativenumber'
   * @type {string}
   * @memberOf jiff_negativenumber
   */
  exports.name = 'negativenumber';

  // secret share implementation
  function createNegativeNumberSecretShare(jiff, share, share_helpers) {
    var hasBigNumber = jiff.has_extension('bignumber');
    var hasFixedPoint = jiff.has_extension('fixedpoint');
    var offset = share.jiff.offset;

    // Keep a copy of the previous implementation of changed primitives
    share.negative_legacy = {};
    var internals = ['cadd', 'csub', 'cmult',
      'sadd', 'ssub', 'smult', 'smult_bgw',
      'cdivfac', 'cdiv', 'sdiv', 'smod',
      'cxor_bit', 'sxor_bit', 'cor_bit', 'sor_bit', 'not',
      'slt', 'slteq', 'sgt', 'sgteq', 'seq', 'sneq',
      'clt', 'clteq', 'cgt', 'cgteq', 'ceq', 'cneq',
      'lt_halfprime', 'if_else' ];
    for (var i = 0; i < internals.length; i++) {
      var key = internals[i];
      share.negative_legacy[key] = share[key];
    }

    // Constant arithmetic and boolean operations
    share.cmult = function (cst, op_id, div) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('cmult', share.holders);
      }

      var result = share.negative_legacy.cmult(cst, op_id, div);
      if (hasFixedPoint) {
        return result;
      }
      // Works for regular and bigNumbers
      result = result.negative_legacy.csub(share_helpers['*'](offset, cst));
      return result.negative_legacy.cadd(offset);
    };

    // Secret arithmetic operations
    share.sadd = function (o) {
      var result = share.negative_legacy.sadd(o);
      return result.negative_legacy.csub(offset);
    };
    share.ssub = function (o) {
      // The offset will cancel with the normal ssub, so we add it back on
      var result = share.negative_legacy.ssub(o);
      return result.negative_legacy.cadd(offset);
    };
    share.smult = function (o, op_id, div) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('smult', share.holders);
      }

      var result;
      if (hasFixedPoint) {
        // Regular multiplication
        // Result: x*y*mag^2 + x*offset*mag^2 + y*offset*mag^2 + offset^2*mag^2
        result = share.negative_legacy.smult(o, op_id, div);
      } else {
        result = share.negative_legacy.csub(offset);
        o = o.negative_legacy.csub(offset);
        result = result.negative_legacy.smult(o, op_id);
        result = result.negative_legacy.cadd(offset);
      }
      return result;
    };
    share.smult_bgw = function (o, op_id, reshare, div) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('smult_bgw', share.holders);
      }

      var result;
      if (hasFixedPoint) {
        // Regular multiplication
        // Result: x*y*mag^2 + x*offset*mag^2 + y*offset*mag^2 + offset^2*mag^2
        result = share.negative_legacy.smult_bgw(o, op_id, reshare, div);
      } else {
        result = share.negative_legacy.csub(offset);
        o = o.negative_legacy.csub(offset);
        result = result.negative_legacy.smult_bgw(o, op_id, reshare);
        result = result.negative_legacy.cadd(offset);
      }
      return result;
    };

    // bit operations
    share.cxor_bit = function (cst) {
      var result = share.negative_legacy.csub(offset);
      result = result.negative_legacy.cxor_bit(cst);
      return result.negative_legacy.cadd(offset);
    };
    share.cor_bit = function (cst_bit) {
      var result = share.negative_legacy.csub(offset);
      result = result.negative_legacy.cor_bit(cst_bit);
      return result.negative_legacy.cadd(offset);
    };
    // secret boolean operations
    share.sxor_bit = function (o, op_id) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('sxor_bit', share.holders);
      }

      var result = share.negative_legacy.csub(offset);
      o = o.negative_legacy.csub(offset);
      result = result.negative_legacy.sxor_bit(o, op_id);
      return result.negative_legacy.cadd(offset);
    };
    share.sor_bit = function (o, op_id) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('sor_bit', share.holders);
      }

      var result = share.negative_legacy.csub(offset);
      o = o.negative_legacy.csub(offset);
      result = result.negative_legacy.sor_bit(o, op_id);
      return result.negative_legacy.cadd(offset);
    };
    // not operator
    share.not = function () {
      var reduced = share.negative_legacy.csub(offset);
      reduced = reduced.icmult(-1).negative_legacy.cadd(1);
      return reduced.negative_legacy.cadd(offset);
    };

    // secret and constant comparisons
    var comparisons = [
      'slt', 'slteq', 'sgt', 'sgteq', 'seq', 'sneq',
      'clt', 'clteq', 'cgt', 'cgteq', 'ceq', 'cneq',
      'lt_halfprime'
    ];
    for (i = 0; i < comparisons.length; i++) {
      key = comparisons[i];
      share[key] = (function (key, i) {
        return function () {
          if (i > 5 && i < 12) {
            if (!(share.isConstant(arguments[0]))) {
              throw new Error('Parameter should be a number (' + key + ')');
            }
            arguments[0] = share_helpers['+'](offset, arguments[0]);
          }
          var result = share.negative_legacy[key].apply(share, arguments);
          return result.negative_legacy.cadd(offset);
        };
      })(key, i);
    }

    // Divisions will utilize this function to reduce the underlying representation
    // of shares that are known to be whole non-negative numbers to the base representation
    // so that they are compatible with base legacy operations.
    function reduce_representation(share) {
      share = share.negative_legacy.csub(offset);
      if (hasFixedPoint) {
        var magnitude = share.jiff.helpers.magnitude(share.jiff.decimal_digits);
        share = share.negative_legacy.cdivfac(magnitude);
      }
      return share;
    }

    // Divisions
    share.cdivfac = function (cst, op_id) {
      if (!(share.isConstant(cst))) {
        throw new Error('Parameter should be a number (cdivfac)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('cdivfac', share.holders);
      }

      // Absolute value of share and cst
      var shareAbs = share.iabs(op_id + ':abs', true);
      var selfNegative = shareAbs.isNegative;
      shareAbs = shareAbs.result.negative_legacy.csub(offset);

      cst = hasBigNumber ? share.jiff.helpers.BigNumber(cst) : cst;
      var otherNegative = share_helpers['<'](cst, 0);
      cst = share_helpers['abs'](cst);

      // This is the result assuming both share and o are non-negative
      var result = shareAbs.negative_legacy.cdivfac(cst);

      // For efficiency, since we know that selfNegative is a bit (i.e. non-negative integer)
      // reduce selfNegative to base representation (either 0 or 1 without offset or magnitude)
      // then use it to correct the sign of the result.
      selfNegative = reduce_representation(selfNegative);
      var signUnit = selfNegative.icmult(-2).icadd(1); // if negative this is -1, if positive this is 1

      // o is positive
      if (!otherNegative) { // only need to correct for if share is negative
        result = result.ismult(signUnit, op_id + ':cor1');
      } else { // o is negative, correct if share is positive
        result = result.ismult(signUnit.icmult(-1), op_id + ':cor1');
      }
      return result.negative_legacy.cadd(offset);
    };
    share.cdiv = function (cst, op_id, floor_down) {
      if (!(share.isConstant(cst))) {
        throw new Error('Parameter should be a number (cdiv)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('cdiv', share.holders);
      }

      // Absolute value of share and cst
      var shareAbs = share.iabs(op_id + ':abs', true);
      var selfNegative = shareAbs.isNegative;
      shareAbs = shareAbs.result.negative_legacy.csub(offset);

      cst = hasBigNumber ? share.jiff.helpers.BigNumber(cst) : cst;
      var otherNegative = share_helpers['<'](cst, 0);
      var cstAbs = share_helpers['abs'](cst);

      // This is the result assuming both share and o are non-negative
      var resultAbs = shareAbs.negative_legacy.cdiv(cstAbs, op_id + ':cdiv');

      // Sign correction
      selfNegative = reduce_representation(selfNegative);
      var signUnit = selfNegative.icmult(-2).icadd(1); // if negative this is -1, if positive this is 1
      var result;
      if (!otherNegative) { // only need to correct for if share is negative
        result = resultAbs.ismult(signUnit, op_id + ':cor1');
      } else {
        result = resultAbs.ismult(signUnit.icmult(-1), op_id + ':cor1');
      }
      result = result.negative_legacy.cadd(offset);

      // Floor correction
      if (floor_down === false) { // Round to zero
        return result;
      } else { // Round down
        var magnitude = hasFixedPoint ? share.jiff.helpers.magnitude(share.jiff.decimal_digits) : 1;
        magnitude = cstAbs.toString().indexOf('.') > -1 ? magnitude : 1;
        magnitude = hasBigNumber ? share.jiff.helpers.BigNumber(magnitude) : magnitude;
        cstAbs = share_helpers['floor'](share_helpers['*'](magnitude, cstAbs));

        var need_round = resultAbs.icmult(cstAbs).isneq(shareAbs.icmult(magnitude), op_id + ':floor:sneq');
        var xorNegative = selfNegative.icxor_bit(otherNegative ? 1 : 0);

        // we must correct if (1) need rounding (i.e. cst does not divide share) (2) xorNegative (i.e. result is negative)
        var and = need_round.ismult(xorNegative, op_id+':floor:and');
        return result.issub(and);
      }
    };
    share.smod = function (o, l, op_id) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('smod', share.holders);
      }

      // Absolute value of share and o
      var shareAbs = share.iabs(op_id+':abs1', true);
      var negative = shareAbs.isNegative;
      shareAbs = shareAbs.result.negative_legacy.csub(offset);
      var oAbs = o.iabs(op_id+':abs2').negative_legacy.csub(offset);

      // |share| % |o|
      var result = shareAbs.negative_legacy.smod(oAbs, l, op_id + ':smod');
      negative = reduce_representation(negative);

      // Sign correction
      negative = negative.icmult(-2).icadd(1); // if negative = -1, else = 1
      result = result.ismult(negative, op_id+':smult');
      return result.negative_legacy.cadd(offset);
    };
    share.sdiv = function (o, l, op_id, floor_down) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('sdiv', share.holders);
      }

      // Absolute value of share and o
      var shareAbs = share.iabs(op_id + ':abs1', true);
      var selfNegative = shareAbs.isNegative;
      shareAbs = shareAbs.result.negative_legacy.csub(offset);

      var otherAbs = o.iabs(op_id + ':abs2', true);
      var otherNegative = otherAbs.isNegative;
      otherAbs = otherAbs.result.negative_legacy.csub(offset);

      // This is the result assuming both share and o are non-negative
      var resultAbs = shareAbs.negative_legacy.sdiv(otherAbs, l, op_id + ':sdiv');

      // Sign correction: if either share or o are negative but not both.
      selfNegative = reduce_representation(selfNegative);
      otherNegative = reduce_representation(otherNegative);
      var xorNegative = selfNegative.isxor_bit(otherNegative, op_id + ':sxor');
      var sign = xorNegative.icmult(-2).icadd(1); // if negative = -1, else = 1
      var result = resultAbs.ismult(sign, op_id + ':cor1');
      result = result.negative_legacy.cadd(offset);

      // Floor correction
      if (floor_down === false) { // Round to zero
        return result;
      } else { // Round down
        var magnitude = hasFixedPoint ? share.jiff.helpers.magnitude(share.jiff.decimal_digits) : 1;
        var need_round = resultAbs.ismult(otherAbs, op_id+':floor:smult').isneq(shareAbs.icmult(magnitude), op_id+':floor:sneq');

        // we must correct if (1) need rounding (i.e. cst does not divide share) (2) xorNegative (i.e. result is negative)
        var and = xorNegative.ismult(need_round, op_id + ':floor:and');
        return result.issub(and);
      }
    };

    // New Operations
    // absolute value
    share.abs = function (op_id, return_intermediate) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('abs', share.holders);
      }

      var _offset = offset;
      if (hasFixedPoint) {
        var magnitude = share.jiff.helpers.magnitude(share.jiff.decimal_digits);
        _offset = share_helpers['*'](magnitude, _offset);
      }

      var isNegative = share.iclt(_offset, op_id + ':clt'); // 0 or 1, no offset or magnitude
      var correction = share.icsub(_offset).icmult(2);
      var result = share.issub(correction.ismult(isNegative, op_id + ':smult'));

      if (return_intermediate === true) {
        if (hasFixedPoint) {
          isNegative = isNegative.icmult(share.jiff.helpers.magnitude(share.jiff.decimal_digits));
        }
        return { result: result, isNegative: isNegative.icadd(_offset) };
      } else {
        return result;
      }
    };
    share.iabs = share.abs;

    // optimized if_else
    share.if_else = function (val1, val2, op_id) {
      if (share.isConstant(val1)) {
        val1 = share_helpers['+'](offset, val1);
      }
      if (share.isConstant(val2)) {
        val2 = share_helpers['+'](offset, val2);
      }

      var reduce_share = share.negative_legacy.csub(offset);
      return reduce_share.negative_legacy.if_else(val1, val2, op_id);
    };

    return share;
  }

  // Take the jiff-client base instance and options for this extension, and use them
  // to construct an instance for this extension.
  function make_jiff(base_instance, options) {
    var jiff = base_instance;

    // Parse options
    if (options == null) {
      options = {};
    }

    // Offset 'scales' negative numbers
    jiff.offset = options.offset;
    if (jiff.offset == null) {
      if (jiff.has_extension('fixedpoint')) {
        jiff.offset = jiff.helpers.magnitude(jiff.integer_digits);

        // Sanity Checks
        var maxNoMult = jiff.helpers.magnitude(jiff.integer_digits + jiff.decimal_digits).times(2);
        if (!maxNoMult.lte(jiff.Zp)) {
          var msg = 'Fixedpoint|NegativeNumber: Zp is not large enough to fit given integer and decimal parts with negative numbers. ';
          msg += 'Need Zp >= ' + maxNoMult.toString() + ' to fit parameters.';
          throw msg;
        }
        var maxWithMult = jiff.helpers.magnitude(jiff.integer_digits + 2*jiff.decimal_digits).times(2);
        if (!maxWithMult.lte(jiff.Zp) && !(options.warn === false)) {
          var warnMsg = 'Warning: Fixedpoint|NegativeNumber extension: not enough free_digits to perform secret multiplications/divisions or constant multiplications/divisions against non-integer constants safely. ';
          warnMsg += 'Need Zp >= ' +maxWithMult.toString();
          console.log(warnMsg);
        }
      } else if (jiff.has_extension('bignumber')) {
        jiff.offset = jiff.Zp.div(2).floor();
      } else {
        jiff.offset = Math.floor(jiff.Zp / 2);
      }
    }

    var old_open = jiff.open;
    jiff.open = function () {
      var promise = old_open.apply(jiff, arguments);
      if (promise == null) {
        return null;
      } else {
        return promise.then(
          function (v) {
            if (jiff.has_extension('bignumber')) {
              return v.minus(jiff.offset);
            } else {
              return v - jiff.offset;
            }
          }
        );
      }
    };

    var old_receive_open = jiff.receive_open;
    jiff.receive_open = function () {
      var promise = old_receive_open.apply(jiff, arguments);
      return promise.then(
        function (v) {
          if (jiff.has_extension('bignumber')) {
            return v.minus(jiff.offset);
          } else {
            return v - jiff.offset;
          }
        }
      );
    };

    /* SHARE */
    var old_share = jiff.share;
    jiff.share = function (secret, threshold, receivers_list, senders_list, Zp, share_id) {
      if (secret != null) {
        if (jiff.has_extension('bignumber')) {
          secret = jiff.offset.plus(secret);
        } else {
          secret = secret + jiff.offset;
        }
      }
      return old_share(secret, threshold, receivers_list, senders_list, Zp, share_id);
    };

    /* changes to preprocessing */
    var previous_namespace = jiff.extensions[jiff.extensions.indexOf(exports.name)-1];
    var should_floor_down_preprocessing = function (threshold, receivers_list, compute_list, Zp, op_id, params) {
      if (params.floor_down === false) {
        params.ignore = true;
      }
      return params;
    };

    jiff.preprocessing_function_map[exports.name] = {
      abs: [
        { op: 'clt', op_id: ':clt' },
        { op: 'smult', op_id: ':smult' }
      ],
      cdivfac: [
        { op: 'abs', op_id: ':abs', namespace: exports.name },
        { op: 'smult', op_id: ':cor1' }
      ],
      cdiv: [
        { op: 'abs', op_id: ':abs', namespace: exports.name },
        { op: 'cdiv', op_id: ':cdiv', namespace: previous_namespace },
        { op: 'smult', op_id: ':cor1' },
        { op: 'sneq', op_id: ':floor:sneq', handler: should_floor_down_preprocessing },
        { op: 'smult', op_id: ':floor:and', handler: should_floor_down_preprocessing }
      ],
      sdiv: [
        { op: 'abs', op_id: ':abs1', namespace: exports.name },
        { op: 'abs', op_id: ':abs2', namespace: exports.name },
        { op: 'sdiv', op_id: ':sdiv', namespace: previous_namespace },
        { op: 'sxor_bit', op_id: ':sxor' },
        { op: 'smult', op_id: ':cor1' },
        { op: 'smult', op_id: ':floor:smult', handler: should_floor_down_preprocessing },
        { op: 'sneq', op_id: ':floor:sneq', handler: should_floor_down_preprocessing },
        { op: 'smult', op_id: ':floor:and', handler: should_floor_down_preprocessing }
      ],
      smod: [
        { op: 'abs', op_id: ':abs1', namespace: exports.name },
        { op: 'abs', op_id: ':abs2', namespace: exports.name },
        { op: 'smod', op_id: ':smod', namespace: previous_namespace },
        { op: 'smult', op_id: ':smult' }
      ]
    };

    /* HOOKS */
    jiff.hooks.createSecretShare.push(createNegativeNumberSecretShare);

    return jiff;
  }

  // Expose API
  exports.make_jiff = make_jiff;

}((typeof exports === 'undefined' ? this.jiff_negativenumber = {} : exports), typeof exports !== 'undefined'));


    </script>
  </body>
</html>
  
