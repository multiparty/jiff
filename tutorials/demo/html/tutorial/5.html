<html>
  <head>
    <meta charset="UTF-8">
    <title>inner-product - Neptune-notebook.js</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    
    <!-- code mirror dependencies -->
    <script type="text/javascript">
      // CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// This is CodeMirror (https://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.CodeMirror = factory());
}(this, (function () { 'use strict';

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
  var android = /Android/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) { presto_version = Number(presto_version[1]); }
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

  var rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      { e.removeChild(e.firstChild); }
    return e
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e)
  }

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) { e.className = className; }
    if (style) { e.style.cssText = style; }
    if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
    return e
  }
  // wrapper for elt, which removes the elt from the accessibility tree
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e
  }

  var range;
  if (document.createRange) { range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r
  }; }
  else { range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r
  }; }

  function contains(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      { child = child.parentNode; }
    if (parent.contains)
      { return parent.contains(child) }
    do {
      if (child.nodeType == 11) { child = child.host; }
      if (child == parent) { return true }
    } while (child = child.parentNode)
  }

  function activeElt() {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;
    try {
      activeElement = document.activeElement;
    } catch(e) {
      activeElement = document.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
      { activeElement = activeElement.shadowRoot.activeElement; }
    return activeElement
  }

  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
    return b
  }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
  else if (ie) // Suppress mysterious IE10 errors
    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args)}
  }

  function copyObj(obj, target, overwrite) {
    if (!target) { target = {}; }
    for (var prop in obj)
      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        { target[prop] = obj[prop]; } }
    return target
  }

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) { end = string.length; }
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        { return n + (end - i) }
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  }

  var Delayed = function() {this.id = null;};
  Delayed.prototype.set = function (ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      { if (array[i] == elt) { return i } }
    return -1
  }

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = {toString: function(){return "CodeMirror.Pass"}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) { nextTab = string.length; }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        { return pos + Math.min(skipped, goal - col) }
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) { return pos }
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      { spaceStrs.push(lst(spaceStrs) + " "); }
    return spaceStrs[n]
  }

  function lst(arr) { return arr[arr.length-1] }

  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
    return out
  }

  function insertSorted(array, value, score) {
    var pos = 0, priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) { pos++; }
    array.splice(pos, 0, value);
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) { copyObj(props, inst); }
    return inst
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordCharBasic(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
  }
  function isWordChar(ch, helper) {
    if (!helper) { return isWordCharBasic(ch) }
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
    return helper.test(ch)
  }

  function isEmpty(obj) {
    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
    return true
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
    return pos
  }

  // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.
  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;
    for (;;) {
      if (from == to) { return from }
      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) { return pred(mid) ? from : to }
      if (pred(mid)) { to = mid; }
      else { from = mid + dir; }
    }
  }

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) { return f(from, to, "ltr", 0) }
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }
    if (!found) { f(from, to, "ltr"); }
  }

  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < ch && cur.to > ch) { return i }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") { found = i; }
        else { bidiOther = i; }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") { found = i; }
        else { bidiOther = i; }
      }
    }
    return found != null ? found : bidiOther
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6f9
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 0xf7) { return lowTypes.charAt(code) }
      else if (0x590 <= code && code <= 0x5f4) { return "R" }
      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
      else if (0x6ee <= code && code <= 0x8ac) { return "r" }
      else if (0x2000 <= code && code <= 0x200b) { return "w" }
      else if (code == 0x200c) { return "b" }
      else { return "L" }
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";

      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
      var len = str.length, types = [];
      for (var i = 0; i < len; ++i)
        { types.push(charType(str.charCodeAt(i))); }

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];
        if (type == "m") { types[i$1] = prev; }
        else { prev = type; }
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];
        if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];
        if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
        else if (type$2 == "," && prev$1 == types[i$3+1] &&
                 (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
        prev$1 = type$2;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];
        if (type$3 == ",") { types[i$4] = "N"; }
        else if (type$3 == "%") {
          var end = (void 0);
          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i$4; j < end; ++j) { types[j] = replace; }
          i$4 = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];
        if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
        else if (isStrong.test(type$4)) { cur$1 = type$4; }
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = (void 0);
          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
          var before = (i$6 ? types[i$6-1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? (before ? "L" : "R") : outerType;
          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
          i$6 = end$1 - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;
          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7, at = order.length;
          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }
              var nstart = j$2;
              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              pos = j$2;
            } else { ++j$2; }
          }
          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }

      return direction == "rtl" ? order.reverse() : order
    }
  })();

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
    return order
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var noHandlers = [];

  var on = function(emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers || (emitter._handlers = {});
      map$$1[type] = (map$$1[type] || noHandlers).concat(f);
    }
  };

  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1)
          { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
      }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type);
    if (!handlers.length) { return }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) { return }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
      { set.push(arr[i]); } }
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  function e_preventDefault(e) {
    if (e.preventDefault) { e.preventDefault(); }
    else { e.returnValue = false; }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) { e.stopPropagation(); }
    else { e.cancelBubble = true; }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
  }
  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

  function e_target(e) {return e.target || e.srcElement}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) { b = 1; }
      else if (e.button & 2) { b = 3; }
      else if (e.button & 4) { b = 2; }
    }
    if (mac && e.ctrlKey && b == 1) { b = 3; }
    return b
  }

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) { return false }
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) { return badBidiRects }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
    return badBidiRects = (r1.right - r0.right < 3)
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) { nl = string.length; }
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result
  } : function (string) { return string.split(/\r\n?|\n/); };

  var hasSelection = window.getSelection ? function (te) {
    try { return te.selectionStart != te.selectionEnd }
    catch(e) { return false }
  } : function (te) {
    var range$$1;
    try {range$$1 = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range$$1 || range$$1.parentElement() != te) { return false }
    return range$$1.compareEndPoints("StartToEnd", range$$1) != 0
  };

  var hasCopyEvent = (function () {
    var e = elt("div");
    if ("oncopy" in e) { return true }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function"
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) { return badZoomedRects }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
  }

  // Known modes, by name and by MIME
  var modes = {}, mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  function defineMode(name, mode) {
    if (arguments.length > 2)
      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
    modes[name] = mode;
  }

  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") { found = {name: found}; }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml")
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json")
    }
    if (typeof spec == "string") { return {name: spec} }
    else { return spec || {name: "null"} }
  }

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) { return getMode(options, "text/plain") }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) { continue }
        if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) { modeObj.helperType = spec.helperType; }
    if (spec.modeProps) { for (var prop$1 in spec.modeProps)
      { modeObj[prop$1] = spec.modeProps[prop$1]; } }

    return modeObj
  }

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  }

  function copyState(mode, state) {
    if (state === true) { return state }
    if (mode.copyState) { return mode.copyState(state) }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) { val = val.concat([]); }
      nstate[n] = val;
    }
    return nstate
  }

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) { break }
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state}
  }

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true
  }

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = function(string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };

  StringStream.prototype.eol = function () {return this.pos >= this.string.length};
  StringStream.prototype.sol = function () {return this.pos == this.lineStart};
  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
  StringStream.prototype.next = function () {
    if (this.pos < this.string.length)
      { return this.string.charAt(this.pos++) }
  };
  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") { ok = ch == match; }
    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
    if (ok) {++this.pos; return ch}
  };
  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;
    while (this.eat(match)){}
    return this.pos > start
  };
  StringStream.prototype.eatSpace = function () {
      var this$1 = this;

    var start = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }
    return this.pos > start
  };
  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) {this.pos = found; return true}
  };
  StringStream.prototype.backUp = function (n) {this.pos -= n;};
  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) -
      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) { this.pos += pattern.length; }
        return true
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) { return null }
      if (match && consume !== false) { this.pos += match[0].length; }
      return match
    }
  };
  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;
    try { return inner() }
    finally { this.lineStart -= n; }
  };
  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n)
  };
  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos)
  };

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
    var chunk = doc;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break }
        n -= sz;
      }
    }
    return chunk.lines[n]
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line) { text = text.slice(0, end.ch); }
      if (n == start.line) { text = text.slice(start.ch); }
      out.push(text);
      ++n;
    });
    return out
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
    return out
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) { return null }
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) { break }
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1], ch = child.height;
        if (h < ch) { chunk = child; continue outer }
        h -= ch;
        n += child.chunkSize();
      }
      return n
    } while (!chunk.lines)
    var i = 0;
    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) { break }
      h -= lh;
    }
    return n + i
  }

  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber))
  }

  // A Pos instance represents a position within the text.
  function Pos(line, ch, sticky) {
    if ( sticky === void 0 ) sticky = null;

    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

  function copyPos(x) {return Pos(x.line, x.ch)}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) { return Pos(doc.first, 0) }
    var last = doc.first + doc.size - 1;
    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
    return clipToLen(pos, getLine(doc, pos.line).text.length)
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
    else if (ch < 0) { return Pos(pos.line, 0) }
    else { return pos }
  }
  function clipPosArray(doc, array) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
    return out
  }

  var SavedContext = function(state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };

  var Context = function(doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };

  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
    return line
  };

  Context.prototype.baseToken = function (n) {
      var this$1 = this;

    if (!this.baseTokens) { return null }
    while (this.baseTokens[this.baseTokenPos] <= n)
      { this$1.baseTokenPos += 2; }
    var type = this.baseTokens[this.baseTokenPos + 1];
    return {type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n}
  };

  Context.prototype.nextLine = function () {
    this.line++;
    if (this.maxLookAhead > 0) { this.maxLookAhead--; }
  };

  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext)
      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
    else
      { return new Context(doc, copyState(doc.mode, saved), line) }
  };

  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
  };


  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
            lineClasses, forceToEnd);
    var state = context.state;

    // Run overlays, adjust style array.
    var loop = function ( o ) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            { st.splice(i, 1, end, st[i+1], i_end); }
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) { return }
        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };

    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) { context.state = resetState; }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) { line.styleClasses = result.classes; }
      else if (line.styleClasses) { line.styleClasses = null; }
      if (updateFrontier === cm.doc.highlightFrontier)
        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
    }
    return line.styles
  }

  function getContextBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) { return new Context(doc, true, n) }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) { doc.modeFrontier = context.line; }
    return context
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") { callBlankLine(mode, context.state); }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) { return mode.blankLine(state) }
    if (!mode.innerMode) { return }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) { inner[0] = innerMode(mode, state).mode; }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) { return style }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.")
  }

  var Token = function(stream, type, state) {
    this.start = stream.start; this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  };

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
    if (asArray) { tokens = []; }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
    }
    return asArray ? tokens : new Token(stream, style, context.state)
  }

  function extractLineClasses(type, output) {
    if (type) { for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) { break }
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        { output[prop] = lineClass[2]; }
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        { output[prop] += " " + lineClass[2]; }
    } }
    return type
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) { processLine(cm, text, context, stream.pos); }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) { return doc.first }
      var line = getLine(doc, search - 1), after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
        { return search }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline
  }

  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);
    if (doc.highlightFrontier < n - 10) { return }
    var start = doc.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter;
      // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break
      }
    }
    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  }

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }

  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) { for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) { return span }
    } }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i = 0; i < spans.length; ++i)
      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
    return r
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    } }
    return nw
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    } }
    return nw
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) { return null }
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) { return null }

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) { span.to = startCh; }
          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];
        if (span$1.to != null) { span$1.to += offset; }
        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);
          if (!found$1) {
            span$1.from = offset;
            if (sameLine) { (first || (first = [])).push(span$1); }
          }
        } else {
          span$1.from += offset;
          if (sameLine) { (first || (first = [])).push(span$1); }
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) { first = clearEmptySpans(first); }
    if (last && last != first) { last = clearEmptySpans(last); }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        { for (var i$2 = 0; i$2 < first.length; ++i$2)
          { if (first[i$2].to == null)
            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
      for (var i$3 = 0; i$3 < gap; ++i$3)
        { newMarkers.push(gapMarkers); }
      newMarkers.push(last);
    }
    return newMarkers
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        { spans.splice(i--, 1); }
    }
    if (!spans.length) { return null }
    return spans
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          { (markers || (markers = [])).push(mark); }
      } }
    });
    if (!markers) { return null }
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          { newParts.push({from: p.from, to: m.from}); }
        if (dto > 0 || !mk.inclusiveRight && !dto)
          { newParts.push({from: m.to, to: p.to}); }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.detachLine(line); }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.attachLine(line); }
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) { return lenDiff }
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) { return -fromCmp }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) { return toCmp }
    return b.id - a.id
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        { found = sp.marker; }
    } }
    return found
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
    } }
    return found
  }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
    var line = getLine(doc, lineNo$$1);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
        { return true }
    } }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      { line = merged.find(-1, true).line; }
    return line
  }

  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return line
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line
      ;(lines || (lines = [])).push(line);
    }
    return lines
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) { return lineN }
    return lineNo(vis)
  }

  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) { return lineN }
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) { return lineN }
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return lineNo(line) + 1
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      if (sp.from == null) { return true }
      if (sp.marker.widgetNode) { continue }
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        { return true }
    } }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      { return true }
    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) { return true }
    }
  }

  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) { break }
      else { h += line.height; }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];
        if (cur == chunk) { break }
        else { h += cur.height; }
      }
    }
    return h
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) { return 0 }
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }
    return len
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };

  Line.prototype.lineNo = function () { return lineNo(this) };
  eventMixin(Line);

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) { line.stateAfter = null; }
    if (line.styles) { line.styles = null; }
    if (line.order != null) { line.order = null; }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) { return null }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"))
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
                   col: 0, pos: 0, cm: cm,
                   trailingSpace: false,
                   splitSpaces: cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
        if (line.styleClasses.textClass)
          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
        { builder.content.className = "cm-tab-wrap-hack"; }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

    return builder
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
    if (!text) { return }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) { mustWrap = true; }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
          else { content.appendChild(txt); }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) { break }
        pos += skipped + 1;
        var txt$1 = (void 0);
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
          else { content.appendChild(txt$1); }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) { fullStyle += startStyle; }
      if (endStyle) { fullStyle += endStyle; }
      var token = elt("span", [content], fullStyle, css);
      if (attributes) {
        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")
          { token.setAttribute(attr, attributes[attr]); } }
      }
      return builder.content.appendChild(token)
    }
    builder.content.appendChild(content);
  }

  // Change some spaces to NBSP to prevent the browser from collapsing
  // trailing spaces at the end of a line when rendering text (issue #1362).
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) { return text }
    var spaceBefore = trailingBefore, result = "";
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
        { ch = "\u00a0"; }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, css, attributes) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = (void 0);
        for (var i = 0; i < order.length; i++) {
          part = order[i];
          if (part.to > start && part.from <= start) { break }
        }
        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    }
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        { widget = builder.content.appendChild(document.createElement("span")); }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1+=2)
        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
      return
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = css = "";
        attributes = null;
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [], endStyles = (void 0);
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) { spanStyle += " " + m.className; }
            if (m.css) { css = (css ? css + ";" : "") + m.css; }
            if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
            // support for the old title property
            // https://github.com/codemirror/CodeMirror/pull/5673
            if (m.title) { (attributes || (attributes = {})).title = m.title; }
            if (m.attributes) {
              for (var attr in m.attributes)
                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              { collapsed = sp; }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) { return }
          if (collapsed.to == pos) { collapsed = false; }
        }
      }
      if (pos >= len) { break }

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }


  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array
  }

  var operationGroup = null;

  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        { callbacks[i].call(null); }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
      }
    } while (i < callbacks.length)
  }

  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) { return }

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      endCb(group);
    }
  }

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type);
    if (!arr.length) { return }
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function ( i ) {
      list.push(function () { return arr[i].apply(null, args); });
    };

    for (var i = 0; i < arr.length; ++i)
      loop( i );
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") { updateLineText(cm, lineView); }
      else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
      else if (type == "class") { updateLineClasses(cm, lineView); }
      else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
    }
    return lineView.node
  }

  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) { cls += " CodeMirror-linebackground"; }
    if (lineView.background) {
      if (cls) { lineView.background.className = cls; }
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built
    }
    return buildLineContent(cm, lineView)
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) { lineView.node = built.pre; }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass)
      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
    else if (lineView.node != lineView.text)
      { lineView.node.className = ""; }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                      ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        { gutterWrap.className += " " + lineView.line.gutterClass; }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        { lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
                                     ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
      } }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) { lineView.alignable = null; }
    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
      next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget")
        { lineView.node.removeChild(node); }
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) { lineView.bgClass = built.bgClass; }
    if (built.textClass) { lineView.textClass = built.textClass; }

    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) { return }
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        { wrap.insertBefore(node, lineView.gutter || lineView.text); }
      else
        { wrap.appendChild(node); }
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
  (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
    }
  }

  function widgetHeight(widget) {
    if (widget.height != null) { return widget.height }
    var cm = widget.doc.cm;
    if (!cm) { return 0 }
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
      if (widget.noHScroll)
        { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight
  }

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        { return true }
    }
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
  function paddingH(display) {
    if (display.cachedPaddingH) { return display.cachedPaddingH }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
    return data
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            { heights.push((cur.bottom + next.top) / 2 - rect.top); }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      { return {map: lineView.measure.map, cache: lineView.measure.cache} }
    for (var i = 0; i < lineView.rest.length; i++)
      { if (lineView.rest[i] == line)
        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
      { if (lineNo(lineView.rest[i$1]) > lineN)
        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      { return cm.display.view[findViewIndex(cm, lineN)] }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      { return ext }
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view)
      { view = updateExternalMeasurement(cm, line); }

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    }
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) { ch = -1; }
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        { prepared.rect = prepared.view.text.getBoundingClientRect(); }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) { prepared.cache[key] = found; }
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom}
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map$$1, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map$$1.length; i += 3) {
      mStart = map$$1[i];
      mEnd = map$$1[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) { collapse = "right"; }
      }
      if (start != null) {
        node = map$$1[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          { collapse = bias; }
        if (bias == "left" && start == 0)
          { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
            node = map$$1[(i -= 3) + 2];
            collapse = "left";
          } }
        if (bias == "right" && start == mEnd - mStart)
          { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
            node = map$$1[(i += 3) + 2];
            collapse = "right";
          } }
        break
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") { for (var i = 0; i < rects.length; i++) {
      if ((rect = rects[i]).left != rect.right) { break }
    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
      if ((rect = rects[i$1]).left != rect.right) { break }
    } }
    return rect
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
          { rect = node.parentNode.getBoundingClientRect(); }
        else
          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
        if (rect.left || rect.right || start == 0) { break }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) { collapse = bias = "right"; }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
      else
        { rect = node.getBoundingClientRect(); }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
      else
        { rect = nullRect; }
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;
    for (; i < heights.length - 1; i++)
      { if (mid < heights[i]) { break } }
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) { result.bogus = true; }
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      { return rect }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY}
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
        { lineView.measure.caches[i] = {}; } }
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      { clearLineMeasurementCacheFor(cm.display.view[i]); }
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
    cm.display.lineNumChars = null;
  }

  function pageScrollX() {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
    return window.pageXOffset || (document.documentElement || document.body).scrollLeft
  }
  function pageScrollY() {
    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
    return window.pageYOffset || (document.documentElement || document.body).scrollTop
  }

  function widgetTopHeight(lineObj) {
    var height = 0;
    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
      { height += widgetHeight(lineObj.widgets[i]); } } }
    return height
  }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height; rect.bottom += height;
    }
    if (context == "line") { return rect }
    if (!context) { context = "local"; }
    var yOff = heightAtLine(lineObj);
    if (context == "local") { yOff += paddingTop(cm.display); }
    else { yOff -= cm.display.viewOffset; }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") { return coords }
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) { m.left = m.right; } else { m.right = m.left; }
      return intoCoordSystem(cm, lineObj, m, context)
    }
    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

    function getBidi(ch, partPos, invert) {
      var part = order[partPos], right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert)
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
    return val
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height}
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) { pos.outside = outside; }
    return pos
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }
    if (x < 0) { x = 0; }

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
      if (!collapsed) { return found }
      var rangeEnd = collapsed.find(1);
      if (rangeEnd.line == lineN) { return rangeEnd }
      lineObj = getLine(doc, lineN = rangeEnd.line);
    }
  }

  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
    return {begin: begin, end: end}
  }

  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
  }

  // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
  }

  function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
    // Move y into line-local coordinate space
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.
    var widgetHeight$$1 = widgetTopHeight(lineObj);
    var begin = 0, end = lineObj.text.length, ltr = true;

    var order = getOrder(lineObj, cm.doc.direction);
    // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
                   (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }

    // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.
    var chAround = null, boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;
      if (!boxIsAfter(box, x, y, false)) { return false }
      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }
      return true
    }, begin, end);

    var baseX, sticky, outside = false;
    // If a box around the coordinates was found, use that
    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) { ch++; }
      // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?
        "after" : "before";
      // Now get accurate coordinates for this place, in order to get a
      // base X position
      var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
    }

    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)
  }

  function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i], ltr = part.level != 1;
      return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"),
                                     "line", lineObj, preparedMeasure), x, y, true)
    }, 0, order.length - 1);
    var part = order[index];
    // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"),
                               "line", lineObj, preparedMeasure);
      if (boxIsAfter(start, x, y, true) && start.top > y)
        { part = order[index - 1]; }
    }
    return part
  }

  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
    var part = null, closestDist = null;
    for (var i = 0; i < order.length; i++) {
      var p = order[i];
      if (p.from >= end || p.to <= begin) { continue }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) { part = order[order.length - 1]; }
    // Clip the part to the wrapped line.
    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
    return part
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) { return display.cachedTextHeight }
    if (measureText == null) {
      measureText = elt("pre", null, "CodeMirror-line-like");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) { display.cachedTextHeight = height; }
    removeChildren(display.measure);
    return height || 1
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) { return display.cachedCharWidth }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor], "CodeMirror-line-like");
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) { display.cachedCharWidth = width; }
    return width || 10
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      var id = cm.display.gutterSpecs[i].className;
      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[id] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth}
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) { return 0 }

      var widgetsHeight = 0;
      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
      } }

      if (wrapping)
        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
      else
        { return widgetsHeight + th }
    }
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height) { updateLineHeight(line, estHeight); }
    });
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e) { return null }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) { return null }
    n -= cm.display.viewFrom;
    if (n < 0) { return null }
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) { return i }
    }
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) { from = cm.doc.first; }
    if (to == null) { to = cm.doc.first + cm.doc.size; }
    if (!lendiff) { lendiff = 0; }

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      { display.updateLineNumbers = from; }

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        { resetView(cm); }
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        { ext.lineN += lendiff; }
      else if (from < ext.lineN + ext.size)
        { display.externalMeasured = null; }
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      { display.externalMeasured = null; }

    if (line < display.viewFrom || line >= display.viewTo) { return }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) { return }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) { arr.push(type); }
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      { return {index: index, lineN: newN} }
    var n = cm.display.viewFrom;
    for (var i = 0; i < index; i++)
      { n += view[i].size; }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) { return null }
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN}
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
      else if (display.viewFrom < from)
        { display.view = display.view.slice(findViewIndex(cm, from)); }
      display.viewFrom = from;
      if (display.viewTo < to)
        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
      else if (display.viewTo > to)
        { display.view = display.view.slice(0, findViewIndex(cm, to)); }
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
    }
    return dirty
  }

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    if ( primary === void 0 ) primary = true;

    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) { continue }
      var range$$1 = doc.sel.ranges[i];
      if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }
      var collapsed = range$$1.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        { drawSelectionCursor(cm, range$$1.head, curFragment); }
      if (!collapsed)
        { drawSelectionRange(cm, range$$1, selFragment); }
    }
    return result
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range$$1, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";

    function add(left, top, width, bottom) {
      if (top < 0) { top = 0; }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
      }

      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop]
      }

      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");

        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
        var first = i == 0, last = !order || i == order.length - 1;
        if (toPos.top - fromPos.top <= 3) { // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else { // Multiple lines
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }

        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
        if (cmpCoords(toPos, start) < 0) { start = toPos; }
        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
        if (cmpCoords(toPos, end) < 0) { end = toPos; }
      });
      return {start: start, end: end}
    }

    var sFrom = range$$1.from(), sTo = range$$1.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        { add(leftSide, leftEnd.bottom, null, rightStart.top); }
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) { return }
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
        cm.options.cursorBlinkRate); }
    else if (cm.options.cursorBlinkRate < 0)
      { display.cursorDiv.style.visibility = "hidden"; }
  }

  function ensureFocus(cm) {
    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
  }

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () { if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
      onBlur(cm);
    } }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }

    if (cm.options.readOnly == "nocursor") { return }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) { return }

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], wrapping = cm.options.lineWrapping;
      var height = (void 0), width = 0;
      if (cur.hidden) { continue }
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
        // Check that lines don't extend past the right of the current
        // editor width
        if (!wrapping && cur.text.firstChild)
          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
      }
      var diff = cur.line.height - height;
      if (diff > .005 || diff < -.005) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
          { updateWidgetHeight(cur.rest[j]); } }
      }
      if (width > cm.display.sizerWidth) {
        var chWidth = Math.ceil(width / charWidth(cm.display));
        if (chWidth > cm.display.maxLineLength) {
          cm.display.maxLineLength = chWidth;
          cm.display.maxLine = cur.line;
          cm.display.maxLineChanged = true;
        }
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
      var w = line.widgets[i], parent = w.node.parentNode;
      if (parent) { w.height = parent.offsetHeight; }
    } }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)}
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (rect.top + box.top < 0) { doScroll = true; }
    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) { margin = 0; }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = {left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
      }
      if (!changed) { break }
    }
    return rect
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, rect) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (rect.top < 0) { rect.top = 0; }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
      if (newTop != screentop) { result.scrollTop = newTop; }
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) { rect.right = rect.left + screenw; }
    if (rect.left < 10)
      { result.scrollLeft = 0; }
    else if (rect.left < screenleft)
      { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
    else if (rect.right > screenw + screenleft - 3)
      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
    return result
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollTop(cm, top) {
    if (top == null) { return }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
  }

  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) { resolveScrollToPos(cm); }
    if (x != null) { cm.curOp.scrollLeft = x; }
    if (y != null) { cm.curOp.scrollTop = y; }
  }

  function scrollToRange(cm, range$$1) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range$$1;
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range$$1 = cm.curOp.scrollToPos;
    if (range$$1) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);
      scrollToCoordsRange(cm, from, to, range$$1.margin);
    }
  }

  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
    if (!gecko) { updateDisplaySimple(cm, {top: val}); }
    setScrollTop(cm, val, true);
    if (gecko) { updateDisplaySimple(cm); }
    startWorker(cm, 100);
  }

  function setScrollTop(cm, val, forceScroll) {
    val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
  }

  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
    cm.display.scrollbars.setScrollLeft(val);
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    }
  }

  var NativeScrollbars = function(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert); place(horiz);

    on(vert, "scroll", function () {
      if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
  };

  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;

    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      // A bug in IE8 can cause this value to be negative, so guard it.
      this.vert.firstChild.style.height =
        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }

    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width =
        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }

    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) { this.zeroWidthHack(); }
      this.checkedZeroWidth = true;
    }

    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
  };

  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
  };

  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
  };

  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
    this.disableHoriz = new Delayed;
    this.disableVert = new Delayed;
  };

  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.pointerEvents = "auto";
    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt$$1 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt$$1 != bar) { bar.style.pointerEvents = "none"; }
      else { delay.set(1000, maybeDisable); }
    }
    delay.set(1000, maybeDisable);
  };

  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };

  var NullScrollbars = function () {};

  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
  NullScrollbars.prototype.setScrollLeft = function () {};
  NullScrollbars.prototype.setScrollTop = function () {};
  NullScrollbars.prototype.clear = function () {};

  function updateScrollbars(cm, measure) {
    if (!measure) { measure = measureForScrollbars(cm); }
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        { updateHeightsInViewport(cm); }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else { d.scrollbarFiller.style.display = ""; }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else { d.gutterFiller.style.display = ""; }
  }

  var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
    }

    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function () {
        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") { setScrollLeft(cm, pos); }
      else { updateScrollTop(cm, pos); }
    }, cm);
    if (cm.display.scrollbars.addClass)
      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
  }

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: 0,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId           // Unique ID
    };
    pushOperation(cm.curOp);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp;
    if (op) { finishOperation(op, function (group) {
      for (var i = 0; i < group.ops.length; i++)
        { group.ops[i].cm.curOp = null; }
      endOperations(group);
    }); }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      { endOperation_R1(ops[i]); }
    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
      { endOperation_W1(ops[i$1]); }
    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
      { endOperation_R2(ops[i$2]); }
    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
      { endOperation_W2(ops[i$3]); }
    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
      { endOperation_finish(ops[i$4]); }
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) { findMaxLine(cm); }

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) { updateHeightsInViewport(cm); }

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      { op.preparedSelection = display.input.prepareSelection(); }
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt();
    if (op.preparedSelection)
      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      { updateScrollbars(cm, op.barMeasure); }
    if (op.updatedDisplay)
      { setDocumentHeight(cm, op.barMeasure); }

    if (op.selectionChanged) { restartBlink(cm); }

    if (cm.state.focused && op.updateInput)
      { cm.display.input.reset(op.typing); }
    if (takeFocus) { ensureFocus(op.cm); }
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      { display.wheelStartX = display.wheelStartY = null; }

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) { for (var i = 0; i < hidden.length; ++i)
      { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

    if (display.wrapper.offsetHeight)
      { doc.scrollTop = cm.display.scroller.scrollTop; }

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      { signal(cm, "changes", cm, op.changeObjs); }
    if (op.update)
      { op.update.finish(); }
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) { return f() }
    startOperation(cm);
    try { return f() }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) { return f.apply(cm, arguments) }
      startOperation(cm);
      try { return f.apply(cm, arguments) }
      finally { endOperation(cm); }
    }
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) { return f.apply(this, arguments) }
      startOperation(this);
      try { return f.apply(this, arguments) }
      finally { endOperation(this); }
    }
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) { return f.apply(this, arguments) }
      startOperation(cm);
      try { return f.apply(this, arguments) }
      finally { endOperation(cm); }
    }
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo)
      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.highlightFrontier >= cm.display.viewTo) { return }
    var end = +new Date + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];

    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) { context.state = resetState; }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) { line.styleClasses = newCls; }
        else if (oldCls) { line.styleClasses = null; }
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
        if (ischange) { changedLines.push(context.line); }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength)
          { processLine(cm, line.text, context); }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
    if (changedLines.length) { runInOp(cm, function () {
      for (var i = 0; i < changedLines.length; i++)
        { regLineChange(cm, changedLines[i], "text"); }
    }); }
  }

  // DISPLAY DRAWING

  var DisplayUpdate = function(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };

  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type))
      { this.events.push(arguments); }
  };
  DisplayUpdate.prototype.finish = function () {
      var this$1 = this;

    for (var i = 0; i < this.events.length; i++)
      { signal.apply(null, this$1.events[i]); }
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  function selectionSnapshot(cm) {
    if (cm.hasFocus()) { return null }
    var active = activeElt();
    if (!active || !contains(cm.display.lineDiv, active)) { return null }
    var result = {activeElt: active};
    if (window.getSelection) {
      var sel = window.getSelection();
      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result
  }

  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
    snapshot.activeElt.focus();
    if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var sel = window.getSelection(), range$$1 = document.createRange();
      range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range$$1.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range$$1);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      { return false }

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      { return false }

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) { display.lineDiv.style.display = ""; }
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    restoreSelection(selSnapshot);

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          { break }
      }
      if (!updateDisplayIfNeeded(cm, update)) { break }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        { node.style.display = "none"; }
      else
        { node.parentNode.removeChild(node); }
      return next
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) { cur = rm(cur); }
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) { cur = rm(cur); }
  }

  function updateGutterSpace(display) {
    var width = display.gutters.offsetWidth;
    display.sizer.style.marginLeft = width + "px";
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
  }

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
      if (cm.options.fixedGutter) {
        if (view[i].gutter)
          { view[i].gutter.style.left = left; }
        if (view[i].gutterBackground)
          { view[i].gutterBackground.style.left = left; }
      }
      var align = view[i].alignable;
      if (align) { for (var j = 0; j < align.length; j++)
        { align[j].style.left = left; } }
    } }
    if (cm.options.fixedGutter)
      { display.gutters.style.left = (comp + gutterW) + "px"; }
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) { return false }
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm.display);
      return true
    }
    return false
  }

  function getGutters(gutters, lineNumbers) {
    var result = [], sawLineNumbers = false;
    for (var i = 0; i < gutters.length; i++) {
      var name = gutters[i], style = null;
      if (typeof name != "string") { style = name.style; name = name.className; }
      if (name == "CodeMirror-linenumbers") {
        if (!lineNumbers) { continue }
        else { sawLineNumbers = true; }
      }
      result.push({className: name, style: style});
    }
    if (lineNumbers && !sawLineNumbers) { result.push({className: "CodeMirror-linenumbers", style: null}); }
    return result
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function renderGutters(display) {
    var gutters = display.gutters, specs = display.gutterSpecs;
    removeChildren(gutters);
    display.lineGutter = null;
    for (var i = 0; i < specs.length; ++i) {
      var ref = specs[i];
      var className = ref.className;
      var style = ref.style;
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
      if (style) { gElt.style.cssText = style; }
      if (className == "CodeMirror-linenumbers") {
        display.lineGutter = gElt;
        gElt.style.width = (display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = specs.length ? "" : "none";
    updateGutterSpace(display);
  }

  function updateGutters(cm) {
    renderGutters(cm.display);
    regChange(cm);
    alignHorizontally(cm);
  }

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input, options) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [lines], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

    if (place) {
      if (place.appendChild) { place.appendChild(d.wrapper); }
      else { place(d.wrapper); }
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
    renderGutters(d);

    input.init(d);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) { wheelPixelsPerUnit = -.53; }
  else if (gecko) { wheelPixelsPerUnit = 15; }
  else if (chrome) { wheelPixelsPerUnit = -.7; }
  else if (safari) { wheelPixelsPerUnit = -1/3; }

  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
    else if (dy == null) { dy = e.wheelDelta; }
    return {x: dx, y: dy}
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta
  }

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) { return }

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY)
        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || (dy && canScrollY))
        { e_preventDefault(e); }
      display.wheelStartX = null; // Abort measurement, if in progress
      return
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) { return }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) { return }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  var Selection = function(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };

  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

  Selection.prototype.equals = function (other) {
      var this$1 = this;

    if (other == this) { return true }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
    for (var i = 0; i < this.ranges.length; i++) {
      var here = this$1.ranges[i], there = other.ranges[i];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
    }
    return true
  };

  Selection.prototype.deepCopy = function () {
      var this$1 = this;

    var out = [];
    for (var i = 0; i < this.ranges.length; i++)
      { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }
    return new Selection(out, this.primIndex)
  };

  Selection.prototype.somethingSelected = function () {
      var this$1 = this;

    for (var i = 0; i < this.ranges.length; i++)
      { if (!this$1.ranges[i].empty()) { return true } }
    return false
  };

  Selection.prototype.contains = function (pos, end) {
      var this$1 = this;

    if (!end) { end = pos; }
    for (var i = 0; i < this.ranges.length; i++) {
      var range = this$1.ranges[i];
      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
        { return i }
    }
    return -1
  };

  var Range = function(anchor, head) {
    this.anchor = anchor; this.head = head;
  };

  Range.prototype.from = function () { return minPos(this.anchor, this.head) };
  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(cm, ranges, primIndex) {
    var mayTouch = cm && cm.options.selectionsMayTouch;
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      var diff = cmp(prev.to(), cur.from());
      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) { --primIndex; }
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex)
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0)
  }

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  function changeEnd(change) {
    if (!change.text) { return change.to }
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
  }

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) { return pos }
    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
    return Pos(line, ch)
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(doc.cm, out, doc.sel.primIndex)
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
    else
      { return Pos(nw.line + (pos.line - old.line), pos.ch) }
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex)
  }

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) { line.stateAfter = null; }
      if (line.styles) { line.styles = null; }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) { regChange(cm); }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight$$1);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i = start; i < end; ++i)
        { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }
      return result
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) { doc.remove(from.line, nlines); }
      if (added.length) { doc.insert(from.line, added); }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);
      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
      doc.insert(from.line + 1, added$2);
    }

    signalLater(doc, "change", doc, change);
  }

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) { continue }
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) { continue }
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      } }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) { throw new Error("This document is already in use.") }
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    if (!cm.options.lineWrapping) { findMaxLine(cm); }
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  function setDirectionClass(cm) {
  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }

  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
    return histChange
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) { array.pop(); }
      else { break }
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done)
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done)
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done)
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;
    var last;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        { pushSelectionToHistory(doc.sel, hist.done); }
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) { hist.done.shift(); }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) { signal(doc, "historyAdded"); }
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      { hist.done[hist.done.length - 1] = sel; }
    else
      { pushSelectionToHistory(sel, hist.done); }

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      { clearSelectionEvents(hist.undone); }
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      { dest.push(sel); }
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) { return null }
    var out;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
      else if (out) { out.push(spans[i]); }
    }
    return !out ? spans : out.length ? out : null
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) { return null }
    var nw = [];
    for (var i = 0; i < change.text.length; ++i)
      { nw.push(removeClearedSpans(found[i])); }
    return nw
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) { return stretched }
    if (!stretched) { return old }

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            { if (oldCur[k].marker == span.marker) { continue spans } }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i = 0; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m = (void 0);
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        } } }
      }
    }
    return copy
  }

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head)
    } else {
      return new Range(other || head, head)
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
    for (var i = 0; i < doc.sel.ranges.length; i++)
      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        var this$1 = this;

        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head)); }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
    else { return sel }
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      { sel = filterSelectionChange(doc, sel, options); }

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      { ensureCursorVisible(doc.cm); }
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) { return }

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = 1;
      doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) { out = sel.ranges.slice(0, i); }
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
      var sp = line.markedSpans[i], m = sp.marker;

      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
      // is with selectLeft/Right
      var preventCursorLeft = ("selectLeft" in m) ? !m.selectLeft : m.inclusiveLeft;
      var preventCursorRight = ("selectRight" in m) ? !m.selectRight : m.inclusiveRight;

      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
        if (mayClear) {
          signal(m, "beforeCursorEnter");
          if (m.explicitlyCleared) {
            if (!line.markedSpans) { break }
            else {--i; continue}
          }
        }
        if (!m.atomic) { continue }

        if (oldPos) {
          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
          if (dir < 0 ? preventCursorRight : preventCursorLeft)
            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
            { return skipAtomicInner(doc, near, pos, dir, mayClear) }
        }

        var far = m.find(dir < 0 ? -1 : 1);
        if (dir < 0 ? preventCursorLeft : preventCursorRight)
          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
      }
    } }
    return pos
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0)
    }
    return found
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
      else { return null }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
      else { return null }
    } else {
      return new Pos(pos.line, pos.ch + dir)
    }
  }

  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }

  // UPDATING

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function () { return obj.canceled = true; }
    };
    if (update) { obj.update = function (from, to, text, origin) {
      if (from) { obj.from = clipPos(doc, from); }
      if (to) { obj.to = clipPos(doc, to); }
      if (text) { obj.text = text; }
      if (origin !== undefined) { obj.origin = origin; }
    }; }
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

    if (obj.canceled) {
      if (doc.cm) { doc.cm.curOp.updateInput = 2; }
      return null
    }
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
      if (doc.cm.state.suppressEdits) { return }
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) { return }
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    var suppress = doc.cm && doc.cm.state.suppressEdits;
    if (suppress && !allowSelectionOnly) { return }

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    var i = 0;
    for (; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        { break }
    }
    if (i == source.length) { return }
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return
        }
        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return
      } else { break }
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    var loop = function ( i ) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {}
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };

    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop( i$1 );

      if ( returned ) return returned.v;
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) { return }
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
      Pos(range.anchor.line + distance, range.anchor.ch),
      Pos(range.head.line + distance, range.head.ch)
    ); }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        { regLineChange(doc.cm, l, "gutter"); }
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return
    }
    if (change.from.line > doc.lastLine()) { return }

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
    else { updateDoc(doc, change, spans); }
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);

    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))
      { doc.cantEdit = false; }
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      { signalCursorActivity(cm); }

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
    }

    retreatFrontier(doc, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      { regChange(cm); }
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      { regLineChange(cm, from.line, "text"); }
    else
      { regChange(cm, from.line, to.line + 1, lendiff); }

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) { signalLater(cm, "change", cm, obj); }
      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    var assign;

    if (!to) { to = from; }
    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
    if (typeof code == "string") { code = doc.splitLines(code); }
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue
      }
      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
    else { no = lineNo(handle); }
    if (no == null) { return null }
    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
    return line
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    var this$1 = this;

    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this$1;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length },

    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      var this$1 = this;

      for (var i = at, e = at + n; i < e; ++i) {
        var line = this$1.lines[i];
        this$1.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },

    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },

    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      var this$1 = this;

      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }
    },

    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      var this$1 = this;

      for (var e = at + n; at < e; ++at)
        { if (op(this$1.lines[at])) { return true } }
    }
  };

  function BranchChunk(children) {
    var this$1 = this;

    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this$1;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size },

    removeInner: function(at, n) {
      var this$1 = this;

      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this$1.height -= oldHeight - child.height;
          if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },

    collapse: function(lines) {
      var this$1 = this;

      for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }
    },

    insertInner: function(at, lines, height) {
      var this$1 = this;

      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this$1.children.splice(++i, 0, leaf);
              leaf.parent = this$1;
            }
            child.lines = child.lines.slice(0, remaining);
            this$1.maybeSpill();
          }
          break
        }
        at -= sz;
      }
    },

    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) { return }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
       } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10)
      me.parent.maybeSpill();
    },

    iterN: function(at, n, op) {
      var this$1 = this;

      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) { return true }
          if ((n -= used) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
    }
  };

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = function(doc, node, options) {
    var this$1 = this;

    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
      { this$1[opt] = options[opt]; } } }
    this.doc = doc;
    this.node = node;
  };

  LineWidget.prototype.clear = function () {
      var this$1 = this;

    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) { return }
    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }
    if (!ws.length) { line.widgets = null; }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };

  LineWidget.prototype.changed = function () {
      var this$1 = this;

    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) { return }
    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      { addToScrollTop(cm, diff); }
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) { widgets.push(widget); }
      else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) { addToScrollTop(cm, widget.height); }
        cm.curOp.forceUpdate = true;
      }
      return true
    });
    if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
    return widget
  }

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  var TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };

  // Clear the marker.
  TextMarker.prototype.clear = function () {
      var this$1 = this;

    if (this.explicitlyCleared) { return }
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) { startOperation(cm); }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) { signalLater(this, "clear", found.from, found.to); }
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text"); }
      else if (cm) {
        if (span.to != null) { max = lineNo(line); }
        if (span.from != null) { min = lineNo(line); }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)
        { updateLineHeight(line, textHeight(cm.display)); }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
      var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    } }

    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) { reCheckSelection(cm.doc); }
    }
    if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
    if (withOp) { endOperation(cm); }
    if (this.parent) { this.parent.clear(); }
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
      var this$1 = this;

    if (side == null && this.type == "bookmark") { side = 1; }
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) { return from }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) { return to }
      }
    }
    return from && {from: from, to: to}
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
      var this$1 = this;

    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) { return }
    runInOp(cm, function () {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          { updateLineHeight(line, line.height + dHeight); }
      }
      signalLater(cm, "markerChanged", cm, this$1);
    });
  };

  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
    }
    this.lines.push(line);
  };

  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp
      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) { copyObj(options, marker, false); }
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      { return marker }
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
      seeCollapsedSpans();
    }

    if (marker.addToHistory)
      { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        { updateMaxLine = true; }
      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
    }); }

    if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc.history.done.length || doc.history.undone.length)
        { doc.clearHistory(); }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
      if (marker.collapsed)
        { regChange(cm, from.line, to.line + 1); }
      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
               marker.attributes || marker.title)
        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
      if (marker.atomic) { reCheckSelection(cm.doc); }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = function(markers, primary) {
    var this$1 = this;

    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      { markers[i].parent = this$1; }
  };

  SharedTextMarker.prototype.clear = function () {
      var this$1 = this;

    if (this.explicitlyCleared) { return }
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      { this$1.markers[i].clear(); }
    signalLater(this, "clear");
  };

  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj)
  };
  eventMixin(SharedTextMarker);

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) { options.widgetNode = widget.cloneNode(true); }
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        { if (doc.linked[i].isParent) { return } }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary)
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    var loop = function ( i ) {
      var marker = markers[i], linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };

    for (var i = 0; i < markers.length; i++) loop( i );
  }

  var nextDocId = 0;
  var Doc = function(text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
    if (firstLine == null) { firstLine = 0; }

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = (direction == "rtl") ? "rtl" : "ltr";
    this.extend = false;

    if (typeof text == "string") { text = this.splitLines(text); }
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) { this.iterN(from - this.first, to - from, op); }
      else { this.iterN(this.first, this.first + this.size, from); }
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
      if (this.cm) { scrollToCoords(this.cm, 0, 0); }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
    getLineNumber: function(line) {return lineNo(line)},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") { line = getLine(this, line); }
      return visualLine(line)
    },

    lineCount: function() {return this.size},
    firstLine: function() {return this.first},
    lastLine: function() {return this.first + this.size - 1},

    clipPos: function(pos) {return clipPos(this, pos)},

    getCursor: function(start) {
      var range$$1 = this.sel.primary(), pos;
      if (start == null || start == "head") { pos = range$$1.head; }
      else if (start == "anchor") { pos = range$$1.anchor; }
      else if (start == "end" || start == "to" || start === false) { pos = range$$1.to(); }
      else { pos = range$$1.from(); }
      return pos
    },
    listSelections: function() { return this.sel.ranges },
    somethingSelected: function() {return this.sel.somethingSelected()},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      var this$1 = this;

      if (!ranges.length) { return }
      var out = [];
      for (var i = 0; i < ranges.length; i++)
        { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
                           clipPos(this$1, ranges[i].head)); }
      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
      setSelection(this, normalizeSelection(this.cm, out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var this$1 = this;

      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) { return lines }
      else { return lines.join(lineSep || this.lineSeparator()) }
    },
    getSelections: function(lineSep) {
      var this$1 = this;

      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }
        parts[i] = sel;
      }
      return parts
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        { dup[i] = code; }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var this$1 = this;

      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range$$1 = sel.ranges[i];
        changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
        { makeChange(this$1, changes[i$1]); }
      if (newSel) { setSelectionReplaceHistory(this, newSel); }
      else if (this.cm) { ensureCursorVisible(this.cm); }
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
      return {undo: done, redo: undone}
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
      return this.history.generation
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration)
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)}
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    setGutterMarker: docMethodOp(function(line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
        return true
      })
    }),

    clearGutter: docMethodOp(function(gutterID) {
      var this$1 = this;

      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
            return true
          });
        }
      });
    }),

    lineInfo: function(line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) { return null }
        n = line;
        line = getLine(this, line);
        if (!line) { return null }
      } else {
        n = lineNo(line);
        if (n == null) { return null }
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets}
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) { line[prop] = cls; }
        else if (classTest(cls).test(line[prop])) { return false }
        else { line[prop] += " " + cls; }
        return true
      })
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) { return false }
        else if (cls == null) { line[prop] = null; }
        else {
          var found = cur.match(classTest(cls));
          if (!found) { return false }
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true
      })
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options)
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark")
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) { for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          { markers.push(span.marker.parent || span.marker); }
      } }
      return markers
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo$$1 = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans) { for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||
                span.from == null && lineNo$$1 != from.line ||
                span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&
              (!filter || filter(span.marker)))
            { found.push(span.marker.parent || span.marker); }
        } }
        ++lineNo$$1;
      });
      return found
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps) { for (var i = 0; i < sps.length; ++i)
          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
      });
      return markers
    },

    posFromIndex: function(off) {
      var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;
        if (sz > off) { ch = off; return true }
        off -= sz;
        ++lineNo$$1;
      });
      return clipPos(this, Pos(lineNo$$1, ch))
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) { return 0 }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc
    },

    linkedDoc: function(options) {
      if (!options) { options = {}; }
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) { from = options.from; }
      if (options.to != null && options.to < to) { to = options.to; }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) { copy.history = this.history
      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy
    },
    unlinkDoc: function(other) {
      var this$1 = this;

      if (other instanceof CodeMirror) { other = other.doc; }
      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
        var link = this$1.linked[i];
        if (link.doc != other) { continue }
        this$1.linked.splice(i, 1);
        other.unlinkDoc(this$1);
        detachSharedMarkers(findSharedMarkers(this$1));
        break
      } }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode},
    getEditor: function() {return this.cm},

    splitLines: function(str) {
      if (this.lineSep) { return str.split(this.lineSep) }
      return splitLinesAuto(str)
    },
    lineSeparator: function() { return this.lineSep || "\n" },

    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") { dir = "ltr"; }
      if (dir == this.direction) { return }
      this.direction = dir;
      this.iter(function (line) { return line.order = null; });
      if (this.cm) { directionChanged(this.cm); }
    })
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      { return }
    e_preventDefault(e);
    if (ie) { lastDrop = +new Date; }
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) { return }
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function (file, i) {
        if (cm.options.allowDropFileTypes &&
            indexOf(cm.options.allowDropFileTypes, file.type) == -1)
          { return }

        var reader = new FileReader;
        reader.onload = operation(cm, function () {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = ""; }
          text[i] = content;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos,
                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                          origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) { loadFile(files[i], i); }
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function () { return cm.display.input.focus(); }, 20);
        return
      }
      try {
        var text$1 = e.dataTransfer.getData("Text");
        if (text$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy)
            { selected = cm.listSelections(); }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
            { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) { img.parentNode.removeChild(img); }
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) { return }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) { return }
    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) { editors.push(cm); }
    }
    if (editors.length) { editors[0].operation(function () {
      for (var i = 0; i < editors.length; i++) { f(editors[i]); }
    }); }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) { return }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) { resizeTimer = setTimeout(function () {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100); }
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function () { return forEachCodeMirror(onBlur); });
  }
  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  var keyNames = {
    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };

  // Number keys
  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
  // Alphabetic keys
  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
  // Function keys
  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

  var keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    "fallthrough": "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
      else if (/^a(lt)?$/i.test(mod)) { alt = true; }
      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
      else if (/^s(hift)?$/i.test(mod)) { shift = true; }
      else { throw new Error("Unrecognized modifier name: " + mod) }
    }
    if (alt) { name = "Alt-" + name; }
    if (ctrl) { name = "Ctrl-" + name; }
    if (cmd) { name = "Cmd-" + name; }
    if (shift) { name = "Shift-" + name; }
    return name
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
      if (value == "...") { delete keymap[keyname]; continue }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val = (void 0), name = (void 0);
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) { copy[name] = val; }
        else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
      }
      delete keymap[keyname];
    } }
    for (var prop in copy) { keymap[prop] = copy[prop]; }
    return keymap
  }

  function lookupKey(key, map$$1, handle, context) {
    map$$1 = getKeyMap(map$$1);
    var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
    if (found === false) { return "nothing" }
    if (found === "...") { return "multi" }
    if (found != null && handle(found)) { return "handled" }

    if (map$$1.fallthrough) {
      if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]")
        { return lookupKey(key, map$$1.fallthrough, handle, context) }
      for (var i = 0; i < map$$1.fallthrough.length; i++) {
        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
        if (result) { return result }
      }
    }
  }

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
  }

  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") { name = "Alt-" + name; }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name; }
    if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
    return name
  }

  // Look up the name of a key as indicated by an event object.
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) { return false }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) { return false }
    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
    if (event.keyCode == 3 && event.code) { name = event.code; }
    return addModifierNames(name, event, noShift)
  }

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
      ensureCursorVisible(cm);
    });
  }

  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target
  }

  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
  }

  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = (dir < 0) == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
        } else { ch = dir < 0 ? part.to : part.from; }
        return new Pos(lineNo, ch, sticky)
      }
    }
    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
  }

  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) { return moveLogically(line, start, dir) }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir)
    }

    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
    var prep;
    var getWrappedLineExtent = function (ch) {
      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch)
    };
    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = (part.level == 1) == (dir < 0);
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky)
      }
    }

    // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part

    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
        ? new Pos(start.line, mv(ch, 1), "before")
        : new Pos(start.line, ch, "after"); };

      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = (dir > 0) == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
      }
    };

    // Case 3a: Look for other bidi parts on the same visual line
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
    if (res) { return res }

    // Case 3b: Look for other bidi parts on the next visual line
    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) { return res }
    }

    // Case 4: Nowhere to move
    return null
  }

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = {
    selectAll: selectAll,
    singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
    killLine: function (cm) { return deleteNearSelection(cm, function (range) {
      if (range.empty()) {
        var len = getLine(cm.doc, range.head.line).text.length;
        if (range.head.ch == len && range.head.line < cm.lastLine())
          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
        else
          { return {from: range.head, to: Pos(range.head.line, len)} }
      } else {
        return {from: range.from(), to: range.to()}
      }
    }); },
    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0),
      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
    }); }); },
    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0), to: range.from()
    }); }); },
    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var leftPos = cm.coordsChar({left: 0, top: top}, "div");
      return {from: leftPos, to: range.from()}
    }); },
    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      return {from: range.from(), to: rightPos }
    }); },
    undo: function (cm) { return cm.undo(); },
    redo: function (cm) { return cm.redo(); },
    undoSelection: function (cm) { return cm.undoSelection(); },
    redoSelection: function (cm) { return cm.redoSelection(); },
    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
      {origin: "+move", bias: 1}
    ); },
    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
      {origin: "+move", bias: 1}
    ); },
    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
      {origin: "+move", bias: -1}
    ); },
    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
    }, sel_move); },
    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: 0, top: top}, "div")
    }, sel_move); },
    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      var pos = cm.coordsChar({left: 0, top: top}, "div");
      if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
      return pos
    }, sel_move); },
    goLineUp: function (cm) { return cm.moveV(-1, "line"); },
    goLineDown: function (cm) { return cm.moveV(1, "line"); },
    goPageUp: function (cm) { return cm.moveV(-1, "page"); },
    goPageDown: function (cm) { return cm.moveV(1, "page"); },
    goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
    goCharRight: function (cm) { return cm.moveH(1, "char"); },
    goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
    goColumnRight: function (cm) { return cm.moveH(1, "column"); },
    goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
    goGroupRight: function (cm) { return cm.moveH(1, "group"); },
    goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
    goWordRight: function (cm) { return cm.moveH(1, "word"); },
    delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
    delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
    delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
    delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
    delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
    delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
    indentAuto: function (cm) { return cm.indentSelection("smart"); },
    indentMore: function (cm) { return cm.indentSelection("add"); },
    indentLess: function (cm) { return cm.indentSelection("subtract"); },
    insertTab: function (cm) { return cm.replaceSelection("\t"); },
    insertSoftTab: function (cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function (cm) {
      if (cm.somethingSelected()) { cm.indentSelection("add"); }
      else { cm.execCommand("insertTab"); }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function (cm) { return runInOp(cm, function () {
      var ranges = cm.listSelections(), newSel = [];
      for (var i = 0; i < ranges.length; i++) {
        if (!ranges[i].empty()) { continue }
        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
        if (line) {
          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
          if (cur.ch > 0) {
            cur = new Pos(cur.line, cur.ch + 1);
            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                            Pos(cur.line, cur.ch - 2), cur, "+transpose");
          } else if (cur.line > cm.doc.first) {
            var prev = getLine(cm.doc, cur.line - 1).text;
            if (prev) {
              cur = new Pos(cur.line, 1);
              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                              prev.charAt(prev.length - 1),
                              Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
            }
          }
        }
        newSel.push(new Range(cur, cur));
      }
      cm.setSelections(newSel);
    }); },
    newlineAndIndent: function (cm) { return runInOp(cm, function () {
      var sels = cm.listSelections();
      for (var i = sels.length - 1; i >= 0; i--)
        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
      sels = cm.listSelections();
      for (var i$1 = 0; i$1 < sels.length; i$1++)
        { cm.indentLine(sels[i$1].from().line, null, true); }
      ensureCursorVisible(cm);
    }); },
    openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
  };


  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, visual, lineN, 1)
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, line, lineN, -1)
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
    }
    return start
  }

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) { return false }
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
      if (dropShift) { cm.display.shift = false; }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) { return result }
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm)
  }

  // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.

  var stopSeq = new Delayed;

  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) { return "handled" }
      if (/\'$/.test(name))
        { cm.state.keySeq = null; }
      else
        { stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        }); }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
    }
    return dispatchKeyInner(cm, name, e, handle)
  }

  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      { cm.state.keySeq = name; }
    if (result == "handled")
      { signalLater(cm, "keyHandled", cm, name, e); }

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    return !!result
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) { return false }

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
          || dispatchKey(cm, name, e, function (b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 { return doHandleBinding(cm, b) }
             })
    } else {
      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) { return }
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        { cm.replaceSelection("", null, "cut"); }
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      { showCrossHair(cm); }
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) { this.doc.sel.shift = false; }
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    // Some browsers fire keypress events for backspace
    if (ch == "\x08") { return }
    if (handleCharBinding(cm, e, ch)) { return }
    cm.display.input.onKeyPress(e);
  }

  var DOUBLECLICK_DELAY = 400;

  var PastClick = function(time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };

  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time &&
      cmp(pos, this.pos) == 0 && button == this.button
  };

  var lastClick, lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +new Date;
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple"
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double"
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single"
    }
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
    display.input.ensurePolled();
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () { return display.scroller.draggable = true; }, 100);
      }
      return
    }
    if (clickInGutter(cm, e)) { return }
    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
    window.focus();

    // #3261: make sure, that we're not starting a second selection
    if (button == 1 && cm.state.selectingText)
      { cm.state.selectingText(e); }

    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

    if (button == 1) {
      if (pos) { leftButtonDown(cm, pos, repeat, e); }
      else if (e_target(e) == display.scroller) { e_preventDefault(e); }
    } else if (button == 2) {
      if (pos) { extendSelection(cm.doc, pos); }
      setTimeout(function () { return display.input.focus(); }, 20);
    } else if (button == 3) {
      if (captureRightClick) { cm.display.input.onContextMenu(e); }
      else { delayBlurEvent(cm); }
    }
  }

  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";
    if (repeat == "double") { name = "Double" + name; }
    else if (repeat == "triple") { name = "Triple" + name; }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") { bound = commands[bound]; }
      if (!bound) { return false }
      var done = false;
      try {
        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done
    })
  }

  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
    return value
  }

  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
    else { cm.curOp.focus = activeElt(); }

    var behavior = configureMouse(cm, repeat, event);

    var sel = cm.doc.sel, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
        repeat == "single" && (contained = sel.contains(pos)) > -1 &&
        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
      { leftButtonStartDrag(cm, event, pos, behavior); }
    else
      { leftButtonSelect(cm, event, pos, behavior); }
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display, moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) { display.scroller.draggable = false; }
      cm.state.draggingText = false;
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew)
          { extendSelection(cm.doc, pos, null, null, behavior.extend); }
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if (webkit || ie && ie_version == 9)
          { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }
        else
          { display.input.focus(); }
      }
    });
    var mouseMove = function(e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function () { return moved = true; };
    // Let the drag handler handle this.
    if (webkit) { display.scroller.draggable = true; }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    // IE's approach to draggable
    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);

    delayBlurEvent(cm);
    setTimeout(function () { return display.input.focus(); }, 20);
  }

  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") { return new Range(pos, pos) }
    if (unit == "word") { return cm.findWordAt(pos) }
    if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
    var result = unit(cm, pos);
    return new Range(result.from, result.to)
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, event, start, behavior) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(event);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        { ourRange = ranges[ourIndex]; }
      else
        { ourRange = new Range(start, start); }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) { ourRange = new Range(start, start); }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range$$1 = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend)
        { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }
      else
        { ourRange = range$$1; }
    }

    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                   {scroll: false, origin: "*mouse"});
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) { return }
      lastPos = pos;

      if (behavior.unit == "rectangle") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
          else if (text.length > leftPos)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
        }
        if (!ranges.length) { ranges.push(new Range(start, start)); }
        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range$$1 = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor, head;
        if (cmp(range$$1.anchor, anchor) > 0) {
          head = range$$1.head;
          anchor = minPos(oldRange.from(), range$$1.anchor);
        } else {
          head = range$$1.anchor;
          anchor = maxPos(oldRange.to(), range$$1.head);
        }
        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) { return }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) { setTimeout(operation(cm, function () {
          if (counter != curCount) { return }
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50); }
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      // If e is null or undefined we interpret this as someone trying
      // to explicitly cancel the selection rather than the user
      // letting go of the mouse button.
      if (e) {
        e_preventDefault(e);
        display.input.focus();
      }
      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function (e) {
      if (e.buttons === 0 || !e_button(e)) { done(e); }
      else { extend(e); }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  }

  // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.
  function bidiSimplify(cm, range$$1) {
    var anchor = range$$1.anchor;
    var head = range$$1.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }
    var order = getOrder(anchorLine);
    if (!order) { return range$$1 }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }
    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) { return range$$1 }

    // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary)
        { leftSide = dir < 0; }
      else
        { leftSide = dir > 0; }
    }

    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)
  }


  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try { mX = e.clientX; mY = e.clientY; }
      catch(e) { return false }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
    if (prevent) { e_preventDefault(e); }

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.display.gutterSpecs[i];
        signal(cm, type, cm, line, gutter.className, e);
        return e_defaultPrevented(e)
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true)
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
    if (signalDOMEvent(cm, e, "contextmenu")) { return }
    if (!captureRightClick) { cm.display.input.onContextMenu(e); }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) { return false }
    return gutterEvent(cm, e, "gutterContextMenu", false)
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  var Init = {toString: function(){return "CodeMirror.Init"}};

  var defaults = {};
  var optionHandlers = {};

  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) { optionHandlers[name] =
        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
    }

    CodeMirror.defineOption = option;

    // Passed to option handlers when there is no old value.
    CodeMirror.Init = Init;

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function (cm, val) { return cm.setValue(val); }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);

    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);

    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;
      if (!val) { return }
      var newBreaks = [], lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) { break }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }
        lineNo++;
      });
      for (var i = newBreaks.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      if (old != Init) { cm.refresh(); }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
    option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
    option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);

    option("theme", "default", function (cm) {
      themeChanged(cm);
      updateGutters(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) { prev.detach(cm, next); }
      if (next.attach) { next.attach(cm, prev || null); }
    });
    option("extraKeys", null);
    option("configureMouse", null);

    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm, val) {
      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
      updateGutters(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm, val) {
      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
      updateGutters(cm);
    }, true);
    option("firstLineNumber", 1, updateGutters, true);
    option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);
    option("showCursorWhenSelecting", false, updateSelection, true);

    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("selectionsMayTouch", false);

    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });
    option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);

    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) { cm.display.input.resetPosition(); }
    });

    option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
    option("phrases", null);
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () { return updateScrollbars(cm); }, 100);
  }

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    var this$1 = this;

    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);

    var doc = options.value;
    if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
    else if (options.mode) { doc.modeOption = options.mode; }
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input, options);
    display.wrapper.CodeMirror = this;
    themeChanged(this);
    if (options.lineWrapping)
      { this.display.wrapper.className += " CodeMirror-wrap"; }
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    if (options.autofocus && !mobile) { display.input.focus(); }

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || this.hasFocus())
      { setTimeout(bind(onFocus, this), 20); }
    else
      { onBlur(this); }

    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
      { optionHandlers[opt](this$1, options[opt], Init); } }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) { options.finishInit(this); }
    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      { display.lineDiv.style.textRendering = "auto"; }
  }

  // The default configuration options.
  CodeMirror.defaults = defaults;
  // Functions to run when options are changed.
  CodeMirror.optionHandlers = optionHandlers;

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      { on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) { return }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      })); }
    else
      { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) { return false }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1
    }
    function farAway(touch, other) {
      if (other.left == null) { return true }
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20
    }
    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) { d.activeTouch.moved = true; }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          { range = new Range(pos, pos); }
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          { range = cm.findWordAt(pos); }
        else // Triple tap
          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
    on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
      start: function (e) { return onDragStart(cm, e); },
      drop: operation(cm, onDrop),
      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
    };

    var inp = d.input.getField();
    on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) { return onFocus(cm, e); });
    on(inp, "blur", function (e) { return onBlur(cm, e); });
  }

  var initHooks = [];
  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) { how = "add"; }
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) { how = "prev"; }
      else { state = getContextBefore(cm, n).state; }
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) { line.stateAfter = null; }
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) { return }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
      else { indentation = 0; }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
    if (pos < indentation) { indentString += spaceStr(indentation - pos); }

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break
        }
      }
    }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;

  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) { sel = doc.sel; }

    var recent = +new Date - 200;
    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
    var textLines = splitLinesAuto(inserted), multiPaste = null;
    // When pasting N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++)
            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) { return [l]; });
      }
    }

    var updateInput = cm.curOp.updateInput;
    // Normal behavior is to insert the new text into every selection
    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range$$1 = sel.ranges[i$1];
      var from = range$$1.from(), to = range$$1.to();
      if (range$$1.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          { from = Pos(from.line, from.ch - deleted); }
        else if (cm.state.overwrite && !paste) // Handle overwrite
          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
          { from = to = Pos(from.line, 0); }
      }
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste)
      { triggerElectric(cm, inserted); }

    ensureCursorVisible(cm);
    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput)
        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
      return true
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) { return }
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range$$1 = sel.ranges[i];
      if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }
      var mode = cm.getModeAt(range$$1.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++)
          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range$$1.head.line, "smart");
            break
          } }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))
          { indented = indentLine(cm, range$$1.head.line, "smart"); }
      }
      if (indented) { signalLater(cm, "electricInput", cm, range$$1.head.line); }
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges}
  }

  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
    field.setAttribute("autocorrect", autocorrect ? "" : "off");
    field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) { te.style.width = "1000px"; }
    else { te.setAttribute("wrap", "off"); }
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) { te.style.border = "1px solid black"; }
    disableBrowserMagic(te);
    return div
  }

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  function addEditorMethods(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    var helpers = CodeMirror.helpers = {};

    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function(){window.focus(); this.display.input.focus();},

      setOption: function(option, value) {
        var options = this.options, old = options[option];
        if (options[option] == value && option != "mode") { return }
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option))
          { operation(this, optionHandlers[option])(this, value, old); }
        signal(this, "optionChange", this, option);
      },

      getOption: function(option) {return this.options[option]},
      getDoc: function() {return this.doc},

      addKeyMap: function(map$$1, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
      },
      removeKeyMap: function(map$$1) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i)
          { if (maps[i] == map$$1 || maps[i].name == map$$1) {
            maps.splice(i, 1);
            return true
          } }
      },

      addOverlay: methodOp(function(spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) { throw new Error("Overlays may not be stateful.") }
        insertSorted(this.state.overlays,
                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                      priority: (options && options.priority) || 0},
                     function (overlay) { return overlay.priority; });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function(spec) {
        var this$1 = this;

        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this$1.state.modeGen++;
            regChange(this$1);
            return
          }
        }
      }),

      indentLine: methodOp(function(n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
          else { dir = dir ? "add" : "subtract"; }
        }
        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
      }),
      indentSelection: methodOp(function(how) {
        var this$1 = this;

        var ranges = this.doc.sel.ranges, end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range$$1 = ranges[i];
          if (!range$$1.empty()) {
            var from = range$$1.from(), to = range$$1.to();
            var start = Math.max(end, from.line);
            end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j)
              { indentLine(this$1, j, how); }
            var newRanges = this$1.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
              { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
          } else if (range$$1.head.line > end) {
            indentLine(this$1, range$$1.head.line, how, true);
            end = range$$1.head.line;
            if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }
          }
        }
      }),

      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function(pos, precise) {
        return takeToken(this, pos, precise)
      },

      getLineTokens: function(line, precise) {
        return takeToken(this, Pos(line), precise, true)
      },

      getTokenTypeAt: function(pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
        var type;
        if (ch == 0) { type = styles[2]; }
        else { for (;;) {
          var mid = (before + after) >> 1;
          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
          else { type = styles[mid * 2 + 2]; break }
        } }
        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
      },

      getModeAt: function(pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) { return mode }
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
      },

      getHelper: function(pos, type) {
        return this.getHelpers(pos, type)[0]
      },

      getHelpers: function(pos, type) {
        var this$1 = this;

        var found = [];
        if (!helpers.hasOwnProperty(type)) { return found }
        var help = helpers[type], mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) { found.push(help[mode[type]]); }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) { found.push(val); }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];
          if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)
            { found.push(cur.val); }
        }
        return found
      },

      getStateAfter: function(line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
        return getContextBefore(this, line + 1, precise).state
      },

      cursorCoords: function(start, mode) {
        var pos, range$$1 = this.doc.sel.primary();
        if (start == null) { pos = range$$1.head; }
        else if (typeof start == "object") { pos = clipPos(this.doc, start); }
        else { pos = start ? range$$1.from() : range$$1.to(); }
        return cursorCoords(this, pos, mode || "page")
      },

      charCoords: function(pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page")
      },

      coordsChar: function(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top)
      },

      lineAtHeight: function(height, mode) {
        height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset)
      },
      heightAtLine: function(line, mode, includeWidgets) {
        var end = false, lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) { line = this.doc.first; }
          else if (line > last) { line = last; end = true; }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
          (end ? this.doc.height - heightAtLine(lineObj) : 0)
      },

      defaultTextHeight: function() { return textHeight(this.display) },
      defaultCharWidth: function() { return charWidth(this.display) },

      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

      addWidget: function(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom, left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
            { top = pos.top - node.offsetHeight; }
          else if (pos.bottom + node.offsetHeight <= vspace)
            { top = pos.bottom; }
          if (left + node.offsetWidth > hspace)
            { left = hspace - node.offsetWidth; }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") { left = 0; }
          else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
          node.style.left = left + "px";
        }
        if (scroll)
          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
      },

      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),

      execCommand: function(cmd) {
        if (commands.hasOwnProperty(cmd))
          { return commands[cmd].call(null, this) }
      },

      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

      findPosH: function(from, amount, unit, visually) {
        var this$1 = this;

        var dir = 1;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          cur = findPosH(this$1.doc, cur, dir, unit, visually);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveH: methodOp(function(dir, unit) {
        var this$1 = this;

        this.extendSelectionsBy(function (range$$1) {
          if (this$1.display.shift || this$1.doc.extend || range$$1.empty())
            { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }
          else
            { return dir < 0 ? range$$1.from() : range$$1.to() }
        }, sel_move);
      }),

      deleteH: methodOp(function(dir, unit) {
        var sel = this.doc.sel, doc = this.doc;
        if (sel.somethingSelected())
          { doc.replaceSelection("", null, "+delete"); }
        else
          { deleteNearSelection(this, function (range$$1) {
            var other = findPosH(doc, range$$1.head, dir, unit, false);
            return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}
          }); }
      }),

      findPosV: function(from, amount, unit, goalColumn) {
        var this$1 = this;

        var dir = 1, x = goalColumn;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          var coords = cursorCoords(this$1, cur, "div");
          if (x == null) { x = coords.left; }
          else { coords.left = x; }
          cur = findPosV(this$1, coords, dir, unit);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveV: methodOp(function(dir, unit) {
        var this$1 = this;

        var doc = this.doc, goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range$$1) {
          if (collapse)
            { return dir < 0 ? range$$1.from() : range$$1.to() }
          var headPos = cursorCoords(this$1, range$$1.head, "div");
          if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }
          goals.push(headPos.left);
          var pos = findPosV(this$1, headPos, dir, unit);
          if (unit == "page" && range$$1 == doc.sel.primary())
            { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
          return pos
        }, sel_move);
        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
          { doc.sel.ranges[i].goalColumn = goals[i]; } }
      }),

      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function(pos) {
        var doc = this.doc, line = getLine(doc, pos.line).text;
        var start = pos.ch, end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper)
            ? function (ch) { return isWordChar(ch, helper); }
            : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
            : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
          while (start > 0 && check(line.charAt(start - 1))) { --start; }
          while (end < line.length && check(line.charAt(end))) { ++end; }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end))
      },

      toggleOverwrite: function(value) {
        if (value != null && value == this.state.overwrite) { return }
        if (this.state.overwrite = !this.state.overwrite)
          { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
        else
          { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function() { return this.display.input.getField() == activeElt() },
      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
      getScrollInfo: function() {
        var scroller = this.display.scroller;
        return {left: scroller.scrollLeft, top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
      },

      scrollIntoView: methodOp(function(range$$1, margin) {
        if (range$$1 == null) {
          range$$1 = {from: this.doc.sel.primary().head, to: null};
          if (margin == null) { margin = this.options.cursorScrollMargin; }
        } else if (typeof range$$1 == "number") {
          range$$1 = {from: Pos(range$$1, 0), to: null};
        } else if (range$$1.from == null) {
          range$$1 = {from: range$$1, to: null};
        }
        if (!range$$1.to) { range$$1.to = range$$1.from; }
        range$$1.margin = margin || 0;

        if (range$$1.from.line != null) {
          scrollToRange(this, range$$1);
        } else {
          scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
        }
      }),

      setSize: methodOp(function(width, height) {
        var this$1 = this;

        var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
        if (width != null) { this.display.wrapper.style.width = interpret(width); }
        if (height != null) { this.display.wrapper.style.height = interpret(height); }
        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
        var lineNo$$1 = this.display.viewFrom;
        this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, "widget"); break } } }
          ++lineNo$$1;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),

      operation: function(f){return runInOp(this, f)},
      startOperation: function(){return startOperation(this)},
      endOperation: function(){return endOperation(this)},

      refresh: methodOp(function() {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this.display);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
          { estimateLineHeights(this); }
        signal(this, "refresh", this);
      }),

      swapDoc: methodOp(function(doc) {
        var old = this.doc;
        old.cm = null;
        // Cancel the current text selection if any (#5821)
        if (this.state.selectingText) { this.state.selectingText(); }
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old
      }),

      phrase: function(phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
      },

      getInputField: function(){return this.display.input.getField()},
      getWrapperElement: function(){return this.display.wrapper},
      getScrollerElement: function(){return this.display.scroller},
      getGutterElement: function(){return this.display.gutters}
    };
    eventMixin(CodeMirror);

    CodeMirror.registerHelper = function(type, name, value) {
      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({pred: predicate, val: value});
    };
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);
    function findNextLine() {
      var l = pos.line + dir;
      if (l < doc.first || l >= doc.first + doc.size) { return false }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l)
    }
    function moveOnce(boundToLine) {
      var next;
      if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine())
          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }
        else
          { return false }
      } else {
        pos = next;
      }
      return true
    }

    if (unit == "char") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) { break }
        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) { type = "s"; }
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
          break
        }

        if (type) { sawType = type; }
        if (dir > 0 && !moveOnce(!first)) { break }
      }
    }
    var result = skipAtomic(doc, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
    return result
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (;;) {
      target = coordsChar(cm, x, y);
      if (!target.outside) { break }
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
      y += dir * 5;
    }
    return target
  }

  // CONTENTEDITABLE INPUT STYLE

  var ContentEditableInput = function(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };

  ContentEditableInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = input.cm;
    var div = input.div = display.lineDiv;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

    on(div, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
    });

    on(div, "compositionstart", function (e) {
      this$1.composing = {data: e.data, done: false};
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
        this$1.composing.done = true;
      }
    });

    on(div, "touchstart", function () { return input.forceCompositionEnd(); });

    on(div, "input", function () {
      if (!this$1.composing) { this$1.readFromDOMSoon(); }
    });

    function onCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
        if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n");
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return
        }
      }
      // Old-fashioned briefly-focus-a-textarea hack
      var kludge = hiddenTextarea(), te = kludge.firstChild;
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = document.activeElement;
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) { input.showPrimarySelection(); }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };

  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = this.cm.state.focused;
    return result
  };

  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) { return }
    if (info.focus || takeFocus) { this.showPrimarySelection(); }
    this.showMultipleSelections(info);
  };

  ContentEditableInput.prototype.getSelection = function () {
    return this.cm.display.wrapper.ownerDocument.getSelection()
  };

  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
    var from = prim.from(), to = prim.to();

    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return
    }

    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
        cmp(minPos(curAnchor, curFocus), from) == 0 &&
        cmp(maxPos(curAnchor, curFocus), to) == 0)
      { return }

    var view = cm.display.view;
    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
        {node: view[0].measure.map[2], offset: 0};
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};
    }

    if (!start || !end) {
      sel.removeAllRanges();
      return
    }

    var old = sel.rangeCount && sel.getRangeAt(0), rng;
    try { rng = range(start.node, start.offset, end.offset, end.node); }
    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) { sel.addRange(old); }
      else if (gecko) { this.startGracePeriod(); }
    }
    this.rememberSelection();
  };

  ContentEditableInput.prototype.startGracePeriod = function () {
      var this$1 = this;

    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;
      if (this$1.selectionChanged())
        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
    }, 20);
  };

  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };

  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
  };

  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = this.getSelection();
    if (!sel.rangeCount) { return false }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node)
  };

  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor())
        { this.showSelection(this.prepareSelection(), true); }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function () { this.div.blur(); };
  ContentEditableInput.prototype.getField = function () { return this.div };

  ContentEditableInput.prototype.supportsTouch = function () { return true };

  ContentEditableInput.prototype.receivedFocus = function () {
    var input = this;
    if (this.selectionInEditor())
      { this.pollSelection(); }
    else
      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };

  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
  };

  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
    var sel = this.getSelection(), cm = this.cm;
    // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.
    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
      this.blur();
      this.focus();
      return
    }
    if (this.composing) { return }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) { runInOp(cm, function () {
      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
    }); }
  };

  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }

    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
    var from = sel.from(), to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine())
      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
      { to = Pos(to.line + 1, 0); }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }

    if (!fromNode) { return false }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
      else { break }
    }

    var cutFront = 0, cutEnd = 0;
    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
      { ++cutFront; }
    var newBot = lst(newText), oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                             oldBot.length - (oldText.length == 1 ? cutFront : 0));
    while (cutEnd < maxCutEnd &&
           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
      { ++cutEnd; }
    // Try to move start of change to start of selection if ambiguous
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }

    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true
    }
  };

  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) { return }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function () {
      var this$1 = this;

    if (this.readDOMTimeout != null) { return }
    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;
      if (this$1.composing) {
        if (this$1.composing.done) { this$1.composing = null; }
        else { return }
      }
      this$1.updateFromDOM();
    }, 80);
  };

  ContentEditableInput.prototype.updateFromDOM = function () {
      var this$1 = this;

    if (this.cm.isReadOnly() || !this.pollContent())
      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
  };

  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };

  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0 || this.composing) { return }
    e.preventDefault();
    if (!this.cm.isReadOnly())
      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
  };

  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };

  ContentEditableInput.prototype.onContextMenu = function () {};
  ContentEditableInput.prototype.resetPosition = function () {};

  ContentEditableInput.prototype.needsContentAttribute = true;

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) { return null }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line, cm.doc.direction), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result
  }

  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode)
      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
    return false
  }

  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
    function close() {
      if (closing) {
        text += lineSep;
        if (extraLinebreak) { text += lineSep; }
        closing = extraLinebreak = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText) {
          addText(cmText);
          return
        }
        var markerID = node.getAttribute("cm-marker"), range$$1;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range$$1 = found[0].find(0)))
            { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }
          return
        }
        if (node.getAttribute("contenteditable") == "false") { return }
        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }

        if (isBlock) { close(); }
        for (var i = 0; i < node.childNodes.length; i++)
          { walk(node.childNodes[i]); }

        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
        if (isBlock) { closing = true; }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
      }
    }
    for (;;) {
      walk(from);
      if (from == to) { break }
      from = from.nextSibling;
      extraLinebreak = false;
    }
    return text
  }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) { return null }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        { return locateNodeInLineView(lineView, node, offset) }
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad)
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) { offset = textNode.nodeValue.length; }
    }
    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map$$1 = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map$$1.length; j += 3) {
          var curNode = map$$1[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map$$1[j] + offset;
            if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }
            return Pos(line, ch)
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) { return badPos(found, bad) }

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        { return badPos(Pos(found.line, found.ch - dist), bad) }
      else
        { dist += after.textContent.length; }
    }
    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        { return badPos(Pos(found.line, found.ch + dist$1), bad) }
      else
        { dist$1 += before.textContent.length; }
    }
  }

  // TEXTAREA INPUT STYLE

  var TextareaInput = function(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };

  TextareaInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = this.cm;
    this.createField(display);
    var te = this.textarea;

    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
    if (ios) { te.style.width = "0px"; }

    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
      input.poll();
    });

    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

      cm.state.pasteIncoming = +new Date;
      input.fastPoll();
    });

    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);

    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +new Date;
        input.focus();
        return
      }

      // Pass the `paste` event to the textarea so it's handled by its event listener.
      var event = new Event("paste");
      event.clipboardData = e.clipboardData;
      te.dispatchEvent(event);
    });

    // Prevent normal selection in the editor (we handle our own)
    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) { e_preventDefault(e); }
    });

    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");
      if (input.composing) { input.composing.range.clear(); }
      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };

  TextareaInput.prototype.createField = function (_display) {
    // Wraps and hides input textarea
    this.wrapper = hiddenTextarea();
    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    this.textarea = this.wrapper.firstChild;
  };

  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm, display = cm.display, doc = cm.doc;
    var result = prepareSelection(cm);

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                          headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                           headPos.left + lineOff.left - wrapOff.left));
    }

    return result
  };

  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm, display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing) { return }
    var cm = this.cm;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) { selectInput(this.textarea); }
      if (ie && ie_version >= 9) { this.hasSelection = content; }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) { this.hasSelection = null; }
    }
  };

  TextareaInput.prototype.getField = function () { return this.textarea };

  TextareaInput.prototype.supportsTouch = function () { return false };

  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
      try { this.textarea.focus(); }
      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
    }
  };

  TextareaInput.prototype.blur = function () { this.textarea.blur(); };

  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };

  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  TextareaInput.prototype.slowPoll = function () {
      var this$1 = this;

    if (this.pollingFast) { return }
    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();
      if (this$1.cm.state.focused) { this$1.slowPoll(); }
    });
  };

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  TextareaInput.prototype.fastPoll = function () {
    var missed = false, input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) {missed = true; input.polling.set(60, p);}
      else {input.pollingFast = false; input.slowPoll();}
    }
    input.polling.set(20, p);
  };

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  TextareaInput.prototype.poll = function () {
      var this$1 = this;

    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (this.contextMenuPending || !cm.state.focused ||
        (hasSelection(input) && !prevInput && !this.composing) ||
        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
      { return false }

    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) { return false }
    // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).
    if (ie && ie_version >= 9 && this.hasSelection === text ||
        mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false
    }

    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
      if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
    }
    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same,
                     null, this$1.composing ? "*compose" : null);

      // Don't leave long text in the textarea, since it makes further polling slow
      if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
      else { this$1.prevInput = text; }

      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
                                           {className: "CodeMirror-composing"});
      }
    });
    return true
  };

  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) { this.pollingFast = false; }
  };

  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) { this.hasSelection = null; }
    this.fastPoll();
  };

  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
    if (input.contextMenuPending) { input.contextMenuPending(); }
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) { return } // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
    input.wrapper.style.cssText = "position: static";
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
    display.input.focus();
    if (webkit) { window.scrollTo(null, oldScrollY); }
    display.input.reset();
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
    input.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200b" + (selected ? te.value : "");
        te.value = "\u21da"; // Used to catch context-menu undo
        te.value = extval;
        input.prevInput = selected ? "" : "\u200b";
        te.selectionStart = 1; te.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      if (input.contextMenuPending != rehide) { return }
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

      // Try to detect the user choosing select-all
      if (te.selectionStart != null) {
        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
        var i = 0, poll = function () {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
              te.selectionEnd > 0 && input.prevInput == "\u200b") {
            operation(cm, selectAll)(cm);
          } else if (i++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && ie_version >= 9) { prepareSelectAllHack(); }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };

  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) { this.reset(); }
    this.textarea.disabled = val == "nocursor";
  };

  TextareaInput.prototype.setUneditable = function () {};

  TextareaInput.prototype.needsContentAttribute = false;

  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      { options.tabindex = textarea.tabIndex; }
    if (!options.placeholder && textarea.placeholder)
      { options.placeholder = textarea.placeholder; }
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}

    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function (cm) {
      cm.save = save;
      cm.getTextArea = function () { return textarea; };
      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function")
            { textarea.form.submit = realSubmit; }
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
      options);
    return cm
  }

  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  }

  // EDITOR CONSTRUCTOR

  defineOptions(CodeMirror);

  addEditorMethods(CodeMirror);

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    { CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments)}
    })(Doc.prototype[prop]); } }

  eventMixin(Doc);
  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name/*, mode, */) {
    if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
    defineMode.apply(this, arguments);
  };

  CodeMirror.defineMIME = defineMIME;

  // Minimal default mode.
  CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
  CodeMirror.defineMIME("text/plain", "null");

  // EXTENSIONS

  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };

  CodeMirror.fromTextArea = fromTextArea;

  addLegacyProps(CodeMirror);

  CodeMirror.version = "5.49.0";

  return CodeMirror;

})));

    </script>
    <style>
      /* BASICS */

.CodeMirror {
  /* Set height, width, borders, and global font properties here */
  font-family: monospace;
  height: 300px;
  color: black;
  direction: ltr;
}

/* PADDING */

.CodeMirror-lines {
  padding: 4px 0; /* Vertical padding around content */
}
.CodeMirror pre.CodeMirror-line,
.CodeMirror pre.CodeMirror-line-like {
  padding: 0 4px; /* Horizontal padding of content */
}

.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
  background-color: white; /* The little square between H and V scrollbars */
}

/* GUTTER */

.CodeMirror-gutters {
  border-right: 1px solid #ddd;
  background-color: #f7f7f7;
  white-space: nowrap;
}
.CodeMirror-linenumbers {}
.CodeMirror-linenumber {
  padding: 0 3px 0 5px;
  min-width: 20px;
  text-align: right;
  color: #999;
  white-space: nowrap;
}

.CodeMirror-guttermarker { color: black; }
.CodeMirror-guttermarker-subtle { color: #999; }

/* CURSOR */

.CodeMirror-cursor {
  border-left: 1px solid black;
  border-right: none;
  width: 0;
}
/* Shown when moving in bi-directional text */
.CodeMirror div.CodeMirror-secondarycursor {
  border-left: 1px solid silver;
}
.cm-fat-cursor .CodeMirror-cursor {
  width: auto;
  border: 0 !important;
  background: #7e7;
}
.cm-fat-cursor div.CodeMirror-cursors {
  z-index: 1;
}
.cm-fat-cursor-mark {
  background-color: rgba(20, 255, 20, 0.5);
  -webkit-animation: blink 1.06s steps(1) infinite;
  -moz-animation: blink 1.06s steps(1) infinite;
  animation: blink 1.06s steps(1) infinite;
}
.cm-animate-fat-cursor {
  width: auto;
  border: 0;
  -webkit-animation: blink 1.06s steps(1) infinite;
  -moz-animation: blink 1.06s steps(1) infinite;
  animation: blink 1.06s steps(1) infinite;
  background-color: #7e7;
}
@-moz-keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}
@-webkit-keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}
@keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}

/* Can style cursor different in overwrite (non-insert) mode */
.CodeMirror-overwrite .CodeMirror-cursor {}

.cm-tab { display: inline-block; text-decoration: inherit; }

.CodeMirror-rulers {
  position: absolute;
  left: 0; right: 0; top: -50px; bottom: 0;
  overflow: hidden;
}
.CodeMirror-ruler {
  border-left: 1px solid #ccc;
  top: 0; bottom: 0;
  position: absolute;
}

/* DEFAULT THEME */

.cm-s-default .cm-header {color: blue;}
.cm-s-default .cm-quote {color: #090;}
.cm-negative {color: #d44;}
.cm-positive {color: #292;}
.cm-header, .cm-strong {font-weight: bold;}
.cm-em {font-style: italic;}
.cm-link {text-decoration: underline;}
.cm-strikethrough {text-decoration: line-through;}

.cm-s-default .cm-keyword {color: #708;}
.cm-s-default .cm-atom {color: #219;}
.cm-s-default .cm-number {color: #164;}
.cm-s-default .cm-def {color: #00f;}
.cm-s-default .cm-variable,
.cm-s-default .cm-punctuation,
.cm-s-default .cm-property,
.cm-s-default .cm-operator {}
.cm-s-default .cm-variable-2 {color: #05a;}
.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}
.cm-s-default .cm-comment {color: #a50;}
.cm-s-default .cm-string {color: #a11;}
.cm-s-default .cm-string-2 {color: #f50;}
.cm-s-default .cm-meta {color: #555;}
.cm-s-default .cm-qualifier {color: #555;}
.cm-s-default .cm-builtin {color: #30a;}
.cm-s-default .cm-bracket {color: #997;}
.cm-s-default .cm-tag {color: #170;}
.cm-s-default .cm-attribute {color: #00c;}
.cm-s-default .cm-hr {color: #999;}
.cm-s-default .cm-link {color: #00c;}

.cm-s-default .cm-error {color: #f00;}
.cm-invalidchar {color: #f00;}

.CodeMirror-composing { border-bottom: 2px solid; }

/* Default styles for common addons */

div.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}
div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}
.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }
.CodeMirror-activeline-background {background: #e8f2ff;}

/* STOP */

/* The rest of this file contains styles related to the mechanics of
   the editor. You probably shouldn't touch them. */

.CodeMirror {
  position: relative;
  overflow: hidden;
  background: white;
}

.CodeMirror-scroll {
  overflow: scroll !important; /* Things will break if this is overridden */
  /* 30px is the magic margin used to hide the element's real scrollbars */
  /* See overflow: hidden in .CodeMirror */
  margin-bottom: -30px; margin-right: -30px;
  padding-bottom: 30px;
  height: 100%;
  outline: none; /* Prevent dragging from highlighting the element */
  position: relative;
}
.CodeMirror-sizer {
  position: relative;
  border-right: 30px solid transparent;
}

/* The fake, visible scrollbars. Used to force redraw during scrolling
   before actual scrolling happens, thus preventing shaking and
   flickering artifacts. */
.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
  position: absolute;
  z-index: 6;
  display: none;
}
.CodeMirror-vscrollbar {
  right: 0; top: 0;
  overflow-x: hidden;
  overflow-y: scroll;
}
.CodeMirror-hscrollbar {
  bottom: 0; left: 0;
  overflow-y: hidden;
  overflow-x: scroll;
}
.CodeMirror-scrollbar-filler {
  right: 0; bottom: 0;
}
.CodeMirror-gutter-filler {
  left: 0; bottom: 0;
}

.CodeMirror-gutters {
  position: absolute; left: 0; top: 0;
  min-height: 100%;
  z-index: 3;
}
.CodeMirror-gutter {
  white-space: normal;
  height: 100%;
  display: inline-block;
  vertical-align: top;
  margin-bottom: -30px;
}
.CodeMirror-gutter-wrapper {
  position: absolute;
  z-index: 4;
  background: none !important;
  border: none !important;
}
.CodeMirror-gutter-background {
  position: absolute;
  top: 0; bottom: 0;
  z-index: 4;
}
.CodeMirror-gutter-elt {
  position: absolute;
  cursor: default;
  z-index: 4;
}
.CodeMirror-gutter-wrapper ::selection { background-color: transparent }
.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }

.CodeMirror-lines {
  cursor: text;
  min-height: 1px; /* prevents collapsing before first draw */
}
.CodeMirror pre.CodeMirror-line,
.CodeMirror pre.CodeMirror-line-like {
  /* Reset some styles that the rest of the page might have set */
  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;
  border-width: 0;
  background: transparent;
  font-family: inherit;
  font-size: inherit;
  margin: 0;
  white-space: pre;
  word-wrap: normal;
  line-height: inherit;
  color: inherit;
  z-index: 2;
  position: relative;
  overflow: visible;
  -webkit-tap-highlight-color: transparent;
  -webkit-font-variant-ligatures: contextual;
  font-variant-ligatures: contextual;
}
.CodeMirror-wrap pre.CodeMirror-line,
.CodeMirror-wrap pre.CodeMirror-line-like {
  word-wrap: break-word;
  white-space: pre-wrap;
  word-break: normal;
}

.CodeMirror-linebackground {
  position: absolute;
  left: 0; right: 0; top: 0; bottom: 0;
  z-index: 0;
}

.CodeMirror-linewidget {
  position: relative;
  z-index: 2;
  padding: 0.1px; /* Force widget margins to stay inside of the container */
}

.CodeMirror-widget {}

.CodeMirror-rtl pre { direction: rtl; }

.CodeMirror-code {
  outline: none;
}

/* Force content-box sizing for the elements where we expect it */
.CodeMirror-scroll,
.CodeMirror-sizer,
.CodeMirror-gutter,
.CodeMirror-gutters,
.CodeMirror-linenumber {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
}

.CodeMirror-measure {
  position: absolute;
  width: 100%;
  height: 0;
  overflow: hidden;
  visibility: hidden;
}

.CodeMirror-cursor {
  position: absolute;
  pointer-events: none;
}
.CodeMirror-measure pre { position: static; }

div.CodeMirror-cursors {
  visibility: hidden;
  position: relative;
  z-index: 3;
}
div.CodeMirror-dragcursors {
  visibility: visible;
}

.CodeMirror-focused div.CodeMirror-cursors {
  visibility: visible;
}

.CodeMirror-selected { background: #d9d9d9; }
.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }
.CodeMirror-crosshair { cursor: crosshair; }
.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }
.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }

.cm-searching {
  background-color: #ffa;
  background-color: rgba(255, 255, 0, .4);
}

/* Used to force a border model for a node */
.cm-force-border { padding-right: .1px; }

@media print {
  /* Hide the cursor when printing */
  .CodeMirror div.CodeMirror-cursors {
    visibility: hidden;
  }
}

/* See issue #2901 */
.cm-tab-wrap-hack:after { content: ''; }

/* Help users use markselection to safely style text background */
span.CodeMirror-selectedtext { background: none; }

    </style>
    <style>
      /**
    Name: IntelliJ IDEA darcula theme
    From IntelliJ IDEA by JetBrains
 */

.cm-s-darcula  { font-family: Consolas, Menlo, Monaco, 'Lucida Console', 'Liberation Mono', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Courier New', monospace, serif;}
.cm-s-darcula.CodeMirror { background: #2B2B2B; color: #A9B7C6; } 

.cm-s-darcula span.cm-meta { color: #BBB529; }
.cm-s-darcula span.cm-number { color: #6897BB; }
.cm-s-darcula span.cm-keyword { color: #CC7832; line-height: 1em; font-weight: bold; }  
.cm-s-darcula span.cm-def { color: #A9B7C6; font-style: italic; }
.cm-s-darcula span.cm-variable { color: #A9B7C6; }
.cm-s-darcula span.cm-variable-2 { color: #A9B7C6; }
.cm-s-darcula span.cm-variable-3 { color: #9876AA; }
.cm-s-darcula span.cm-type { color: #AABBCC; font-weight: bold; }
.cm-s-darcula span.cm-property { color: #FFC66D; }
.cm-s-darcula span.cm-operator { color: #A9B7C6; }
.cm-s-darcula span.cm-string { color: #6A8759; }
.cm-s-darcula span.cm-string-2 { color: #6A8759; }
.cm-s-darcula span.cm-comment { color: #61A151; font-style: italic; } 
.cm-s-darcula span.cm-link { color: #CC7832; }
.cm-s-darcula span.cm-atom { color: #CC7832; }
.cm-s-darcula span.cm-error { color: #BC3F3C; }
.cm-s-darcula span.cm-tag { color: #629755; font-weight: bold; font-style: italic; text-decoration: underline; }
.cm-s-darcula span.cm-attribute { color: #6897bb; }
.cm-s-darcula span.cm-qualifier { color: #6A8759; }
.cm-s-darcula span.cm-bracket { color: #A9B7C6; }
.cm-s-darcula span.cm-builtin { color: #FF9E59; }
.cm-s-darcula span.cm-special { color: #FF9E59; }

.cm-s-darcula .CodeMirror-cursor { border-left: 1px solid #A9B7C6; }  
.cm-s-darcula .CodeMirror-activeline-background { background: #323232; } 
.cm-s-darcula .CodeMirror-gutters { background: #313335; border-right: 1px solid #313335; } 
.cm-s-darcula .CodeMirror-guttermarker { color: #FFEE80; }  
.cm-s-darcula .CodeMirror-guttermarker-subtle { color: #D0D0D0; }  
.cm-s-darcula .CodeMirrir-linenumber { color: #606366; } 
.cm-s-darcula .CodeMirror-matchingbracket { background-color: #3B514D; color: #FFEF28 !important; font-weight: bold; } 

.cm-s-darcula div.CodeMirror-selected { background: #214283; }  

.CodeMirror-hints.darcula {
  font-family: Menlo, Monaco, Consolas, 'Courier New', monospace;
  color: #9C9E9E;
  background-color: #3B3E3F !important;
}

.CodeMirror-hints.darcula .CodeMirror-hint-active {
  background-color: #494D4E !important;
  color: #9C9E9E !important;
}

    </style>
    <script type="text/javascript">
      // CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var isTS = parserConfig.typescript;
  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    return {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": D, "break": D, "continue": D, "new": kw("new"), "delete": C, "void": C, "throw": C,
      "debugger": kw("debugger"), "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this"), "class": kw("class"), "super": kw("atom"),
      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
      "await": C
    };
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == "/" && !inSet) return;
        if (next == "[") inSet = true;
        else if (inSet && next == "]") inSet = false;
      }
      escaped = !escaped && next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
      return ret("number", "number");
    } else if (ch == "." && stream.match("..")) {
      return ret("spread", "meta");
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "=" && stream.eat(">")) {
      return ret("=>", "operator");
    } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
      return ret("number", "number");
    } else if (/\d/.test(ch)) {
      stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
      return ret("number", "number");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (expressionAllowed(stream, state, 1)) {
        readRegexp(stream);
        stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
        return ret("regexp", "string-2");
      } else {
        stream.eat("=");
        return ret("operator", "operator", stream.current());
      }
    } else if (ch == "`") {
      state.tokenize = tokenQuasi;
      return tokenQuasi(stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    } else if (ch == "<" && stream.match("!--") || ch == "-" && stream.match("->")) {
      stream.skipToEnd()
      return ret("comment", "comment")
    } else if (isOperatorChar.test(ch)) {
      if (ch != ">" || !state.lexical || state.lexical.type != ">") {
        if (stream.eat("=")) {
          if (ch == "!" || ch == "=") stream.eat("=")
        } else if (/[<>*+\-]/.test(ch)) {
          stream.eat(ch)
          if (ch == ">") stream.eat(ch)
        }
      }
      return ret("operator", "operator", stream.current());
    } else if (wordRE.test(ch)) {
      stream.eatWhile(wordRE);
      var word = stream.current()
      if (state.lastType != ".") {
        if (keywords.propertyIsEnumerable(word)) {
          var kw = keywords[word]
          return ret(kw.type, kw.style, word)
        }
        if (word == "async" && stream.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, false))
          return ret("async", "keyword", word)
      }
      return ret("variable", "variable", word)
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
        state.tokenize = tokenBase;
        return ret("jsonld-keyword", "meta");
      }
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) break;
        escaped = !escaped && next == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret("string", "string");
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenQuasi(stream, state) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    return ret("quasi", "string-2", stream.current());
  }

  var brackets = "([{}])";
  // This is a crude lookahead trick to try and notice that we're
  // parsing the argument patterns for a fat-arrow function before we
  // actually hit the arrow token. It only works if the arrow is on
  // the same line as the arguments and there's no strange noise
  // (comments) in between. Fallback is to only notice when we hit the
  // arrow, and not declare the arguments as locals for the arrow
  // body.
  function findFatArrow(stream, state) {
    if (state.fatArrowAt) state.fatArrowAt = null;
    var arrow = stream.string.indexOf("=>", stream.start);
    if (arrow < 0) return;

    if (isTS) { // Try to skip TypeScript return type declarations after the arguments
      var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow))
      if (m) arrow = m.index
    }

    var depth = 0, sawSomething = false;
    for (var pos = arrow - 1; pos >= 0; --pos) {
      var ch = stream.string.charAt(pos);
      var bracket = brackets.indexOf(ch);
      if (bracket >= 0 && bracket < 3) {
        if (!depth) { ++pos; break; }
        if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
      } else if (bracket >= 3 && bracket < 6) {
        ++depth;
      } else if (wordRE.test(ch)) {
        sawSomething = true;
      } else if (/["'\/`]/.test(ch)) {
        for (;; --pos) {
          if (pos == 0) return
          var next = stream.string.charAt(pos - 1)
          if (next == ch && stream.string.charAt(pos - 2) != "\\") { pos--; break }
        }
      } else if (sawSomething && !depth) {
        ++pos;
        break;
      }
    }
    if (sawSomething && !depth) state.fatArrowAt = pos;
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
    for (var cx = state.context; cx; cx = cx.prev) {
      for (var v = cx.vars; v; v = v.next)
        if (v.name == varname) return true;
    }
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function inList(name, list) {
    for (var v = list; v; v = v.next) if (v.name == name) return true
    return false;
  }
  function register(varname) {
    var state = cx.state;
    cx.marked = "def";
    if (state.context) {
      if (state.lexical.info == "var" && state.context && state.context.block) {
        // FIXME function decls are also not block scoped
        var newContext = registerVarScoped(varname, state.context)
        if (newContext != null) {
          state.context = newContext
          return
        }
      } else if (!inList(varname, state.localVars)) {
        state.localVars = new Var(varname, state.localVars)
        return
      }
    }
    // Fall through means this is global
    if (parserConfig.globalVars && !inList(varname, state.globalVars))
      state.globalVars = new Var(varname, state.globalVars)
  }
  function registerVarScoped(varname, context) {
    if (!context) {
      return null
    } else if (context.block) {
      var inner = registerVarScoped(varname, context.prev)
      if (!inner) return null
      if (inner == context.prev) return context
      return new Context(inner, context.vars, true)
    } else if (inList(varname, context.vars)) {
      return context
    } else {
      return new Context(context.prev, new Var(varname, context.vars), false)
    }
  }

  function isModifier(name) {
    return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly"
  }

  // Combinators

  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }
  function Var(name, next) { this.name = name; this.next = next }

  var defaultVars = new Var("this", new Var("arguments", null))
  function pushcontext() {
    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)
    cx.state.localVars = defaultVars
  }
  function pushblockcontext() {
    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)
    cx.state.localVars = null
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars
    cx.state.context = cx.state.context.prev
  }
  popcontext.lex = true
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
        indent = outer.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function exp(type) {
      if (type == wanted) return cont();
      else if (wanted == ";" || type == "}" || type == ")" || type == "]") return pass();
      else return cont(exp);
    };
    return exp;
  }

  function statement(type, value) {
    if (type == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
    if (type == "debugger") return cont(expect(";"));
    if (type == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
    if (type == ";") return cont();
    if (type == "if") {
      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
        cx.state.cc.pop()();
      return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
    }
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
    if (type == "class" || (isTS && value == "interface")) {
      cx.marked = "keyword"
      return cont(pushlex("form", type == "class" ? type : value), className, poplex)
    }
    if (type == "variable") {
      if (isTS && value == "declare") {
        cx.marked = "keyword"
        return cont(statement)
      } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
        cx.marked = "keyword"
        if (value == "enum") return cont(enumdef);
        else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));
        else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)
      } else if (isTS && value == "namespace") {
        cx.marked = "keyword"
        return cont(pushlex("form"), expression, statement, poplex)
      } else if (isTS && value == "abstract") {
        cx.marked = "keyword"
        return cont(statement)
      } else {
        return cont(pushlex("stat"), maybelabel);
      }
    }
    if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext,
                                      block, poplex, poplex, popcontext);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
    if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
    if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
    if (type == "async") return cont(statement)
    if (value == "@") return cont(expression, statement)
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function maybeCatchBinding(type) {
    if (type == "(") return cont(funarg, expect(")"))
  }
  function expression(type, value) {
    return expressionInner(type, value, false);
  }
  function expressionNoComma(type, value) {
    return expressionInner(type, value, true);
  }
  function parenExpr(type) {
    if (type != "(") return pass()
    return cont(pushlex(")"), expression, expect(")"), poplex)
  }
  function expressionInner(type, value, noComma) {
    if (cx.state.fatArrowAt == cx.stream.start) {
      var body = noComma ? arrowBodyNoComma : arrowBody;
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
    }

    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef, maybeop);
    if (type == "class" || (isTS && value == "interface")) { cx.marked = "keyword"; return cont(pushlex("form"), classExpression, poplex); }
    if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
    if (type == "quasi") return pass(quasi, maybeop);
    if (type == "new") return cont(maybeTarget(noComma));
    if (type == "import") return cont(expression);
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(expression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
    if (type == "operator") {
      if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
      if (isTS && value == "<" && cx.stream.match(/^([^>]|<.*?>)*>\s*\(/, false))
        return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
      if (value == "?") return cont(expression, expect(":"), expr);
      return cont(expr);
    }
    if (type == "quasi") { return pass(quasi, me); }
    if (type == ";") return;
    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
    if (isTS && value == "as") { cx.marked = "keyword"; return cont(typeexpr, me) }
    if (type == "regexp") {
      cx.state.lastType = cx.marked = "operator"
      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)
      return cont(expr)
    }
  }
  function quasi(type, value) {
    if (type != "quasi") return pass();
    if (value.slice(value.length - 2) != "${") return cont(quasi);
    return cont(expression, continueQuasi);
  }
  function continueQuasi(type) {
    if (type == "}") {
      cx.marked = "string-2";
      cx.state.tokenize = tokenQuasi;
      return cont(quasi);
    }
  }
  function arrowBody(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expression);
  }
  function arrowBodyNoComma(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expressionNoComma);
  }
  function maybeTarget(noComma) {
    return function(type) {
      if (type == ".") return cont(noComma ? targetNoComma : target);
      else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)
      else return pass(noComma ? expressionNoComma : expression);
    };
  }
  function target(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
  }
  function targetNoComma(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "async") {
      cx.marked = "property";
      return cont(objprop);
    } else if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params
      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
        cx.state.fatArrowAt = cx.stream.pos + m[0].length
      return cont(afterprop);
    } else if (type == "number" || type == "string") {
      cx.marked = jsonldMode ? "property" : (cx.style + " property");
      return cont(afterprop);
    } else if (type == "jsonld-keyword") {
      return cont(afterprop);
    } else if (isTS && isModifier(value)) {
      cx.marked = "keyword"
      return cont(objprop)
    } else if (type == "[") {
      return cont(expression, maybetype, expect("]"), afterprop);
    } else if (type == "spread") {
      return cont(expressionNoComma, afterprop);
    } else if (value == "*") {
      cx.marked = "keyword";
      return cont(objprop);
    } else if (type == ":") {
      return pass(afterprop)
    }
  }
  function getterSetter(type) {
    if (type != "variable") return pass(afterprop);
    cx.marked = "property";
    return cont(functiondef);
  }
  function afterprop(type) {
    if (type == ":") return cont(expressionNoComma);
    if (type == "(") return pass(functiondef);
  }
  function commasep(what, end, sep) {
    function proceed(type, value) {
      if (sep ? sep.indexOf(type) > -1 : type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(function(type, value) {
          if (type == end || value == end) return pass()
          return pass(what)
        }, proceed);
      }
      if (type == end || value == end) return cont();
      if (sep && sep.indexOf(";") > -1) return pass(what)
      return cont(expect(end));
    }
    return function(type, value) {
      if (type == end || value == end) return cont();
      return pass(what, proceed);
    };
  }
  function contCommasep(what, end, info) {
    for (var i = 3; i < arguments.length; i++)
      cx.cc.push(arguments[i]);
    return cont(pushlex(end, info), commasep(what, end), poplex);
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type, value) {
    if (isTS) {
      if (type == ":") return cont(typeexpr);
      if (value == "?") return cont(maybetype);
    }
  }
  function maybetypeOrIn(type, value) {
    if (isTS && (type == ":" || value == "in")) return cont(typeexpr)
  }
  function mayberettype(type) {
    if (isTS && type == ":") {
      if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr)
      else return cont(typeexpr)
    }
  }
  function isKW(_, value) {
    if (value == "is") {
      cx.marked = "keyword"
      return cont()
    }
  }
  function typeexpr(type, value) {
    if (value == "keyof" || value == "typeof" || value == "infer") {
      cx.marked = "keyword"
      return cont(value == "typeof" ? expressionNoComma : typeexpr)
    }
    if (type == "variable" || value == "void") {
      cx.marked = "type"
      return cont(afterType)
    }
    if (value == "|" || value == "&") return cont(typeexpr)
    if (type == "string" || type == "number" || type == "atom") return cont(afterType);
    if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType)
    if (type == "{") return cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex, afterType)
    if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType)
    if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr)
  }
  function maybeReturnType(type) {
    if (type == "=>") return cont(typeexpr)
  }
  function typeprop(type, value) {
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property"
      return cont(typeprop)
    } else if (value == "?" || type == "number" || type == "string") {
      return cont(typeprop)
    } else if (type == ":") {
      return cont(typeexpr)
    } else if (type == "[") {
      return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop)
    } else if (type == "(") {
      return pass(functiondecl, typeprop)
    }
  }
  function typearg(type, value) {
    if (type == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg)
    if (type == ":") return cont(typeexpr)
    if (type == "spread") return cont(typearg)
    return pass(typeexpr)
  }
  function afterType(type, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
    if (value == "|" || type == "." || value == "&") return cont(typeexpr)
    if (type == "[") return cont(typeexpr, expect("]"), afterType)
    if (value == "extends" || value == "implements") { cx.marked = "keyword"; return cont(typeexpr) }
    if (value == "?") return cont(typeexpr, expect(":"), typeexpr)
  }
  function maybeTypeArgs(_, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
  }
  function typeparam() {
    return pass(typeexpr, maybeTypeDefault)
  }
  function maybeTypeDefault(_, value) {
    if (value == "=") return cont(typeexpr)
  }
  function vardef(_, value) {
    if (value == "enum") {cx.marked = "keyword"; return cont(enumdef)}
    return pass(pattern, maybetype, maybeAssign, vardefCont);
  }
  function pattern(type, value) {
    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(pattern) }
    if (type == "variable") { register(value); return cont(); }
    if (type == "spread") return cont(pattern);
    if (type == "[") return contCommasep(eltpattern, "]");
    if (type == "{") return contCommasep(proppattern, "}");
  }
  function proppattern(type, value) {
    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
      register(value);
      return cont(maybeAssign);
    }
    if (type == "variable") cx.marked = "property";
    if (type == "spread") return cont(pattern);
    if (type == "}") return pass();
    if (type == "[") return cont(expression, expect(']'), expect(':'), proppattern);
    return cont(expect(":"), pattern, maybeAssign);
  }
  function eltpattern() {
    return pass(pattern, maybeAssign)
  }
  function maybeAssign(_type, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function vardefCont(type) {
    if (type == ",") return cont(vardef);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
  }
  function forspec(type, value) {
    if (value == "await") return cont(forspec);
    if (type == "(") return cont(pushlex(")"), forspec1, poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef, forspec2);
    if (type == "variable") return cont(forspec2);
    return pass(forspec2)
  }
  function forspec2(type, value) {
    if (type == ")") return cont()
    if (type == ";") return cont(forspec2)
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression, forspec2) }
    return pass(expression, forspec2)
  }
  function functiondef(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef)
  }
  function functiondecl(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondecl);}
    if (type == "variable") {register(value); return cont(functiondecl);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl)
  }
  function typename(type, value) {
    if (type == "keyword" || type == "variable") {
      cx.marked = "type"
      return cont(typename)
    } else if (value == "<") {
      return cont(pushlex(">"), commasep(typeparam, ">"), poplex)
    }
  }
  function funarg(type, value) {
    if (value == "@") cont(expression, funarg)
    if (type == "spread") return cont(funarg);
    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(funarg); }
    if (isTS && type == "this") return cont(maybetype, maybeAssign)
    return pass(pattern, maybetype, maybeAssign);
  }
  function classExpression(type, value) {
    // Class expressions may have an optional name.
    if (type == "variable") return className(type, value);
    return classNameAfter(type, value);
  }
  function className(type, value) {
    if (type == "variable") {register(value); return cont(classNameAfter);}
  }
  function classNameAfter(type, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter)
    if (value == "extends" || value == "implements" || (isTS && type == ",")) {
      if (value == "implements") cx.marked = "keyword";
      return cont(isTS ? typeexpr : expression, classNameAfter);
    }
    if (type == "{") return cont(pushlex("}"), classBody, poplex);
  }
  function classBody(type, value) {
    if (type == "async" ||
        (type == "variable" &&
         (value == "static" || value == "get" || value == "set" || (isTS && isModifier(value))) &&
         cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false))) {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      return cont(isTS ? classfield : functiondef, classBody);
    }
    if (type == "number" || type == "string") return cont(isTS ? classfield : functiondef, classBody);
    if (type == "[")
      return cont(expression, maybetype, expect("]"), isTS ? classfield : functiondef, classBody)
    if (value == "*") {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (isTS && type == "(") return pass(functiondecl, classBody)
    if (type == ";" || type == ",") return cont(classBody);
    if (type == "}") return cont();
    if (value == "@") return cont(expression, classBody)
  }
  function classfield(type, value) {
    if (value == "?") return cont(classfield)
    if (type == ":") return cont(typeexpr, maybeAssign)
    if (value == "=") return cont(expressionNoComma)
    var context = cx.state.lexical.prev, isInterface = context && context.info == "interface"
    return pass(isInterface ? functiondecl : functiondef)
  }
  function afterExport(type, value) {
    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
    if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
    return pass(statement);
  }
  function exportField(type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }
    if (type == "variable") return pass(expressionNoComma, exportField);
  }
  function afterImport(type) {
    if (type == "string") return cont();
    if (type == "(") return pass(expression);
    return pass(importSpec, maybeMoreImports, maybeFrom);
  }
  function importSpec(type, value) {
    if (type == "{") return contCommasep(importSpec, "}");
    if (type == "variable") register(value);
    if (value == "*") cx.marked = "keyword";
    return cont(maybeAs);
  }
  function maybeMoreImports(type) {
    if (type == ",") return cont(importSpec, maybeMoreImports)
  }
  function maybeAs(_type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
  }
  function maybeFrom(_type, value) {
    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
  }
  function arrayLiteral(type) {
    if (type == "]") return cont();
    return pass(commasep(expressionNoComma, "]"));
  }
  function enumdef() {
    return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)
  }
  function enummember() {
    return pass(pattern, maybeAssign);
  }

  function isContinuedStatement(state, textAfter) {
    return state.lastType == "operator" || state.lastType == "," ||
      isOperatorChar.test(textAfter.charAt(0)) ||
      /[,.]/.test(textAfter.charAt(0));
  }

  function expressionAllowed(stream, state, backUp) {
    return state.tokenize == tokenBase &&
      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
      (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
  }

  // Interface

  return {
    startState: function(basecolumn) {
      var state = {
        tokenize: tokenBase,
        lastType: "sof",
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        context: parserConfig.localVars && new Context(null, null, false),
        indented: basecolumn || 0
      };
      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
        findFatArrow(stream, state);
      }
      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == tokenComment) return CodeMirror.Pass;
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse) break;
      }
      while ((lexical.type == "stat" || lexical.type == "form") &&
             (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
                                   !/^[,\.=+\-*:?[\(]/.test(textAfter))))
        lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    blockCommentContinue: jsonMode ? null : " * ",
    lineComment: jsonMode ? null : "//",
    fold: "brace",
    closeBrackets: "()[]{}''\"\"``",

    helperType: jsonMode ? "json" : "javascript",
    jsonldMode: jsonldMode,
    jsonMode: jsonMode,

    expressionAllowed: expressionAllowed,

    skipExpression: function(state) {
      var top = state.cc[state.cc.length - 1]
      if (top == expression || top == expressionNoComma) state.cc.pop()
    }
  };
});

CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/x-javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

});

    </script>
    <script type="text/javascript">
      // CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

var htmlConfig = {
  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
                    'track': true, 'wbr': true, 'menuitem': true},
  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
                     'th': true, 'tr': true},
  contextGrabbers: {
    'dd': {'dd': true, 'dt': true},
    'dt': {'dd': true, 'dt': true},
    'li': {'li': true},
    'option': {'option': true, 'optgroup': true},
    'optgroup': {'optgroup': true},
    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
    'rp': {'rp': true, 'rt': true},
    'rt': {'rp': true, 'rt': true},
    'tbody': {'tbody': true, 'tfoot': true},
    'td': {'td': true, 'th': true},
    'tfoot': {'tbody': true},
    'th': {'td': true, 'th': true},
    'thead': {'tbody': true, 'tfoot': true},
    'tr': {'tr': true}
  },
  doNotIndent: {"pre": true},
  allowUnquoted: true,
  allowMissing: true,
  caseFold: true
}

var xmlConfig = {
  autoSelfClosers: {},
  implicitlyClosed: {},
  contextGrabbers: {},
  doNotIndent: {},
  allowUnquoted: false,
  allowMissing: false,
  allowMissingTagName: false,
  caseFold: false
}

CodeMirror.defineMode("xml", function(editorConf, config_) {
  var indentUnit = editorConf.indentUnit
  var config = {}
  var defaults = config_.htmlMode ? htmlConfig : xmlConfig
  for (var prop in defaults) config[prop] = defaults[prop]
  for (var prop in config_) config[prop] = config_[prop]

  // Return variables for tokenizers
  var type, setStyle;

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var ch = stream.next();
    if (ch == "<") {
      if (stream.eat("!")) {
        if (stream.eat("[")) {
          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
          else return null;
        } else if (stream.match("--")) {
          return chain(inBlock("comment", "-->"));
        } else if (stream.match("DOCTYPE", true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else {
          return null;
        }
      } else if (stream.eat("?")) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock("meta", "?>");
        return "meta";
      } else {
        type = stream.eat("/") ? "closeTag" : "openTag";
        state.tokenize = inTag;
        return "tag bracket";
      }
    } else if (ch == "&") {
      var ok;
      if (stream.eat("#")) {
        if (stream.eat("x")) {
          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
        } else {
          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
      }
      return ok ? "atom" : "error";
    } else {
      stream.eatWhile(/[^&<]/);
      return null;
    }
  }
  inText.isInText = true;

  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
      state.tokenize = inText;
      type = ch == ">" ? "endTag" : "selfcloseTag";
      return "tag bracket";
    } else if (ch == "=") {
      type = "equals";
      return null;
    } else if (ch == "<") {
      state.tokenize = inText;
      state.state = baseState;
      state.tagName = state.tagStart = null;
      var next = state.tokenize(stream, state);
      return next ? next + " tag error" : "tag error";
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      state.stringStartCol = stream.column();
      return state.tokenize(stream, state);
    } else {
      stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
      return "word";
    }
  }

  function inAttribute(quote) {
    var closure = function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return "string";
    };
    closure.isInAttribute = true;
    return closure;
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    }
  }

  function doctype(depth) {
    return function(stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == "<") {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == ">") {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return "meta";
    };
  }

  function Context(state, tagName, startOfLine) {
    this.prev = state.context;
    this.tagName = tagName;
    this.indent = state.indented;
    this.startOfLine = startOfLine;
    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
      this.noIndent = true;
  }
  function popContext(state) {
    if (state.context) state.context = state.context.prev;
  }
  function maybePopContext(state, nextTagName) {
    var parentTagName;
    while (true) {
      if (!state.context) {
        return;
      }
      parentTagName = state.context.tagName;
      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||
          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
        return;
      }
      popContext(state);
    }
  }

  function baseState(type, stream, state) {
    if (type == "openTag") {
      state.tagStart = stream.column();
      return tagNameState;
    } else if (type == "closeTag") {
      return closeTagNameState;
    } else {
      return baseState;
    }
  }
  function tagNameState(type, stream, state) {
    if (type == "word") {
      state.tagName = stream.current();
      setStyle = "tag";
      return attrState;
    } else if (config.allowMissingTagName && type == "endTag") {
      setStyle = "tag bracket";
      return attrState(type, stream, state);
    } else {
      setStyle = "error";
      return tagNameState;
    }
  }
  function closeTagNameState(type, stream, state) {
    if (type == "word") {
      var tagName = stream.current();
      if (state.context && state.context.tagName != tagName &&
          config.implicitlyClosed.hasOwnProperty(state.context.tagName))
        popContext(state);
      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
        setStyle = "tag";
        return closeState;
      } else {
        setStyle = "tag error";
        return closeStateErr;
      }
    } else if (config.allowMissingTagName && type == "endTag") {
      setStyle = "tag bracket";
      return closeState(type, stream, state);
    } else {
      setStyle = "error";
      return closeStateErr;
    }
  }

  function closeState(type, _stream, state) {
    if (type != "endTag") {
      setStyle = "error";
      return closeState;
    }
    popContext(state);
    return baseState;
  }
  function closeStateErr(type, stream, state) {
    setStyle = "error";
    return closeState(type, stream, state);
  }

  function attrState(type, _stream, state) {
    if (type == "word") {
      setStyle = "attribute";
      return attrEqState;
    } else if (type == "endTag" || type == "selfcloseTag") {
      var tagName = state.tagName, tagStart = state.tagStart;
      state.tagName = state.tagStart = null;
      if (type == "selfcloseTag" ||
          config.autoSelfClosers.hasOwnProperty(tagName)) {
        maybePopContext(state, tagName);
      } else {
        maybePopContext(state, tagName);
        state.context = new Context(state, tagName, tagStart == state.indented);
      }
      return baseState;
    }
    setStyle = "error";
    return attrState;
  }
  function attrEqState(type, stream, state) {
    if (type == "equals") return attrValueState;
    if (!config.allowMissing) setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrValueState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
    setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrContinuedState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    return attrState(type, stream, state);
  }

  return {
    startState: function(baseIndent) {
      var state = {tokenize: inText,
                   state: baseState,
                   indented: baseIndent || 0,
                   tagName: null, tagStart: null,
                   context: null}
      if (baseIndent != null) state.baseIndent = baseIndent
      return state
    },

    token: function(stream, state) {
      if (!state.tagName && stream.sol())
        state.indented = stream.indentation();

      if (stream.eatSpace()) return null;
      type = null;
      var style = state.tokenize(stream, state);
      if ((style || type) && style != "comment") {
        setStyle = null;
        state.state = state.state(type || style, stream, state);
        if (setStyle)
          style = setStyle == "error" ? style + " error" : setStyle;
      }
      return style;
    },

    indent: function(state, textAfter, fullLine) {
      var context = state.context;
      // Indent multi-line strings (e.g. css).
      if (state.tokenize.isInAttribute) {
        if (state.tagStart == state.indented)
          return state.stringStartCol + 1;
        else
          return state.indented + indentUnit;
      }
      if (context && context.noIndent) return CodeMirror.Pass;
      if (state.tokenize != inTag && state.tokenize != inText)
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
      // Indent the starts of attribute names.
      if (state.tagName) {
        if (config.multilineTagIndentPastTag !== false)
          return state.tagStart + state.tagName.length + 2;
        else
          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
      }
      if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
      if (tagAfter && tagAfter[1]) { // Closing tag spotted
        while (context) {
          if (context.tagName == tagAfter[2]) {
            context = context.prev;
            break;
          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
            context = context.prev;
          } else {
            break;
          }
        }
      } else if (tagAfter) { // Opening tag spotted
        while (context) {
          var grabbers = config.contextGrabbers[context.tagName];
          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
            context = context.prev;
          else
            break;
        }
      }
      while (context && context.prev && !context.startOfLine)
        context = context.prev;
      if (context) return context.indent + indentUnit;
      else return state.baseIndent || 0;
    },

    electricInput: /<\/[\s\w:]+>$/,
    blockCommentStart: "<!--",
    blockCommentEnd: "-->",

    configuration: config.htmlMode ? "html" : "xml",
    helperType: config.htmlMode ? "html" : "xml",

    skipAttribute: function(state) {
      if (state.state == attrValueState)
        state.state = attrState
    },

    xmlCurrentTag: function(state) {
      return state.tagName ? {name: state.tagName, close: state.type == "closeTag"} : null
    },

    xmlCurrentContext: function(state) {
      var context = []
      for (var cx = state.context; cx; cx = cx.prev)
        if (cx.tagName) context.push(cx.tagName)
      return context.reverse()
    }
  };
});

CodeMirror.defineMIME("text/xml", "xml");
CodeMirror.defineMIME("application/xml", "xml");
if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});

});

    </script>
    <script type="text/javascript">
      // CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("css", function(config, parserConfig) {
  var inline = parserConfig.inline
  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

  var indentUnit = config.indentUnit,
      tokenHooks = parserConfig.tokenHooks,
      documentTypes = parserConfig.documentTypes || {},
      mediaTypes = parserConfig.mediaTypes || {},
      mediaFeatures = parserConfig.mediaFeatures || {},
      mediaValueKeywords = parserConfig.mediaValueKeywords || {},
      propertyKeywords = parserConfig.propertyKeywords || {},
      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
      fontProperties = parserConfig.fontProperties || {},
      counterDescriptors = parserConfig.counterDescriptors || {},
      colorKeywords = parserConfig.colorKeywords || {},
      valueKeywords = parserConfig.valueKeywords || {},
      allowNested = parserConfig.allowNested,
      lineComment = parserConfig.lineComment,
      supportsAtComponent = parserConfig.supportsAtComponent === true;

  var type, override;
  function ret(style, tp) { type = tp; return style; }

  // Tokenizers

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (tokenHooks[ch]) {
      var result = tokenHooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == "@") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("def", stream.current());
    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
      return ret(null, "compare");
    } else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "#") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("atom", "hash");
    } else if (ch == "!") {
      stream.match(/^\s*\w*/);
      return ret("keyword", "important");
    } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
      stream.eatWhile(/[\w.%]/);
      return ret("number", "unit");
    } else if (ch === "-") {
      if (/[\d.]/.test(stream.peek())) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (stream.match(/^-[\w\\\-]*/)) {
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ret("variable-2", "variable-definition");
        return ret("variable-2", "variable");
      } else if (stream.match(/^\w+-/)) {
        return ret("meta", "meta");
      }
    } else if (/[,+>*\/]/.test(ch)) {
      return ret(null, "select-op");
    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
      return ret("qualifier", "qualifier");
    } else if (/[:;{}\[\]\(\)]/.test(ch)) {
      return ret(null, ch);
    } else if (stream.match(/[\w-.]+(?=\()/)) {
      if (/^(url(-prefix)?|domain|regexp)$/.test(stream.current().toLowerCase())) {
        state.tokenize = tokenParenthesized;
      }
      return ret("variable callee", "variable");
    } else if (/[\w\\\-]/.test(ch)) {
      stream.eatWhile(/[\w\\\-]/);
      return ret("property", "word");
    } else {
      return ret(null, null);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped) {
          if (quote == ")") stream.backUp(1);
          break;
        }
        escaped = !escaped && ch == "\\";
      }
      if (ch == quote || !escaped && quote != ")") state.tokenize = null;
      return ret("string", "string");
    };
  }

  function tokenParenthesized(stream, state) {
    stream.next(); // Must be '('
    if (!stream.match(/\s*[\"\')]/, false))
      state.tokenize = tokenString(")");
    else
      state.tokenize = null;
    return ret(null, "(");
  }

  // Context management

  function Context(type, indent, prev) {
    this.type = type;
    this.indent = indent;
    this.prev = prev;
  }

  function pushContext(state, stream, type, indent) {
    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
    return type;
  }

  function popContext(state) {
    if (state.context.prev)
      state.context = state.context.prev;
    return state.context.type;
  }

  function pass(type, stream, state) {
    return states[state.context.type](type, stream, state);
  }
  function popAndPass(type, stream, state, n) {
    for (var i = n || 1; i > 0; i--)
      state.context = state.context.prev;
    return pass(type, stream, state);
  }

  // Parser

  function wordAsValue(stream) {
    var word = stream.current().toLowerCase();
    if (valueKeywords.hasOwnProperty(word))
      override = "atom";
    else if (colorKeywords.hasOwnProperty(word))
      override = "keyword";
    else
      override = "variable";
  }

  var states = {};

  states.top = function(type, stream, state) {
    if (type == "{") {
      return pushContext(state, stream, "block");
    } else if (type == "}" && state.context.prev) {
      return popContext(state);
    } else if (supportsAtComponent && /@component/i.test(type)) {
      return pushContext(state, stream, "atComponentBlock");
    } else if (/^@(-moz-)?document$/i.test(type)) {
      return pushContext(state, stream, "documentTypes");
    } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {
      return pushContext(state, stream, "atBlock");
    } else if (/^@(font-face|counter-style)/i.test(type)) {
      state.stateArg = type;
      return "restricted_atBlock_before";
    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {
      return "keyframes";
    } else if (type && type.charAt(0) == "@") {
      return pushContext(state, stream, "at");
    } else if (type == "hash") {
      override = "builtin";
    } else if (type == "word") {
      override = "tag";
    } else if (type == "variable-definition") {
      return "maybeprop";
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    } else if (type == ":") {
      return "pseudo";
    } else if (allowNested && type == "(") {
      return pushContext(state, stream, "parens");
    }
    return state.context.type;
  };

  states.block = function(type, stream, state) {
    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (propertyKeywords.hasOwnProperty(word)) {
        override = "property";
        return "maybeprop";
      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
        override = "string-2";
        return "maybeprop";
      } else if (allowNested) {
        override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
        return "block";
      } else {
        override += " error";
        return "maybeprop";
      }
    } else if (type == "meta") {
      return "block";
    } else if (!allowNested && (type == "hash" || type == "qualifier")) {
      override = "error";
      return "block";
    } else {
      return states.top(type, stream, state);
    }
  };

  states.maybeprop = function(type, stream, state) {
    if (type == ":") return pushContext(state, stream, "prop");
    return pass(type, stream, state);
  };

  states.prop = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
    if (type == "}" || type == "{") return popAndPass(type, stream, state);
    if (type == "(") return pushContext(state, stream, "parens");

    if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
      override += " error";
    } else if (type == "word") {
      wordAsValue(stream);
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    }
    return "prop";
  };

  states.propBlock = function(type, _stream, state) {
    if (type == "}") return popContext(state);
    if (type == "word") { override = "property"; return "maybeprop"; }
    return state.context.type;
  };

  states.parens = function(type, stream, state) {
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == ")") return popContext(state);
    if (type == "(") return pushContext(state, stream, "parens");
    if (type == "interpolation") return pushContext(state, stream, "interpolation");
    if (type == "word") wordAsValue(stream);
    return "parens";
  };

  states.pseudo = function(type, stream, state) {
    if (type == "meta") return "pseudo";

    if (type == "word") {
      override = "variable-3";
      return state.context.type;
    }
    return pass(type, stream, state);
  };

  states.documentTypes = function(type, stream, state) {
    if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
      override = "tag";
      return state.context.type;
    } else {
      return states.atBlock(type, stream, state);
    }
  };

  states.atBlock = function(type, stream, state) {
    if (type == "(") return pushContext(state, stream, "atBlock_parens");
    if (type == "}" || type == ";") return popAndPass(type, stream, state);
    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");

    if (type == "interpolation") return pushContext(state, stream, "interpolation");

    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (word == "only" || word == "not" || word == "and" || word == "or")
        override = "keyword";
      else if (mediaTypes.hasOwnProperty(word))
        override = "attribute";
      else if (mediaFeatures.hasOwnProperty(word))
        override = "property";
      else if (mediaValueKeywords.hasOwnProperty(word))
        override = "keyword";
      else if (propertyKeywords.hasOwnProperty(word))
        override = "property";
      else if (nonStandardPropertyKeywords.hasOwnProperty(word))
        override = "string-2";
      else if (valueKeywords.hasOwnProperty(word))
        override = "atom";
      else if (colorKeywords.hasOwnProperty(word))
        override = "keyword";
      else
        override = "error";
    }
    return state.context.type;
  };

  states.atComponentBlock = function(type, stream, state) {
    if (type == "}")
      return popAndPass(type, stream, state);
    if (type == "{")
      return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
    if (type == "word")
      override = "error";
    return state.context.type;
  };

  states.atBlock_parens = function(type, stream, state) {
    if (type == ")") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
    return states.atBlock(type, stream, state);
  };

  states.restricted_atBlock_before = function(type, stream, state) {
    if (type == "{")
      return pushContext(state, stream, "restricted_atBlock");
    if (type == "word" && state.stateArg == "@counter-style") {
      override = "variable";
      return "restricted_atBlock_before";
    }
    return pass(type, stream, state);
  };

  states.restricted_atBlock = function(type, stream, state) {
    if (type == "}") {
      state.stateArg = null;
      return popContext(state);
    }
    if (type == "word") {
      if ((state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||
          (state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))
        override = "error";
      else
        override = "property";
      return "maybeprop";
    }
    return "restricted_atBlock";
  };

  states.keyframes = function(type, stream, state) {
    if (type == "word") { override = "variable"; return "keyframes"; }
    if (type == "{") return pushContext(state, stream, "top");
    return pass(type, stream, state);
  };

  states.at = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == "word") override = "tag";
    else if (type == "hash") override = "builtin";
    return "at";
  };

  states.interpolation = function(type, stream, state) {
    if (type == "}") return popContext(state);
    if (type == "{" || type == ";") return popAndPass(type, stream, state);
    if (type == "word") override = "variable";
    else if (type != "variable" && type != "(" && type != ")") override = "error";
    return "interpolation";
  };

  return {
    startState: function(base) {
      return {tokenize: null,
              state: inline ? "block" : "top",
              stateArg: null,
              context: new Context(inline ? "block" : "top", base || 0, null)};
    },

    token: function(stream, state) {
      if (!state.tokenize && stream.eatSpace()) return null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style && typeof style == "object") {
        type = style[1];
        style = style[0];
      }
      override = style;
      if (type != "comment")
        state.state = states[state.state](type, stream, state);
      return override;
    },

    indent: function(state, textAfter) {
      var cx = state.context, ch = textAfter && textAfter.charAt(0);
      var indent = cx.indent;
      if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
      if (cx.prev) {
        if (ch == "}" && (cx.type == "block" || cx.type == "top" ||
                          cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
          // Resume indentation from parent context.
          cx = cx.prev;
          indent = cx.indent;
        } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||
            ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
          // Dedent relative to current context.
          indent = Math.max(0, cx.indent - indentUnit);
        }
      }
      return indent;
    },

    electricChars: "}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    blockCommentContinue: " * ",
    lineComment: lineComment,
    fold: "brace"
  };
});

  function keySet(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) {
      keys[array[i].toLowerCase()] = true;
    }
    return keys;
  }

  var documentTypes_ = [
    "domain", "regexp", "url", "url-prefix"
  ], documentTypes = keySet(documentTypes_);

  var mediaTypes_ = [
    "all", "aural", "braille", "handheld", "print", "projection", "screen",
    "tty", "tv", "embossed"
  ], mediaTypes = keySet(mediaTypes_);

  var mediaFeatures_ = [
    "width", "min-width", "max-width", "height", "min-height", "max-height",
    "device-width", "min-device-width", "max-device-width", "device-height",
    "min-device-height", "max-device-height", "aspect-ratio",
    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
    "max-color", "color-index", "min-color-index", "max-color-index",
    "monochrome", "min-monochrome", "max-monochrome", "resolution",
    "min-resolution", "max-resolution", "scan", "grid", "orientation",
    "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio",
    "pointer", "any-pointer", "hover", "any-hover"
  ], mediaFeatures = keySet(mediaFeatures_);

  var mediaValueKeywords_ = [
    "landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover",
    "interlace", "progressive"
  ], mediaValueKeywords = keySet(mediaValueKeywords_);

  var propertyKeywords_ = [
    "align-content", "align-items", "align-self", "alignment-adjust",
    "alignment-baseline", "anchor-point", "animation", "animation-delay",
    "animation-direction", "animation-duration", "animation-fill-mode",
    "animation-iteration-count", "animation-name", "animation-play-state",
    "animation-timing-function", "appearance", "azimuth", "backface-visibility",
    "background", "background-attachment", "background-blend-mode", "background-clip",
    "background-color", "background-image", "background-origin", "background-position",
    "background-repeat", "background-size", "baseline-shift", "binding",
    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
    "bookmark-target", "border", "border-bottom", "border-bottom-color",
    "border-bottom-left-radius", "border-bottom-right-radius",
    "border-bottom-style", "border-bottom-width", "border-collapse",
    "border-color", "border-image", "border-image-outset",
    "border-image-repeat", "border-image-slice", "border-image-source",
    "border-image-width", "border-left", "border-left-color",
    "border-left-style", "border-left-width", "border-radius", "border-right",
    "border-right-color", "border-right-style", "border-right-width",
    "border-spacing", "border-style", "border-top", "border-top-color",
    "border-top-left-radius", "border-top-right-radius", "border-top-style",
    "border-top-width", "border-width", "bottom", "box-decoration-break",
    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
    "caption-side", "caret-color", "clear", "clip", "color", "color-profile", "column-count",
    "column-fill", "column-gap", "column-rule", "column-rule-color",
    "column-rule-style", "column-rule-width", "column-span", "column-width",
    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
    "cue-after", "cue-before", "cursor", "direction", "display",
    "dominant-baseline", "drop-initial-after-adjust",
    "drop-initial-after-align", "drop-initial-before-adjust",
    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
    "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",
    "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",
    "font-stretch", "font-style", "font-synthesis", "font-variant",
    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
    "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow",
    "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap",
    "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap",
    "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns",
    "grid-template-rows", "hanging-punctuation", "height", "hyphens",
    "icon", "image-orientation", "image-rendering", "image-resolution",
    "inline-box-align", "justify-content", "justify-items", "justify-self", "left", "letter-spacing",
    "line-break", "line-height", "line-stacking", "line-stacking-ruby",
    "line-stacking-shift", "line-stacking-strategy", "list-style",
    "list-style-image", "list-style-position", "list-style-type", "margin",
    "margin-bottom", "margin-left", "margin-right", "margin-top",
    "marks", "marquee-direction", "marquee-loop",
    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
    "max-width", "min-height", "min-width", "mix-blend-mode", "move-to", "nav-down", "nav-index",
    "nav-left", "nav-right", "nav-up", "object-fit", "object-position",
    "opacity", "order", "orphans", "outline",
    "outline-color", "outline-offset", "outline-style", "outline-width",
    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
    "page", "page-break-after", "page-break-before", "page-break-inside",
    "page-policy", "pause", "pause-after", "pause-before", "perspective",
    "perspective-origin", "pitch", "pitch-range", "place-content", "place-items", "place-self", "play-during", "position",
    "presentation-level", "punctuation-trim", "quotes", "region-break-after",
    "region-break-before", "region-break-inside", "region-fragment",
    "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",
    "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",
    "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin",
    "shape-outside", "size", "speak", "speak-as", "speak-header",
    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
    "tab-size", "table-layout", "target", "target-name", "target-new",
    "target-position", "text-align", "text-align-last", "text-decoration",
    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
    "text-decoration-style", "text-emphasis", "text-emphasis-color",
    "text-emphasis-position", "text-emphasis-style", "text-height",
    "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",
    "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",
    "text-wrap", "top", "transform", "transform-origin", "transform-style",
    "transition", "transition-delay", "transition-duration",
    "transition-property", "transition-timing-function", "unicode-bidi",
    "user-select", "vertical-align", "visibility", "voice-balance", "voice-duration",
    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
    "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break",
    "word-spacing", "word-wrap", "z-index",
    // SVG-specific
    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
    "color-interpolation", "color-interpolation-filters",
    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",
    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
    "glyph-orientation-vertical", "text-anchor", "writing-mode"
  ], propertyKeywords = keySet(propertyKeywords_);

  var nonStandardPropertyKeywords_ = [
    "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",
    "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",
    "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside",
    "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button",
    "searchfield-results-decoration", "zoom"
  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);

  var fontProperties_ = [
    "font-family", "src", "unicode-range", "font-variant", "font-feature-settings",
    "font-stretch", "font-weight", "font-style"
  ], fontProperties = keySet(fontProperties_);

  var counterDescriptors_ = [
    "additive-symbols", "fallback", "negative", "pad", "prefix", "range",
    "speak-as", "suffix", "symbols", "system"
  ], counterDescriptors = keySet(counterDescriptors_);

  var colorKeywords_ = [
    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
    "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown",
    "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
    "whitesmoke", "yellow", "yellowgreen"
  ], colorKeywords = keySet(colorKeywords_);

  var valueKeywords_ = [
    "above", "absolute", "activeborder", "additive", "activecaption", "afar",
    "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate",
    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
    "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page",
    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",
    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
    "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel",
    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian",
    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
    "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch",
    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
    "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse",
    "compact", "condensed", "contain", "content", "contents",
    "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop",
    "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal",
    "decimal-leading-zero", "default", "default-button", "dense", "destination-atop",
    "destination-in", "destination-out", "destination-over", "devanagari", "difference",
    "disc", "discard", "disclosure-closed", "disclosure-open", "document",
    "dot-dash", "dot-dot-dash",
    "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig",
    "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed",
    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes",
    "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove",
    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew",
    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore",
    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
    "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert",
    "italic", "japanese-formal", "japanese-informal", "justify", "kannada",
    "katakana", "katakana-iroha", "keep-all", "khmer",
    "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal",
    "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten",
    "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem",
    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
    "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d",
    "media-controls-background", "media-current-time-display",
    "media-fullscreen-button", "media-mute-button", "media-play-button",
    "media-return-to-realtime-button", "media-rewind-button",
    "media-seek-back-button", "media-seek-forward-button", "media-slider",
    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
    "menu", "menulist", "menulist-button", "menulist-text",
    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
    "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize",
    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
    "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote",
    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
    "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter",
    "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d",
    "progress", "push-button", "radial-gradient", "radio", "read-only",
    "read-write", "read-write-plaintext-only", "rectangle", "region",
    "relative", "repeat", "repeating-linear-gradient",
    "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse",
    "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY",
    "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running",
    "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen",
    "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield",
    "searchfield-cancel-button", "searchfield-decoration",
    "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end",
    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
    "simp-chinese-formal", "simp-chinese-informal", "single",
    "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal",
    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
    "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali",
    "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square",
    "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub",
    "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table",
    "table-caption", "table-cell", "table-column", "table-column-group",
    "table-footer-group", "table-header-group", "table-row", "table-row-group",
    "tamil",
    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
    "trad-chinese-formal", "trad-chinese-informal", "transform",
    "translate", "translate3d", "translateX", "translateY", "translateZ",
    "transparent", "ultra-condensed", "ultra-expanded", "underline", "unset", "up",
    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
    "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
    "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor",
    "xx-large", "xx-small"
  ], valueKeywords = keySet(valueKeywords_);

  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)
    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)
    .concat(valueKeywords_);
  CodeMirror.registerHelper("hintWords", "css", allWords);

  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ["comment", "comment"];
  }

  CodeMirror.defineMIME("text/css", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    tokenHooks: {
      "/": function(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css"
  });

  CodeMirror.defineMIME("text/x-scss", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      ":": function(stream) {
        if (stream.match(/\s*\{/, false))
          return [null, null]
        return false;
      },
      "$": function(stream) {
        stream.match(/^[\w-]+/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "#": function(stream) {
        if (!stream.eat("{")) return false;
        return [null, "interpolation"];
      }
    },
    name: "css",
    helperType: "scss"
  });

  CodeMirror.defineMIME("text/x-less", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      "@": function(stream) {
        if (stream.eat("{")) return [null, "interpolation"];
        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false)) return false;
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "&": function() {
        return ["atom", "atom"];
      }
    },
    name: "css",
    helperType: "less"
  });

  CodeMirror.defineMIME("text/x-gss", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    supportsAtComponent: true,
    tokenHooks: {
      "/": function(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css",
    helperType: "gss"
  });

});

    </script>
    <script type="text/javascript">
      // CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("../xml/xml"), require("../javascript/javascript"), require("../css/css"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript", "../css/css"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var defaultTags = {
    script: [
      ["lang", /(javascript|babel)/i, "javascript"],
      ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
      ["type", /./, "text/plain"],
      [null, null, "javascript"]
    ],
    style:  [
      ["lang", /^css$/i, "css"],
      ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
      ["type", /./, "text/plain"],
      [null, null, "css"]
    ]
  };

  function maybeBackup(stream, pat, style) {
    var cur = stream.current(), close = cur.search(pat);
    if (close > -1) {
      stream.backUp(cur.length - close);
    } else if (cur.match(/<\/?$/)) {
      stream.backUp(cur.length);
      if (!stream.match(pat, false)) stream.match(cur);
    }
    return style;
  }

  var attrRegexpCache = {};
  function getAttrRegexp(attr) {
    var regexp = attrRegexpCache[attr];
    if (regexp) return regexp;
    return attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*");
  }

  function getAttrValue(text, attr) {
    var match = text.match(getAttrRegexp(attr))
    return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : ""
  }

  function getTagRegexp(tagName, anchored) {
    return new RegExp((anchored ? "^" : "") + "<\/\s*" + tagName + "\s*>", "i");
  }

  function addTags(from, to) {
    for (var tag in from) {
      var dest = to[tag] || (to[tag] = []);
      var source = from[tag];
      for (var i = source.length - 1; i >= 0; i--)
        dest.unshift(source[i])
    }
  }

  function findMatchingMode(tagInfo, tagText) {
    for (var i = 0; i < tagInfo.length; i++) {
      var spec = tagInfo[i];
      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];
    }
  }

  CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
    var htmlMode = CodeMirror.getMode(config, {
      name: "xml",
      htmlMode: true,
      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag
    });

    var tags = {};
    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;
    addTags(defaultTags, tags);
    if (configTags) addTags(configTags, tags);
    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)
      tags.script.unshift(["type", configScript[i].matches, configScript[i].mode])

    function html(stream, state) {
      var style = htmlMode.token(stream, state.htmlState), tag = /\btag\b/.test(style), tagName
      if (tag && !/[<>\s\/]/.test(stream.current()) &&
          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&
          tags.hasOwnProperty(tagName)) {
        state.inTag = tagName + " "
      } else if (state.inTag && tag && />$/.test(stream.current())) {
        var inTag = /^([\S]+) (.*)/.exec(state.inTag)
        state.inTag = null
        var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2])
        var mode = CodeMirror.getMode(config, modeSpec)
        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
        state.token = function (stream, state) {
          if (stream.match(endTagA, false)) {
            state.token = html;
            state.localState = state.localMode = null;
            return null;
          }
          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
        };
        state.localMode = mode;
        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, "", ""));
      } else if (state.inTag) {
        state.inTag += stream.current()
        if (stream.eol()) state.inTag += " "
      }
      return style;
    };

    return {
      startState: function () {
        var state = CodeMirror.startState(htmlMode);
        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};
      },

      copyState: function (state) {
        var local;
        if (state.localState) {
          local = CodeMirror.copyState(state.localMode, state.localState);
        }
        return {token: state.token, inTag: state.inTag,
                localMode: state.localMode, localState: local,
                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
      },

      token: function (stream, state) {
        return state.token(stream, state);
      },

      indent: function (state, textAfter, line) {
        if (!state.localMode || /^\s*<\//.test(textAfter))
          return htmlMode.indent(state.htmlState, textAfter, line);
        else if (state.localMode.indent)
          return state.localMode.indent(state.localState, textAfter, line);
        else
          return CodeMirror.Pass;
      },

      innerMode: function (state) {
        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
      }
    };
  }, "xml", "javascript", "css");

  CodeMirror.defineMIME("text/html", "htmlmixed");
});

    </script>
    <!-- end of code mirror -->
    <!-- file saver.js -->
    <script type="text/javascript">
      /*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var saveAs=saveAs||function(e){"use strict";if("undefined"==typeof navigator||!/MSIE [1-9]\./.test(navigator.userAgent)){var t=e.document,n=function(){return e.URL||e.webkitURL||e},o=t.createElementNS("http://www.w3.org/1999/xhtml","a"),r="download"in o,i=function(n){var o=t.createEvent("MouseEvents");o.initMouseEvent("click",!0,!1,e,0,0,0,0,0,!1,!1,!1,!1,0,null),n.dispatchEvent(o)},a=e.webkitRequestFileSystem,c=e.requestFileSystem||a||e.mozRequestFileSystem,u=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},f="application/octet-stream",s=0,d=500,l=function(t){var o=function(){"string"==typeof t?n().revokeObjectURL(t):t.remove()};e.chrome?o():setTimeout(o,d)},v=function(e,t,n){t=[].concat(t);for(var o=t.length;o--;){var r=e["on"+t[o]];if("function"==typeof r)try{r.call(e,n||e)}catch(i){u(i)}}},p=function(e){return/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)?new Blob(["\ufeff",e],{type:e.type}):e},w=function(t,u){t=p(t);var d,w,y,m=this,S=t.type,h=!1,O=function(){v(m,"writestart progress write writeend".split(" "))},E=function(){if((h||!d)&&(d=n().createObjectURL(t)),w)w.location.href=d;else{var o=e.open(d,"_blank");void 0==o&&"undefined"!=typeof safari&&(e.location.href=d)}m.readyState=m.DONE,O(),l(d)},R=function(e){return function(){return m.readyState!==m.DONE?e.apply(this,arguments):void 0}},b={create:!0,exclusive:!1};return m.readyState=m.INIT,u||(u="download"),r?(d=n().createObjectURL(t),o.href=d,o.download=u,i(o),m.readyState=m.DONE,O(),void l(d)):(e.chrome&&S&&S!==f&&(y=t.slice||t.webkitSlice,t=y.call(t,0,t.size,f),h=!0),a&&"download"!==u&&(u+=".download"),(S===f||a)&&(w=e),c?(s+=t.size,void c(e.TEMPORARY,s,R(function(e){e.root.getDirectory("saved",b,R(function(e){var n=function(){e.getFile(u,b,R(function(e){e.createWriter(R(function(n){n.onwriteend=function(t){w.location.href=e.toURL(),m.readyState=m.DONE,v(m,"writeend",t),l(e)},n.onerror=function(){var e=n.error;e.code!==e.ABORT_ERR&&E()},"writestart progress write abort".split(" ").forEach(function(e){n["on"+e]=m["on"+e]}),n.write(t),m.abort=function(){n.abort(),m.readyState=m.DONE},m.readyState=m.WRITING}),E)}),E)};e.getFile(u,{create:!1},R(function(e){e.remove(),n()}),R(function(e){e.code===e.NOT_FOUND_ERR?n():E()}))}),E)}),E)):void E())},y=w.prototype,m=function(e,t){return new w(e,t)};return"undefined"!=typeof navigator&&navigator.msSaveOrOpenBlob?function(e,t){return navigator.msSaveOrOpenBlob(p(e),t)}:(y.abort=function(){var e=this;e.readyState=e.DONE,v(e,"abort")},y.readyState=y.INIT=0,y.WRITING=1,y.DONE=2,y.error=y.onwritestart=y.onprogress=y.onwrite=y.onabort=y.onerror=y.onwriteend=null,m)}}("undefined"!=typeof self&&self||"undefined"!=typeof window&&window||this.content);"undefined"!=typeof module&&module.exports?module.exports.saveAs=saveAs:"undefined"!=typeof define&&null!==define&&null!=define.amd&&define([],function(){return saveAs});

    </script>
    <!-- end of file saver -->

    <!-- neptune -->
    <style>
      /* neptune.css */
      /*
 * General styling
 */
* {
  box-sizing: border-box;
}

body {
  padding: 50px;
}

/* Bar on top for downloading and stuff */
#neptune-bar {
  /* style */
  background: #ffffff;
  border-bottom: solid #000000 2px;
  /* layout */
  margin: -50px -50px 0 -50px;
  height: 40px;
  position: relative;
  text-align: center;
}

#neptune-bar span {
  /* layout */
  position: absolute;
  bottom: 0;
  right: 0;
  padding: 0 5px 5px 0;
  /* font */
  font-size: 8px;
}

#neptune-download {
  /* layout */
  display: block;
  width: 150px;
  height: 40px;
  padding: 10px;
  margin: auto;
  /* font */
  font-weight: bold;
  font-size: 20px;
  /* style */
  cursor: pointer;
}

#neptune-download:hover {
  background: #2B2B2B;
  color: #FFFFFF;
}

/*
 * Tabs layout
 * https://kyusuf.com/post/completely-css-tabs/
 */
.code-tabs {
  /* box-shadow: 0 48px 80px -32px rgba(0,0,0,0.3); */
  padding: 30px 10px 10px 10px;
  background: #e5e5e5;
  overflow: hidden;
  border: dashed 1px #333333;
  border-radius: 20px;
}
.tab-input {
  position: absolute;
  opacity: 0;
}
.tab-label {
  border-radius: 10px 10px 0 0;
  width: 100%;
  padding: 20px 30px;
  background: #e5e5e5;
  cursor: pointer;
  font-weight: bold;
  font-size: 18px;
  color: #7f7f7f;
  transition background 0.1s, color 0.1s;

}
.tab-label-selected {
  background: #2B2B2B;
  color: #FFFFFF;
}
.tab-label:hover {
  color: #4CAF50;
}
.code-tab {
  display: none;
  clear: both;
}
.tab-input:checked + .code-tab {
  display: block;
}

/*
 * Code editor
 * Use a "transparent" <textarea> super-imposed right on top of <code> in parent <pre>
 */
.CodeMirror {
  /* layout */
  overflow: hidden;
  height: auto;
  min-height: 40px;

  /* font */
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  font-size: 1em;
  line-height: 1.5;
}
.CodeMirror-scroll {
  height: auto;
  overflow-y: hidden;
  overflow-x: auto;
}

.CodeMirror-linenumbers {
  margin-right: 15px;
}

/*
 * bar with execute button 
 * Inspired by https://www.w3schools.com/howto/howto_css_icon_bar.asp
 */
.code-top-toolbar {
  float: right;
  position: relative;
  top: -10px;
  padding: 0;
}

.code-top-toolbar a {
  text-align: center;
  padding: 10px;
  transition: all 0.3s ease;
  color: #333333;
  font-size: 30px;
  z-index: 2;
}

.code-top-toolbar a:hover {
  background-color: #2B2B2B;
  color: #FFFFFF;
}

/*
 * output terminal like panel
 */
.output-panel {
  /* layout */
  display: none;
  margin: .5em 0;
  padding: 1em;
  /* colors */
  background-color: #2B2B2B;
  color: #ccc;
  /* font */
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  font-size: 1.2em;
  line-height: 1.5;
}

.output-line-span {
  color: #999;
}

/*
 * Custom output divs
 */
.custom-output-div {
}

    </style>

    <!-- injection -->
    <style>
      /* injected CSS */
      
    </style>
    
  </head>
  <body>
    <div id="neptune-bar">
      <a id="neptune-download">Save <i class="fa fa-download"></i></a>
      <span>Made by <a href="https://www.npmjs.com/package/neptune-notebook">Neptune Notebook</a></span>
    </div>
    <h1 id="innerproductandfixedpointnumbers">Inner Product and fixedpoint numbers</h1>
<p>In this tutorial, we will look at an example implementation of inner product that supports fixed-point numbers.
We optimize the implementation by lazyily reducing the precision only at the end. This tutorial implements
the 2-party version for simplicity, but the techniques exend to aribtrary many parties.</p>
<h4 id="tutorialcontent">Tutorial content:</h4>
<ol>
<li>Setting up the fixedpoint numbers extension.</li>
<li>Basic inner product implementation.</li>
<li>How the fixedpoint numbers extension work.</li>
<li>Efficient inner product implementation.</li>
</ol>
<h1 id="setupfixedpointnumbersextension">Setup: fixedpoint numbers extension</h1>
<p>Fixedpoint numbers are effectively transformed into integers in the desired field automatically by JIFF, by scaling them up
by the magnitude. These means that even small fixedpoint numbers can turn into large integers in the actual implementation.</p>
<p>Unfortunetly, Javascript is not very good with large numbers. The largest safe integer javascript can represent accurately is 53 bits long.
This means that operating (specifically multiplying) on numbers that are 27 bits or more can result in unsafe (intermediate) results.</p>
<pre><code class="neptune[title=Max&nbsp;Safe&nbsp;Number,scope=None,frame=frame1] language-neptune[title=Max&nbsp;Safe&nbsp;Number,scope=None,frame=frame1]">var safe = Number.MAX_SAFE_INTEGER;
Console.log(safe, safe.toString(2).length);
var sqrt = Math.floor(Math.sqrt(safe));
Console.log(sqrt, sqrt.toString(2).length);
Console.log('Choosing a prime larger than the above safe number requires use of bignumber extensions');
</code></pre>
<p>JIFF supports handling infinite precision number based on the <strong>bignumber.js</strong> library. The fixedpoint extension requires that this
bignumber extension is applied first. The bignumber extension should be applied at the server as well as clients.</p>
<p>When using the fixedpoint numbers extension, one can specify how many digits after and before the decimal point to support.
Note that these digits must fit within the given prime, otherwise JIFF will throw an error.
If multiplication (or other primitives using it) should be supported, then there should at least as many free digits in the field
as decimal digits. So that intermediate multiplication results fit in the field.</p>
<pre><code class="neptune[title=Server,frame=frame2,env=server] language-neptune[title=Server,frame=frame2,env=server]">var jiff = require('../../../../../lib/jiff-server.js');
var jiff_bignumber = require('../../../../../lib/ext/jiff-server-bignumber.js');

var jiff_instance = jiff.make_jiff(server, { logs:true });
jiff_instance.apply_extension(jiff_bignumber);

Console.log('Server is running on port 9111');
</code></pre>
<pre><code class="neptune[title=Party&nbsp;1,frame=frame2,scope=1] language-neptune[title=Party&nbsp;1,frame=frame2,scope=1]">function onConnect() {
  Console.log('All parties connected!');
}

var options = { party_count: 2, party_id: 1, crypto_provider: true, onConnect: onConnect, Zp: 15485867, autoConnect: false, integer_digits: 3, decimal_digits: 2 };
var jiff_instance = jiff.make_jiff('http://localhost:9111', 'product-application', options);
jiff_instance.apply_extension(jiff_bignumber, options);
jiff_instance.apply_extension(jiff_fixedpoint, options);
jiff_instance.connect();
</code></pre>
<pre><code class="neptune[title=Party&nbsp;2,frame=frame2,scope=2] language-neptune[title=Party&nbsp;2,frame=frame2,scope=2]">function onConnect() {
  Console.log('All parties connected!');
}

var options = { party_count: 2, party_id: 2, crypto_provider: true, onConnect: onConnect, Zp: 15485867, autoConnect: false, integer_digits: 3, decimal_digits: 2 };
var jiff_instance = jiff.make_jiff('http://localhost:9111', 'product-application', options);
jiff_instance.apply_extension(jiff_bignumber, options);
jiff_instance.apply_extension(jiff_fixedpoint, options);
jiff_instance.connect();
</code></pre>
<pre><code class="neptune[title=Party&nbsp;1&nbsp;Incorrect,frame=frame2,scope=None] language-neptune[title=Party&nbsp;1&nbsp;Incorrect,frame=frame2,scope=None]">function onConnect() {
  Console.log('All parties connected!');
}

var options = { party_count: 2, party_id: 1, crypto_provider: true, onConnect: onConnect, Zp: 15485867, autoConnect: false, integer_digits: 5, decimal_digits: 5 };
var jiff_instance = jiff.make_jiff('http://localhost:9111', 'product-application', options);
jiff_instance.apply_extension(jiff_bignumber, options);
jiff_instance.apply_extension(jiff_fixedpoint, options);
jiff_instance.connect();
</code></pre>
<h2 id="basicinnerproduct">Basic inner product</h2>
<p>Once the setup details are taken care of, we can define the interesting part of the computation.</p>
<pre><code class="neptune[title=Party&nbsp;1,frame=frame3,scope=1] language-neptune[title=Party&nbsp;1,frame=frame3,scope=1]">var input = [ 1.32, 10.22, 5.67]

function innerprod(input) {
  var promise = jiff_instance.share_array(input);
  return promise.then(function (arrays) {
    var array1 = arrays[1];
    var array2 = arrays[2];

    var result = array1[0].smult(array2[0]);
    for (var i = 1; i &lt; array1.length; i++) {
      result = result.sadd(array1[i].smult(array2[i]));
    }

    return jiff_instance.open(result);
  });
}

innerprod(input).then(function (result) {
  Console.log('Inner product', result);
  Console.log('Verify', 1.32*5.91 + 10.22*3.73 + 5.67*50.03);
});
</code></pre>
<pre><code class="neptune[title=Party&nbsp;2,frame=frame3,scope=2] language-neptune[title=Party&nbsp;2,frame=frame3,scope=2]">var input = [ 5.91, 3.73, 50.03]

function innerprod(input) {
  var promise = jiff_instance.share_array(input);
  return promise.then(function (arrays) {
    var array1 = arrays[1];
    var array2 = arrays[2];

    var result = array1[0].smult(array2[0]);
    for (var i = 1; i &lt; array1.length; i++) {
      result = result.sadd(array1[i].smult(array2[i]));
    }

    return jiff_instance.open(result);
  });
}

innerprod(input).then(function (result) {
  Console.log('Inner product', result);
});
</code></pre>
<h1 id="internalsoffixedpointnumbersextension">Internals of fixedpoint numbers extension</h1>
<p>The inner product above is very easy to implement, but it does take a long amount of time for how little it seems to be doing. Let us look at the implementation of fixedpoint extenion smult.</p>
<pre><code class="neptune[title=Fixedpoint&nbsp;Numbers&nbsp;Extenion,frame=frame4,scope=1] language-neptune[title=Fixedpoint&nbsp;Numbers&nbsp;Extenion,frame=frame4,scope=1]">var dummy = jiff_instance.secret_share(jiff_instance, true, undefined, 10, [1], 1, jiff_instance.Zp); // creating a dummy share for debugging
var code = dummy.smult.toString().split('\n');
var relavent = [code[0]].concat(code.slice(10, 15)).concat(code.slice(35)).join('\n');
Console.log(relavent);
</code></pre>
<p>The variable magnitude represents the magnitude of the decimal precision, since our example supports two decimal digits, magnitude is 100.</p>
<p>The reason for the slowdown is the final call to cdiv inside smult. While JIFF has a pretty efficient (original) cdiv protocol, it still is a lot more expensive than a plain multiplication.
This last call to cdiv is important in general, since the result of the multiplication may be used arbitrarily by user code, including using it for other multiplications. It is important
that all intermediate shares exposed to the user have consistent decimal point position, so that operations on these shares produce correct results. Hence, smult moves the decimal point
back to its original place after multiplication.</p>
<p>Note that cdiv is integer division by a public constant, so it is equivalent to dropping the least significant precision-many bits from the value.</p>
<h1 id="efficientinnerproduct">Efficient inner product</h1>
<p>Looking at our code carefully, we realize that our program has a nice property. The result of multiplication is never used in another multiplication.
Addition operations are only performed on results of multiplications.</p>
<p>This means that we can make do without having to shift the decimal point after every multiplication. Instead, we can delay the shift until all multiplications
are computed and then summed. We can acheive this by setting the <em>div</em> parameter to false.</p>
<p>Further examination of the code will show that such a shift (i.e. division by a public constant) is reversible, since we are revealing
its output, and it can be performed outside of MPC all together. This is true only because our final output is the inner product. In cases
where the inner product is a secret intermediate value needed for computing the actual output, we must perform the division under MPC.</p>
<pre><code class="neptune[title=Party&nbsp;1,frame=frame5,scope=1] language-neptune[title=Party&nbsp;1,frame=frame5,scope=1]">var input = [ 1.32, 10.22, 5.67]

function innerprod(input) {
  var promise = jiff_instance.share_array(input);
  return promise.then(function (arrays) {
    var array1 = arrays[1];
    var array2 = arrays[2];

    var result = array1[0].smult(array2[0], null, false);
    for (var i = 1; i &lt; array1.length; i++) {
      result = result.sadd(array1[i].smult(array2[i], null, false));
    }

    return jiff_instance.open(result);
  });
}

innerprod(input).then(function (result) {
  Console.log('Inner product', result.div(100)); // shift decimal point outside of MPC
  Console.log('Verify', 1.32*5.91 + 10.22*3.73 + 5.67*50.03);
});
</code></pre>
<pre><code class="neptune[title=Party&nbsp;2,frame=frame5,scope=2] language-neptune[title=Party&nbsp;2,frame=frame5,scope=2]">var input = [ 5.91, 3.73, 50.03]

function innerprod(input) {
  var promise = jiff_instance.share_array(input);
  return promise.then(function (arrays) {
    var array1 = arrays[1];
    var array2 = arrays[2];

    var result = array1[0].smult(array2[0], null, false);
    for (var i = 1; i &lt; array1.length; i++) {
      result = result.sadd(array1[i].smult(array2[i], null, false));
    }

    return jiff_instance.open(result);
  });
}

innerprod(input).then(function (result) {
  Console.log('Inner product', result.div(100)); // shift decimal point outside of MPC
});
</code></pre>

    <script type="text/javascript">
      // injected JS
      /* bignumber.js v5.0.0 https://github.com/MikeMcl/bignumber.js/LICENCE */
!function(e){"use strict";function n(e){function a(e,n){var t,r,i,o,u,s,l=this;if(!(l instanceof a))return new a(e,n);if(null!=n&&V(n,2,64,C,"base")){if(n=0|n,s=e+"",10==n)return l=new a(e instanceof a?e:s),I(l,B+l.e+1,P);if((o="number"==typeof e)&&0*e!=0||!new RegExp("^-?"+(t="["+v.slice(0,n)+"]+")+"(?:\\."+t+")?$",37>n?"i":"").test(s))return U(l,s,o,n);o?(l.s=0>1/e?(s=s.slice(1),-1):1,z&&s.replace(/^0\.0*|\./,"").length>15&&x(C,w,e),o=!1):l.s=45===s.charCodeAt(0)?(s=s.slice(1),-1):1,s=A(s,10,n,l.s)}else{if(e instanceof a)return l.s=e.s,l.e=e.e,l.c=(e=e.c)?e.slice():e,void(C=0);if((o="number"==typeof e)&&0*e==0){if(l.s=0>1/e?(e=-e,-1):1,e===~~e){for(r=0,i=e;i>=10;i/=10,r++);return l.e=r,l.c=[e],void(C=0)}s=e+""}else{if(!h.test(s=e+""))return U(l,s,o);l.s=45===s.charCodeAt(0)?(s=s.slice(1),-1):1}}for((r=s.indexOf("."))>-1&&(s=s.replace(".","")),(i=s.search(/e/i))>0?(0>r&&(r=i),r+=+s.slice(i+1),s=s.substring(0,i)):0>r&&(r=s.length),i=0;48===s.charCodeAt(i);i++);for(u=s.length;48===s.charCodeAt(--u););if(s=s.slice(i,u+1))if(u=s.length,o&&z&&u>15&&(e>y||e!==p(e))&&x(C,w,l.s*e),r=r-i-1,r>G)l.c=l.e=null;else if($>r)l.c=[l.e=0];else{if(l.e=r,l.c=[],i=(r+1)%b,0>r&&(i+=b),u>i){for(i&&l.c.push(+s.slice(0,i)),u-=b;u>i;)l.c.push(+s.slice(i,i+=b));s=s.slice(i),i=b-s.length}else i-=u;for(;i--;s+="0");l.c.push(+s)}else l.c=[l.e=0];C=0}function A(e,n,t,i){var o,u,l,f,h,g,p,d=e.indexOf("."),m=B,w=P;for(37>t&&(e=e.toLowerCase()),d>=0&&(l=W,W=0,e=e.replace(".",""),p=new a(t),h=p.pow(e.length-d),W=l,p.c=s(c(r(h.c),h.e),10,n),p.e=p.c.length),g=s(e,t,n),u=l=g.length;0==g[--l];g.pop());if(!g[0])return"0";if(0>d?--u:(h.c=g,h.e=u,h.s=i,h=L(h,p,m,w,n),g=h.c,f=h.r,u=h.e),o=u+m+1,d=g[o],l=n/2,f=f||0>o||null!=g[o+1],f=4>w?(null!=d||f)&&(0==w||w==(h.s<0?3:2)):d>l||d==l&&(4==w||f||6==w&&1&g[o-1]||w==(h.s<0?8:7)),1>o||!g[0])e=f?c("1",-m):"0";else{if(g.length=o,f)for(--n;++g[--o]>n;)g[o]=0,o||(++u,g=[1].concat(g));for(l=g.length;!g[--l];);for(d=0,e="";l>=d;e+=v.charAt(g[d++]));e=c(e,u)}return e}function E(e,n,t,i){var o,u,s,f,h;if(t=null!=t&&V(t,0,8,i,m)?0|t:P,!e.c)return e.toString();if(o=e.c[0],s=e.e,null==n)h=r(e.c),h=19==i||24==i&&q>=s?l(h,s):c(h,s);else if(e=I(new a(e),n,t),u=e.e,h=r(e.c),f=h.length,19==i||24==i&&(u>=n||q>=u)){for(;n>f;h+="0",f++);h=l(h,u)}else if(n-=s,h=c(h,u),u+1>f){if(--n>0)for(h+=".";n--;h+="0");}else if(n+=u-f,n>0)for(u+1==f&&(h+=".");n--;h+="0");return e.s<0&&o?"-"+h:h}function D(e,n){var t,r,i=0;for(u(e[0])&&(e=e[0]),t=new a(e[0]);++i<e.length;){if(r=new a(e[i]),!r.s){t=r;break}n.call(t,r)&&(t=r)}return t}function F(e,n,t,r,i){return(n>e||e>t||e!=f(e))&&x(r,(i||"decimal places")+(n>e||e>t?" out of range":" not an integer"),e),!0}function _(e,n,t){for(var r=1,i=n.length;!n[--i];n.pop());for(i=n[0];i>=10;i/=10,r++);return(t=r+t*b-1)>G?e.c=e.e=null:$>t?e.c=[e.e=0]:(e.e=t,e.c=n),e}function x(e,n,t){var r=new Error(["new BigNumber","cmp","config","div","divToInt","eq","gt","gte","lt","lte","minus","mod","plus","precision","random","round","shift","times","toDigits","toExponential","toFixed","toFormat","toFraction","pow","toPrecision","toString","BigNumber"][e]+"() "+n+": "+t);throw r.name="BigNumber Error",C=0,r}function I(e,n,t,r){var i,o,u,s,l,c,f,a=e.c,h=O;if(a){e:{for(i=1,s=a[0];s>=10;s/=10,i++);if(o=n-i,0>o)o+=b,u=n,l=a[c=0],f=l/h[i-u-1]%10|0;else if(c=g((o+1)/b),c>=a.length){if(!r)break e;for(;a.length<=c;a.push(0));l=f=0,i=1,o%=b,u=o-b+1}else{for(l=s=a[c],i=1;s>=10;s/=10,i++);o%=b,u=o-b+i,f=0>u?0:l/h[i-u-1]%10|0}if(r=r||0>n||null!=a[c+1]||(0>u?l:l%h[i-u-1]),r=4>t?(f||r)&&(0==t||t==(e.s<0?3:2)):f>5||5==f&&(4==t||r||6==t&&(o>0?u>0?l/h[i-u]:0:a[c-1])%10&1||t==(e.s<0?8:7)),1>n||!a[0])return a.length=0,r?(n-=e.e+1,a[0]=h[(b-n%b)%b],e.e=-n||0):a[0]=e.e=0,e;if(0==o?(a.length=c,s=1,c--):(a.length=c+1,s=h[b-o],a[c]=u>0?p(l/h[i-u]%h[u])*s:0),r)for(;;){if(0==c){for(o=1,u=a[0];u>=10;u/=10,o++);for(u=a[0]+=s,s=1;u>=10;u/=10,s++);o!=s&&(e.e++,a[0]==N&&(a[0]=1));break}if(a[c]+=s,a[c]!=N)break;a[c--]=0,s=1}for(o=a.length;0===a[--o];a.pop());}e.e>G?e.c=e.e=null:e.e<$&&(e.c=[e.e=0])}return e}var L,U,C=0,M=a.prototype,T=new a(1),B=20,P=4,q=-7,k=21,$=-1e7,G=1e7,z=!0,V=F,j=!1,H=1,W=0,J={decimalSeparator:".",groupSeparator:",",groupSize:3,secondaryGroupSize:0,fractionGroupSeparator:"",fractionGroupSize:0};return a.another=n,a.ROUND_UP=0,a.ROUND_DOWN=1,a.ROUND_CEIL=2,a.ROUND_FLOOR=3,a.ROUND_HALF_UP=4,a.ROUND_HALF_DOWN=5,a.ROUND_HALF_EVEN=6,a.ROUND_HALF_CEIL=7,a.ROUND_HALF_FLOOR=8,a.EUCLID=9,a.config=a.set=function(){var e,n,t=0,r={},i=arguments,s=i[0],l=s&&"object"==typeof s?function(){return s.hasOwnProperty(n)?null!=(e=s[n]):void 0}:function(){return i.length>t?null!=(e=i[t++]):void 0};return l(n="DECIMAL_PLACES")&&V(e,0,S,2,n)&&(B=0|e),r[n]=B,l(n="ROUNDING_MODE")&&V(e,0,8,2,n)&&(P=0|e),r[n]=P,l(n="EXPONENTIAL_AT")&&(u(e)?V(e[0],-S,0,2,n)&&V(e[1],0,S,2,n)&&(q=0|e[0],k=0|e[1]):V(e,-S,S,2,n)&&(q=-(k=0|(0>e?-e:e)))),r[n]=[q,k],l(n="RANGE")&&(u(e)?V(e[0],-S,-1,2,n)&&V(e[1],1,S,2,n)&&($=0|e[0],G=0|e[1]):V(e,-S,S,2,n)&&(0|e?$=-(G=0|(0>e?-e:e)):z&&x(2,n+" cannot be zero",e))),r[n]=[$,G],l(n="ERRORS")&&(e===!!e||1===e||0===e?(C=0,V=(z=!!e)?F:o):z&&x(2,n+d,e)),r[n]=z,l(n="CRYPTO")&&(e===!0||e===!1||1===e||0===e?e?(e="undefined"==typeof crypto,!e&&crypto&&(crypto.getRandomValues||crypto.randomBytes)?j=!0:z?x(2,"crypto unavailable",e?void 0:crypto):j=!1):j=!1:z&&x(2,n+d,e)),r[n]=j,l(n="MODULO_MODE")&&V(e,0,9,2,n)&&(H=0|e),r[n]=H,l(n="POW_PRECISION")&&V(e,0,S,2,n)&&(W=0|e),r[n]=W,l(n="FORMAT")&&("object"==typeof e?J=e:z&&x(2,n+" not an object",e)),r[n]=J,r},a.max=function(){return D(arguments,M.lt)},a.min=function(){return D(arguments,M.gt)},a.random=function(){var e=9007199254740992,n=Math.random()*e&2097151?function(){return p(Math.random()*e)}:function(){return 8388608*(1073741824*Math.random()|0)+(8388608*Math.random()|0)};return function(e){var t,r,i,o,u,s=0,l=[],c=new a(T);if(e=null!=e&&V(e,0,S,14)?0|e:B,o=g(e/b),j)if(crypto.getRandomValues){for(t=crypto.getRandomValues(new Uint32Array(o*=2));o>s;)u=131072*t[s]+(t[s+1]>>>11),u>=9e15?(r=crypto.getRandomValues(new Uint32Array(2)),t[s]=r[0],t[s+1]=r[1]):(l.push(u%1e14),s+=2);s=o/2}else if(crypto.randomBytes){for(t=crypto.randomBytes(o*=7);o>s;)u=281474976710656*(31&t[s])+1099511627776*t[s+1]+4294967296*t[s+2]+16777216*t[s+3]+(t[s+4]<<16)+(t[s+5]<<8)+t[s+6],u>=9e15?crypto.randomBytes(7).copy(t,s):(l.push(u%1e14),s+=7);s=o/7}else j=!1,z&&x(14,"crypto unavailable",crypto);if(!j)for(;o>s;)u=n(),9e15>u&&(l[s++]=u%1e14);for(o=l[--s],e%=b,o&&e&&(u=O[b-e],l[s]=p(o/u)*u);0===l[s];l.pop(),s--);if(0>s)l=[i=0];else{for(i=-1;0===l[0];l.splice(0,1),i-=b);for(s=1,u=l[0];u>=10;u/=10,s++);b>s&&(i-=b-s)}return c.e=i,c.c=l,c}}(),L=function(){function e(e,n,t){var r,i,o,u,s=0,l=e.length,c=n%R,f=n/R|0;for(e=e.slice();l--;)o=e[l]%R,u=e[l]/R|0,r=f*o+u*c,i=c*o+r%R*R+s,s=(i/t|0)+(r/R|0)+f*u,e[l]=i%t;return s&&(e=[s].concat(e)),e}function n(e,n,t,r){var i,o;if(t!=r)o=t>r?1:-1;else for(i=o=0;t>i;i++)if(e[i]!=n[i]){o=e[i]>n[i]?1:-1;break}return o}function r(e,n,t,r){for(var i=0;t--;)e[t]-=i,i=e[t]<n[t]?1:0,e[t]=i*r+e[t]-n[t];for(;!e[0]&&e.length>1;e.splice(0,1));}return function(i,o,u,s,l){var c,f,h,g,d,m,w,v,y,O,R,S,A,E,D,F,_,x=i.s==o.s?1:-1,L=i.c,U=o.c;if(!(L&&L[0]&&U&&U[0]))return new a(i.s&&o.s&&(L?!U||L[0]!=U[0]:U)?L&&0==L[0]||!U?0*x:x/0:NaN);for(v=new a(x),y=v.c=[],f=i.e-o.e,x=u+f+1,l||(l=N,f=t(i.e/b)-t(o.e/b),x=x/b|0),h=0;U[h]==(L[h]||0);h++);if(U[h]>(L[h]||0)&&f--,0>x)y.push(1),g=!0;else{for(E=L.length,F=U.length,h=0,x+=2,d=p(l/(U[0]+1)),d>1&&(U=e(U,d,l),L=e(L,d,l),F=U.length,E=L.length),A=F,O=L.slice(0,F),R=O.length;F>R;O[R++]=0);_=U.slice(),_=[0].concat(_),D=U[0],U[1]>=l/2&&D++;do{if(d=0,c=n(U,O,F,R),0>c){if(S=O[0],F!=R&&(S=S*l+(O[1]||0)),d=p(S/D),d>1)for(d>=l&&(d=l-1),m=e(U,d,l),w=m.length,R=O.length;1==n(m,O,w,R);)d--,r(m,w>F?_:U,w,l),w=m.length,c=1;else 0==d&&(c=d=1),m=U.slice(),w=m.length;if(R>w&&(m=[0].concat(m)),r(O,m,R,l),R=O.length,-1==c)for(;n(U,O,F,R)<1;)d++,r(O,R>F?_:U,R,l),R=O.length}else 0===c&&(d++,O=[0]);y[h++]=d,O[0]?O[R++]=L[A]||0:(O=[L[A]],R=1)}while((A++<E||null!=O[0])&&x--);g=null!=O[0],y[0]||y.splice(0,1)}if(l==N){for(h=1,x=y[0];x>=10;x/=10,h++);I(v,u+(v.e=h+f*b-1)+1,s,g)}else v.e=f,v.r=+g;return v}}(),U=function(){var e=/^(-?)0([xbo])(?=\w[\w.]*$)/i,n=/^([^.]+)\.$/,t=/^\.([^.]+)$/,r=/^-?(Infinity|NaN)$/,i=/^\s*\+(?=[\w.])|^\s+|\s+$/g;return function(o,u,s,l){var c,f=s?u:u.replace(i,"");if(r.test(f))o.s=isNaN(f)?null:0>f?-1:1;else{if(!s&&(f=f.replace(e,function(e,n,t){return c="x"==(t=t.toLowerCase())?16:"b"==t?2:8,l&&l!=c?e:n}),l&&(c=l,f=f.replace(n,"$1").replace(t,"0.$1")),u!=f))return new a(f,c);z&&x(C,"not a"+(l?" base "+l:"")+" number",u),o.s=null}o.c=o.e=null,C=0}}(),M.absoluteValue=M.abs=function(){var e=new a(this);return e.s<0&&(e.s=1),e},M.ceil=function(){return I(new a(this),this.e+1,2)},M.comparedTo=M.cmp=function(e,n){return C=1,i(this,new a(e,n))},M.decimalPlaces=M.dp=function(){var e,n,r=this.c;if(!r)return null;if(e=((n=r.length-1)-t(this.e/b))*b,n=r[n])for(;n%10==0;n/=10,e--);return 0>e&&(e=0),e},M.dividedBy=M.div=function(e,n){return C=3,L(this,new a(e,n),B,P)},M.dividedToIntegerBy=M.divToInt=function(e,n){return C=4,L(this,new a(e,n),0,1)},M.equals=M.eq=function(e,n){return C=5,0===i(this,new a(e,n))},M.floor=function(){return I(new a(this),this.e+1,3)},M.greaterThan=M.gt=function(e,n){return C=6,i(this,new a(e,n))>0},M.greaterThanOrEqualTo=M.gte=function(e,n){return C=7,1===(n=i(this,new a(e,n)))||0===n},M.isFinite=function(){return!!this.c},M.isInteger=M.isInt=function(){return!!this.c&&t(this.e/b)>this.c.length-2},M.isNaN=function(){return!this.s},M.isNegative=M.isNeg=function(){return this.s<0},M.isZero=function(){return!!this.c&&0==this.c[0]},M.lessThan=M.lt=function(e,n){return C=8,i(this,new a(e,n))<0},M.lessThanOrEqualTo=M.lte=function(e,n){return C=9,-1===(n=i(this,new a(e,n)))||0===n},M.minus=M.sub=function(e,n){var r,i,o,u,s=this,l=s.s;if(C=10,e=new a(e,n),n=e.s,!l||!n)return new a(NaN);if(l!=n)return e.s=-n,s.plus(e);var c=s.e/b,f=e.e/b,h=s.c,g=e.c;if(!c||!f){if(!h||!g)return h?(e.s=-n,e):new a(g?s:NaN);if(!h[0]||!g[0])return g[0]?(e.s=-n,e):new a(h[0]?s:3==P?-0:0)}if(c=t(c),f=t(f),h=h.slice(),l=c-f){for((u=0>l)?(l=-l,o=h):(f=c,o=g),o.reverse(),n=l;n--;o.push(0));o.reverse()}else for(i=(u=(l=h.length)<(n=g.length))?l:n,l=n=0;i>n;n++)if(h[n]!=g[n]){u=h[n]<g[n];break}if(u&&(o=h,h=g,g=o,e.s=-e.s),n=(i=g.length)-(r=h.length),n>0)for(;n--;h[r++]=0);for(n=N-1;i>l;){if(h[--i]<g[i]){for(r=i;r&&!h[--r];h[r]=n);--h[r],h[i]+=N}h[i]-=g[i]}for(;0==h[0];h.splice(0,1),--f);return h[0]?_(e,h,f):(e.s=3==P?-1:1,e.c=[e.e=0],e)},M.modulo=M.mod=function(e,n){var t,r,i=this;return C=11,e=new a(e,n),!i.c||!e.s||e.c&&!e.c[0]?new a(NaN):!e.c||i.c&&!i.c[0]?new a(i):(9==H?(r=e.s,e.s=1,t=L(i,e,0,3),e.s=r,t.s*=r):t=L(i,e,0,H),i.minus(t.times(e)))},M.negated=M.neg=function(){var e=new a(this);return e.s=-e.s||null,e},M.plus=M.add=function(e,n){var r,i=this,o=i.s;if(C=12,e=new a(e,n),n=e.s,!o||!n)return new a(NaN);if(o!=n)return e.s=-n,i.minus(e);var u=i.e/b,s=e.e/b,l=i.c,c=e.c;if(!u||!s){if(!l||!c)return new a(o/0);if(!l[0]||!c[0])return c[0]?e:new a(l[0]?i:0*o)}if(u=t(u),s=t(s),l=l.slice(),o=u-s){for(o>0?(s=u,r=c):(o=-o,r=l),r.reverse();o--;r.push(0));r.reverse()}for(o=l.length,n=c.length,0>o-n&&(r=c,c=l,l=r,n=o),o=0;n;)o=(l[--n]=l[n]+c[n]+o)/N|0,l[n]=N===l[n]?0:l[n]%N;return o&&(l=[o].concat(l),++s),_(e,l,s)},M.precision=M.sd=function(e){var n,t,r=this,i=r.c;if(null!=e&&e!==!!e&&1!==e&&0!==e&&(z&&x(13,"argument"+d,e),e!=!!e&&(e=null)),!i)return null;if(t=i.length-1,n=t*b+1,t=i[t]){for(;t%10==0;t/=10,n--);for(t=i[0];t>=10;t/=10,n++);}return e&&r.e+1>n&&(n=r.e+1),n},M.round=function(e,n){var t=new a(this);return(null==e||V(e,0,S,15))&&I(t,~~e+this.e+1,null!=n&&V(n,0,8,15,m)?0|n:P),t},M.shift=function(e){var n=this;return V(e,-y,y,16,"argument")?n.times("1e"+f(e)):new a(n.c&&n.c[0]&&(-y>e||e>y)?n.s*(0>e?0:1/0):n)},M.squareRoot=M.sqrt=function(){var e,n,i,o,u,s=this,l=s.c,c=s.s,f=s.e,h=B+4,g=new a("0.5");if(1!==c||!l||!l[0])return new a(!c||0>c&&(!l||l[0])?NaN:l?s:1/0);if(c=Math.sqrt(+s),0==c||c==1/0?(n=r(l),(n.length+f)%2==0&&(n+="0"),c=Math.sqrt(n),f=t((f+1)/2)-(0>f||f%2),c==1/0?n="1e"+f:(n=c.toExponential(),n=n.slice(0,n.indexOf("e")+1)+f),i=new a(n)):i=new a(c+""),i.c[0])for(f=i.e,c=f+h,3>c&&(c=0);;)if(u=i,i=g.times(u.plus(L(s,u,h,1))),r(u.c).slice(0,c)===(n=r(i.c)).slice(0,c)){if(i.e<f&&--c,n=n.slice(c-3,c+1),"9999"!=n&&(o||"4999"!=n)){(!+n||!+n.slice(1)&&"5"==n.charAt(0))&&(I(i,i.e+B+2,1),e=!i.times(i).eq(s));break}if(!o&&(I(u,u.e+B+2,0),u.times(u).eq(s))){i=u;break}h+=4,c+=4,o=1}return I(i,i.e+B+1,P,e)},M.times=M.mul=function(e,n){var r,i,o,u,s,l,c,f,h,g,p,d,m,w,v,y=this,O=y.c,S=(C=17,e=new a(e,n)).c;if(!(O&&S&&O[0]&&S[0]))return!y.s||!e.s||O&&!O[0]&&!S||S&&!S[0]&&!O?e.c=e.e=e.s=null:(e.s*=y.s,O&&S?(e.c=[0],e.e=0):e.c=e.e=null),e;for(i=t(y.e/b)+t(e.e/b),e.s*=y.s,c=O.length,g=S.length,g>c&&(m=O,O=S,S=m,o=c,c=g,g=o),o=c+g,m=[];o--;m.push(0));for(w=N,v=R,o=g;--o>=0;){for(r=0,p=S[o]%v,d=S[o]/v|0,s=c,u=o+s;u>o;)f=O[--s]%v,h=O[s]/v|0,l=d*f+h*p,f=p*f+l%v*v+m[u]+r,r=(f/w|0)+(l/v|0)+d*h,m[u--]=f%w;m[u]=r}return r?++i:m.splice(0,1),_(e,m,i)},M.toDigits=function(e,n){var t=new a(this);return e=null!=e&&V(e,1,S,18,"precision")?0|e:null,n=null!=n&&V(n,0,8,18,m)?0|n:P,e?I(t,e,n):t},M.toExponential=function(e,n){return E(this,null!=e&&V(e,0,S,19)?~~e+1:null,n,19)},M.toFixed=function(e,n){return E(this,null!=e&&V(e,0,S,20)?~~e+this.e+1:null,n,20)},M.toFormat=function(e,n){var t=E(this,null!=e&&V(e,0,S,21)?~~e+this.e+1:null,n,21);if(this.c){var r,i=t.split("."),o=+J.groupSize,u=+J.secondaryGroupSize,s=J.groupSeparator,l=i[0],c=i[1],f=this.s<0,a=f?l.slice(1):l,h=a.length;if(u&&(r=o,o=u,u=r,h-=r),o>0&&h>0){for(r=h%o||o,l=a.substr(0,r);h>r;r+=o)l+=s+a.substr(r,o);u>0&&(l+=s+a.slice(r)),f&&(l="-"+l)}t=c?l+J.decimalSeparator+((u=+J.fractionGroupSize)?c.replace(new RegExp("\\d{"+u+"}\\B","g"),"$&"+J.fractionGroupSeparator):c):l}return t},M.toFraction=function(e){var n,t,i,o,u,s,l,c,f,h=z,g=this,p=g.c,d=new a(T),m=t=new a(T),w=l=new a(T);if(null!=e&&(z=!1,s=new a(e),z=h,(!(h=s.isInt())||s.lt(T))&&(z&&x(22,"max denominator "+(h?"out of range":"not an integer"),e),e=!h&&s.c&&I(s,s.e+1,1).gte(T)?s:null)),!p)return g.toString();for(f=r(p),o=d.e=f.length-g.e-1,d.c[0]=O[(u=o%b)<0?b+u:u],e=!e||s.cmp(d)>0?o>0?d:m:s,u=G,G=1/0,s=new a(f),l.c[0]=0;c=L(s,d,0,1),i=t.plus(c.times(w)),1!=i.cmp(e);)t=w,w=i,m=l.plus(c.times(i=m)),l=i,d=s.minus(c.times(i=d)),s=i;return i=L(e.minus(t),w,0,1),l=l.plus(i.times(m)),t=t.plus(i.times(w)),l.s=m.s=g.s,o*=2,n=L(m,w,o,P).minus(g).abs().cmp(L(l,t,o,P).minus(g).abs())<1?[m.toString(),w.toString()]:[l.toString(),t.toString()],G=u,n},M.toNumber=function(){return+this},M.toPower=M.pow=function(e,n){var t,r,i,o=p(0>e?-e:+e),u=this;if(null!=n&&(C=23,n=new a(n)),!V(e,-y,y,23,"exponent")&&(!isFinite(e)||o>y&&(e/=0)||parseFloat(e)!=e&&!(e=NaN))||0==e)return t=Math.pow(+u,e),new a(n?t%n:t);for(n?e>1&&u.gt(T)&&u.isInt()&&n.gt(T)&&n.isInt()?u=u.mod(n):(i=n,n=null):W&&(t=g(W/b+2)),r=new a(T);;){if(o%2){if(r=r.times(u),!r.c)break;t?r.c.length>t&&(r.c.length=t):n&&(r=r.mod(n))}if(o=p(o/2),!o)break;u=u.times(u),t?u.c&&u.c.length>t&&(u.c.length=t):n&&(u=u.mod(n))}return n?r:(0>e&&(r=T.div(r)),i?r.mod(i):t?I(r,W,P):r)},M.toPrecision=function(e,n){return E(this,null!=e&&V(e,1,S,24,"precision")?0|e:null,n,24)},M.toString=function(e){var n,t=this,i=t.s,o=t.e;return null===o?i?(n="Infinity",0>i&&(n="-"+n)):n="NaN":(n=r(t.c),n=null!=e&&V(e,2,64,25,"base")?A(c(n,o),0|e,10,i):q>=o||o>=k?l(n,o):c(n,o),0>i&&t.c[0]&&(n="-"+n)),n},M.truncated=M.trunc=function(){return I(new a(this),this.e+1,1)},M.valueOf=M.toJSON=function(){var e,n=this,t=n.e;return null===t?n.toString():(e=r(n.c),e=q>=t||t>=k?l(e,t):c(e,t),n.s<0?"-"+e:e)},M.isBigNumber=!0,null!=e&&a.config(e),a}function t(e){var n=0|e;return e>0||e===n?n:n-1}function r(e){for(var n,t,r=1,i=e.length,o=e[0]+"";i>r;){for(n=e[r++]+"",t=b-n.length;t--;n="0"+n);o+=n}for(i=o.length;48===o.charCodeAt(--i););return o.slice(0,i+1||1)}function i(e,n){var t,r,i=e.c,o=n.c,u=e.s,s=n.s,l=e.e,c=n.e;if(!u||!s)return null;if(t=i&&!i[0],r=o&&!o[0],t||r)return t?r?0:-s:u;if(u!=s)return u;if(t=0>u,r=l==c,!i||!o)return r?0:!i^t?1:-1;if(!r)return l>c^t?1:-1;for(s=(l=i.length)<(c=o.length)?l:c,u=0;s>u;u++)if(i[u]!=o[u])return i[u]>o[u]^t?1:-1;return l==c?0:l>c^t?1:-1}function o(e,n,t){return(e=f(e))>=n&&t>=e}function u(e){return"[object Array]"==Object.prototype.toString.call(e)}function s(e,n,t){for(var r,i,o=[0],u=0,s=e.length;s>u;){for(i=o.length;i--;o[i]*=n);for(o[r=0]+=v.indexOf(e.charAt(u++));r<o.length;r++)o[r]>t-1&&(null==o[r+1]&&(o[r+1]=0),o[r+1]+=o[r]/t|0,o[r]%=t)}return o.reverse()}function l(e,n){return(e.length>1?e.charAt(0)+"."+e.slice(1):e)+(0>n?"e":"e+")+n}function c(e,n){var t,r;if(0>n){for(r="0.";++n;r+="0");e=r+e}else if(t=e.length,++n>t){for(r="0",n-=t;--n;r+="0");e+=r}else t>n&&(e=e.slice(0,n)+"."+e.slice(n));return e}function f(e){return e=parseFloat(e),0>e?g(e):p(e)}var a,h=/^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,g=Math.ceil,p=Math.floor,d=" not a boolean or binary digit",m="rounding mode",w="number type has more than 15 significant digits",v="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_",N=1e14,b=14,y=9007199254740991,O=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13],R=1e7,S=1e9;a=n(),a["default"]=a.BigNumber=a,"function"==typeof define&&define.amd?define(function(){return a}):"undefined"!=typeof module&&module.exports?module.exports=a:(e||(e="undefined"!=typeof self?self:Function("return this")()),e.BigNumber=a)}(this);
//# sourceMappingURL=bignumber.js.map
/*!
 * Socket.IO v2.2.0
 * (c) 2014-2018 Guillermo Rauch
 * Released under the MIT License.
 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.io=e():t.io=e()}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports}var n={};return e.m=t,e.c=n,e.p="",e(0)}([function(t,e,n){"use strict";function r(t,e){"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{};var n,r=i(t),s=r.source,u=r.id,h=r.path,f=p[u]&&h in p[u].nsps,l=e.forceNew||e["force new connection"]||!1===e.multiplex||f;return l?(c("ignoring socket cache for %s",s),n=a(s,e)):(p[u]||(c("new io instance for %s",s),p[u]=a(s,e)),n=p[u]),r.query&&!e.query&&(e.query=r.query),n.socket(r.path,e)}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=n(1),s=n(7),a=n(12),c=n(3)("socket.io-client");t.exports=e=r;var p=e.managers={};e.protocol=s.protocol,e.connect=r,e.Manager=n(12),e.Socket=n(36)},function(t,e,n){"use strict";function r(t,e){var n=t;e=e||"undefined"!=typeof location&&location,null==t&&(t=e.protocol+"//"+e.host),"string"==typeof t&&("/"===t.charAt(0)&&(t="/"===t.charAt(1)?e.protocol+t:e.host+t),/^(https?|wss?):\/\//.test(t)||(i("protocol-less url %s",t),t="undefined"!=typeof e?e.protocol+"//"+t:"https://"+t),i("parse %s",t),n=o(t)),n.port||(/^(http|ws)$/.test(n.protocol)?n.port="80":/^(http|ws)s$/.test(n.protocol)&&(n.port="443")),n.path=n.path||"/";var r=n.host.indexOf(":")!==-1,s=r?"["+n.host+"]":n.host;return n.id=n.protocol+"://"+s+":"+n.port,n.href=n.protocol+"://"+s+(e&&e.port===n.port?"":":"+n.port),n}var o=n(2),i=n(3)("socket.io-client:url");t.exports=r},function(t,e){var n=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,r=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];t.exports=function(t){var e=t,o=t.indexOf("["),i=t.indexOf("]");o!=-1&&i!=-1&&(t=t.substring(0,o)+t.substring(o,i).replace(/:/g,";")+t.substring(i,t.length));for(var s=n.exec(t||""),a={},c=14;c--;)a[r[c]]=s[c]||"";return o!=-1&&i!=-1&&(a.source=e,a.host=a.host.substring(1,a.host.length-1).replace(/;/g,":"),a.authority=a.authority.replace("[","").replace("]","").replace(/;/g,":"),a.ipv6uri=!0),a}},function(t,e,n){(function(r){function o(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))}function i(t){var n=this.useColors;if(t[0]=(n?"%c":"")+this.namespace+(n?" %c":" ")+t[0]+(n?"%c ":" ")+"+"+e.humanize(this.diff),n){var r="color: "+this.color;t.splice(1,0,r,"color: inherit");var o=0,i=0;t[0].replace(/%[a-zA-Z%]/g,function(t){"%%"!==t&&(o++,"%c"===t&&(i=o))}),t.splice(i,0,r)}}function s(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function a(t){try{null==t?e.storage.removeItem("debug"):e.storage.debug=t}catch(n){}}function c(){var t;try{t=e.storage.debug}catch(n){}return!t&&"undefined"!=typeof r&&"env"in r&&(t=r.env.DEBUG),t}function p(){try{return window.localStorage}catch(t){}}e=t.exports=n(5),e.log=s,e.formatArgs=i,e.save=a,e.load=c,e.useColors=o,e.storage="undefined"!=typeof chrome&&"undefined"!=typeof chrome.storage?chrome.storage.local:p(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],e.formatters.j=function(t){try{return JSON.stringify(t)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}},e.enable(c())}).call(e,n(4))},function(t,e){function n(){throw new Error("setTimeout has not been defined")}function r(){throw new Error("clearTimeout has not been defined")}function o(t){if(u===setTimeout)return setTimeout(t,0);if((u===n||!u)&&setTimeout)return u=setTimeout,setTimeout(t,0);try{return u(t,0)}catch(e){try{return u.call(null,t,0)}catch(e){return u.call(this,t,0)}}}function i(t){if(h===clearTimeout)return clearTimeout(t);if((h===r||!h)&&clearTimeout)return h=clearTimeout,clearTimeout(t);try{return h(t)}catch(e){try{return h.call(null,t)}catch(e){return h.call(this,t)}}}function s(){y&&l&&(y=!1,l.length?d=l.concat(d):m=-1,d.length&&a())}function a(){if(!y){var t=o(s);y=!0;for(var e=d.length;e;){for(l=d,d=[];++m<e;)l&&l[m].run();m=-1,e=d.length}l=null,y=!1,i(t)}}function c(t,e){this.fun=t,this.array=e}function p(){}var u,h,f=t.exports={};!function(){try{u="function"==typeof setTimeout?setTimeout:n}catch(t){u=n}try{h="function"==typeof clearTimeout?clearTimeout:r}catch(t){h=r}}();var l,d=[],y=!1,m=-1;f.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];d.push(new c(t,e)),1!==d.length||y||o(a)},c.prototype.run=function(){this.fun.apply(null,this.array)},f.title="browser",f.browser=!0,f.env={},f.argv=[],f.version="",f.versions={},f.on=p,f.addListener=p,f.once=p,f.off=p,f.removeListener=p,f.removeAllListeners=p,f.emit=p,f.prependListener=p,f.prependOnceListener=p,f.listeners=function(t){return[]},f.binding=function(t){throw new Error("process.binding is not supported")},f.cwd=function(){return"/"},f.chdir=function(t){throw new Error("process.chdir is not supported")},f.umask=function(){return 0}},function(t,e,n){function r(t){var n,r=0;for(n in t)r=(r<<5)-r+t.charCodeAt(n),r|=0;return e.colors[Math.abs(r)%e.colors.length]}function o(t){function n(){if(n.enabled){var t=n,r=+new Date,i=r-(o||r);t.diff=i,t.prev=o,t.curr=r,o=r;for(var s=new Array(arguments.length),a=0;a<s.length;a++)s[a]=arguments[a];s[0]=e.coerce(s[0]),"string"!=typeof s[0]&&s.unshift("%O");var c=0;s[0]=s[0].replace(/%([a-zA-Z%])/g,function(n,r){if("%%"===n)return n;c++;var o=e.formatters[r];if("function"==typeof o){var i=s[c];n=o.call(t,i),s.splice(c,1),c--}return n}),e.formatArgs.call(t,s);var p=n.log||e.log||console.log.bind(console);p.apply(t,s)}}var o;return n.namespace=t,n.enabled=e.enabled(t),n.useColors=e.useColors(),n.color=r(t),n.destroy=i,"function"==typeof e.init&&e.init(n),e.instances.push(n),n}function i(){var t=e.instances.indexOf(this);return t!==-1&&(e.instances.splice(t,1),!0)}function s(t){e.save(t),e.names=[],e.skips=[];var n,r=("string"==typeof t?t:"").split(/[\s,]+/),o=r.length;for(n=0;n<o;n++)r[n]&&(t=r[n].replace(/\*/g,".*?"),"-"===t[0]?e.skips.push(new RegExp("^"+t.substr(1)+"$")):e.names.push(new RegExp("^"+t+"$")));for(n=0;n<e.instances.length;n++){var i=e.instances[n];i.enabled=e.enabled(i.namespace)}}function a(){e.enable("")}function c(t){if("*"===t[t.length-1])return!0;var n,r;for(n=0,r=e.skips.length;n<r;n++)if(e.skips[n].test(t))return!1;for(n=0,r=e.names.length;n<r;n++)if(e.names[n].test(t))return!0;return!1}function p(t){return t instanceof Error?t.stack||t.message:t}e=t.exports=o.debug=o["default"]=o,e.coerce=p,e.disable=a,e.enable=s,e.enabled=c,e.humanize=n(6),e.instances=[],e.names=[],e.skips=[],e.formatters={}},function(t,e){function n(t){if(t=String(t),!(t.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t);if(e){var n=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return n*u;case"days":case"day":case"d":return n*p;case"hours":case"hour":case"hrs":case"hr":case"h":return n*c;case"minutes":case"minute":case"mins":case"min":case"m":return n*a;case"seconds":case"second":case"secs":case"sec":case"s":return n*s;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return n;default:return}}}}function r(t){return t>=p?Math.round(t/p)+"d":t>=c?Math.round(t/c)+"h":t>=a?Math.round(t/a)+"m":t>=s?Math.round(t/s)+"s":t+"ms"}function o(t){return i(t,p,"day")||i(t,c,"hour")||i(t,a,"minute")||i(t,s,"second")||t+" ms"}function i(t,e,n){if(!(t<e))return t<1.5*e?Math.floor(t/e)+" "+n:Math.ceil(t/e)+" "+n+"s"}var s=1e3,a=60*s,c=60*a,p=24*c,u=365.25*p;t.exports=function(t,e){e=e||{};var i=typeof t;if("string"===i&&t.length>0)return n(t);if("number"===i&&isNaN(t)===!1)return e["long"]?o(t):r(t);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(t))}},function(t,e,n){function r(){}function o(t){var n=""+t.type;if(e.BINARY_EVENT!==t.type&&e.BINARY_ACK!==t.type||(n+=t.attachments+"-"),t.nsp&&"/"!==t.nsp&&(n+=t.nsp+","),null!=t.id&&(n+=t.id),null!=t.data){var r=i(t.data);if(r===!1)return g;n+=r}return f("encoded %j as %s",t,n),n}function i(t){try{return JSON.stringify(t)}catch(e){return!1}}function s(t,e){function n(t){var n=d.deconstructPacket(t),r=o(n.packet),i=n.buffers;i.unshift(r),e(i)}d.removeBlobs(t,n)}function a(){this.reconstructor=null}function c(t){var n=0,r={type:Number(t.charAt(0))};if(null==e.types[r.type])return h("unknown packet type "+r.type);if(e.BINARY_EVENT===r.type||e.BINARY_ACK===r.type){for(var o="";"-"!==t.charAt(++n)&&(o+=t.charAt(n),n!=t.length););if(o!=Number(o)||"-"!==t.charAt(n))throw new Error("Illegal attachments");r.attachments=Number(o)}if("/"===t.charAt(n+1))for(r.nsp="";++n;){var i=t.charAt(n);if(","===i)break;if(r.nsp+=i,n===t.length)break}else r.nsp="/";var s=t.charAt(n+1);if(""!==s&&Number(s)==s){for(r.id="";++n;){var i=t.charAt(n);if(null==i||Number(i)!=i){--n;break}if(r.id+=t.charAt(n),n===t.length)break}r.id=Number(r.id)}if(t.charAt(++n)){var a=p(t.substr(n)),c=a!==!1&&(r.type===e.ERROR||y(a));if(!c)return h("invalid payload");r.data=a}return f("decoded %s as %j",t,r),r}function p(t){try{return JSON.parse(t)}catch(e){return!1}}function u(t){this.reconPack=t,this.buffers=[]}function h(t){return{type:e.ERROR,data:"parser error: "+t}}var f=n(3)("socket.io-parser"),l=n(8),d=n(9),y=n(10),m=n(11);e.protocol=4,e.types=["CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK"],e.CONNECT=0,e.DISCONNECT=1,e.EVENT=2,e.ACK=3,e.ERROR=4,e.BINARY_EVENT=5,e.BINARY_ACK=6,e.Encoder=r,e.Decoder=a;var g=e.ERROR+'"encode error"';r.prototype.encode=function(t,n){if(f("encoding packet %j",t),e.BINARY_EVENT===t.type||e.BINARY_ACK===t.type)s(t,n);else{var r=o(t);n([r])}},l(a.prototype),a.prototype.add=function(t){var n;if("string"==typeof t)n=c(t),e.BINARY_EVENT===n.type||e.BINARY_ACK===n.type?(this.reconstructor=new u(n),0===this.reconstructor.reconPack.attachments&&this.emit("decoded",n)):this.emit("decoded",n);else{if(!m(t)&&!t.base64)throw new Error("Unknown type: "+t);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");n=this.reconstructor.takeBinaryData(t),n&&(this.reconstructor=null,this.emit("decoded",n))}},a.prototype.destroy=function(){this.reconstructor&&this.reconstructor.finishedReconstruction()},u.prototype.takeBinaryData=function(t){if(this.buffers.push(t),this.buffers.length===this.reconPack.attachments){var e=d.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null},u.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]}},function(t,e,n){function r(t){if(t)return o(t)}function o(t){for(var e in r.prototype)t[e]=r.prototype[e];return t}t.exports=r,r.prototype.on=r.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},r.prototype.once=function(t,e){function n(){this.off(t,n),e.apply(this,arguments)}return n.fn=e,this.on(t,n),this},r.prototype.off=r.prototype.removeListener=r.prototype.removeAllListeners=r.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n=this._callbacks["$"+t];if(!n)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var r,o=0;o<n.length;o++)if(r=n[o],r===e||r.fn===e){n.splice(o,1);break}return this},r.prototype.emit=function(t){this._callbacks=this._callbacks||{};var e=[].slice.call(arguments,1),n=this._callbacks["$"+t];if(n){n=n.slice(0);for(var r=0,o=n.length;r<o;++r)n[r].apply(this,e)}return this},r.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},r.prototype.hasListeners=function(t){return!!this.listeners(t).length}},function(t,e,n){function r(t,e){if(!t)return t;if(s(t)){var n={_placeholder:!0,num:e.length};return e.push(t),n}if(i(t)){for(var o=new Array(t.length),a=0;a<t.length;a++)o[a]=r(t[a],e);return o}if("object"==typeof t&&!(t instanceof Date)){var o={};for(var c in t)o[c]=r(t[c],e);return o}return t}function o(t,e){if(!t)return t;if(t&&t._placeholder)return e[t.num];if(i(t))for(var n=0;n<t.length;n++)t[n]=o(t[n],e);else if("object"==typeof t)for(var r in t)t[r]=o(t[r],e);return t}var i=n(10),s=n(11),a=Object.prototype.toString,c="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===a.call(Blob),p="function"==typeof File||"undefined"!=typeof File&&"[object FileConstructor]"===a.call(File);e.deconstructPacket=function(t){var e=[],n=t.data,o=t;return o.data=r(n,e),o.attachments=e.length,{packet:o,buffers:e}},e.reconstructPacket=function(t,e){return t.data=o(t.data,e),t.attachments=void 0,t},e.removeBlobs=function(t,e){function n(t,a,u){if(!t)return t;if(c&&t instanceof Blob||p&&t instanceof File){r++;var h=new FileReader;h.onload=function(){u?u[a]=this.result:o=this.result,--r||e(o)},h.readAsArrayBuffer(t)}else if(i(t))for(var f=0;f<t.length;f++)n(t[f],f,t);else if("object"==typeof t&&!s(t))for(var l in t)n(t[l],l,t)}var r=0,o=t;n(o),r||e(o)}},function(t,e){var n={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==n.call(t)}},function(t,e){function n(t){return r&&Buffer.isBuffer(t)||o&&(t instanceof ArrayBuffer||i(t))}t.exports=n;var r="function"==typeof Buffer&&"function"==typeof Buffer.isBuffer,o="function"==typeof ArrayBuffer,i=function(t){return"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(t):t.buffer instanceof ArrayBuffer}},function(t,e,n){"use strict";function r(t,e){if(!(this instanceof r))return new r(t,e);t&&"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{},e.path=e.path||"/socket.io",this.nsps={},this.subs=[],this.opts=e,this.reconnection(e.reconnection!==!1),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new l({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==e.timeout?2e4:e.timeout),this.readyState="closed",this.uri=t,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[];var n=e.parser||c;this.encoder=new n.Encoder,this.decoder=new n.Decoder,this.autoConnect=e.autoConnect!==!1,this.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=n(13),s=n(36),a=n(8),c=n(7),p=n(38),u=n(39),h=n(3)("socket.io-client:manager"),f=n(35),l=n(40),d=Object.prototype.hasOwnProperty;t.exports=r,r.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var t in this.nsps)d.call(this.nsps,t)&&this.nsps[t].emit.apply(this.nsps[t],arguments)},r.prototype.updateSocketIds=function(){for(var t in this.nsps)d.call(this.nsps,t)&&(this.nsps[t].id=this.generateId(t))},r.prototype.generateId=function(t){return("/"===t?"":t+"#")+this.engine.id},a(r.prototype),r.prototype.reconnection=function(t){return arguments.length?(this._reconnection=!!t,this):this._reconnection},r.prototype.reconnectionAttempts=function(t){return arguments.length?(this._reconnectionAttempts=t,this):this._reconnectionAttempts},r.prototype.reconnectionDelay=function(t){return arguments.length?(this._reconnectionDelay=t,this.backoff&&this.backoff.setMin(t),this):this._reconnectionDelay},r.prototype.randomizationFactor=function(t){return arguments.length?(this._randomizationFactor=t,this.backoff&&this.backoff.setJitter(t),this):this._randomizationFactor},r.prototype.reconnectionDelayMax=function(t){return arguments.length?(this._reconnectionDelayMax=t,this.backoff&&this.backoff.setMax(t),this):this._reconnectionDelayMax},r.prototype.timeout=function(t){return arguments.length?(this._timeout=t,this):this._timeout},r.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()},r.prototype.open=r.prototype.connect=function(t,e){if(h("readyState %s",this.readyState),~this.readyState.indexOf("open"))return this;h("opening %s",this.uri),this.engine=i(this.uri,this.opts);var n=this.engine,r=this;this.readyState="opening",this.skipReconnect=!1;var o=p(n,"open",function(){r.onopen(),t&&t()}),s=p(n,"error",function(e){if(h("connect_error"),r.cleanup(),r.readyState="closed",r.emitAll("connect_error",e),t){var n=new Error("Connection error");n.data=e,t(n)}else r.maybeReconnectOnOpen()});if(!1!==this._timeout){var a=this._timeout;h("connect attempt will timeout after %d",a);var c=setTimeout(function(){h("connect attempt timed out after %d",a),o.destroy(),n.close(),n.emit("error","timeout"),r.emitAll("connect_timeout",a)},a);this.subs.push({destroy:function(){clearTimeout(c)}})}return this.subs.push(o),this.subs.push(s),this},r.prototype.onopen=function(){h("open"),this.cleanup(),this.readyState="open",this.emit("open");var t=this.engine;this.subs.push(p(t,"data",u(this,"ondata"))),this.subs.push(p(t,"ping",u(this,"onping"))),this.subs.push(p(t,"pong",u(this,"onpong"))),this.subs.push(p(t,"error",u(this,"onerror"))),this.subs.push(p(t,"close",u(this,"onclose"))),this.subs.push(p(this.decoder,"decoded",u(this,"ondecoded")))},r.prototype.onping=function(){this.lastPing=new Date,this.emitAll("ping")},r.prototype.onpong=function(){this.emitAll("pong",new Date-this.lastPing)},r.prototype.ondata=function(t){this.decoder.add(t)},r.prototype.ondecoded=function(t){this.emit("packet",t)},r.prototype.onerror=function(t){h("error",t),this.emitAll("error",t)},r.prototype.socket=function(t,e){function n(){~f(o.connecting,r)||o.connecting.push(r)}var r=this.nsps[t];if(!r){r=new s(this,t,e),this.nsps[t]=r;var o=this;r.on("connecting",n),r.on("connect",function(){r.id=o.generateId(t)}),this.autoConnect&&n()}return r},r.prototype.destroy=function(t){var e=f(this.connecting,t);~e&&this.connecting.splice(e,1),this.connecting.length||this.close()},r.prototype.packet=function(t){h("writing packet %j",t);var e=this;t.query&&0===t.type&&(t.nsp+="?"+t.query),e.encoding?e.packetBuffer.push(t):(e.encoding=!0,this.encoder.encode(t,function(n){for(var r=0;r<n.length;r++)e.engine.write(n[r],t.options);e.encoding=!1,e.processPacketQueue()}))},r.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var t=this.packetBuffer.shift();this.packet(t)}},r.prototype.cleanup=function(){h("cleanup");for(var t=this.subs.length,e=0;e<t;e++){var n=this.subs.shift();n.destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()},r.prototype.close=r.prototype.disconnect=function(){h("disconnect"),this.skipReconnect=!0,this.reconnecting=!1,"opening"===this.readyState&&this.cleanup(),this.backoff.reset(),this.readyState="closed",this.engine&&this.engine.close()},r.prototype.onclose=function(t){h("onclose"),this.cleanup(),this.backoff.reset(),this.readyState="closed",this.emit("close",t),this._reconnection&&!this.skipReconnect&&this.reconnect()},r.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var t=this;if(this.backoff.attempts>=this._reconnectionAttempts)h("reconnect failed"),this.backoff.reset(),this.emitAll("reconnect_failed"),this.reconnecting=!1;else{var e=this.backoff.duration();h("will wait %dms before reconnect attempt",e),this.reconnecting=!0;var n=setTimeout(function(){t.skipReconnect||(h("attempting reconnect"),t.emitAll("reconnect_attempt",t.backoff.attempts),t.emitAll("reconnecting",t.backoff.attempts),t.skipReconnect||t.open(function(e){e?(h("reconnect attempt error"),t.reconnecting=!1,t.reconnect(),t.emitAll("reconnect_error",e.data)):(h("reconnect success"),t.onreconnect())}))},e);this.subs.push({destroy:function(){clearTimeout(n)}})}},r.prototype.onreconnect=function(){var t=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll("reconnect",t)}},function(t,e,n){t.exports=n(14),t.exports.parser=n(21)},function(t,e,n){function r(t,e){return this instanceof r?(e=e||{},t&&"object"==typeof t&&(e=t,t=null),t?(t=u(t),e.hostname=t.host,e.secure="https"===t.protocol||"wss"===t.protocol,e.port=t.port,t.query&&(e.query=t.query)):e.host&&(e.hostname=u(e.host).host),this.secure=null!=e.secure?e.secure:"undefined"!=typeof location&&"https:"===location.protocol,e.hostname&&!e.port&&(e.port=this.secure?"443":"80"),this.agent=e.agent||!1,this.hostname=e.hostname||("undefined"!=typeof location?location.hostname:"localhost"),this.port=e.port||("undefined"!=typeof location&&location.port?location.port:this.secure?443:80),this.query=e.query||{},"string"==typeof this.query&&(this.query=h.decode(this.query)),this.upgrade=!1!==e.upgrade,this.path=(e.path||"/engine.io").replace(/\/$/,"")+"/",this.forceJSONP=!!e.forceJSONP,this.jsonp=!1!==e.jsonp,this.forceBase64=!!e.forceBase64,this.enablesXDR=!!e.enablesXDR,this.timestampParam=e.timestampParam||"t",this.timestampRequests=e.timestampRequests,this.transports=e.transports||["polling","websocket"],this.transportOptions=e.transportOptions||{},this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=e.policyPort||843,this.rememberUpgrade=e.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=e.onlyBinaryUpgrades,this.perMessageDeflate=!1!==e.perMessageDeflate&&(e.perMessageDeflate||{}),!0===this.perMessageDeflate&&(this.perMessageDeflate={}),this.perMessageDeflate&&null==this.perMessageDeflate.threshold&&(this.perMessageDeflate.threshold=1024),this.pfx=e.pfx||null,this.key=e.key||null,this.passphrase=e.passphrase||null,this.cert=e.cert||null,this.ca=e.ca||null,this.ciphers=e.ciphers||null,this.rejectUnauthorized=void 0===e.rejectUnauthorized||e.rejectUnauthorized,this.forceNode=!!e.forceNode,this.isReactNative="undefined"!=typeof navigator&&"string"==typeof navigator.product&&"reactnative"===navigator.product.toLowerCase(),("undefined"==typeof self||this.isReactNative)&&(e.extraHeaders&&Object.keys(e.extraHeaders).length>0&&(this.extraHeaders=e.extraHeaders),e.localAddress&&(this.localAddress=e.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,void this.open()):new r(t,e)}function o(t){var e={};for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);return e}var i=n(15),s=n(8),a=n(3)("engine.io-client:socket"),c=n(35),p=n(21),u=n(2),h=n(29);t.exports=r,r.priorWebsocketSuccess=!1,s(r.prototype),r.protocol=p.protocol,r.Socket=r,r.Transport=n(20),r.transports=n(15),r.parser=n(21),r.prototype.createTransport=function(t){a('creating transport "%s"',t);var e=o(this.query);e.EIO=p.protocol,e.transport=t;var n=this.transportOptions[t]||{};this.id&&(e.sid=this.id);var r=new i[t]({query:e,socket:this,agent:n.agent||this.agent,hostname:n.hostname||this.hostname,port:n.port||this.port,secure:n.secure||this.secure,path:n.path||this.path,forceJSONP:n.forceJSONP||this.forceJSONP,jsonp:n.jsonp||this.jsonp,forceBase64:n.forceBase64||this.forceBase64,enablesXDR:n.enablesXDR||this.enablesXDR,timestampRequests:n.timestampRequests||this.timestampRequests,timestampParam:n.timestampParam||this.timestampParam,policyPort:n.policyPort||this.policyPort,pfx:n.pfx||this.pfx,key:n.key||this.key,passphrase:n.passphrase||this.passphrase,cert:n.cert||this.cert,ca:n.ca||this.ca,ciphers:n.ciphers||this.ciphers,rejectUnauthorized:n.rejectUnauthorized||this.rejectUnauthorized,perMessageDeflate:n.perMessageDeflate||this.perMessageDeflate,extraHeaders:n.extraHeaders||this.extraHeaders,forceNode:n.forceNode||this.forceNode,localAddress:n.localAddress||this.localAddress,requestTimeout:n.requestTimeout||this.requestTimeout,protocols:n.protocols||void 0,isReactNative:this.isReactNative});return r},r.prototype.open=function(){var t;if(this.rememberUpgrade&&r.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1)t="websocket";else{if(0===this.transports.length){var e=this;return void setTimeout(function(){e.emit("error","No transports available")},0)}t=this.transports[0]}this.readyState="opening";try{t=this.createTransport(t)}catch(n){return this.transports.shift(),void this.open()}t.open(),this.setTransport(t)},r.prototype.setTransport=function(t){a("setting transport %s",t.name);var e=this;this.transport&&(a("clearing existing transport %s",this.transport.name),this.transport.removeAllListeners()),this.transport=t,t.on("drain",function(){e.onDrain()}).on("packet",function(t){e.onPacket(t)}).on("error",function(t){e.onError(t)}).on("close",function(){e.onClose("transport close")})},r.prototype.probe=function(t){function e(){if(f.onlyBinaryUpgrades){var e=!this.supportsBinary&&f.transport.supportsBinary;h=h||e}h||(a('probe transport "%s" opened',t),u.send([{type:"ping",data:"probe"}]),u.once("packet",function(e){if(!h)if("pong"===e.type&&"probe"===e.data){if(a('probe transport "%s" pong',t),f.upgrading=!0,f.emit("upgrading",u),!u)return;r.priorWebsocketSuccess="websocket"===u.name,a('pausing current transport "%s"',f.transport.name),f.transport.pause(function(){h||"closed"!==f.readyState&&(a("changing transport and sending upgrade packet"),p(),f.setTransport(u),u.send([{type:"upgrade"}]),f.emit("upgrade",u),u=null,f.upgrading=!1,f.flush())})}else{a('probe transport "%s" failed',t);var n=new Error("probe error");n.transport=u.name,f.emit("upgradeError",n)}}))}function n(){h||(h=!0,p(),u.close(),u=null)}function o(e){var r=new Error("probe error: "+e);r.transport=u.name,n(),a('probe transport "%s" failed because of error: %s',t,e),f.emit("upgradeError",r)}function i(){o("transport closed")}function s(){o("socket closed")}function c(t){u&&t.name!==u.name&&(a('"%s" works - aborting "%s"',t.name,u.name),n())}function p(){u.removeListener("open",e),u.removeListener("error",o),u.removeListener("close",i),f.removeListener("close",s),f.removeListener("upgrading",c)}a('probing transport "%s"',t);var u=this.createTransport(t,{probe:1}),h=!1,f=this;r.priorWebsocketSuccess=!1,u.once("open",e),u.once("error",o),u.once("close",i),this.once("close",s),this.once("upgrading",c),u.open()},r.prototype.onOpen=function(){if(a("socket open"),this.readyState="open",r.priorWebsocketSuccess="websocket"===this.transport.name,this.emit("open"),this.flush(),"open"===this.readyState&&this.upgrade&&this.transport.pause){a("starting upgrade probes");for(var t=0,e=this.upgrades.length;t<e;t++)this.probe(this.upgrades[t])}},r.prototype.onPacket=function(t){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(a('socket receive: type "%s", data "%s"',t.type,t.data),this.emit("packet",t),this.emit("heartbeat"),t.type){case"open":this.onHandshake(JSON.parse(t.data));break;case"pong":this.setPing(),this.emit("pong");break;case"error":var e=new Error("server error");e.code=t.data,this.onError(e);break;case"message":this.emit("data",t.data),this.emit("message",t.data)}else a('packet received with socket readyState "%s"',this.readyState)},r.prototype.onHandshake=function(t){this.emit("handshake",t),this.id=t.sid,this.transport.query.sid=t.sid,this.upgrades=this.filterUpgrades(t.upgrades),this.pingInterval=t.pingInterval,this.pingTimeout=t.pingTimeout,this.onOpen(),"closed"!==this.readyState&&(this.setPing(),this.removeListener("heartbeat",this.onHeartbeat),this.on("heartbeat",this.onHeartbeat))},r.prototype.onHeartbeat=function(t){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout(function(){"closed"!==e.readyState&&e.onClose("ping timeout")},t||e.pingInterval+e.pingTimeout)},r.prototype.setPing=function(){var t=this;clearTimeout(t.pingIntervalTimer),t.pingIntervalTimer=setTimeout(function(){a("writing ping packet - expecting pong within %sms",t.pingTimeout),t.ping(),t.onHeartbeat(t.pingTimeout)},t.pingInterval)},r.prototype.ping=function(){var t=this;this.sendPacket("ping",function(){t.emit("ping")})},r.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emit("drain"):this.flush()},r.prototype.flush=function(){"closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(a("flushing %d packets in socket",this.writeBuffer.length),this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit("flush"))},r.prototype.write=r.prototype.send=function(t,e,n){return this.sendPacket("message",t,e,n),this},r.prototype.sendPacket=function(t,e,n,r){if("function"==typeof e&&(r=e,e=void 0),"function"==typeof n&&(r=n,n=null),"closing"!==this.readyState&&"closed"!==this.readyState){n=n||{},n.compress=!1!==n.compress;var o={type:t,data:e,options:n};this.emit("packetCreate",o),this.writeBuffer.push(o),r&&this.once("flush",r),this.flush()}},r.prototype.close=function(){function t(){r.onClose("forced close"),a("socket closing - telling transport to close"),r.transport.close()}function e(){r.removeListener("upgrade",e),r.removeListener("upgradeError",e),t()}function n(){r.once("upgrade",e),r.once("upgradeError",e)}if("opening"===this.readyState||"open"===this.readyState){this.readyState="closing";var r=this;this.writeBuffer.length?this.once("drain",function(){this.upgrading?n():t()}):this.upgrading?n():t()}return this},r.prototype.onError=function(t){a("socket error %j",t),r.priorWebsocketSuccess=!1,this.emit("error",t),this.onClose("transport error",t)},r.prototype.onClose=function(t,e){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState){a('socket close with reason: "%s"',t);var n=this;clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),this.readyState="closed",this.id=null,this.emit("close",t,e),n.writeBuffer=[],n.prevBufferLen=0}},r.prototype.filterUpgrades=function(t){for(var e=[],n=0,r=t.length;n<r;n++)~c(this.transports,t[n])&&e.push(t[n]);return e}},function(t,e,n){function r(t){var e,n=!1,r=!1,a=!1!==t.jsonp;
if("undefined"!=typeof location){var c="https:"===location.protocol,p=location.port;p||(p=c?443:80),n=t.hostname!==location.hostname||p!==t.port,r=t.secure!==c}if(t.xdomain=n,t.xscheme=r,e=new o(t),"open"in e&&!t.forceJSONP)return new i(t);if(!a)throw new Error("JSONP disabled");return new s(t)}var o=n(16),i=n(18),s=n(32),a=n(33);e.polling=r,e.websocket=a},function(t,e,n){var r=n(17);t.exports=function(t){var e=t.xdomain,n=t.xscheme,o=t.enablesXDR;try{if("undefined"!=typeof XMLHttpRequest&&(!e||r))return new XMLHttpRequest}catch(i){}try{if("undefined"!=typeof XDomainRequest&&!n&&o)return new XDomainRequest}catch(i){}if(!e)try{return new(self[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(i){}}},function(t,e){try{t.exports="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(n){t.exports=!1}},function(t,e,n){function r(){}function o(t){if(c.call(this,t),this.requestTimeout=t.requestTimeout,this.extraHeaders=t.extraHeaders,"undefined"!=typeof location){var e="https:"===location.protocol,n=location.port;n||(n=e?443:80),this.xd="undefined"!=typeof location&&t.hostname!==location.hostname||n!==t.port,this.xs=t.secure!==e}}function i(t){this.method=t.method||"GET",this.uri=t.uri,this.xd=!!t.xd,this.xs=!!t.xs,this.async=!1!==t.async,this.data=void 0!==t.data?t.data:null,this.agent=t.agent,this.isBinary=t.isBinary,this.supportsBinary=t.supportsBinary,this.enablesXDR=t.enablesXDR,this.requestTimeout=t.requestTimeout,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.extraHeaders=t.extraHeaders,this.create()}function s(){for(var t in i.requests)i.requests.hasOwnProperty(t)&&i.requests[t].abort()}var a=n(16),c=n(19),p=n(8),u=n(30),h=n(3)("engine.io-client:polling-xhr");if(t.exports=o,t.exports.Request=i,u(o,c),o.prototype.supportsBinary=!0,o.prototype.request=function(t){return t=t||{},t.uri=this.uri(),t.xd=this.xd,t.xs=this.xs,t.agent=this.agent||!1,t.supportsBinary=this.supportsBinary,t.enablesXDR=this.enablesXDR,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized,t.requestTimeout=this.requestTimeout,t.extraHeaders=this.extraHeaders,new i(t)},o.prototype.doWrite=function(t,e){var n="string"!=typeof t&&void 0!==t,r=this.request({method:"POST",data:t,isBinary:n}),o=this;r.on("success",e),r.on("error",function(t){o.onError("xhr post error",t)}),this.sendXhr=r},o.prototype.doPoll=function(){h("xhr poll");var t=this.request(),e=this;t.on("data",function(t){e.onData(t)}),t.on("error",function(t){e.onError("xhr poll error",t)}),this.pollXhr=t},p(i.prototype),i.prototype.create=function(){var t={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized;var e=this.xhr=new a(t),n=this;try{h("xhr open %s: %s",this.method,this.uri),e.open(this.method,this.uri,this.async);try{if(this.extraHeaders){e.setDisableHeaderCheck&&e.setDisableHeaderCheck(!0);for(var r in this.extraHeaders)this.extraHeaders.hasOwnProperty(r)&&e.setRequestHeader(r,this.extraHeaders[r])}}catch(o){}if("POST"===this.method)try{this.isBinary?e.setRequestHeader("Content-type","application/octet-stream"):e.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(o){}try{e.setRequestHeader("Accept","*/*")}catch(o){}"withCredentials"in e&&(e.withCredentials=!0),this.requestTimeout&&(e.timeout=this.requestTimeout),this.hasXDR()?(e.onload=function(){n.onLoad()},e.onerror=function(){n.onError(e.responseText)}):e.onreadystatechange=function(){if(2===e.readyState)try{var t=e.getResponseHeader("Content-Type");n.supportsBinary&&"application/octet-stream"===t&&(e.responseType="arraybuffer")}catch(r){}4===e.readyState&&(200===e.status||1223===e.status?n.onLoad():setTimeout(function(){n.onError(e.status)},0))},h("xhr data %s",this.data),e.send(this.data)}catch(o){return void setTimeout(function(){n.onError(o)},0)}"undefined"!=typeof document&&(this.index=i.requestsCount++,i.requests[this.index]=this)},i.prototype.onSuccess=function(){this.emit("success"),this.cleanup()},i.prototype.onData=function(t){this.emit("data",t),this.onSuccess()},i.prototype.onError=function(t){this.emit("error",t),this.cleanup(!0)},i.prototype.cleanup=function(t){if("undefined"!=typeof this.xhr&&null!==this.xhr){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=r:this.xhr.onreadystatechange=r,t)try{this.xhr.abort()}catch(e){}"undefined"!=typeof document&&delete i.requests[this.index],this.xhr=null}},i.prototype.onLoad=function(){var t;try{var e;try{e=this.xhr.getResponseHeader("Content-Type")}catch(n){}t="application/octet-stream"===e?this.xhr.response||this.xhr.responseText:this.xhr.responseText}catch(n){this.onError(n)}null!=t&&this.onData(t)},i.prototype.hasXDR=function(){return"undefined"!=typeof XDomainRequest&&!this.xs&&this.enablesXDR},i.prototype.abort=function(){this.cleanup()},i.requestsCount=0,i.requests={},"undefined"!=typeof document)if("function"==typeof attachEvent)attachEvent("onunload",s);else if("function"==typeof addEventListener){var f="onpagehide"in self?"pagehide":"unload";addEventListener(f,s,!1)}},function(t,e,n){function r(t){var e=t&&t.forceBase64;u&&!e||(this.supportsBinary=!1),o.call(this,t)}var o=n(20),i=n(29),s=n(21),a=n(30),c=n(31),p=n(3)("engine.io-client:polling");t.exports=r;var u=function(){var t=n(16),e=new t({xdomain:!1});return null!=e.responseType}();a(r,o),r.prototype.name="polling",r.prototype.doOpen=function(){this.poll()},r.prototype.pause=function(t){function e(){p("paused"),n.readyState="paused",t()}var n=this;if(this.readyState="pausing",this.polling||!this.writable){var r=0;this.polling&&(p("we are currently polling - waiting to pause"),r++,this.once("pollComplete",function(){p("pre-pause polling complete"),--r||e()})),this.writable||(p("we are currently writing - waiting to pause"),r++,this.once("drain",function(){p("pre-pause writing complete"),--r||e()}))}else e()},r.prototype.poll=function(){p("polling"),this.polling=!0,this.doPoll(),this.emit("poll")},r.prototype.onData=function(t){var e=this;p("polling got data %s",t);var n=function(t,n,r){return"opening"===e.readyState&&e.onOpen(),"close"===t.type?(e.onClose(),!1):void e.onPacket(t)};s.decodePayload(t,this.socket.binaryType,n),"closed"!==this.readyState&&(this.polling=!1,this.emit("pollComplete"),"open"===this.readyState?this.poll():p('ignoring poll - transport state "%s"',this.readyState))},r.prototype.doClose=function(){function t(){p("writing close packet"),e.write([{type:"close"}])}var e=this;"open"===this.readyState?(p("transport open - closing"),t()):(p("transport not open - deferring close"),this.once("open",t))},r.prototype.write=function(t){var e=this;this.writable=!1;var n=function(){e.writable=!0,e.emit("drain")};s.encodePayload(t,this.supportsBinary,function(t){e.doWrite(t,n)})},r.prototype.uri=function(){var t=this.query||{},e=this.secure?"https":"http",n="";!1!==this.timestampRequests&&(t[this.timestampParam]=c()),this.supportsBinary||t.sid||(t.b64=1),t=i.encode(t),this.port&&("https"===e&&443!==Number(this.port)||"http"===e&&80!==Number(this.port))&&(n=":"+this.port),t.length&&(t="?"+t);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+n+this.path+t}},function(t,e,n){function r(t){this.path=t.path,this.hostname=t.hostname,this.port=t.port,this.secure=t.secure,this.query=t.query,this.timestampParam=t.timestampParam,this.timestampRequests=t.timestampRequests,this.readyState="",this.agent=t.agent||!1,this.socket=t.socket,this.enablesXDR=t.enablesXDR,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.forceNode=t.forceNode,this.isReactNative=t.isReactNative,this.extraHeaders=t.extraHeaders,this.localAddress=t.localAddress}var o=n(21),i=n(8);t.exports=r,i(r.prototype),r.prototype.onError=function(t,e){var n=new Error(t);return n.type="TransportError",n.description=e,this.emit("error",n),this},r.prototype.open=function(){return"closed"!==this.readyState&&""!==this.readyState||(this.readyState="opening",this.doOpen()),this},r.prototype.close=function(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this},r.prototype.send=function(t){if("open"!==this.readyState)throw new Error("Transport not open");this.write(t)},r.prototype.onOpen=function(){this.readyState="open",this.writable=!0,this.emit("open")},r.prototype.onData=function(t){var e=o.decodePacket(t,this.socket.binaryType);this.onPacket(e)},r.prototype.onPacket=function(t){this.emit("packet",t)},r.prototype.onClose=function(){this.readyState="closed",this.emit("close")}},function(t,e,n){function r(t,n){var r="b"+e.packets[t.type]+t.data.data;return n(r)}function o(t,n,r){if(!n)return e.encodeBase64Packet(t,r);var o=t.data,i=new Uint8Array(o),s=new Uint8Array(1+o.byteLength);s[0]=v[t.type];for(var a=0;a<i.length;a++)s[a+1]=i[a];return r(s.buffer)}function i(t,n,r){if(!n)return e.encodeBase64Packet(t,r);var o=new FileReader;return o.onload=function(){e.encodePacket({type:t.type,data:o.result},n,!0,r)},o.readAsArrayBuffer(t.data)}function s(t,n,r){if(!n)return e.encodeBase64Packet(t,r);if(g)return i(t,n,r);var o=new Uint8Array(1);o[0]=v[t.type];var s=new k([o.buffer,t.data]);return r(s)}function a(t){try{t=d.decode(t,{strict:!1})}catch(e){return!1}return t}function c(t,e,n){for(var r=new Array(t.length),o=l(t.length,n),i=function(t,n,o){e(n,function(e,n){r[t]=n,o(e,r)})},s=0;s<t.length;s++)i(s,t[s],o)}var p,u=n(22),h=n(23),f=n(24),l=n(25),d=n(26);"undefined"!=typeof ArrayBuffer&&(p=n(27));var y="undefined"!=typeof navigator&&/Android/i.test(navigator.userAgent),m="undefined"!=typeof navigator&&/PhantomJS/i.test(navigator.userAgent),g=y||m;e.protocol=3;var v=e.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},b=u(v),w={type:"error",data:"parser error"},k=n(28);e.encodePacket=function(t,e,n,i){"function"==typeof e&&(i=e,e=!1),"function"==typeof n&&(i=n,n=null);var a=void 0===t.data?void 0:t.data.buffer||t.data;if("undefined"!=typeof ArrayBuffer&&a instanceof ArrayBuffer)return o(t,e,i);if("undefined"!=typeof k&&a instanceof k)return s(t,e,i);if(a&&a.base64)return r(t,i);var c=v[t.type];return void 0!==t.data&&(c+=n?d.encode(String(t.data),{strict:!1}):String(t.data)),i(""+c)},e.encodeBase64Packet=function(t,n){var r="b"+e.packets[t.type];if("undefined"!=typeof k&&t.data instanceof k){var o=new FileReader;return o.onload=function(){var t=o.result.split(",")[1];n(r+t)},o.readAsDataURL(t.data)}var i;try{i=String.fromCharCode.apply(null,new Uint8Array(t.data))}catch(s){for(var a=new Uint8Array(t.data),c=new Array(a.length),p=0;p<a.length;p++)c[p]=a[p];i=String.fromCharCode.apply(null,c)}return r+=btoa(i),n(r)},e.decodePacket=function(t,n,r){if(void 0===t)return w;if("string"==typeof t){if("b"===t.charAt(0))return e.decodeBase64Packet(t.substr(1),n);if(r&&(t=a(t),t===!1))return w;var o=t.charAt(0);return Number(o)==o&&b[o]?t.length>1?{type:b[o],data:t.substring(1)}:{type:b[o]}:w}var i=new Uint8Array(t),o=i[0],s=f(t,1);return k&&"blob"===n&&(s=new k([s])),{type:b[o],data:s}},e.decodeBase64Packet=function(t,e){var n=b[t.charAt(0)];if(!p)return{type:n,data:{base64:!0,data:t.substr(1)}};var r=p.decode(t.substr(1));return"blob"===e&&k&&(r=new k([r])),{type:n,data:r}},e.encodePayload=function(t,n,r){function o(t){return t.length+":"+t}function i(t,r){e.encodePacket(t,!!s&&n,!1,function(t){r(null,o(t))})}"function"==typeof n&&(r=n,n=null);var s=h(t);return n&&s?k&&!g?e.encodePayloadAsBlob(t,r):e.encodePayloadAsArrayBuffer(t,r):t.length?void c(t,i,function(t,e){return r(e.join(""))}):r("0:")},e.decodePayload=function(t,n,r){if("string"!=typeof t)return e.decodePayloadAsBinary(t,n,r);"function"==typeof n&&(r=n,n=null);var o;if(""===t)return r(w,0,1);for(var i,s,a="",c=0,p=t.length;c<p;c++){var u=t.charAt(c);if(":"===u){if(""===a||a!=(i=Number(a)))return r(w,0,1);if(s=t.substr(c+1,i),a!=s.length)return r(w,0,1);if(s.length){if(o=e.decodePacket(s,n,!1),w.type===o.type&&w.data===o.data)return r(w,0,1);var h=r(o,c+i,p);if(!1===h)return}c+=i,a=""}else a+=u}return""!==a?r(w,0,1):void 0},e.encodePayloadAsArrayBuffer=function(t,n){function r(t,n){e.encodePacket(t,!0,!0,function(t){return n(null,t)})}return t.length?void c(t,r,function(t,e){var r=e.reduce(function(t,e){var n;return n="string"==typeof e?e.length:e.byteLength,t+n.toString().length+n+2},0),o=new Uint8Array(r),i=0;return e.forEach(function(t){var e="string"==typeof t,n=t;if(e){for(var r=new Uint8Array(t.length),s=0;s<t.length;s++)r[s]=t.charCodeAt(s);n=r.buffer}e?o[i++]=0:o[i++]=1;for(var a=n.byteLength.toString(),s=0;s<a.length;s++)o[i++]=parseInt(a[s]);o[i++]=255;for(var r=new Uint8Array(n),s=0;s<r.length;s++)o[i++]=r[s]}),n(o.buffer)}):n(new ArrayBuffer(0))},e.encodePayloadAsBlob=function(t,n){function r(t,n){e.encodePacket(t,!0,!0,function(t){var e=new Uint8Array(1);if(e[0]=1,"string"==typeof t){for(var r=new Uint8Array(t.length),o=0;o<t.length;o++)r[o]=t.charCodeAt(o);t=r.buffer,e[0]=0}for(var i=t instanceof ArrayBuffer?t.byteLength:t.size,s=i.toString(),a=new Uint8Array(s.length+1),o=0;o<s.length;o++)a[o]=parseInt(s[o]);if(a[s.length]=255,k){var c=new k([e.buffer,a.buffer,t]);n(null,c)}})}c(t,r,function(t,e){return n(new k(e))})},e.decodePayloadAsBinary=function(t,n,r){"function"==typeof n&&(r=n,n=null);for(var o=t,i=[];o.byteLength>0;){for(var s=new Uint8Array(o),a=0===s[0],c="",p=1;255!==s[p];p++){if(c.length>310)return r(w,0,1);c+=s[p]}o=f(o,2+c.length),c=parseInt(c);var u=f(o,0,c);if(a)try{u=String.fromCharCode.apply(null,new Uint8Array(u))}catch(h){var l=new Uint8Array(u);u="";for(var p=0;p<l.length;p++)u+=String.fromCharCode(l[p])}i.push(u),o=f(o,c)}var d=i.length;i.forEach(function(t,o){r(e.decodePacket(t,n,!0),o,d)})}},function(t,e){t.exports=Object.keys||function(t){var e=[],n=Object.prototype.hasOwnProperty;for(var r in t)n.call(t,r)&&e.push(r);return e}},function(t,e,n){function r(t){if(!t||"object"!=typeof t)return!1;if(o(t)){for(var e=0,n=t.length;e<n;e++)if(r(t[e]))return!0;return!1}if("function"==typeof Buffer&&Buffer.isBuffer&&Buffer.isBuffer(t)||"function"==typeof ArrayBuffer&&t instanceof ArrayBuffer||s&&t instanceof Blob||a&&t instanceof File)return!0;if(t.toJSON&&"function"==typeof t.toJSON&&1===arguments.length)return r(t.toJSON(),!0);for(var i in t)if(Object.prototype.hasOwnProperty.call(t,i)&&r(t[i]))return!0;return!1}var o=n(10),i=Object.prototype.toString,s="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===i.call(Blob),a="function"==typeof File||"undefined"!=typeof File&&"[object FileConstructor]"===i.call(File);t.exports=r},function(t,e){t.exports=function(t,e,n){var r=t.byteLength;if(e=e||0,n=n||r,t.slice)return t.slice(e,n);if(e<0&&(e+=r),n<0&&(n+=r),n>r&&(n=r),e>=r||e>=n||0===r)return new ArrayBuffer(0);for(var o=new Uint8Array(t),i=new Uint8Array(n-e),s=e,a=0;s<n;s++,a++)i[a]=o[s];return i.buffer}},function(t,e){function n(t,e,n){function o(t,r){if(o.count<=0)throw new Error("after called too many times");--o.count,t?(i=!0,e(t),e=n):0!==o.count||i||e(null,r)}var i=!1;return n=n||r,o.count=t,0===t?e():o}function r(){}t.exports=n},function(t,e){function n(t){for(var e,n,r=[],o=0,i=t.length;o<i;)e=t.charCodeAt(o++),e>=55296&&e<=56319&&o<i?(n=t.charCodeAt(o++),56320==(64512&n)?r.push(((1023&e)<<10)+(1023&n)+65536):(r.push(e),o--)):r.push(e);return r}function r(t){for(var e,n=t.length,r=-1,o="";++r<n;)e=t[r],e>65535&&(e-=65536,o+=d(e>>>10&1023|55296),e=56320|1023&e),o+=d(e);return o}function o(t,e){if(t>=55296&&t<=57343){if(e)throw Error("Lone surrogate U+"+t.toString(16).toUpperCase()+" is not a scalar value");return!1}return!0}function i(t,e){return d(t>>e&63|128)}function s(t,e){if(0==(4294967168&t))return d(t);var n="";return 0==(4294965248&t)?n=d(t>>6&31|192):0==(4294901760&t)?(o(t,e)||(t=65533),n=d(t>>12&15|224),n+=i(t,6)):0==(4292870144&t)&&(n=d(t>>18&7|240),n+=i(t,12),n+=i(t,6)),n+=d(63&t|128)}function a(t,e){e=e||{};for(var r,o=!1!==e.strict,i=n(t),a=i.length,c=-1,p="";++c<a;)r=i[c],p+=s(r,o);return p}function c(){if(l>=f)throw Error("Invalid byte index");var t=255&h[l];if(l++,128==(192&t))return 63&t;throw Error("Invalid continuation byte")}function p(t){var e,n,r,i,s;if(l>f)throw Error("Invalid byte index");if(l==f)return!1;if(e=255&h[l],l++,0==(128&e))return e;if(192==(224&e)){if(n=c(),s=(31&e)<<6|n,s>=128)return s;throw Error("Invalid continuation byte")}if(224==(240&e)){if(n=c(),r=c(),s=(15&e)<<12|n<<6|r,s>=2048)return o(s,t)?s:65533;throw Error("Invalid continuation byte")}if(240==(248&e)&&(n=c(),r=c(),i=c(),s=(7&e)<<18|n<<12|r<<6|i,s>=65536&&s<=1114111))return s;throw Error("Invalid UTF-8 detected")}function u(t,e){e=e||{};var o=!1!==e.strict;h=n(t),f=h.length,l=0;for(var i,s=[];(i=p(o))!==!1;)s.push(i);return r(s)}/*! https://mths.be/utf8js v2.1.2 by @mathias */
var h,f,l,d=String.fromCharCode;t.exports={version:"2.1.2",encode:a,decode:u}},function(t,e){!function(){"use strict";for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n=new Uint8Array(256),r=0;r<t.length;r++)n[t.charCodeAt(r)]=r;e.encode=function(e){var n,r=new Uint8Array(e),o=r.length,i="";for(n=0;n<o;n+=3)i+=t[r[n]>>2],i+=t[(3&r[n])<<4|r[n+1]>>4],i+=t[(15&r[n+1])<<2|r[n+2]>>6],i+=t[63&r[n+2]];return o%3===2?i=i.substring(0,i.length-1)+"=":o%3===1&&(i=i.substring(0,i.length-2)+"=="),i},e.decode=function(t){var e,r,o,i,s,a=.75*t.length,c=t.length,p=0;"="===t[t.length-1]&&(a--,"="===t[t.length-2]&&a--);var u=new ArrayBuffer(a),h=new Uint8Array(u);for(e=0;e<c;e+=4)r=n[t.charCodeAt(e)],o=n[t.charCodeAt(e+1)],i=n[t.charCodeAt(e+2)],s=n[t.charCodeAt(e+3)],h[p++]=r<<2|o>>4,h[p++]=(15&o)<<4|i>>2,h[p++]=(3&i)<<6|63&s;return u}}()},function(t,e){function n(t){return t.map(function(t){if(t.buffer instanceof ArrayBuffer){var e=t.buffer;if(t.byteLength!==e.byteLength){var n=new Uint8Array(t.byteLength);n.set(new Uint8Array(e,t.byteOffset,t.byteLength)),e=n.buffer}return e}return t})}function r(t,e){e=e||{};var r=new i;return n(t).forEach(function(t){r.append(t)}),e.type?r.getBlob(e.type):r.getBlob()}function o(t,e){return new Blob(n(t),e||{})}var i="undefined"!=typeof i?i:"undefined"!=typeof WebKitBlobBuilder?WebKitBlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"undefined"!=typeof MozBlobBuilder&&MozBlobBuilder,s=function(){try{var t=new Blob(["hi"]);return 2===t.size}catch(e){return!1}}(),a=s&&function(){try{var t=new Blob([new Uint8Array([1,2])]);return 2===t.size}catch(e){return!1}}(),c=i&&i.prototype.append&&i.prototype.getBlob;"undefined"!=typeof Blob&&(r.prototype=Blob.prototype,o.prototype=Blob.prototype),t.exports=function(){return s?a?Blob:o:c?r:void 0}()},function(t,e){e.encode=function(t){var e="";for(var n in t)t.hasOwnProperty(n)&&(e.length&&(e+="&"),e+=encodeURIComponent(n)+"="+encodeURIComponent(t[n]));return e},e.decode=function(t){for(var e={},n=t.split("&"),r=0,o=n.length;r<o;r++){var i=n[r].split("=");e[decodeURIComponent(i[0])]=decodeURIComponent(i[1])}return e}},function(t,e){t.exports=function(t,e){var n=function(){};n.prototype=e.prototype,t.prototype=new n,t.prototype.constructor=t}},function(t,e){"use strict";function n(t){var e="";do e=s[t%a]+e,t=Math.floor(t/a);while(t>0);return e}function r(t){var e=0;for(u=0;u<t.length;u++)e=e*a+c[t.charAt(u)];return e}function o(){var t=n(+new Date);return t!==i?(p=0,i=t):t+"."+n(p++)}for(var i,s="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),a=64,c={},p=0,u=0;u<a;u++)c[s[u]]=u;o.encode=n,o.decode=r,t.exports=o},function(t,e,n){(function(e){function r(){}function o(){return"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof e?e:{}}function i(t){if(s.call(this,t),this.query=this.query||{},!c){var e=o();c=e.___eio=e.___eio||[]}this.index=c.length;var n=this;c.push(function(t){n.onData(t)}),this.query.j=this.index,"function"==typeof addEventListener&&addEventListener("beforeunload",function(){n.script&&(n.script.onerror=r)},!1)}var s=n(19),a=n(30);t.exports=i;var c,p=/\n/g,u=/\\n/g;a(i,s),i.prototype.supportsBinary=!1,i.prototype.doClose=function(){this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),this.form&&(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),s.prototype.doClose.call(this)},i.prototype.doPoll=function(){var t=this,e=document.createElement("script");this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(e){t.onError("jsonp poll error",e)};var n=document.getElementsByTagName("script")[0];n?n.parentNode.insertBefore(e,n):(document.head||document.body).appendChild(e),this.script=e;var r="undefined"!=typeof navigator&&/gecko/i.test(navigator.userAgent);r&&setTimeout(function(){var t=document.createElement("iframe");document.body.appendChild(t),document.body.removeChild(t)},100)},i.prototype.doWrite=function(t,e){function n(){r(),e()}function r(){if(o.iframe)try{o.form.removeChild(o.iframe)}catch(t){o.onError("jsonp polling iframe removal error",t)}try{var e='<iframe src="javascript:0" name="'+o.iframeId+'">';i=document.createElement(e)}catch(t){i=document.createElement("iframe"),i.name=o.iframeId,i.src="javascript:0"}i.id=o.iframeId,o.form.appendChild(i),o.iframe=i}var o=this;if(!this.form){var i,s=document.createElement("form"),a=document.createElement("textarea"),c=this.iframeId="eio_iframe_"+this.index;s.className="socketio",s.style.position="absolute",s.style.top="-1000px",s.style.left="-1000px",s.target=c,s.method="POST",s.setAttribute("accept-charset","utf-8"),a.name="d",s.appendChild(a),document.body.appendChild(s),this.form=s,this.area=a}this.form.action=this.uri(),r(),t=t.replace(u,"\\\n"),this.area.value=t.replace(p,"\\n");try{this.form.submit()}catch(h){}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){"complete"===o.iframe.readyState&&n()}:this.iframe.onload=n}}).call(e,function(){return this}())},function(t,e,n){function r(t){var e=t&&t.forceBase64;e&&(this.supportsBinary=!1),this.perMessageDeflate=t.perMessageDeflate,this.usingBrowserWebSocket=o&&!t.forceNode,this.protocols=t.protocols,this.usingBrowserWebSocket||(l=i),s.call(this,t)}var o,i,s=n(20),a=n(21),c=n(29),p=n(30),u=n(31),h=n(3)("engine.io-client:websocket");if("undefined"==typeof self)try{i=n(34)}catch(f){}else o=self.WebSocket||self.MozWebSocket;var l=o||i;t.exports=r,p(r,s),r.prototype.name="websocket",r.prototype.supportsBinary=!0,r.prototype.doOpen=function(){if(this.check()){var t=this.uri(),e=this.protocols,n={agent:this.agent,perMessageDeflate:this.perMessageDeflate};n.pfx=this.pfx,n.key=this.key,n.passphrase=this.passphrase,n.cert=this.cert,n.ca=this.ca,n.ciphers=this.ciphers,n.rejectUnauthorized=this.rejectUnauthorized,this.extraHeaders&&(n.headers=this.extraHeaders),this.localAddress&&(n.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket&&!this.isReactNative?e?new l(t,e):new l(t):new l(t,e,n)}catch(r){return this.emit("error",r)}void 0===this.ws.binaryType&&(this.supportsBinary=!1),this.ws.supports&&this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType="nodebuffer"):this.ws.binaryType="arraybuffer",this.addEventListeners()}},r.prototype.addEventListeners=function(){var t=this;this.ws.onopen=function(){t.onOpen()},this.ws.onclose=function(){t.onClose()},this.ws.onmessage=function(e){t.onData(e.data)},this.ws.onerror=function(e){t.onError("websocket error",e)}},r.prototype.write=function(t){function e(){n.emit("flush"),setTimeout(function(){n.writable=!0,n.emit("drain")},0)}var n=this;this.writable=!1;for(var r=t.length,o=0,i=r;o<i;o++)!function(t){a.encodePacket(t,n.supportsBinary,function(o){if(!n.usingBrowserWebSocket){var i={};if(t.options&&(i.compress=t.options.compress),n.perMessageDeflate){var s="string"==typeof o?Buffer.byteLength(o):o.length;s<n.perMessageDeflate.threshold&&(i.compress=!1)}}try{n.usingBrowserWebSocket?n.ws.send(o):n.ws.send(o,i)}catch(a){h("websocket closed before onclose event")}--r||e()})}(t[o])},r.prototype.onClose=function(){s.prototype.onClose.call(this)},r.prototype.doClose=function(){"undefined"!=typeof this.ws&&this.ws.close()},r.prototype.uri=function(){var t=this.query||{},e=this.secure?"wss":"ws",n="";this.port&&("wss"===e&&443!==Number(this.port)||"ws"===e&&80!==Number(this.port))&&(n=":"+this.port),this.timestampRequests&&(t[this.timestampParam]=u()),this.supportsBinary||(t.b64=1),t=c.encode(t),t.length&&(t="?"+t);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+n+this.path+t},r.prototype.check=function(){return!(!l||"__initialize"in l&&this.name===r.prototype.name)}},function(t,e){},function(t,e){var n=[].indexOf;t.exports=function(t,e){if(n)return t.indexOf(e);for(var r=0;r<t.length;++r)if(t[r]===e)return r;return-1}},function(t,e,n){"use strict";function r(t,e,n){this.io=t,this.nsp=e,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,this.flags={},n&&n.query&&(this.query=n.query),this.io.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=n(7),s=n(8),a=n(37),c=n(38),p=n(39),u=n(3)("socket.io-client:socket"),h=n(29),f=n(23);t.exports=e=r;var l={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},d=s.prototype.emit;s(r.prototype),r.prototype.subEvents=function(){if(!this.subs){var t=this.io;this.subs=[c(t,"open",p(this,"onopen")),c(t,"packet",p(this,"onpacket")),c(t,"close",p(this,"onclose"))]}},r.prototype.open=r.prototype.connect=function(){return this.connected?this:(this.subEvents(),this.io.open(),"open"===this.io.readyState&&this.onopen(),this.emit("connecting"),this)},r.prototype.send=function(){var t=a(arguments);return t.unshift("message"),this.emit.apply(this,t),this},r.prototype.emit=function(t){if(l.hasOwnProperty(t))return d.apply(this,arguments),this;var e=a(arguments),n={type:(void 0!==this.flags.binary?this.flags.binary:f(e))?i.BINARY_EVENT:i.EVENT,data:e};return n.options={},n.options.compress=!this.flags||!1!==this.flags.compress,"function"==typeof e[e.length-1]&&(u("emitting packet with ack id %d",this.ids),this.acks[this.ids]=e.pop(),n.id=this.ids++),this.connected?this.packet(n):this.sendBuffer.push(n),this.flags={},this},r.prototype.packet=function(t){t.nsp=this.nsp,this.io.packet(t)},r.prototype.onopen=function(){if(u("transport is open - connecting"),"/"!==this.nsp)if(this.query){var t="object"===o(this.query)?h.encode(this.query):this.query;u("sending connect packet with query %s",t),this.packet({type:i.CONNECT,query:t})}else this.packet({type:i.CONNECT})},r.prototype.onclose=function(t){u("close (%s)",t),this.connected=!1,this.disconnected=!0,delete this.id,this.emit("disconnect",t)},r.prototype.onpacket=function(t){var e=t.nsp===this.nsp,n=t.type===i.ERROR&&"/"===t.nsp;if(e||n)switch(t.type){case i.CONNECT:this.onconnect();break;case i.EVENT:this.onevent(t);break;case i.BINARY_EVENT:this.onevent(t);break;case i.ACK:this.onack(t);break;case i.BINARY_ACK:this.onack(t);break;case i.DISCONNECT:this.ondisconnect();break;case i.ERROR:this.emit("error",t.data)}},r.prototype.onevent=function(t){var e=t.data||[];u("emitting event %j",e),null!=t.id&&(u("attaching ack callback to event"),e.push(this.ack(t.id))),this.connected?d.apply(this,e):this.receiveBuffer.push(e)},r.prototype.ack=function(t){var e=this,n=!1;return function(){if(!n){n=!0;var r=a(arguments);u("sending ack %j",r),e.packet({type:f(r)?i.BINARY_ACK:i.ACK,id:t,data:r})}}},r.prototype.onack=function(t){var e=this.acks[t.id];"function"==typeof e?(u("calling ack %s with %j",t.id,t.data),e.apply(this,t.data),delete this.acks[t.id]):u("bad ack %s",t.id)},r.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emit("connect"),this.emitBuffered()},r.prototype.emitBuffered=function(){var t;for(t=0;t<this.receiveBuffer.length;t++)d.apply(this,this.receiveBuffer[t]);for(this.receiveBuffer=[],t=0;t<this.sendBuffer.length;t++)this.packet(this.sendBuffer[t]);this.sendBuffer=[]},r.prototype.ondisconnect=function(){u("server disconnect (%s)",this.nsp),this.destroy(),this.onclose("io server disconnect")},r.prototype.destroy=function(){if(this.subs){for(var t=0;t<this.subs.length;t++)this.subs[t].destroy();this.subs=null}this.io.destroy(this)},r.prototype.close=r.prototype.disconnect=function(){return this.connected&&(u("performing disconnect (%s)",this.nsp),this.packet({type:i.DISCONNECT})),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},r.prototype.compress=function(t){return this.flags.compress=t,this},r.prototype.binary=function(t){return this.flags.binary=t,this}},function(t,e){function n(t,e){var n=[];e=e||0;for(var r=e||0;r<t.length;r++)n[r-e]=t[r];return n}t.exports=n},function(t,e){"use strict";function n(t,e,n){return t.on(e,n),{destroy:function(){t.removeListener(e,n)}}}t.exports=n},function(t,e){var n=[].slice;t.exports=function(t,e){if("string"==typeof e&&(e=t[e]),"function"!=typeof e)throw new Error("bind() requires a function");var r=n.call(arguments,2);return function(){return e.apply(t,r.concat(n.call(arguments)))}}},function(t,e){function n(t){t=t||{},this.ms=t.min||100,this.max=t.max||1e4,this.factor=t.factor||2,this.jitter=t.jitter>0&&t.jitter<=1?t.jitter:0,this.attempts=0}t.exports=n,n.prototype.duration=function(){var t=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),n=Math.floor(e*this.jitter*t);t=0==(1&Math.floor(10*e))?t-n:t+n}return 0|Math.min(t,this.max)},n.prototype.reset=function(){this.attempts=0},n.prototype.setMin=function(t){this.ms=t},n.prototype.setMax=function(t){this.max=t},n.prototype.setJitter=function(t){this.jitter=t}}])});
//# sourceMappingURL=socket.io.js.map
/* eslint-disable */
!function(A){function I(A){"use strict";var I;void 0===(I=A)&&(I={});var e=I;"object"!=typeof e.sodium&&("object"==typeof global?e=global:"object"==typeof window&&(e=window)),"object"==typeof e.sodium&&"number"==typeof e.sodium.totalMemory&&(I.TOTAL_MEMORY=e.sodium.totalMemory);var g=I;return I.ready=new Promise(function(A,I){function e(A){X("NO_DYNAMIC_EXECUTION=1 was set, cannot eval")}function i(A,I){A||X("Assertion failed: "+I)}function B(A){var I=K["_"+A];return I||X("NO_DYNAMIC_EXECUTION=1 was set, cannot eval"),i(I,"Cannot call unknown function "+A+" (perhaps LLVM optimizations or closure removed it?)"),I}function t(A,I,e,g){switch("*"===(e=e||"i8").charAt(e.length-1)&&(e="i32"),e){case"i1":case"i8":aA[A>>0]=I;break;case"i16":CA[A>>1]=I;break;case"i32":cA[A>>2]=I;break;case"i64":tempI64=[I>>>0,(tempDouble=I,+HA(tempDouble)>=1?tempDouble>0?(0|RA(+SA(tempDouble/4294967296),4294967295))>>>0:~~+YA((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],cA[A>>2]=tempI64[0],cA[A+4>>2]=tempI64[1];break;case"float":EA[A>>2]=I;break;case"double":sA[A>>3]=I;break;default:X("invalid type for setValue: "+e)}}function r(A,I,e){switch("*"===(I=I||"i8").charAt(I.length-1)&&(I="i32"),I){case"i1":case"i8":return aA[A>>0];case"i16":return CA[A>>1];case"i32":case"i64":return cA[A>>2];case"float":return EA[A>>2];case"double":return sA[A>>3];default:X("invalid type for getValue: "+I)}return null}function a(A,I,e,g){var B,r;"number"==typeof A?(B=!0,r=A):(B=!1,r=A.length);var a,n="string"==typeof I?I:null;if(a=e==BA?g:["function"==typeof ZA?ZA:$.staticAlloc,$.stackAlloc,$.staticAlloc,$.dynamicAlloc][void 0===e?iA:e](Math.max(r,n?1:I.length)),B){var C;for(g=a,i(0==(3&a)),C=a+(-4&r);g<C;g+=4)cA[g>>2]=0;for(C=a+r;g<C;)aA[g++>>0]=0;return a}if("i8"===n)return A.subarray||A.slice?nA.set(A,a):nA.set(new Uint8Array(A),a),a;for(var o,c,Q,E=0;E<r;){var s=A[E];"function"==typeof s&&(s=$.getFunctionIndex(s)),0!==(o=n||I[E])?("i64"==o&&(o="i32"),t(a+E,s,o),Q!==o&&(c=$.getNativeTypeSize(o),Q=o),E+=c):E++}return a}function n(A,I){if(0===I||!A)return"";for(var e,g=0,i=0;e=nA[A+i>>0],g|=e,(0!=e||I)&&(i++,!I||i!=I););I||(I=i);var B="";if(g<128){for(var t;I>0;)t=String.fromCharCode.apply(String,nA.subarray(A,A+Math.min(I,1024))),B=B?B+t:t,A+=1024,I-=1024;return B}return K.UTF8ToString(A)}function C(A,I){for(var e=I;A[e];)++e;if(e-I>16&&A.subarray&&tA)return tA.decode(A.subarray(I,e));for(var g,i,B,t,r,a="";;){if(!(g=A[I++]))return a;if(128&g)if(i=63&A[I++],192!=(224&g))if(B=63&A[I++],224==(240&g)?g=(15&g)<<12|i<<6|B:(t=63&A[I++],240==(248&g)?g=(7&g)<<18|i<<12|B<<6|t:(r=63&A[I++],g=248==(252&g)?(3&g)<<24|i<<18|B<<12|t<<6|r:(1&g)<<30|i<<24|B<<18|t<<12|r<<6|63&A[I++])),g<65536)a+=String.fromCharCode(g);else{var n=g-65536;a+=String.fromCharCode(55296|n>>10,56320|1023&n)}else a+=String.fromCharCode((31&g)<<6|i);else a+=String.fromCharCode(g)}}function o(A,I,e,g){if(!(g>0))return 0;for(var i=e,B=e+g-1,t=0;t<A.length;++t){var r=A.charCodeAt(t);if(r>=55296&&r<=57343&&(r=65536+((1023&r)<<10)|1023&A.charCodeAt(++t)),r<=127){if(e>=B)break;I[e++]=r}else if(r<=2047){if(e+1>=B)break;I[e++]=192|r>>6,I[e++]=128|63&r}else if(r<=65535){if(e+2>=B)break;I[e++]=224|r>>12,I[e++]=128|r>>6&63,I[e++]=128|63&r}else if(r<=2097151){if(e+3>=B)break;I[e++]=240|r>>18,I[e++]=128|r>>12&63,I[e++]=128|r>>6&63,I[e++]=128|63&r}else if(r<=67108863){if(e+4>=B)break;I[e++]=248|r>>24,I[e++]=128|r>>18&63,I[e++]=128|r>>12&63,I[e++]=128|r>>6&63,I[e++]=128|63&r}else{if(e+5>=B)break;I[e++]=252|r>>30,I[e++]=128|r>>24&63,I[e++]=128|r>>18&63,I[e++]=128|r>>12&63,I[e++]=128|r>>6&63,I[e++]=128|63&r}}return I[e]=0,e-i}function c(A,I,e){return o(A,nA,I,e)}function Q(A){for(var I=0,e=0;e<A.length;++e){var g=A.charCodeAt(e);g>=55296&&g<=57343&&(g=65536+((1023&g)<<10)|1023&A.charCodeAt(++e)),g<=127?++I:I+=g<=2047?2:g<=65535?3:g<=2097151?4:g<=67108863?5:6}return I}function E(A){var I=K.___cxa_demangle||K.__cxa_demangle;if(I){try{var e=A.substr(1),g=Q(e)+1,i=ZA(g);c(e,i,g);var B=ZA(4),t=I(i,0,0,B);if(0===r(B,"i32")&&t)return n(t)}catch(A){}finally{i&&jA(i),B&&jA(B),t&&jA(t)}return A}return $.warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling"),A}function s(A){return A.replace(/__Z[\w\d_]+/g,function(A){var I=E(A);return A===I?A:A+" ["+I+"]"})}function h(){var A=new Error;if(!A.stack){try{throw new Error(0)}catch(I){A=I}if(!A.stack)return"(no stack trace available)"}return A.stack.toString()}function y(){var A=h();return K.extraStackTrace&&(A+="\n"+K.extraStackTrace()),s(A)}function f(A,I){return A%I>0&&(A+=I-A%I),A}function _(A){K.buffer=rA=A}function p(){K.HEAP8=aA=new Int8Array(rA),K.HEAP16=CA=new Int16Array(rA),K.HEAP32=cA=new Int32Array(rA),K.HEAPU8=nA=new Uint8Array(rA),K.HEAPU16=oA=new Uint16Array(rA),K.HEAPU32=QA=new Uint32Array(rA),K.HEAPF32=EA=new Float32Array(rA),K.HEAPF64=sA=new Float64Array(rA)}function w(){X("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value "+dA+", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")}function l(){w()}function u(A){for(;A.length>0;){var I=A.shift();if("function"!=typeof I){var e=I.func;"number"==typeof e?void 0===I.arg?K.dynCall_v(e):K.dynCall_vi(e,I.arg):e(void 0===I.arg?null:I.arg)}else I()}}function d(){if(K.preRun)for("function"==typeof K.preRun&&(K.preRun=[K.preRun]);K.preRun.length;)G(K.preRun.shift());u(DA)}function D(){FA||(FA=!0,u(vA))}function v(){u(bA)}function b(){u(kA),mA=!0}function k(){if(K.postRun)for("function"==typeof K.postRun&&(K.postRun=[K.postRun]);K.postRun.length;)F(K.postRun.shift());u(GA)}function G(A){DA.unshift(A)}function F(A){GA.unshift(A)}function m(A,I){aA.set(A,I)}function M(A,I,e){for(var g=0;g<A.length;++g)aA[I++>>0]=A.charCodeAt(g);e||(aA[I>>0]=0)}function H(A){NA++,K.monitorRunDependencies&&K.monitorRunDependencies(NA)}function Y(A){if(NA--,K.monitorRunDependencies&&K.monitorRunDependencies(NA),0==NA&&(null!==UA&&(clearInterval(UA),UA=null),JA)){var I=JA;JA=null,I()}}function S(A){return K.___errno_location&&(cA[K.___errno_location()>>2]=A),A}function R(A,I,e){var g=e>0?e:Q(A)+1,i=new Array(g),B=o(A,i,0,i.length);return I&&(i.length=B),i}function N(A){for(var I=[],e=0;e<A.length;e++){var g=A[e];g>255&&(KA&&i(!1,"Character code "+g+" ("+String.fromCharCode(g)+")  at offset "+e+" not in 0x00-0xFF."),g&=255),I.push(String.fromCharCode(g))}return I.join("")}function U(A){if("boolean"==typeof Z&&Z){var I;try{I=Buffer.from(A,"base64")}catch(e){I=new Buffer(A,"base64")}return new Uint8Array(I.buffer,I.byteOffset,I.byteLength)}try{for(var e=VA(A),g=new Uint8Array(e.length),i=0;i<e.length;++i)g[i]=e.charCodeAt(i);return g}catch(A){throw new Error("Converting base64 string to bytes failed.")}}function J(A){var I="data:application/octet-stream;base64,";if(String.prototype.startsWith?A.startsWith(I):0===A.indexOf(I))return U(A.slice(I.length))}function P(A){this.name="ExitStatus",this.message="Program terminated with exit("+A+")",this.status=A}function L(A){function I(){K.calledRun||(K.calledRun=!0,eA||(D(),v(),K.onRuntimeInitialized&&K.onRuntimeInitialized(),K._main&&BI&&K.callMain(A),k()))}A=A||K.arguments,null===eI&&(eI=Date.now()),NA>0||(d(),NA>0||K.calledRun||(K.setStatus?(K.setStatus("Running..."),setTimeout(function(){setTimeout(function(){K.setStatus("")},1),I()},1)):I()))}function x(A,I){I&&K.noExitRuntime||(K.noExitRuntime||(eA=!0,gA=A,_A=II,b(),K.onExit&&K.onExit(A)),Z&&process.exit(A),K.quit(A,new P(A)))}function X(A){K.onAbort&&K.onAbort(A),void 0!==A?(K.print(A),K.printErr(A),A=JSON.stringify(A)):A="",eA=!0,gA=1;var I="abort("+A+") at "+y()+"\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";throw iI&&iI.forEach(function(e){I=e(I,A)}),I}(K=g).onAbort=I,K.onRuntimeInitialized=A;var K;K||(K=(void 0!==K?K:null)||{});var T,V={};for(T in K)K.hasOwnProperty(T)&&(V[T]=K[T]);var q=!1,j=!1,Z=!1,W=!1;if(K.ENVIRONMENT)if("WEB"===K.ENVIRONMENT)q=!0;else if("WORKER"===K.ENVIRONMENT)j=!0;else if("NODE"===K.ENVIRONMENT)Z=!0;else{if("SHELL"!==K.ENVIRONMENT)throw new Error("The provided Module['ENVIRONMENT'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.");W=!0}else q="object"==typeof window,j="function"==typeof importScripts,Z="object"==typeof process&&"function"==typeof require&&!q&&!j,W=!q&&!Z&&!j;if(Z){K.print||(K.print=console.log),K.printErr||(K.printErr=console.warn);var z,O;K.read=function(A,I){var e;return(e=J(A))||(z||(z=require("fs")),O||(O=require("path")),A=O.normalize(A),e=z.readFileSync(A)),I?e:e.toString()},K.readBinary=function(A){var I=K.read(A,!0);return I.buffer||(I=new Uint8Array(I)),i(I.buffer),I},K.load=function(A){e(read(A))},K.thisProgram||(process.argv.length>1?K.thisProgram=process.argv[1].replace(/\\/g,"/"):K.thisProgram="unknown-program"),K.arguments=process.argv.slice(2),"undefined"!=typeof module&&(module.exports=K),process.on("uncaughtException",function(A){if(!(A instanceof P))throw A}),K.inspect=function(){return"[Emscripten Module object]"}}else if(W)K.print||(K.print=print),"undefined"!=typeof printErr&&(K.printErr=printErr),"undefined"!=typeof read?K.read=function(A){var I=J(A);return I?N(I):read(A)}:K.read=function(){throw"no read() available"},K.readBinary=function(A){var I;return(I=J(A))?I:"function"==typeof readbuffer?new Uint8Array(readbuffer(A)):(I=read(A,"binary"),i("object"==typeof I),I)},"undefined"!=typeof scriptArgs?K.arguments=scriptArgs:void 0!==arguments&&(K.arguments=arguments),"function"==typeof quit&&(K.quit=function(A,I){quit(A)});else{if(!q&&!j)throw new Error("Unknown runtime environment. Where are we?");K.read=function(A){try{var I=new XMLHttpRequest;return I.open("GET",A,!1),I.send(null),I.responseText}catch(I){var e=J(A);if(e)return N(e);throw I}},j&&(K.readBinary=function(A){try{var I=new XMLHttpRequest;return I.open("GET",A,!1),I.responseType="arraybuffer",I.send(null),new Uint8Array(I.response)}catch(I){var e=J(A);if(e)return e;throw I}}),K.readAsync=function(A,I,e){var g=new XMLHttpRequest;g.open("GET",A,!0),g.responseType="arraybuffer",g.onload=function(){if(200==g.status||0==g.status&&g.response)I(g.response);else{var i=J(A);i?I(i.buffer):e()}},g.onerror=e,g.send(null)},void 0!==arguments&&(K.arguments=arguments),"undefined"!=typeof console?(K.print||(K.print=function(A){}),K.printErr||(K.printErr=function(A){})):K.print||(K.print=function(A){}),j&&(K.load=importScripts),void 0===K.setWindowTitle&&(K.setWindowTitle=function(A){document.title=A})}!K.load&&K.read&&(K.load=function(A){e(K.read(A))}),K.print||(K.print=function(){}),K.printErr||(K.printErr=K.print),K.arguments||(K.arguments=[]),K.thisProgram||(K.thisProgram="./this.program"),K.quit||(K.quit=function(A,I){throw I}),K.print=K.print,K.printErr=K.printErr,K.preRun=[],K.postRun=[];for(T in V)V.hasOwnProperty(T)&&(K[T]=V[T]);V=void 0;var $={setTempRet0:function(A){return tempRet0=A,A},getTempRet0:function(){return tempRet0},stackSave:function(){return _A},stackRestore:function(A){_A=A},getNativeTypeSize:function(A){switch(A){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:if("*"===A[A.length-1])return $.QUANTUM_SIZE;if("i"===A[0]){var I=parseInt(A.substr(1));return i(I%8==0),I/8}return 0}},getNativeFieldSize:function(A){return Math.max($.getNativeTypeSize(A),$.QUANTUM_SIZE)},STACK_ALIGN:16,prepVararg:function(A,I){return"double"===I||"i64"===I?7&A&&(i(4==(7&A)),A+=4):i(0==(3&A)),A},getAlignSize:function(A,I,e){return e||"i64"!=A&&"double"!=A?A?Math.min(I||(A?$.getNativeFieldSize(A):0),$.QUANTUM_SIZE):Math.min(I,8):8},dynCall:function(A,I,e){return e&&e.length?K["dynCall_"+A].apply(null,[I].concat(e)):K["dynCall_"+A].call(null,I)},functionPointers:[null,null,null,null,null,null,null,null],addFunction:function(A){for(var I=0;I<$.functionPointers.length;I++)if(!$.functionPointers[I])return $.functionPointers[I]=A,1*(1+I);throw"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS."},removeFunction:function(A){$.functionPointers[(A-1)/1]=null},warnOnce:function(A){$.warnOnce.shown||($.warnOnce.shown={}),$.warnOnce.shown[A]||($.warnOnce.shown[A]=1,K.printErr(A))},funcWrappers:{},getFuncWrapper:function(A,I){if(A){i(I),$.funcWrappers[I]||($.funcWrappers[I]={});var e=$.funcWrappers[I];return e[A]||(1===I.length?e[A]=function(){return $.dynCall(I,A)}:2===I.length?e[A]=function(e){return $.dynCall(I,A,[e])}:e[A]=function(){return $.dynCall(I,A,Array.prototype.slice.call(arguments))}),e[A]}},getCompilerSetting:function(A){throw"You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work"},stackAlloc:function(A){var I=_A;return _A=_A+A|0,_A=_A+15&-16,I},staticAlloc:function(A){var I=yA;return yA=yA+A|0,yA=yA+15&-16,I},dynamicAlloc:function(A){var I=cA[lA>>2],e=-16&(I+A+15|0);return cA[lA>>2]=e,e>=dA&&!l()?(cA[lA>>2]=I,0):I},alignMemory:function(A,I){return A=Math.ceil(A/(I||16))*(I||16)},makeBigInt:function(A,I,e){return e?+(A>>>0)+4294967296*+(I>>>0):+(A>>>0)+4294967296*+(0|I)},GLOBAL_BASE:1024,QUANTUM_SIZE:4,__dummy__:0};K.Runtime=$;var AA,IA,eA=0,gA=0;!function(){var A={stackSave:function(){$.stackSave()},stackRestore:function(){$.stackRestore()},arrayToC:function(A){var I=$.stackAlloc(A.length);return m(A,I),I},stringToC:function(A){var I=0;if(null!==A&&void 0!==A&&0!==A){var e=1+(A.length<<2);c(A,I=$.stackAlloc(e),e)}return I}},I={string:A.stringToC,array:A.arrayToC};IA=function(A,e,g,i,t){var r=B(A),a=[],C=0;if(i)for(var o=0;o<i.length;o++){var c=I[g[o]];c?(0===C&&(C=$.stackSave()),a[o]=c(i[o])):a[o]=i[o]}var Q=r.apply(null,a);return"string"===e&&(Q=n(Q)),0!==C&&$.stackRestore(C),Q},AA=function(A,I,e){return function(){return IA(A,I,e,arguments)}}}(),K.ccall=IA,K.cwrap=AA,K.setValue=t,K.getValue=r;var iA=2,BA=4;K.ALLOC_NORMAL=0,K.ALLOC_STACK=1,K.ALLOC_STATIC=iA,K.ALLOC_DYNAMIC=3,K.ALLOC_NONE=BA,K.allocate=a,K.getMemory=function(A){return fA?FA?ZA(A):$.dynamicAlloc(A):$.staticAlloc(A)},K.Pointer_stringify=n,K.AsciiToString=function(A){for(var I="";;){var e=aA[A++>>0];if(!e)return I;I+=String.fromCharCode(e)}},K.stringToAscii=function(A,I){return M(A,I,!1)};var tA="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;K.UTF8ArrayToString=C,K.UTF8ToString=function(A){return C(nA,A)},K.stringToUTF8Array=o,K.stringToUTF8=c,K.lengthBytesUTF8=Q,"undefined"!=typeof TextDecoder&&new TextDecoder("utf-16le"),K.stackTrace=y;var rA,aA,nA,CA,oA,cA,QA,EA,sA,hA,yA,fA,_A,pA,wA,lA;hA=yA=_A=pA=wA=lA=0,fA=!1;var uA=K.TOTAL_STACK||5242880,dA=K.TOTAL_MEMORY||16777216;if(dA<uA&&K.printErr("TOTAL_MEMORY should be larger than TOTAL_STACK, was "+dA+"! (TOTAL_STACK="+uA+")"),K.buffer?rA=K.buffer:"object"==typeof WebAssembly&&"function"==typeof WebAssembly.Memory?(K.wasmMemory=new WebAssembly.Memory({initial:dA/65536,maximum:dA/65536}),rA=K.wasmMemory.buffer):rA=new ArrayBuffer(dA),p(),cA[0]=1668509029,CA[1]=25459,115!==nA[2]||99!==nA[3])throw"Runtime error: expected the system to be little-endian!";K.HEAP=void 0,K.buffer=rA,K.HEAP8=aA,K.HEAP16=CA,K.HEAP32=cA,K.HEAPU8=nA,K.HEAPU16=oA,K.HEAPU32=QA,K.HEAPF32=EA,K.HEAPF64=sA;var DA=[],vA=[],bA=[],kA=[],GA=[],FA=!1,mA=!1;if(K.addOnPreRun=G,K.addOnInit=function(A){vA.unshift(A)},K.addOnPreMain=function(A){bA.unshift(A)},K.addOnExit=function(A){kA.unshift(A)},K.addOnPostRun=F,K.writeStringToMemory=function(A,I,e){$.warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");var g,i;e&&(i=I+Q(A),g=aA[i]),c(A,I,1/0),e&&(aA[i]=g)},K.writeArrayToMemory=m,K.writeAsciiToMemory=M,Math.imul&&-5===Math.imul(4294967295,5)||(Math.imul=function(A,I){var e=65535&A,g=65535&I;return e*g+((A>>>16)*g+e*(I>>>16)<<16)|0}),Math.imul=Math.imul,!Math.fround){var MA=new Float32Array(1);Math.fround=function(A){return MA[0]=A,MA[0]}}Math.fround=Math.fround,Math.clz32||(Math.clz32=function(A){A>>>=0;for(var I=0;I<32;I++)if(A&1<<31-I)return I;return 32}),Math.clz32=Math.clz32,Math.trunc||(Math.trunc=function(A){return A<0?Math.ceil(A):Math.floor(A)}),Math.trunc=Math.trunc;var HA=Math.abs,YA=(Math.cos,Math.sin,Math.tan,Math.acos,Math.asin,Math.atan,Math.atan2,Math.exp,Math.log,Math.sqrt,Math.ceil),SA=Math.floor,RA=(Math.pow,Math.imul,Math.fround,Math.round,Math.min),NA=(Math.clz32,Math.trunc,0),UA=null,JA=null;K.addRunDependency=H,K.removeRunDependency=Y,K.preloadedImages={},K.preloadedAudios={};var PA=null;!function(){function A(A){var I=K.buffer;A.byteLength<I.byteLength&&K.printErr("the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here");var e=new Int8Array(I),g=new Int8Array(A);PA||e.set(g.subarray(K.STATIC_BASE,K.STATIC_BASE+K.STATIC_BUMP),K.STATIC_BASE),g.set(e),_(A),p()}function I(A){return A}function e(){try{if(K.wasmBinary)return new Uint8Array(K.wasmBinary);var A=J(r);if(A)return A;if(K.readBinary)return K.readBinary(r);throw"on the web, we need the wasm binary to be preloaded and set on Module['wasmBinary']. emcc.py will do that for you when generating HTML (but not JS)"}catch(A){X(A)}}function g(){return K.wasmBinary||!q&&!j||"function"!=typeof fetch?new Promise(function(A,I){A(e())}):fetch(r,{credentials:"same-origin"}).then(function(A){if(!A.ok)throw"failed to load wasm binary file at '"+r+"'";return A.arrayBuffer()}).catch(function(){return e()})}function i(I,e,i){function B(I){(C=I.exports).memory&&A(C.memory),K.asm=C,K.usingWasm=!0,Y("wasm-instantiate")}function t(A){B(A.instance)}function a(A){g().then(function(A){return WebAssembly.instantiate(A,n)}).then(A).catch(function(A){K.printErr("failed to asynchronously prepare wasm: "+A),X(A)})}if("object"!=typeof WebAssembly)return K.printErr("no native wasm support detected"),!1;if(!(K.wasmMemory instanceof WebAssembly.Memory))return K.printErr("no native wasm Memory in use"),!1;if(e.memory=K.wasmMemory,n.global={NaN:NaN,Infinity:1/0},n["global.Math"]=I.Math,n.env=e,H("wasm-instantiate"),K.instantiateWasm)try{return K.instantiateWasm(n,B)}catch(A){return K.printErr("Module.instantiateWasm callback failed with error: "+A),!1}return K.wasmBinary||"function"!=typeof WebAssembly.instantiateStreaming||0===r.indexOf("data:")||"function"!=typeof fetch?a(t):WebAssembly.instantiateStreaming(fetch(r,{credentials:"same-origin"}),n).then(t).catch(function(A){K.printErr("wasm streaming compile failed: "+A),K.printErr("falling back to ArrayBuffer instantiation"),a(t)}),{}}var B=K.wasmJSMethod||"native-wasm";K.wasmJSMethod=B;var t=K.wasmTextFile||"",r=K.wasmBinaryFile||"data:application/octet-stream;base64,AGFzbQEAAAAByQM0YAABf2AEf39/fwBgAX8AYAAAYAF/AX9gA39/fwF/YAJ/fwBgCn9/f39+f35/f38Bf2ACf34AYAl/f39+f35/f38Bf2AJf39/fn9/fn9/AX9gCX9/f39+f35/fwF/YAR/f35/AX9gA39/fgBgBH9/fn8AYAJ/fwF/YAZ/f39+f38Bf2AHf39/fn9/fwF/YAV/f35/fwF/YAZ/f35/f38Bf2ADf39/AGABfwF+YAN/f38BfmAEf39/fwF/YAN/f34Bf2ACfn8BfmAFf39/f38AYAZ/f39/fn8AYAV/f39/fwF/YAJ+fgF+YAx/f39/f39/f39/f38Bf2AHf35/fn9+fwF/YAV/f35+fwF/YAR/fn9/AX9gCH9+f35/fn9/AX9gBn9/fn5/fwF/YAN/fn8Bf2AIf39/f35/fn8Bf2AIf39/f39+f34Bf2AFf39/fn8Bf2AGf39/fn9/AGAFf39/fn8AYAR/fn9/AGAFf39+f38AYAZ/f35/f38AYAZ/f35/fn8AYAR/f39+AGAHf39/f39/fwF/YAh/f39/f39/fwF/YAt/f39/f39/f39/fwF/YAZ/f39/f38Bf2AKf39/f39/f39/fwF/Ar8CEANlbnYORFlOQU1JQ1RPUF9QVFIDfwADZW52CFNUQUNLVE9QA38AA2VudglTVEFDS19NQVgDfwADZW52DWVubGFyZ2VNZW1vcnkAAANlbnYOZ2V0VG90YWxNZW1vcnkAAANlbnYXYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkAAANlbnYOX19fYXNzZXJ0X2ZhaWwAAQNlbnYLX19fc2V0RXJyTm8AAgNlbnYGX2Fib3J0AAMDZW52F19lbXNjcmlwdGVuX2FzbV9jb25zdF9pAAQDZW52Fl9lbXNjcmlwdGVuX21lbWNweV9iaWcABQNlbnYIX3N5c2NvbmYABANlbnYGbWVtb3J5AgGAAoACA2VudgV0YWJsZQFwAAADZW52Cm1lbW9yeUJhc2UDfwADZW52CXRhYmxlQmFzZQN/AAP3AvUCBAACBgYCAAcICQcJCgsKCwAAAAACAAcJCgsADAwGDQYGDgwFDwUQERITEBESEwwUEgAFBQYVFgYGBgYUFBQUAgYEFAYEDwYGBgYGFAEGBgYUFAYCBgIUDxQGFAQGBAQBAgQXBA8GFBQUAAAQFxgFBhUZBgIGAgYGAQ0IGgUbGhAcFw0FGAINAQYVBgYUCA0SEgUPHBwGDQYODAYNDQYGBgYGBgYXBgQGBhQPDwUPFwYGFBQUHQIPHhcBHyAYIR8gGAAAAAAAAAAAAAAAACIgIxgkAA8FBQ8UFAYFDxASEBIFAgUCJQYmAAAMAg4ZAAUPJycnDAQYFwUBBRQGDw8SDCcGKAIpJxQqKywqKi0sBhQuFCsrDwUPAAMEBhQIFy8PAhwEBDAEBBwAAwMCBgUPAgMcFwAAKi0EAgQGBA8ABQQPDwMFBQUEMTExHjExMR4xMTEeHBwwLy8yMC8vMhwyLxcXMjEvMBcXLzIvMjMzHDIyMhccFAYfBn8BIwALfwEjAQt/ASMCC38BQQALfwFBAAt/AUEACwf0LsMBJF9jcnlwdG9fYWVhZF9jaGFjaGEyMHBvbHkxMzA1X2FieXRlcwAcJV9jcnlwdG9fYWVhZF9jaGFjaGEyMHBvbHkxMzA1X2RlY3J5cHQA0AIuX2NyeXB0b19hZWFkX2NoYWNoYTIwcG9seTEzMDVfZGVjcnlwdF9kZXRhY2hlZADRAiVfY3J5cHRvX2FlYWRfY2hhY2hhMjBwb2x5MTMwNV9lbmNyeXB0ANICLl9jcnlwdG9fYWVhZF9jaGFjaGEyMHBvbHkxMzA1X2VuY3J5cHRfZGV0YWNoZWQA0wIpX2NyeXB0b19hZWFkX2NoYWNoYTIwcG9seTEzMDVfaWV0Zl9hYnl0ZXMAHCpfY3J5cHRvX2FlYWRfY2hhY2hhMjBwb2x5MTMwNV9pZXRmX2RlY3J5cHQA1AIzX2NyeXB0b19hZWFkX2NoYWNoYTIwcG9seTEzMDVfaWV0Zl9kZWNyeXB0X2RldGFjaGVkANUCKl9jcnlwdG9fYWVhZF9jaGFjaGEyMHBvbHkxMzA1X2lldGZfZW5jcnlwdADWAjNfY3J5cHRvX2FlYWRfY2hhY2hhMjBwb2x5MTMwNV9pZXRmX2VuY3J5cHRfZGV0YWNoZWQA1wIrX2NyeXB0b19hZWFkX2NoYWNoYTIwcG9seTEzMDVfaWV0Zl9rZXlieXRlcwAZKV9jcnlwdG9fYWVhZF9jaGFjaGEyMHBvbHkxMzA1X2lldGZfa2V5Z2VuAB0sX2NyeXB0b19hZWFkX2NoYWNoYTIwcG9seTEzMDVfaWV0Zl9ucHViYnl0ZXMAGixfY3J5cHRvX2FlYWRfY2hhY2hhMjBwb2x5MTMwNV9pZXRmX25zZWNieXRlcwAbJl9jcnlwdG9fYWVhZF9jaGFjaGEyMHBvbHkxMzA1X2tleWJ5dGVzABkkX2NyeXB0b19hZWFkX2NoYWNoYTIwcG9seTEzMDVfa2V5Z2VuAB0nX2NyeXB0b19hZWFkX2NoYWNoYTIwcG9seTEzMDVfbnB1YmJ5dGVzAB4nX2NyeXB0b19hZWFkX2NoYWNoYTIwcG9seTEzMDVfbnNlY2J5dGVzABsqX2NyeXB0b19hZWFkX3hjaGFjaGEyMHBvbHkxMzA1X2lldGZfYWJ5dGVzABwrX2NyeXB0b19hZWFkX3hjaGFjaGEyMHBvbHkxMzA1X2lldGZfZGVjcnlwdADYAjRfY3J5cHRvX2FlYWRfeGNoYWNoYTIwcG9seTEzMDVfaWV0Zl9kZWNyeXB0X2RldGFjaGVkANkCK19jcnlwdG9fYWVhZF94Y2hhY2hhMjBwb2x5MTMwNV9pZXRmX2VuY3J5cHQA2gI0X2NyeXB0b19hZWFkX3hjaGFjaGEyMHBvbHkxMzA1X2lldGZfZW5jcnlwdF9kZXRhY2hlZADbAixfY3J5cHRvX2FlYWRfeGNoYWNoYTIwcG9seTEzMDVfaWV0Zl9rZXlieXRlcwAZKl9jcnlwdG9fYWVhZF94Y2hhY2hhMjBwb2x5MTMwNV9pZXRmX2tleWdlbgAdLV9jcnlwdG9fYWVhZF94Y2hhY2hhMjBwb2x5MTMwNV9pZXRmX25wdWJieXRlcwAjLV9jcnlwdG9fYWVhZF94Y2hhY2hhMjBwb2x5MTMwNV9pZXRmX25zZWNieXRlcwAbDF9jcnlwdG9fYXV0aADcAhJfY3J5cHRvX2F1dGhfYnl0ZXMAGRVfY3J5cHRvX2F1dGhfa2V5Ynl0ZXMAGRNfY3J5cHRvX2F1dGhfa2V5Z2VuAB0TX2NyeXB0b19hdXRoX3ZlcmlmeQDdAhRfY3J5cHRvX2JveF9iZWZvcmVubQAuGV9jcnlwdG9fYm94X2JlZm9yZW5tYnl0ZXMAGRRfY3J5cHRvX2JveF9kZXRhY2hlZADeAhxfY3J5cHRvX2JveF9kZXRhY2hlZF9hZnRlcm5tAN8CEF9jcnlwdG9fYm94X2Vhc3kA4AIYX2NyeXB0b19ib3hfZWFzeV9hZnRlcm5tAOECE19jcnlwdG9fYm94X2tleXBhaXIALRRfY3J5cHRvX2JveF9tYWNieXRlcwAcFl9jcnlwdG9fYm94X25vbmNlYnl0ZXMAIxlfY3J5cHRvX2JveF9vcGVuX2RldGFjaGVkAOICIV9jcnlwdG9fYm94X29wZW5fZGV0YWNoZWRfYWZ0ZXJubQDjAhVfY3J5cHRvX2JveF9vcGVuX2Vhc3kA5AIdX2NyeXB0b19ib3hfb3Blbl9lYXN5X2FmdGVybm0A5QIaX2NyeXB0b19ib3hfcHVibGlja2V5Ynl0ZXMAGRBfY3J5cHRvX2JveF9zZWFsAOYCFV9jcnlwdG9fYm94X3NlYWxfb3BlbgDnAhVfY3J5cHRvX2JveF9zZWFsYnl0ZXMAOhpfY3J5cHRvX2JveF9zZWNyZXRrZXlieXRlcwAZGF9jcnlwdG9fYm94X3NlZWRfa2V5cGFpcgAsFV9jcnlwdG9fYm94X3NlZWRieXRlcwAZFl9jcnlwdG9fY29yZV9oY2hhY2hhMjAAayFfY3J5cHRvX2NvcmVfaGNoYWNoYTIwX2NvbnN0Ynl0ZXMAHCFfY3J5cHRvX2NvcmVfaGNoYWNoYTIwX2lucHV0Ynl0ZXMAHB9fY3J5cHRvX2NvcmVfaGNoYWNoYTIwX2tleWJ5dGVzABkiX2NyeXB0b19jb3JlX2hjaGFjaGEyMF9vdXRwdXRieXRlcwAZE19jcnlwdG9fZ2VuZXJpY2hhc2gA6AIZX2NyeXB0b19nZW5lcmljaGFzaF9ieXRlcwAZHV9jcnlwdG9fZ2VuZXJpY2hhc2hfYnl0ZXNfbWF4AHIdX2NyeXB0b19nZW5lcmljaGFzaF9ieXRlc19taW4AHBlfY3J5cHRvX2dlbmVyaWNoYXNoX2ZpbmFsAHcYX2NyeXB0b19nZW5lcmljaGFzaF9pbml0AHUcX2NyeXB0b19nZW5lcmljaGFzaF9rZXlieXRlcwAZIF9jcnlwdG9fZ2VuZXJpY2hhc2hfa2V5Ynl0ZXNfbWF4AHIgX2NyeXB0b19nZW5lcmljaGFzaF9rZXlieXRlc19taW4AHBpfY3J5cHRvX2dlbmVyaWNoYXNoX2tleWdlbgAdHl9jcnlwdG9fZ2VuZXJpY2hhc2hfc3RhdGVieXRlcwBzGl9jcnlwdG9fZ2VuZXJpY2hhc2hfdXBkYXRlAOkCDF9jcnlwdG9faGFzaADqAhJfY3J5cHRvX2hhc2hfYnl0ZXMAchVfY3J5cHRvX2tkZl9ieXRlc19tYXgAchVfY3J5cHRvX2tkZl9ieXRlc19taW4AHBhfY3J5cHRvX2tkZl9jb250ZXh0Ynl0ZXMAHhtfY3J5cHRvX2tkZl9kZXJpdmVfZnJvbV9rZXkA6wIUX2NyeXB0b19rZGZfa2V5Ynl0ZXMAGRJfY3J5cHRvX2tkZl9rZXlnZW4AHR5fY3J5cHRvX2t4X2NsaWVudF9zZXNzaW9uX2tleXMAnAESX2NyeXB0b19reF9rZXlwYWlyAJsBGV9jcnlwdG9fa3hfcHVibGlja2V5Ynl0ZXMAGRlfY3J5cHRvX2t4X3NlY3JldGtleWJ5dGVzABkXX2NyeXB0b19reF9zZWVkX2tleXBhaXIAmgEUX2NyeXB0b19reF9zZWVkYnl0ZXMAGR5fY3J5cHRvX2t4X3NlcnZlcl9zZXNzaW9uX2tleXMAnQEaX2NyeXB0b19reF9zZXNzaW9ua2V5Ynl0ZXMAGQ5fY3J5cHRvX3B3aGFzaADsAhxfY3J5cHRvX3B3aGFzaF9hbGdfYXJnb24yaTEzAMoBHV9jcnlwdG9fcHdoYXNoX2FsZ19hcmdvbjJpZDEzAMsBGl9jcnlwdG9fcHdoYXNoX2FsZ19kZWZhdWx0AMsBGF9jcnlwdG9fcHdoYXNoX2J5dGVzX21heADMARhfY3J5cHRvX3B3aGFzaF9ieXRlc19taW4AHCNfY3J5cHRvX3B3aGFzaF9tZW1saW1pdF9pbnRlcmFjdGl2ZQDRARtfY3J5cHRvX3B3aGFzaF9tZW1saW1pdF9tYXgA0AEbX2NyeXB0b19wd2hhc2hfbWVtbGltaXRfbWluAM8BIF9jcnlwdG9fcHdoYXNoX21lbWxpbWl0X21vZGVyYXRlANMBIV9jcnlwdG9fcHdoYXNoX21lbWxpbWl0X3NlbnNpdGl2ZQDVASNfY3J5cHRvX3B3aGFzaF9vcHNsaW1pdF9pbnRlcmFjdGl2ZQDLARtfY3J5cHRvX3B3aGFzaF9vcHNsaW1pdF9tYXgAzAEbX2NyeXB0b19wd2hhc2hfb3BzbGltaXRfbWluAMoBIF9jcnlwdG9fcHdoYXNoX29wc2xpbWl0X21vZGVyYXRlANIBIV9jcnlwdG9fcHdoYXNoX29wc2xpbWl0X3NlbnNpdGl2ZQDUARlfY3J5cHRvX3B3aGFzaF9wYXNzd2RfbWF4AMwBGV9jcnlwdG9fcHdoYXNoX3Bhc3N3ZF9taW4AGxhfY3J5cHRvX3B3aGFzaF9wcmltaXRpdmUA2wEYX2NyeXB0b19wd2hhc2hfc2FsdGJ5dGVzABwSX2NyeXB0b19wd2hhc2hfc3RyAO0CFl9jcnlwdG9fcHdoYXNoX3N0cl9hbGcA7gIfX2NyeXB0b19wd2hhc2hfc3RyX25lZWRzX3JlaGFzaADvAhlfY3J5cHRvX3B3aGFzaF9zdHJfdmVyaWZ5APACF19jcnlwdG9fcHdoYXNoX3N0cmJ5dGVzAM0BGF9jcnlwdG9fcHdoYXNoX3N0cnByZWZpeADOARJfY3J5cHRvX3NjYWxhcm11bHQA3QEXX2NyeXB0b19zY2FsYXJtdWx0X2Jhc2UA3AEYX2NyeXB0b19zY2FsYXJtdWx0X2J5dGVzABkeX2NyeXB0b19zY2FsYXJtdWx0X3NjYWxhcmJ5dGVzABkaX2NyeXB0b19zZWNyZXRib3hfZGV0YWNoZWQA8QIWX2NyeXB0b19zZWNyZXRib3hfZWFzeQDyAhpfY3J5cHRvX3NlY3JldGJveF9rZXlieXRlcwAZGF9jcnlwdG9fc2VjcmV0Ym94X2tleWdlbgAdGl9jcnlwdG9fc2VjcmV0Ym94X21hY2J5dGVzABwcX2NyeXB0b19zZWNyZXRib3hfbm9uY2VieXRlcwAjH19jcnlwdG9fc2VjcmV0Ym94X29wZW5fZGV0YWNoZWQA8wIbX2NyeXB0b19zZWNyZXRib3hfb3Blbl9lYXN5APQCLV9jcnlwdG9fc2VjcmV0c3RyZWFtX3hjaGFjaGEyMHBvbHkxMzA1X2FieXRlcwDxATJfY3J5cHRvX3NlY3JldHN0cmVhbV94Y2hhY2hhMjBwb2x5MTMwNV9oZWFkZXJieXRlcwAjMF9jcnlwdG9fc2VjcmV0c3RyZWFtX3hjaGFjaGEyMHBvbHkxMzA1X2luaXRfcHVsbADrATBfY3J5cHRvX3NlY3JldHN0cmVhbV94Y2hhY2hhMjBwb2x5MTMwNV9pbml0X3B1c2gA6QEvX2NyeXB0b19zZWNyZXRzdHJlYW1feGNoYWNoYTIwcG9seTEzMDVfa2V5Ynl0ZXMAGS1fY3J5cHRvX3NlY3JldHN0cmVhbV94Y2hhY2hhMjBwb2x5MTMwNV9rZXlnZW4AHTdfY3J5cHRvX3NlY3JldHN0cmVhbV94Y2hhY2hhMjBwb2x5MTMwNV9tZXNzYWdlYnl0ZXNfbWF4AMwBK19jcnlwdG9fc2VjcmV0c3RyZWFtX3hjaGFjaGEyMHBvbHkxMzA1X3B1bGwA9QIrX2NyeXB0b19zZWNyZXRzdHJlYW1feGNoYWNoYTIwcG9seTEzMDVfcHVzaAD2AixfY3J5cHRvX3NlY3JldHN0cmVhbV94Y2hhY2hhMjBwb2x5MTMwNV9yZWtleQDsATFfY3J5cHRvX3NlY3JldHN0cmVhbV94Y2hhY2hhMjBwb2x5MTMwNV9zdGF0ZWJ5dGVzAPABMF9jcnlwdG9fc2VjcmV0c3RyZWFtX3hjaGFjaGEyMHBvbHkxMzA1X3RhZ19maW5hbADSATJfY3J5cHRvX3NlY3JldHN0cmVhbV94Y2hhY2hhMjBwb2x5MTMwNV90YWdfbWVzc2FnZQAbL19jcnlwdG9fc2VjcmV0c3RyZWFtX3hjaGFjaGEyMHBvbHkxMzA1X3RhZ19wdXNoAMoBMF9jcnlwdG9fc2VjcmV0c3RyZWFtX3hjaGFjaGEyMHBvbHkxMzA1X3RhZ19yZWtleQDLARFfY3J5cHRvX3Nob3J0aGFzaAD3AhdfY3J5cHRvX3Nob3J0aGFzaF9ieXRlcwAeGl9jcnlwdG9fc2hvcnRoYXNoX2tleWJ5dGVzABwYX2NyeXB0b19zaG9ydGhhc2hfa2V5Z2VuAPMBDF9jcnlwdG9fc2lnbgD4AhJfY3J5cHRvX3NpZ25fYnl0ZXMAchVfY3J5cHRvX3NpZ25fZGV0YWNoZWQA+QIlX2NyeXB0b19zaWduX2VkMjU1MTlfcGtfdG9fY3VydmUyNTUxOQCFAiVfY3J5cHRvX3NpZ25fZWQyNTUxOV9za190b19jdXJ2ZTI1NTE5AIYCGV9jcnlwdG9fc2lnbl9maW5hbF9jcmVhdGUA/wEZX2NyeXB0b19zaWduX2ZpbmFsX3ZlcmlmeQCAAhFfY3J5cHRvX3NpZ25faW5pdAD9ARRfY3J5cHRvX3NpZ25fa2V5cGFpcgD4ARFfY3J5cHRvX3NpZ25fb3BlbgD6AhtfY3J5cHRvX3NpZ25fcHVibGlja2V5Ynl0ZXMAGRtfY3J5cHRvX3NpZ25fc2VjcmV0a2V5Ynl0ZXMAchlfY3J5cHRvX3NpZ25fc2VlZF9rZXlwYWlyAPcBFl9jcnlwdG9fc2lnbl9zZWVkYnl0ZXMAGRdfY3J5cHRvX3NpZ25fc3RhdGVieXRlcwD2ARNfY3J5cHRvX3NpZ25fdXBkYXRlAPsCHF9jcnlwdG9fc2lnbl92ZXJpZnlfZGV0YWNoZWQA/AIVX2NyeXB0b19zdHJlYW1fa2V5Z2VuAB0bX2Vtc2NyaXB0ZW5fZ2V0X2dsb2JhbF9saWJjAMYCBV9mcmVlAMECB19tYWxsb2MAwAIHX21lbWNweQDMAghfbWVtbW92ZQDNAgdfbWVtc2V0AM4CDF9yYW5kb21ieXRlcwD9AhBfcmFuZG9tYnl0ZXNfYnVmAKMCHl9yYW5kb21ieXRlc19idWZfZGV0ZXJtaW5pc3RpYwCkAhJfcmFuZG9tYnl0ZXNfY2xvc2UAGxNfcmFuZG9tYnl0ZXNfcmFuZG9tAKACFl9yYW5kb21ieXRlc19zZWVkYnl0ZXMAGRFfcmFuZG9tYnl0ZXNfc3RpcgChAhRfcmFuZG9tYnl0ZXNfdW5pZm9ybQCiAgVfc2JyawDPAhJfc29kaXVtX2Jhc2U2NDJiaW4ArQIaX3NvZGl1bV9iYXNlNjRfZW5jb2RlZF9sZW4AqAISX3NvZGl1bV9iaW4yYmFzZTY0AKoCD19zb2RpdW1fYmluMmhleACmAg9fc29kaXVtX2hleDJiaW4ApwIMX3NvZGl1bV9pbml0ALECF19zb2RpdW1fbGlicmFyeV9taW5pbWFsAMoBHV9zb2RpdW1fbGlicmFyeV92ZXJzaW9uX21ham9yAL0CHV9zb2RpdW1fbGlicmFyeV92ZXJzaW9uX21pbm9yABsLX3NvZGl1bV9wYWQAugINX3NvZGl1bV91bnBhZAC7AhZfc29kaXVtX3ZlcnNpb25fc3RyaW5nALwCE2VzdGFibGlzaFN0YWNrU3BhY2UADAtnZXRUZW1wUmV0MAAPC3J1blBvc3RTZXRzAMsCC3NldFRlbXBSZXQwAA4Ic2V0VGhyZXcADQpzdGFja0FsbG9jAAkMc3RhY2tSZXN0b3JlAAsJc3RhY2tTYXZlAAoJAQAK2OEE9QIbAQF/IwYhASMGIABqJAYjBkEPakFwcSQGIAELBAAjBgsGACAAJAYLCgAgACQGIAEkBwsQACMIRQRAIAAkCCABJAkLCwYAIAAkCgsEACMKC5QBAQJ/IwYhCiMGQdACaiQGIApBiAJqIgsgCCAJEI8CIAoiByALEJ4BIAtBwAAQtQIgByAFIAYQnwEgCkGAAmoiBSAGEBEgByAFQggQnwEgACADIAQgCCAJEJECIAcgACAEEJ8BIAUgBBARIAcgBUIIEJ8BIAcgARCgASAHQYACELUCIAIEQCACQhA3AwALIAokBkEACwkAIAAgATcAAAs9ACADQu////8PVgRAELICCyAAIAAgA6dqQQAgAiADIAQgBUEAIAcgCBAQGiABBEAgASADQhB8NwMAC0EAC7sBAQJ/IwYhCiMGQdACaiQGIApBiAJqIgtCwAAgCCAJEJACIAoiByALEJ4BIAtBwAAQtQIgByAFIAYQnwEgB0HImwJCACAGfUIPgxCfASAAIAMgBCAIQQEgCRCSAiAHIAAgBBCfASAHQcibAkIAIAR9Qg+DEJ8BIApBgAJqIgAgBhARIAcgAEIIEJ8BIAAgBBARIAcgAEIIEJ8BIAcgARCgASAHQYACELUCIAIEQCACQhA3AwALIAokBkEACz0AIANC7////w9WBEAQsgILIAAgACADp2pBACACIAMgBCAFQQAgByAIEBMaIAEEQCABIANCEHw3AwALQQALugEBAn8jBiEJIwZB4AJqJAYgCUGYAmoiCiAHIAgQjwIgCSIBIAoQngEgCkHAABC1AiABIAUgBhCfASAJQZACaiIFIAYQESABIAVCCBCfASABIAIgAxCfASAFIAMQESABIAVCCBCfASABIAlBgAJqIgUQoAEgAUGAAhC1AiAFIAQQnQIhASAFQRAQtQIgAARAIAEEfyAAQQAgA6cQzgIaQX8FIAAgAiADIAcgCBCRAkEACyEBCyAJJAYgAQtFAQF/IARCD1YEfyAAQQAgAyAEQnB8IAMgBKdqQXBqIAUgBiAHIAgQFQVBfwshCSABBEAgAUIAIARCcHwgCRs3AwALIAkL4QEBAn8jBiEJIwZB4AJqJAYgCUGYAmoiCkLAACAHIAgQkAIgCSIBIAoQngEgCkHAABC1AiABIAUgBhCfASABQcibAkIAIAZ9Qg+DEJ8BIAEgAiADEJ8BIAFByJsCQgAgA31CD4MQnwEgCUGQAmoiBSAGEBEgASAFQggQnwEgBSADEBEgASAFQggQnwEgASAJQYACaiIFEKABIAFBgAIQtQIgBSAEEJ0CIQEgBUEQELUCIAAEQCABBH8gAEEAIAOnEM4CGkF/BSAAIAIgAyAHQQEgCBCSAkEACyEBCyAJJAYgAQtFAQF/IARCD1YEfyAAQQAgAyAEQnB8IAMgBKdqQXBqIAUgBiAHIAgQFwVBfwshCSABBEAgAUIAIARCcHwgCRs3AwALIAkLBABBIAsEAEEMCwQAQQALBABBEAsJACAAQSAQowILBABBCAtWAQJ/IwYhByMGQTBqJAYgByIKQQA2AgAgB0EQaiILIAggCUEAEGsaIAogCCkAEDcCBCAAIAEgAiADIAQgBSAGQQAgCiALEBMaIAtBIBC1AiAHJAZBAAs5ACADQm9WBEAQsgILIAAgACADp2pBACACIAMgBCAFQQAgByAIEB8aIAEEQCABIANCEHw3AwALQQALVQECfyMGIQEjBkEwaiQGIAEiCUEANgIAIAFBEGoiCiAHIAhBABBrGiAJIAcpABA3AgQgAEEAIAIgAyAEIAUgBiAJIAoQFyEAIApBIBC1AiABJAYgAAtFAQF/IARCD1YEfyAAQQAgAyAEQnB8IAMgBKdqQXBqIAUgBiAHIAgQIQVBfwshCSABBEAgAUIAIARCcHwgCRs3AwALIAkLBABBGAsOACAAIAEgAiADECpBAAsMACAAIAEgAiADECsL1QUBBX8jBiEEIwZBwAFqJAYgBCEGIAAQjgEgBEHAAGoiA0EBaiICQrbs2LHjxo2bNjcAACACQrbs2LHjxo2bNjcACCACQrbs2LHjxo2bNjcAECACQrbs2LHjxo2bNjcAGCACQrbs2LHjxo2bNjcAICACQrbs2LHjxo2bNjcAKCACQrbs2LHjxo2bNjcAMCACQrbs2LHjxo2bNjcAOCACQrbs2LHjxo2bNjcAQCACQrbs2LHjxo2bNjcASCACQrbs2LHjxo2bNjcAUCACQrbs2LHjxo2bNjcAWCACQrbs2LHjxo2bNjcAYCACQrbs2LHjxo2bNjcAaCACQrbs2LHjxo2bNjcAcCACQbbs2LEDNgB4IAJBtuwAOwB8IAJBNjoAfiADIAEsAABBNnM6AABBASECA0AgAyACaiIFIAUsAAAgASACaiwAAHM6AAAgAkEBaiICQSBHDQALIAAgA0KAARCPASAAQdABaiICEI4BIANBAWoiAELcuPHixYuXrtwANwAAIABC3Ljx4sWLl67cADcACCAAQty48eLFi5eu3AA3ABAgAELcuPHixYuXrtwANwAYIABC3Ljx4sWLl67cADcAICAAQty48eLFi5eu3AA3ACggAELcuPHixYuXrtwANwAwIABC3Ljx4sWLl67cADcAOCAAQty48eLFi5eu3AA3AEAgAELcuPHixYuXrtwANwBIIABC3Ljx4sWLl67cADcAUCAAQty48eLFi5eu3AA3AFggAELcuPHixYuXrtwANwBgIABC3Ljx4sWLl67cADcAaCAAQty48eLFi5eu3AA3AHAgAEHcuPHiBTYAeCAAQdy4ATsAfCAAQdwAOgB+IAMgASwAAEHcAHM6AABBASEAA0AgAyAAaiIFIAUsAAAgASAAaiwAAHM6AAAgAEEBaiIAQSBHDQALIAIgA0KAARCPASADQYABELUCIAZBwAAQtQIgBCQGCwsAIAAgASACEI8BCzwBAn8jBiECIwZBwABqJAYgACACIgMQkwEgAEHQAWoiACADQsAAEI8BIAAgARCTASADQcAAELUCIAIkBgtEAQF/IwYhAiMGQcAAaiQGIAAgAiIAECggASAAKQAANwAAIAEgACkACDcACCABIAApABA3ABAgASAAKQAYNwAYIAIkBgssAQJ/IwYhBCMGQaADaiQGIAQiBSADECYgBSIDIAEgAhAnIAUgABApIAQkBgs8AQJ/IwYhBSMGQSBqJAYgBSIEIAEgAiADECpBfyAAIAQQnwIgBCAARhsgBCAAQSAQtgJyIQAgBSQGIAALCgAgACABIAIQOwsQACABQSAQowIgACABEOQBCwoAIAAgASACEDwLFAAgACABIAIgAyAEIAUQ5QEaQQALPwECfyMGIQcjBkEgaiQGIAciCCAFIAYQLgR/QX8FIAAgASACIAMgBCAIEC8aIAhBIBC1AkEACyEAIAckBiAACykAIAJC7////w9WBEAQsgIFIABBEGogACABIAIgAyAEEC8aQQAPC0EACygAIAJC7////w9WBEAQsgIFIABBEGogACABIAIgAyAEIAUQMA8LQQALEQAgACABIAIgAyAEIAUQ5wELPgECfyMG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fyMGIQYjBkE/akFAcSQGIwYhAiMGQeANaiQGIAJB4ANqIgUgARBRIAJBwAJqIgMgARBXIAIiASADEFAgAyABIAUQRSACQaABaiIEIAMQUCAFQaABaiICIAQQUSADIAEgAhBFIAQgAxBQIAVBwAJqIgIgBBBRIAMgASACEEUgBCADEFAgBUHgA2oiAiAEEFEgAyABIAIQRSAEIAMQUCAFQYAFaiICIAQQUSADIAEgAhBFIAQgAxBQIAVBoAZqIgIgBBBRIAMgASACEEUgBCADEFAgBUHAB2oiAiAEEFEgAyABIAIQRSAEIAMQUCAFQeAIaiAEEFEgABBeQfwBIQEDQCADIAAQVyABQcyJAmosAAAiAkEASgRAIAQgAxBQIAMgBCAFIAJB/wFxQQF2QaABbGoQRQUgAkEASARAIAQgAxBQIAMgBCAFIAJBfm1BGHRBGHVBoAFsahBUCwsgACADEFAgAUF/aiECIAFBAEoEQCACIQEMAQsLIAYkBgtQAQJ/IAAsAB9B/wBxQf8AcyEBQR4hAgNAIAEgACACaiwAAEF/c3IhASACQX9qIgINAAtB7AEgAC0AAGsgAUH/AXFB/wNqcUEIdkEBcUEBcwueAQEHfyAALAAAIQdBACECA0ACQEEAIQVBACEDIAJBBXRBgAhqLAAAIQQgByEBA0AgBCABc0H/AXEgA3IhAyAAIAVBAWoiAWosAAAhBiACQQV0QYAIaiABaiwAACEEIAFBH0cEQCABIQUgBiEBDAELCyAGQf8AcSAEc0H/AXEgA3JFBEBBASEADAELIAJBAWoiAkEHSQ0BQQAhAAsLIAALsiACAX84fiABLAAAIAEsAAEgAUECaiIELAAAED9C////AIMhByAEED5CBYhC////AIMhBiABLAAFIAEsAAYgAUEHaiIELAAAED9CAohC////AIMhBSAEED5CB4hC////AIMhESABQQpqED5CBIhC////AIMhCCABLAANIAEsAA4gAUEPaiIELAAAED9CAYhC////AIMhDiAEED5CBohC////AIMhCiABLAASIAEsABMgASwAFBA/QgOIQv///wCDIQsgASwAFSABLAAWIAFBF2oiBCwAABA/Qv///wCDIRIgBBA+QgWIQv///wCDIQwgASwAGiABLAAbIAFBHGoiASwAABA/QgKIQv///wCDIQkgARA+QgeIIQ8gAiwAACACLAABIAJBAmoiASwAABA/Qv///wCDIRkgARA+QgWIQv///wCDIRogAiwABSACLAAGIAJBB2oiASwAABA/QgKIQv///wCDIRsgARA+QgeIQv///wCDIRwgAkEKahA+QgSIQv///wCDIRMgAiwADSACLAAOIAJBD2oiASwAABA/QgGIQv///wCDIRYgARA+QgaIQv///wCDIRcgAiwAEiACLAATIAIsABQQP0IDiEL///8AgyEYIAIsABUgAiwAFiACQRdqIgEsAAAQP0L///8AgyEUIAEQPkIFiEL///8AgyEVIAIsABogAiwAGyACQRxqIgEsAAAQP0ICiEL///8AgyEQIAEQPkIHiCENIAMsAAAgAywAASADQQJqIgEsAAAQP0L///8AgyEfIAEQPkIFiEL///8AgyEgIAMsAAUgAywABiADQQdqIgEsAAAQP0ICiEL///8AgyEqIAEQPkIHiEL///8AgyErIANBCmoQPkIEiEL///8AgyEsIAMsAA0gAywADiADQQ9qIgEsAAAQP0IBiEL///8AgyEtIAEQPkIGiEL///8AgyEuIAMsABIgAywAEyADLAAUED9CA4hC////AIMhLyADLAAVIAMsABYgA0EXaiIBLAAAED9C////AIMhJiABED5CBYhC////AIMhJyAaIAx+IBkgCX58IBsgEn58IBwgC358IBMgCn58IBYgDn58IBcgCH58IBQgBX58IBggEX58IBUgBn58IBAgB358IAMsABogAywAGyADQRxqIgEsAAAQP0ICiEL///8Ag3wiMEKAgMAAfEIVhyEjIBUgCX4gFCAPfnwgECAMfnwgDSASfnwgGCAPfiAUIAl+fCAVIAx+fCAQIBJ+fCANIAt+fCIhQoCAwAB8QhWHIh18ISIgGiAHfiAZIAZ+fCAgfCAfIBkgB358IjFCgIDAAHxCFYgiMnwiM0KAgMAAfEIViCEpIBQgDH4gFyAPfnwgGCAJfnwgFSASfnwgECALfnwgDSAKfnwgFyAJfiAWIA9+fCAUIBJ+fCAYIAx+fCAVIAt+fCAQIAp+fCANIA5+fCIgQoCAwAB8QhWHIh58IjRCgIDAAHxCFYciNSAhIB1CFYZ9fCEfICAgDSAPfiIhQoCAwAB8QhWHIiBCg6FWfnwgHkIVhn0gFiAJfiATIA9+fCAXIAx+fCAU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fCIjNwMAIAsgJyAjhUE/EHo3AwAgLSABKQMAIiQgKHwgGikDAHwiKIVBIBB6IScgISAoICQgBikDACAnfCIkhUEYEHoiKHwgGSkDAHwiJTcDACAOICcgJYVBEBB6Iic3AwAgBiAkICd8Iic3AwAgASAoICeFQT8QejcDACAAICYgACkDAIUgI4U3AwBBASEBA0AgACABQQN0aiICICIgAikDAIUgAyABQQhqQQN0aikDAIU3AwAgAUEBaiIBQQhHBEAgAyABQQN0aikDACEiDAELCyAeJAYLBwAgACkAAAsTACAAQcAAIAFrrYYgACABrYiECz4CAn8BfiAAEHxBACECA0AgASACQQN0ahB5IQQgACACQQN0aiIDIAMpAwAgBIU3AwAgAkEBaiICQQhHDQALC2kAIABB4AkpAwA3AwAgAEHoCSkDADcDCCAAQfAJKQMANwMQIABB+AkpAwA3AxggAEGACikDADcDICAAQYgKKQMANwMoIABBkAopAwA3AzAgAEGYCikDADcDOCAAQcAAakEAQaUCEM4CGgucAQECfyMGIQMjBkE/akFAcSQGIwYhAiMGQcAAaiQGIAFBf2pBGHRBGHVB/wFxQT9KBEAQsgIFIAIgAToAACACQQA6AAEgAkEBOgACIAJBAToAAyACQQRqEH4gAkEIakIAEBEgAkEQaiIBQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCAAIAIQeyADJAYLCwkAIABBADYAAAsdAQF/IABBIGoiAiABKQAANwAAIAIgASkACDcACAsdAQF/IABBMGoiAiABKQAANwAAIAIgASkACDcACAuBAgEDfyMGIQYjBkE/akFAcSQGIwYhBSMGQcABaiQGIAFBf2pBGHRBGHVB/wFxQT9KBEAQsgILIAVBgAFqIQQgA0F/akEYdEEYdUH/AXFBP0ogAkVyBEAQsgIFIAQgAToAACAEIAM6AAEgBEEBOgACIARBAToAAyAEQQRqEH4gBEEIakIAEBEgBEEQaiIBQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCAAIAQQeyAFIANB/wFxIgFqQQBBAEGAASABayADQRh0QRh1QQBIGxDOAhogBSACIAEQzAIaIAAgBUKAARCCASAFQYABELUCIAYkBgsL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AhAhCyAAQRRqIg0oAgAhBCAAQRhqIg4oAgAhAyAAQRxqIg8oAgAhBSAAQSBqIhAoAgAhBiAAQSRqIhEoAgAhByACQg9WBEAgACgCAK0hEyALQQVsrSEUIApBBWytIRsgCUEFbK0hHSAIQQVsrSEfIAitIRUgCa0hHCAKrSEeIAutISAgAyEAIAEhAwNAIAMQbEH///8fcSAEaiEBIANBA2oQbEECdkH///8fcSAAaq0iFiAUfiABrSIXIBN+fCADQQZqEGxBBHZB////H3EgBWqtIhggG358IANBCWoQbEEGdiAGaq0iGSAdfnwgA0EMahBsQQh2IAxyIAdqrSIaIB9+fCISpyEEIBYgFX4gFyAcfnwgGCATfnwgGSAUfnwgGiAbfnwgFiATfiAXIBV+fCAYIBR+fCAZIBt+fCAaIB1+fCASQhqIQv////8Pg3wiIUIaiEL/////D4N8IhKnQf///x9xIQUgFiAcfiAXIB5+fCAYIBV+fCAZIBN+fCAaIBR+fCASQhqIQv////8Pg3wiEqdB////H3EhBiAWIB5+IBcgIH58IBggHH58IBkgFX58IBogE358IBJCGohC/////w+DfCISp0H///8fcSEHIBJCGoinQQVsIgAgBGpB////H3EhASAAIARB////H3FqQRp2ICGnQf///x9xaiEAIANBEGohAyACQnB8IgJCD1YEQCABIQQMAQsLBSAEIQEgAyEACyANIAE2AgAgDiAANgIAIA8gBTYCACAQIAY2AgAgESAHNgIAC5YCAgF/A34CQAJAIABBOGoiAykDACIEQgBRDQAgAkIQIAR9IgUgBSACVhsiBkIAUgRAQgAhBQNAIABBwABqIAQgBXynaiABIAWnaiwAADoAACADKQMAIQQgBUIBfCIFIAZUDQALCyADIAQgBnwiBDcDACAEQhBaBEAgACAAQcAAakIQEKQBIANCADcDACABIAanaiEBIAIgBn0hAgwBCwwBCyACQnCDIQQgAkIPVgR+IAAgASAEEKQBIAEgBKdqIQEgAiAEfQUgAgsiBUIAUgRAQgAhAiADKQMAIQQDQCAAQcAAaiAEIAJ8p2ogASACp2osAAA6AAAgAykDACEEIAJCAXwiAiAFVA0ACyADIAQgBXw3AwALCwu+AQEBfyAAIAEQbEH///8fcTYCACAAIAFBA2oQbEECdkGD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AzYCHCAAIAM2AiAgACADNgIkIAAgAzYCKCAAIAM2AiwgACADNgIwIAAgAzYCNCAAIAM2AjggACADNgI8IABBwABqIQAMAQsLA0AgACAFSARAIAAgAzYCACAAQQRqIQAMAQsLCwNAIAAgBEgEQCAAIAE6AAAgAEEBaiEADAELCyAEIAJrC1sBAn8jBSgCACICIABBD2pBcHEiAGohASAAQQBKIAEgAkhxIAFBAEhyBEAQAhpBDBAEQX8PCyMFIAE2AgAgARABSgRAEABFBEAjBSACNgIAQQwQBEF/DwsLIAILJgAgACABIAIgAyAErSAFrUIghoQgBiAHrSAIrUIghoQgCSAKEBYLJgAgACABIAIgA60gBK1CIIaEIAUgBiAHrSAIrUIghoQgCSAKEBULJgAgACABIAIgA60gBK1CIIaEIAUgBq0gB61CIIaEIAggCSAKEBILKAAgACABIAIgAyAErSAFrUIghoQgBiAHrSAIrUIghoQgCSAKIAsQEAsmACAAIAEgAiADIAStIAWtQiCGhCAGIAetIAitQiCGhCAJIAoQGAsmACAAIAEgAiADrSAErUIghoQgBSAGIAetIAitQiCGhCAJIAoQFwsmACAAIAEgAiADrSAErUIghoQgBSAGrSAHrUIghoQgCCAJIAoQFAsoACAAIAEgAiADIAStIAWtQiCGhCAGIAetIAitQiCGhCAJIAogCxATCyYAIAAgASACIAMgBK0gBa1CIIaEIAYgB60gCK1CIIaEIAkgChAiCyYAIAAgASACIAOtIAStQiCGhCAFIAYgB60gCK1CIIaEIAkgChAhCyYAIAAgASACIAOtIAStQiCGhCAFIAatIAetQiCGhCAIIAkgChAgCygAIAAgASACIAMgBK0gBa1CIIaEIAYgB60gCK1CIIaEIAkgCiALEB8LFAAgACABIAKtIAOtQiCGhCAEECQLFAAgACABIAKtIAOtQiCGhCAEECULGgAgACABIAIgA60gBK1CIIaEIAUgBiAHEDALGAAgACABIAIgA60gBK1CIIaEIAUgBhAvCxgAIAAgASACrSADrUIghoQgBCAFIAYQMgsWACAAIAEgAq0gA61CIIaEIAQgBRAxCxoAIAAgASACIAOtIAStQiCGhCAFIAYgBxA0CxgAIAAgASACIAOtIAStQiCGhCAFIAYQMwsYACAAIAEgAq0gA61CIIaEIAQgBSAGEDYLFgAgACABIAKtIAOtQiCGhCAEIAUQNQsUACAAIAEgAq0gA61CIIaEIAQQNwsWACAAIAEgAq0gA61CIIaEIAQgBRA5CxgAIAAgASACIAOtIAStQiCGhCAFIAYQdAsSACAAIAEgAq0gA61CIIaEEHYLEwAgACABIAKtIAOtQiCGhBCNAQsXACAAIAEgAq0gA61CIIaEIAQgBRCZAQstACAAIAGtIAKtQiCGhCADIAStIAWtQiCGhCAGIAetIAitQiCGhCAJIAoQ1gELHwAgACABIAKtIAOtQiCGhCAErSAFrUIghoQgBhDXAQshACAAIAEgAq0gA61CIIaEIAStIAWtQiCGhCAGIAcQ2AELEwAgACABrSACrUIghoQgAxDaAQsTACAAIAEgAq0gA61CIIaEENkBCxkAIAAgASACIAOtIAStQiCGhCAFIAYQ5QELFwAgACABIAKtIAOtQiCGhCAEIAUQ5gELGQAgACABIAIgA60gBK1CIIaEIAUgBhDnAQsXACAAIAEgAq0gA61CIIaEIAQgBRDoAQslACAAIAEgAiADIAQgBa0gBq1CIIaEIAcgCK0gCa1CIIaEEO8BCyUAIAAgASACIAMgBK0gBa1CIIaEIAYgB60gCK1CIIaEIAkQ7QELFQAgACABIAKtIAOtQiCGhCAEEPIBCxcAIAAgASACIAOtIAStQiCGhCAFEPkBCxcAIAAgASACIAOtIAStQiCGhCAFEPsBCxcAIAAgASACIAOtIAStQiCGhCAFEPoBCxMAIAAgASACrSADrUIghoQQ/gELFQAgACABIAKtIAOtQiCGhCAEEPwBCxEAIAAgAa0gAq1CIIaEEKUCCwvyigIIAEGgCAsBAQBBwAgLl/8BJuiVj8KyJ7BFw/SJ8u+Y8NXfrAXTxjM5sTgCiG1T/AXHF2pwPU3YT7o8C3YNEGcPKiBT+iw5zMZOx/13kqwDeuz///////////////////////////////////////9/7f///////////////////////////////////////3/u////////////////////////////////////////fwjJvPNn5glqO6fKhIWuZ7sr+JT+cvNuPPE2HV869U+l0YLmrX9SDlEfbD4rjGgFm2u9Qfur2YMfeSF+ExnN4Fsi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Qsj+ETTkAHXcj/7L+HsAOBKu/7qXpP8z6NABoOQr//kdGQFEvj8AQZSJAgsCsI0AQcyJAgszDQAAAAD/AAAAAPUAAAAAAAD7AAAAAAAA/QAAAADzAAAAAAcAAAAAAAMAAAAA8wAAAAAFAEGHigILQAsAAAAAAAsAAAAA8wAAAAAAAP0AAAAAAP8AAAAAAwAAAAD1AAAAAAAAAA8AAAAAAP8AAAAA/wAAAAAHAAAAAAUAQciLAgsRAe3T9VwaYxJY1pz3ot753hQAQeiLAguqAhBTLT5idWZsZW4gPD0gQkxBS0UyQl9CTE9DS0JZVEVTAGNyeXB0b19nZW5lcmljaGFzaC9ibGFrZTJiL3JlZi9ibGFrZTJiLXJlZi5jAGNyeXB0b19nZW5lcmljaGFzaF9ibGFrZTJiX19maW5hbABvdXRsZW4gPD0gVUlOVDhfTUFYAGNyeXB0b19nZW5lcmljaGFzaC9ibGFrZTJiL3JlZi9nZW5lcmljaGFzaF9ibGFrZTJiLmMAY3J5cHRvX2dlbmVyaWNoYXNoX2JsYWtlMmIAa2V5bGVuIDw9IFVJTlQ4X01BWABjcnlwdG9fZ2VuZXJpY2hhc2hfYmxha2UyYl9pbml0AGNyeXB0b19nZW5lcmljaGFzaF9ibGFrZTJiX2ZpbmFsAIAAQZGPAgvvByRhcmdvbjJpZAAkYXJnb24yaQAkdj0AJG09ACx0PQAscD0AJGFyZ29uMmlkJHY9ACRhcmdvbjJpJHY9ACRhcmdvbjJpZCQAJGFyZ29uMmkkAGFyZ29uMmkAU2lnRWQyNTUxOSBubyBFZDI1NTE5IGNvbGxpc2lvbnMBAHsgcmV0dXJuIE1vZHVsZS5nZXRSYW5kb21WYWx1ZSgpOyB9AHsgaWYgKE1vZHVsZS5nZXRSYW5kb21WYWx1ZSA9PT0gdW5kZWZpbmVkKSB7IHRyeSB7IHZhciB3aW5kb3dfID0gJ29iamVjdCcgPT09IHR5cGVvZiB3aW5kb3cgPyB3aW5kb3cgOiBzZWxmOyB2YXIgY3J5cHRvXyA9IHR5cGVvZiB3aW5kb3dfLmNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3dfLmNyeXB0byA6IHdpbmRvd18ubXNDcnlwdG87IHZhciByYW5kb21WYWx1ZXNTdGFuZGFyZCA9IGZ1bmN0aW9uKCkgeyB2YXIgYnVmID0gbmV3IFVpbnQzMkFycmF5KDEpOyBjcnlwdG9fLmdldFJhbmRvbVZhbHVlcyhidWYpOyByZXR1cm4gYnVmWzBdID4+PiAwOyB9OyByYW5kb21WYWx1ZXNTdGFuZGFyZCgpOyBNb2R1bGUuZ2V0UmFuZG9tVmFsdWUgPSByYW5kb21WYWx1ZXNTdGFuZGFyZDsgfSBjYXRjaCAoZSkgeyB0cnkgeyB2YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7IHZhciByYW5kb21WYWx1ZU5vZGVKUyA9IGZ1bmN0aW9uKCkgeyB2YXIgYnVmID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDQpOyByZXR1cm4gKGJ1ZlswXSA8PCAyNCB8IGJ1ZlsxXSA8PCAxNiB8IGJ1ZlsyXSA8PCA4IHwgYnVmWzNdKSA+Pj4gMDsgfTsgcmFuZG9tVmFsdWVOb2RlSlMoKTsgTW9kdWxlLmdldFJhbmRvbVZhbHVlID0gcmFuZG9tVmFsdWVOb2RlSlM7IH0gY2F0Y2ggKGUpIHsgdGhyb3cgJ05vIHNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBmb3VuZCc7IH0gfSB9IH0ATGlic29kaXVtRFJHYnVmX2xlbiA8PSBTSVpFX01BWAByYW5kb21ieXRlcy9yYW5kb21ieXRlcy5jAHJhbmRvbWJ5dGVzAGI2NF9wb3MgPD0gYjY0X2xlbgBzb2RpdW0vY29kZWNzLmMAc29kaXVtX2JpbjJiYXNlNjQAMS4wLjE1",a=K.asmjsCodeFile||"";"function"==typeof K.locateFile&&(t=K.locateFile(t),r=K.locateFile(r),a=K.locateFile(a));var n={global:null,env:null,asm2wasm:{"f64-rem":function(A,I){return A%I},"f64-to-int":function(A){return 0|A},"i32s-div":function(A,I){return(0|A)/(0|I)|0},"i32u-div":function(A,I){return(A>>>0)/(I>>>0)>>>0},"i32s-rem":function(A,I){return(0|A)%(0|I)|0},"i32u-rem":function(A,I){return(A>>>0)%(I>>>0)>>>0},debugger:function(){}},parent:K},C=null;K.asmPreload=K.asm;var o=K.reallocBuffer,c=function(A){A=f(A,K.usingWasm?65536:16777216);var I=K.buffer,e=I.byteLength;if(!K.usingWasm)return C.__growWasmMemory((A-e)/65536),K.buffer!==I?K.buffer:null;try{return-1!==K.wasmMemory.grow((A-e)/65536)?K.buffer=K.wasmMemory.buffer:null}catch(A){return null}};K.reallocBuffer=function(A){return"asmjs"===Q?o(A):c(A)};var Q="";K.asm=function(A,e,g){if(A=I(A),!(e=I(e)).table){var B=K.wasmTableSize;void 0===B&&(B=1024);var t=K.wasmMaxTableSize;"object"==typeof WebAssembly&&"function"==typeof WebAssembly.Table?e.table=void 0!==t?new WebAssembly.Table({initial:B,maximum:t,element:"anyfunc"}):new WebAssembly.Table({initial:B,element:"anyfunc"}):e.table=new Array(B),K.wasmTable=e.table}e.memoryBase||(e.memoryBase=K.STATIC_BASE),e.tableBase||(e.tableBase=0);var r;return(r=i(A,e))||X("no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/WebAssembly#binaryen-methods"),r},K.asm}();var LA=[function(){return K.getRandomValue()},function(){if(void 0===K.getRandomValue)try{var A="object"==typeof window?window:self,I=void 0!==A.crypto?A.crypto:A.msCrypto,e=function(){var A=new Uint32Array(1);return I.getRandomValues(A),A[0]>>>0};e(),K.getRandomValue=e}catch(A){try{var g=require("crypto"),i=function(){var A=g.randomBytes(4);return(A[0]<<24|A[1]<<16|A[2]<<8|A[3])>>>0};i(),K.getRandomValue=i}catch(A){throw"No secure random number generator found"}}}];hA=$.GLOBAL_BASE,yA=hA+36368,vA.push(),PA=null,K.STATIC_BASE=hA,K.STATIC_BUMP=36368;var xA=yA;yA+=16;var XA={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};lA=a(1,"i32",iA),pA=(_A=$.alignMemory(yA))+uA,wA=$.alignMemory(pA),cA[lA>>2]=wA,fA=!0;var KA=!1;K.intArrayFromString=R,K.intArrayToString=N;var TA="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",VA="function"==typeof atob?atob:function(A){var I,e,g,i,B,t,r="",a=0;A=A.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{I=TA.indexOf(A.charAt(a++))<<2|(i=TA.indexOf(A.charAt(a++)))>>4,e=(15&i)<<4|(B=TA.indexOf(A.charAt(a++)))>>2,g=(3&B)<<6|(t=TA.indexOf(A.charAt(a++))),r+=String.fromCharCode(I),64!==B&&(r+=String.fromCharCode(e)),64!==t&&(r+=String.fromCharCode(g))}while(a<A.length);return r};K.wasmTableSize=0,K.wasmMaxTableSize=0,K.asmGlobalArg={Math:Math,Int8Array:Int8Array,Int16Array:Int16Array,Int32Array:Int32Array,Uint8Array:Uint8Array,Uint16Array:Uint16Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,NaN:NaN,Infinity:1/0},K.asmLibraryArg={abort:X,assert:i,enlargeMemory:l,getTotalMemory:function(){return dA},abortOnCannotGrowMemory:w,___assert_fail:function(A,I,e,g){throw eA=!0,"Assertion failed: "+n(A)+", at: "+[I?n(I):"unknown filename",e,g?n(g):"unknown function"]+" at "+y()},___setErrNo:S,_abort:function(){K.abort()},_emscripten_asm_const_i:function(A){return LA[A]()},_emscripten_memcpy_big:function(A,I,e){return nA.set(nA.subarray(I,I+e),A),A},_sysconf:function(A){switch(A){case 30:return 16384;case 85:return nA.length/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 80:case 81:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 79:return 0;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return"object"==typeof navigator?navigator.hardwareConcurrency||1:1}return S(XA.EINVAL),-1},DYNAMICTOP_PTR:lA,tempDoublePtr:xA,ABORT:eA,STACKTOP:_A,STACK_MAX:pA};var qA=K.asm(K.asmGlobalArg,K.asmLibraryArg,rA);K.asm=qA,K._crypto_aead_chacha20poly1305_abytes=function(){return K.asm._crypto_aead_chacha20poly1305_abytes.apply(null,arguments)},K._crypto_aead_chacha20poly1305_decrypt=function(){return K.asm._crypto_aead_chacha20poly1305_decrypt.apply(null,arguments)},K._crypto_aead_chacha20poly1305_decrypt_detached=function(){return K.asm._crypto_aead_chacha20poly1305_decrypt_detached.apply(null,arguments)},K._crypto_aead_chacha20poly1305_encrypt=function(){return K.asm._crypto_aead_chacha20poly1305_encrypt.apply(null,arguments)},K._crypto_aead_chacha20poly1305_encrypt_detached=function(){return K.asm._crypto_aead_chacha20poly1305_encrypt_detached.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_abytes=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_abytes.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_decrypt=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_decrypt.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_decrypt_detached=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_decrypt_detached.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_encrypt=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_encrypt.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_encrypt_detached=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_encrypt_detached.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_keybytes=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_keybytes.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_keygen=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_keygen.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_npubbytes=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_npubbytes.apply(null,arguments)},K._crypto_aead_chacha20poly1305_ietf_nsecbytes=function(){return K.asm._crypto_aead_chacha20poly1305_ietf_nsecbytes.apply(null,arguments)},K._crypto_aead_chacha20poly1305_keybytes=function(){return K.asm._crypto_aead_chacha20poly1305_keybytes.apply(null,arguments)},K._crypto_aead_chacha20poly1305_keygen=function(){return K.asm._crypto_aead_chacha20poly1305_keygen.apply(null,arguments)},K._crypto_aead_chacha20poly1305_npubbytes=function(){return K.asm._crypto_aead_chacha20poly1305_npubbytes.apply(null,arguments)},K._crypto_aead_chacha20poly1305_nsecbytes=function(){return K.asm._crypto_aead_chacha20poly1305_nsecbytes.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_abytes=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_abytes.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_decrypt=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_decrypt.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_decrypt_detached=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_decrypt_detached.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_encrypt=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_encrypt.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_encrypt_detached=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_encrypt_detached.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_keybytes=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_keybytes.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_keygen=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_keygen.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_npubbytes=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_npubbytes.apply(null,arguments)},K._crypto_aead_xchacha20poly1305_ietf_nsecbytes=function(){return K.asm._crypto_aead_xchacha20poly1305_ietf_nsecbytes.apply(null,arguments)},K._crypto_auth=function(){return K.asm._crypto_auth.apply(null,arguments)},K._crypto_auth_bytes=function(){return K.asm._crypto_auth_bytes.apply(null,arguments)},K._crypto_auth_keybytes=function(){return K.asm._crypto_auth_keybytes.apply(null,arguments)},K._crypto_auth_keygen=function(){return K.asm._crypto_auth_keygen.apply(null,arguments)},K._crypto_auth_verify=function(){return K.asm._crypto_auth_verify.apply(null,arguments)},K._crypto_box_beforenm=function(){return K.asm._crypto_box_beforenm.apply(null,arguments)},K._crypto_box_beforenmbytes=function(){return K.asm._crypto_box_beforenmbytes.apply(null,arguments)},K._crypto_box_detached=function(){return K.asm._crypto_box_detached.apply(null,arguments)},K._crypto_box_detached_afternm=function(){return K.asm._crypto_box_detached_afternm.apply(null,arguments)},K._crypto_box_easy=function(){return K.asm._crypto_box_easy.apply(null,arguments)},K._crypto_box_easy_afternm=function(){return K.asm._crypto_box_easy_afternm.apply(null,arguments)},K._crypto_box_keypair=function(){return K.asm._crypto_box_keypair.apply(null,arguments)},K._crypto_box_macbytes=function(){return K.asm._crypto_box_macbytes.apply(null,arguments)},K._crypto_box_noncebytes=function(){return K.asm._crypto_box_noncebytes.apply(null,arguments)},K._crypto_box_open_detached=function(){return K.asm._crypto_box_open_detached.apply(null,arguments)},K._crypto_box_open_detached_afternm=function(){return K.asm._crypto_box_open_detached_afternm.apply(null,arguments)},K._crypto_box_open_easy=function(){return K.asm._crypto_box_open_easy.apply(null,arguments)},K._crypto_box_open_easy_afternm=function(){return K.asm._crypto_box_open_easy_afternm.apply(null,arguments)},K._crypto_box_publickeybytes=function(){return K.asm._crypto_box_publickeybytes.apply(null,arguments)},K._crypto_box_seal=function(){return K.asm._crypto_box_seal.apply(null,arguments)},K._crypto_box_seal_open=function(){return K.asm._crypto_box_seal_open.apply(null,arguments)},K._crypto_box_sealbytes=function(){return K.asm._crypto_box_sealbytes.apply(null,arguments)},K._crypto_box_secretkeybytes=function(){return K.asm._crypto_box_secretkeybytes.apply(null,arguments)},K._crypto_box_seed_keypair=function(){return K.asm._crypto_box_seed_keypair.apply(null,arguments)},K._crypto_box_seedbytes=function(){return K.asm._crypto_box_seedbytes.apply(null,arguments)},K._crypto_core_hchacha20=function(){return K.asm._crypto_core_hchacha20.apply(null,arguments)},K._crypto_core_hchacha20_constbytes=function(){return K.asm._crypto_core_hchacha20_constbytes.apply(null,arguments)},K._crypto_core_hchacha20_inputbytes=function(){return K.asm._crypto_core_hchacha20_inputbytes.apply(null,arguments)},K._crypto_core_hchacha20_keybytes=function(){return K.asm._crypto_core_hchacha20_keybytes.apply(null,arguments)},K._crypto_core_hchacha20_outputbytes=function(){return K.asm._crypto_core_hchacha20_outputbytes.apply(null,arguments)},K._crypto_generichash=function(){return K.asm._crypto_generichash.apply(null,arguments)},K._crypto_generichash_bytes=function(){return K.asm._crypto_generichash_bytes.apply(null,arguments)},K._crypto_generichash_bytes_max=function(){return K.asm._crypto_generichash_bytes_max.apply(null,arguments)},K._crypto_generichash_bytes_min=function(){return K.asm._crypto_generichash_bytes_min.apply(null,arguments)},K._crypto_generichash_final=function(){return K.asm._crypto_generichash_final.apply(null,arguments)},K._crypto_generichash_init=function(){return K.asm._crypto_generichash_init.apply(null,arguments)},K._crypto_generichash_keybytes=function(){return K.asm._crypto_generichash_keybytes.apply(null,arguments)},K._crypto_generichash_keybytes_max=function(){return K.asm._crypto_generichash_keybytes_max.apply(null,arguments)},K._crypto_generichash_keybytes_min=function(){return K.asm._crypto_generichash_keybytes_min.apply(null,arguments)},K._crypto_generichash_keygen=function(){return K.asm._crypto_generichash_keygen.apply(null,arguments)},K._crypto_generichash_statebytes=function(){return K.asm._crypto_generichash_statebytes.apply(null,arguments)},K._crypto_generichash_update=function(){return K.asm._crypto_generichash_update.apply(null,arguments)},K._crypto_hash=function(){return K.asm._crypto_hash.apply(null,arguments)},K._crypto_hash_bytes=function(){return K.asm._crypto_hash_bytes.apply(null,arguments)},K._crypto_kdf_bytes_max=function(){return K.asm._crypto_kdf_bytes_max.apply(null,arguments)},K._crypto_kdf_bytes_min=function(){return K.asm._crypto_kdf_bytes_min.apply(null,arguments)},K._crypto_kdf_contextbytes=function(){return K.asm._crypto_kdf_contextbytes.apply(null,arguments)},K._crypto_kdf_derive_from_key=function(){return K.asm._crypto_kdf_derive_from_key.apply(null,arguments)},K._crypto_kdf_keybytes=function(){return K.asm._crypto_kdf_keybytes.apply(null,arguments)},K._crypto_kdf_keygen=function(){return K.asm._crypto_kdf_keygen.apply(null,arguments)},K._crypto_kx_client_session_keys=function(){return K.asm._crypto_kx_client_session_keys.apply(null,arguments)},K._crypto_kx_keypair=function(){return K.asm._crypto_kx_keypair.apply(null,arguments)},K._crypto_kx_publickeybytes=function(){return K.asm._crypto_kx_publickeybytes.apply(null,arguments)},K._crypto_kx_secretkeybytes=function(){return K.asm._crypto_kx_secretkeybytes.apply(null,arguments)},K._crypto_kx_seed_keypair=function(){return K.asm._crypto_kx_seed_keypair.apply(null,arguments)},K._crypto_kx_seedbytes=function(){return K.asm._crypto_kx_seedbytes.apply(null,arguments)},K._crypto_kx_server_session_keys=function(){return K.asm._crypto_kx_server_session_keys.apply(null,arguments)},K._crypto_kx_sessionkeybytes=function(){return K.asm._crypto_kx_sessionkeybytes.apply(null,arguments)},K._crypto_pwhash=function(){return K.asm._crypto_pwhash.apply(null,arguments)},K._crypto_pwhash_alg_argon2i13=function(){return K.asm._crypto_pwhash_alg_argon2i13.apply(null,arguments)},K._crypto_pwhash_alg_argon2id13=function(){return K.asm._crypto_pwhash_alg_argon2id13.apply(null,arguments)},K._crypto_pwhash_alg_default=function(){return K.asm._crypto_pwhash_alg_default.apply(null,arguments)},K._crypto_pwhash_bytes_max=function(){return K.asm._crypto_pwhash_bytes_max.apply(null,arguments)},K._crypto_pwhash_bytes_min=function(){return K.asm._crypto_pwhash_bytes_min.apply(null,arguments)},K._crypto_pwhash_memlimit_interactive=function(){return K.asm._crypto_pwhash_memlimit_interactive.apply(null,arguments)},K._crypto_pwhash_memlimit_max=function(){return K.asm._crypto_pwhash_memlimit_max.apply(null,arguments)},K._crypto_pwhash_memlimit_min=function(){return K.asm._crypto_pwhash_memlimit_min.apply(null,arguments)},K._crypto_pwhash_memlimit_moderate=function(){return K.asm._crypto_pwhash_memlimit_moderate.apply(null,arguments)},K._crypto_pwhash_memlimit_sensitive=function(){return K.asm._crypto_pwhash_memlimit_sensitive.apply(null,arguments)},K._crypto_pwhash_opslimit_interactive=function(){return K.asm._crypto_pwhash_opslimit_interactive.apply(null,arguments)},K._crypto_pwhash_opslimit_max=function(){return K.asm._crypto_pwhash_opslimit_max.apply(null,arguments)},K._crypto_pwhash_opslimit_min=function(){return K.asm._crypto_pwhash_opslimit_min.apply(null,arguments)},K._crypto_pwhash_opslimit_moderate=function(){return K.asm._crypto_pwhash_opslimit_moderate.apply(null,arguments)},K._crypto_pwhash_opslimit_sensitive=function(){return K.asm._crypto_pwhash_opslimit_sensitive.apply(null,arguments)},K._crypto_pwhash_passwd_max=function(){return K.asm._crypto_pwhash_passwd_max.apply(null,arguments)},K._crypto_pwhash_passwd_min=function(){return K.asm._crypto_pwhash_passwd_min.apply(null,arguments)},K._crypto_pwhash_primitive=function(){return K.asm._crypto_pwhash_primitive.apply(null,arguments)},K._crypto_pwhash_saltbytes=function(){return K.asm._crypto_pwhash_saltbytes.apply(null,arguments)},K._crypto_pwhash_str=function(){return K.asm._crypto_pwhash_str.apply(null,arguments)},K._crypto_pwhash_str_alg=function(){return K.asm._crypto_pwhash_str_alg.apply(null,arguments)},K._crypto_pwhash_str_needs_rehash=function(){return K.asm._crypto_pwhash_str_needs_rehash.apply(null,arguments)},K._crypto_pwhash_str_verify=function(){return K.asm._crypto_pwhash_str_verify.apply(null,arguments)},K._crypto_pwhash_strbytes=function(){return K.asm._crypto_pwhash_strbytes.apply(null,arguments)},K._crypto_pwhash_strprefix=function(){return K.asm._crypto_pwhash_strprefix.apply(null,arguments)},K._crypto_scalarmult=function(){return K.asm._crypto_scalarmult.apply(null,arguments)},K._crypto_scalarmult_base=function(){return K.asm._crypto_scalarmult_base.apply(null,arguments)},K._crypto_scalarmult_bytes=function(){return K.asm._crypto_scalarmult_bytes.apply(null,arguments)},K._crypto_scalarmult_scalarbytes=function(){return K.asm._crypto_scalarmult_scalarbytes.apply(null,arguments)},K._crypto_secretbox_detached=function(){return K.asm._crypto_secretbox_detached.apply(null,arguments)},K._crypto_secretbox_easy=function(){return K.asm._crypto_secretbox_easy.apply(null,arguments)},K._crypto_secretbox_keybytes=function(){return K.asm._crypto_secretbox_keybytes.apply(null,arguments)},K._crypto_secretbox_keygen=function(){return K.asm._crypto_secretbox_keygen.apply(null,arguments)},K._crypto_secretbox_macbytes=function(){return K.asm._crypto_secretbox_macbytes.apply(null,arguments)},K._crypto_secretbox_noncebytes=function(){return K.asm._crypto_secretbox_noncebytes.apply(null,arguments)},K._crypto_secretbox_open_detached=function(){return K.asm._crypto_secretbox_open_detached.apply(null,arguments)},K._crypto_secretbox_open_easy=function(){return K.asm._crypto_secretbox_open_easy.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_abytes=function(){return K.asm._crypto_secretstream_xchacha20poly1305_abytes.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_headerbytes=function(){return K.asm._crypto_secretstream_xchacha20poly1305_headerbytes.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_init_pull=function(){return K.asm._crypto_secretstream_xchacha20poly1305_init_pull.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_init_push=function(){return K.asm._crypto_secretstream_xchacha20poly1305_init_push.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_keybytes=function(){return K.asm._crypto_secretstream_xchacha20poly1305_keybytes.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_keygen=function(){return K.asm._crypto_secretstream_xchacha20poly1305_keygen.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_messagebytes_max=function(){return K.asm._crypto_secretstream_xchacha20poly1305_messagebytes_max.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_pull=function(){return K.asm._crypto_secretstream_xchacha20poly1305_pull.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_push=function(){return K.asm._crypto_secretstream_xchacha20poly1305_push.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_rekey=function(){return K.asm._crypto_secretstream_xchacha20poly1305_rekey.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_statebytes=function(){return K.asm._crypto_secretstream_xchacha20poly1305_statebytes.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_tag_final=function(){return K.asm._crypto_secretstream_xchacha20poly1305_tag_final.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_tag_message=function(){return K.asm._crypto_secretstream_xchacha20poly1305_tag_message.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_tag_push=function(){return K.asm._crypto_secretstream_xchacha20poly1305_tag_push.apply(null,arguments)},K._crypto_secretstream_xchacha20poly1305_tag_rekey=function(){return K.asm._crypto_secretstream_xchacha20poly1305_tag_rekey.apply(null,arguments)},K._crypto_shorthash=function(){return K.asm._crypto_shorthash.apply(null,arguments)},K._crypto_shorthash_bytes=function(){return K.asm._crypto_shorthash_bytes.apply(null,arguments)},K._crypto_shorthash_keybytes=function(){return K.asm._crypto_shorthash_keybytes.apply(null,arguments)},K._crypto_shorthash_keygen=function(){return K.asm._crypto_shorthash_keygen.apply(null,arguments)},K._crypto_sign=function(){return K.asm._crypto_sign.apply(null,arguments)},K._crypto_sign_bytes=function(){return K.asm._crypto_sign_bytes.apply(null,arguments)},K._crypto_sign_detached=function(){return K.asm._crypto_sign_detached.apply(null,arguments)},K._crypto_sign_ed25519_pk_to_curve25519=function(){return K.asm._crypto_sign_ed25519_pk_to_curve25519.apply(null,arguments)},K._crypto_sign_ed25519_sk_to_curve25519=function(){return K.asm._crypto_sign_ed25519_sk_to_curve25519.apply(null,arguments)},K._crypto_sign_final_create=function(){return K.asm._crypto_sign_final_create.apply(null,arguments)},K._crypto_sign_final_verify=function(){return K.asm._crypto_sign_final_verify.apply(null,arguments)},K._crypto_sign_init=function(){return K.asm._crypto_sign_init.apply(null,arguments)},K._crypto_sign_keypair=function(){return K.asm._crypto_sign_keypair.apply(null,arguments)},K._crypto_sign_open=function(){return K.asm._crypto_sign_open.apply(null,arguments)},K._crypto_sign_publickeybytes=function(){return K.asm._crypto_sign_publickeybytes.apply(null,arguments)},K._crypto_sign_secretkeybytes=function(){return K.asm._crypto_sign_secretkeybytes.apply(null,arguments)},K._crypto_sign_seed_keypair=function(){return K.asm._crypto_sign_seed_keypair.apply(null,arguments)},K._crypto_sign_seedbytes=function(){return K.asm._crypto_sign_seedbytes.apply(null,arguments)},K._crypto_sign_statebytes=function(){return K.asm._crypto_sign_statebytes.apply(null,arguments)},K._crypto_sign_update=function(){return K.asm._crypto_sign_update.apply(null,arguments)},K._crypto_sign_verify_detached=function(){return K.asm._crypto_sign_verify_detached.apply(null,arguments)},K._crypto_stream_keygen=function(){return K.asm._crypto_stream_keygen.apply(null,arguments)},K._emscripten_get_global_libc=function(){return K.asm._emscripten_get_global_libc.apply(null,arguments)};var jA=K._free=function(){return K.asm._free.apply(null,arguments)},ZA=K._malloc=function(){return K.asm._malloc.apply(null,arguments)};if(K._memcpy=function(){return K.asm._memcpy.apply(null,arguments)},K._memmove=function(){return K.asm._memmove.apply(null,arguments)},K._memset=function(){return K.asm._memset.apply(null,arguments)},K._randombytes=function(){return K.asm._randombytes.apply(null,arguments)},K._randombytes_buf=function(){return K.asm._randombytes_buf.apply(null,arguments)},K._randombytes_buf_deterministic=function(){return K.asm._randombytes_buf_deterministic.apply(null,arguments)},K._randombytes_close=function(){return K.asm._randombytes_close.apply(null,arguments)},K._randombytes_random=function(){return K.asm._randombytes_random.apply(null,arguments)},K._randombytes_seedbytes=function(){return K.asm._randombytes_seedbytes.apply(null,arguments)},K._randombytes_stir=function(){return K.asm._randombytes_stir.apply(null,arguments)},K._randombytes_uniform=function(){return K.asm._randombytes_uniform.apply(null,arguments)},K._sbrk=function(){return K.asm._sbrk.apply(null,arguments)},K._sodium_base642bin=function(){return K.asm._sodium_base642bin.apply(null,arguments)},K._sodium_base64_encoded_len=function(){return K.asm._sodium_base64_encoded_len.apply(null,arguments)},K._sodium_bin2base64=function(){return K.asm._sodium_bin2base64.apply(null,arguments)},K._sodium_bin2hex=function(){return K.asm._sodium_bin2hex.apply(null,arguments)},K._sodium_hex2bin=function(){return K.asm._sodium_hex2bin.apply(null,arguments)},K._sodium_init=function(){return K.asm._sodium_init.apply(null,arguments)},K._sodium_library_minimal=function(){return K.asm._sodium_library_minimal.apply(null,arguments)},K._sodium_library_version_major=function(){return K.asm._sodium_library_version_major.apply(null,arguments)},K._sodium_library_version_minor=function(){return K.asm._sodium_library_version_minor.apply(null,arguments)},K._sodium_pad=function(){return K.asm._sodium_pad.apply(null,arguments)},K._sodium_unpad=function(){return K.asm._sodium_unpad.apply(null,arguments)},K._sodium_version_string=function(){return K.asm._sodium_version_string.apply(null,arguments)},K.establishStackSpace=function(){return K.asm.establishStackSpace.apply(null,arguments)},K.getTempRet0=function(){return K.asm.getTempRet0.apply(null,arguments)},K.runPostSets=function(){return K.asm.runPostSets.apply(null,arguments)},K.setTempRet0=function(){return K.asm.setTempRet0.apply(null,arguments)},K.setThrew=function(){return K.asm.setThrew.apply(null,arguments)},K.stackAlloc=function(){return K.asm.stackAlloc.apply(null,arguments)},K.stackRestore=function(){return K.asm.stackRestore.apply(null,arguments)},K.stackSave=function(){return K.asm.stackSave.apply(null,arguments)},$.stackAlloc=K.stackAlloc,$.stackSave=K.stackSave,$.stackRestore=K.stackRestore,$.establishStackSpace=K.establishStackSpace,$.setTempRet0=K.setTempRet0,$.getTempRet0=K.getTempRet0,K.asm=qA,PA)if("function"==typeof K.locateFile?PA=K.locateFile(PA):K.memoryInitializerPrefixURL&&(PA=K.memoryInitializerPrefixURL+PA),Z||W){var WA=K.readBinary(PA);nA.set(WA,$.GLOBAL_BASE)}else{H("memory initializer");var zA=function(A){A.byteLength&&(A=new Uint8Array(A)),nA.set(A,$.GLOBAL_BASE),K.memoryInitializerRequest&&delete K.memoryInitializerRequest.response,Y("memory initializer")};function OA(){K.readAsync(PA,zA,function(){throw"could not load memory initializer "+PA})}var $A=J(PA);if($A)zA($A.buffer);else if(K.memoryInitializerRequest){function AI(){var A=K.memoryInitializerRequest,I=A.response;if(200!==A.status&&0!==A.status){var e=J(K.memoryInitializerRequestURL);if(!e)return void OA();I=e.buffer}zA(I)}K.memoryInitializerRequest.response?setTimeout(AI,0):K.memoryInitializerRequest.addEventListener("load",AI)}else OA()}P.prototype=new Error,P.prototype.constructor=P;var II,eI=null,gI=!1;JA=function A(){K.calledRun||L(),K.calledRun||(JA=A)},K.callMain=K.callMain=function(A){function I(){for(var A=0;A<3;A++)g.push(0)}A=A||[],D();var e=A.length+1,g=[a(R(K.thisProgram),"i8",0)];I();for(var i=0;i<e-1;i+=1)g.push(a(R(A[i]),"i8",0)),I();g.push(0),g=a(g,"i32",0);try{x(K._main(e,g,0),!0)}catch(A){if(A instanceof P)return;if("SimulateInfiniteLoop"==A)return void(K.noExitRuntime=!0);var B=A;A&&"object"==typeof A&&A.stack&&(B=[A,A.stack]),K.printErr("exception thrown: "+B),K.quit(1,A)}finally{gI=!0}},K.run=K.run=L,K.exit=K.exit=x;var iI=[];if(K.abort=K.abort=X,K.preInit)for("function"==typeof K.preInit&&(K.preInit=[K.preInit]);K.preInit.length>0;)K.preInit.pop()();var BI=!0;K.noInitialRun&&(BI=!1),L()}).catch(function(){function A(A){U("NO_DYNAMIC_EXECUTION=1 was set, cannot eval")}function I(A,I){A||U("Assertion failed: "+I)}function e(A){var e=J["_"+A];return e||U("NO_DYNAMIC_EXECUTION=1 was set, cannot eval"),I(e,"Cannot call unknown function "+A+" (perhaps LLVM optimizations or closure removed it?)"),e}function i(A,I,e,g){switch("*"===(e=e||"i8").charAt(e.length-1)&&(e="i32"),e){case"i1":case"i8":gA[A>>0]=I;break;case"i16":BA[A>>1]=I;break;case"i32":rA[A>>2]=I;break;case"i64":tempI64=[I>>>0,(tempDouble=I,+bA(tempDouble)>=1?tempDouble>0?(0|FA(+GA(tempDouble/4294967296),4294967295))>>>0:~~+kA((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],rA[A>>2]=tempI64[0],rA[A+4>>2]=tempI64[1];break;case"float":nA[A>>2]=I;break;case"double":CA[A>>3]=I;break;default:U("invalid type for setValue: "+e)}}function B(A,I,e){switch("*"===(I=I||"i8").charAt(I.length-1)&&(I="i32"),I){case"i1":case"i8":return gA[A>>0];case"i16":return BA[A>>1];case"i32":case"i64":return rA[A>>2];case"float":return nA[A>>2];case"double":return CA[A>>3];default:U("invalid type for getValue: "+I)}return null}function t(A,e,g,B){var t,r;"number"==typeof A?(t=!0,r=A):(t=!1,r=A.length);var a,n="string"==typeof e?e:null;if(a=g==AA?B:["function"==typeof KA?KA:j.staticAlloc,j.stackAlloc,j.staticAlloc,j.dynamicAlloc][void 0===g?$:g](Math.max(r,n?1:e.length)),t){var C;for(B=a,I(0==(3&a)),C=a+(-4&r);B<C;B+=4)rA[B>>2]=0;for(C=a+r;B<C;)gA[B++>>0]=0;return a}if("i8"===n)return A.subarray||A.slice?iA.set(A,a):iA.set(new Uint8Array(A),a),a;for(var o,c,Q,E=0;E<r;){var s=A[E];"function"==typeof s&&(s=j.getFunctionIndex(s)),0!==(o=n||e[E])?("i64"==o&&(o="i32"),i(a+E,s,o),Q!==o&&(c=j.getNativeTypeSize(o),Q=o),E+=c):E++}return a}function r(A,I){if(0===I||!A)return"";for(var e,g=0,i=0;e=iA[A+i>>0],g|=e,(0!=e||I)&&(i++,!I||i!=I););I||(I=i);var B="";if(g<128){for(var t;I>0;)t=String.fromCharCode.apply(String,iA.subarray(A,A+Math.min(I,1024))),B=B?B+t:t,A+=1024,I-=1024;return B}return J.UTF8ToString(A)}function a(A,I){for(var e=I;A[e];)++e;if(e-I>16&&A.subarray&&IA)return IA.decode(A.subarray(I,e));for(var g,i,B,t,r,a="";;){if(!(g=A[I++]))return a;if(128&g)if(i=63&A[I++],192!=(224&g))if(B=63&A[I++],224==(240&g)?g=(15&g)<<12|i<<6|B:(t=63&A[I++],240==(248&g)?g=(7&g)<<18|i<<12|B<<6|t:(r=63&A[I++],g=248==(252&g)?(3&g)<<24|i<<18|B<<12|t<<6|r:(1&g)<<30|i<<24|B<<18|t<<12|r<<6|63&A[I++])),g<65536)a+=String.fromCharCode(g);else{var n=g-65536;a+=String.fromCharCode(55296|n>>10,56320|1023&n)}else a+=String.fromCharCode((31&g)<<6|i);else a+=String.fromCharCode(g)}}function n(A,I,e,g){if(!(g>0))return 0;for(var i=e,B=e+g-1,t=0;t<A.length;++t){var r=A.charCodeAt(t);if(r>=55296&&r<=57343&&(r=65536+((1023&r)<<10)|1023&A.charCodeAt(++t)),r<=127){if(e>=B)break;I[e++]=r}else if(r<=2047){if(e+1>=B)break;I[e++]=192|r>>6,I[e++]=128|63&r}else if(r<=65535){if(e+2>=B)break;I[e++]=224|r>>12,I[e++]=128|r>>6&63,I[e++]=128|63&r}else if(r<=2097151){if(e+3>=B)break;I[e++]=240|r>>18,I[e++]=128|r>>12&63,I[e++]=128|r>>6&63,I[e++]=128|63&r}else if(r<=67108863){if(e+4>=B)break;I[e++]=248|r>>24,I[e++]=128|r>>18&63,I[e++]=128|r>>12&63,I[e++]=128|r>>6&63,I[e++]=128|63&r}else{if(e+5>=B)break;I[e++]=252|r>>30,I[e++]=128|r>>24&63,I[e++]=128|r>>18&63,I[e++]=128|r>>12&63,I[e++]=128|r>>6&63,I[e++]=128|63&r}}return I[e]=0,e-i}function C(A,I,e){return n(A,iA,I,e)}function o(A){for(var I=0,e=0;e<A.length;++e){var g=A.charCodeAt(e);g>=55296&&g<=57343&&(g=65536+((1023&g)<<10)|1023&A.charCodeAt(++e)),g<=127?++I:I+=g<=2047?2:g<=65535?3:g<=2097151?4:g<=67108863?5:6}return I}function c(A){var I=J.___cxa_demangle||J.__cxa_demangle;if(I){try{var e=A.substr(1),g=o(e)+1,i=KA(g);C(e,i,g);var t=KA(4),a=I(i,0,0,t);if(0===B(t,"i32")&&a)return r(a)}catch(A){}finally{i&&XA(i),t&&XA(t),a&&XA(a)}return A}return j.warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling"),A}function Q(A){return A.replace(/__Z[\w\d_]+/g,function(A){var I=c(A);return A===I?A:A+" ["+I+"]"})}function E(){var A=new Error;if(!A.stack){try{throw new Error(0)}catch(I){A=I}if(!A.stack)return"(no stack trace available)"}return A.stack.toString()}function s(){var A=E();return J.extraStackTrace&&(A+="\n"+J.extraStackTrace()),Q(A)}function h(){U("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value "+_A+", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or (4) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")}function y(){h()}function f(A){for(;A.length>0;){var I=A.shift();if("function"!=typeof I){var e=I.func;"number"==typeof e?void 0===I.arg?J.dynCall_v(e):J.dynCall_vi(e,I.arg):e(void 0===I.arg?null:I.arg)}else I()}}function _(){if(J.preRun)for("function"==typeof J.preRun&&(J.preRun=[J.preRun]);J.preRun.length;)d(J.preRun.shift());f(pA)}function p(){DA||(DA=!0,f(wA))}function w(){f(lA)}function l(){f(uA),vA=!0}function u(){if(J.postRun)for("function"==typeof J.postRun&&(J.postRun=[J.postRun]);J.postRun.length;)D(J.postRun.shift());f(dA)}function d(A){pA.unshift(A)}function D(A){dA.unshift(A)}function v(A,I){gA.set(A,I)}function b(A,I,e){for(var g=0;g<A.length;++g)gA[I++>>0]=A.charCodeAt(g);e||(gA[I>>0]=0)}function k(A){mA++,J.monitorRunDependencies&&J.monitorRunDependencies(mA)}function G(A){if(mA--,J.monitorRunDependencies&&J.monitorRunDependencies(mA),0==mA&&(null!==MA&&(clearInterval(MA),MA=null),HA)){var I=HA;HA=null,I()}}function F(A){return J.___errno_location&&(rA[J.___errno_location()>>2]=A),A}function m(A,I,e){var g=e>0?e:o(A)+1,i=new Array(g),B=n(A,i,0,i.length);return I&&(i.length=B),i}function M(A){for(var e=[],g=0;g<A.length;g++){var i=A[g];i>255&&(JA&&I(!1,"Character code "+i+" ("+String.fromCharCode(i)+")  at offset "+g+" not in 0x00-0xFF."),i&=255),e.push(String.fromCharCode(i))}return e.join("")}function H(A){if("boolean"==typeof K&&K){var I;try{I=Buffer.from(A,"base64")}catch(e){I=new Buffer(A,"base64")}return new Uint8Array(I.buffer,I.byteOffset,I.byteLength)}try{for(var e=LA(A),g=new Uint8Array(e.length),i=0;i<e.length;++i)g[i]=e.charCodeAt(i);return g}catch(A){throw new Error("Converting base64 string to bytes failed.")}}function Y(A){var I="data:application/octet-stream;base64,";if(String.prototype.startsWith?A.startsWith(I):0===A.indexOf(I))return H(A.slice(I.length))}function S(A){this.name="ExitStatus",this.message="Program terminated with exit("+A+")",this.status=A}function R(A){function I(){J.calledRun||(J.calledRun=!0,z||(p(),w(),J.onRuntimeInitialized&&J.onRuntimeInitialized(),J._main&&AI&&J.callMain(A),u()))}A=A||J.arguments,null===zA&&(zA=Date.now()),mA>0||(_(),mA>0||J.calledRun||(J.setStatus?(J.setStatus("Running..."),setTimeout(function(){setTimeout(function(){J.setStatus("")},1),I()},1)):I()))}function N(A,I){I&&J.noExitRuntime||(J.noExitRuntime||(z=!0,O=A,EA=WA,l(),J.onExit&&J.onExit(A)),K&&process.exit(A),J.quit(A,new S(A)))}function U(A){J.onAbort&&J.onAbort(A),void 0!==A?(J.print(A),J.printErr(A),A=JSON.stringify(A)):A="",z=!0,O=1;var I="abort("+A+") at "+s()+"\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";throw $A&&$A.forEach(function(e){I=e(I,A)}),I}(J=g).onAbort=void 0,J.onRuntimeInitialized=void 0;var J;J||(J=(void 0!==J?J:null)||{});var P,L={};for(P in J)J.hasOwnProperty(P)&&(L[P]=J[P]);var x=!1,X=!1,K=!1,T=!1;if(J.ENVIRONMENT)if("WEB"===J.ENVIRONMENT)x=!0;else if("WORKER"===J.ENVIRONMENT)X=!0;else if("NODE"===J.ENVIRONMENT)K=!0;else{if("SHELL"!==J.ENVIRONMENT)throw new Error("The provided Module['ENVIRONMENT'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.");T=!0}else x="object"==typeof window,X="function"==typeof importScripts,K="object"==typeof process&&"function"==typeof require&&!x&&!X,T=!x&&!K&&!X;if(K){J.print||(J.print=console.log),J.printErr||(J.printErr=console.warn);var V,q;J.read=function(A,I){var e;return(e=Y(A))||(V||(V=require("fs")),q||(q=require("path")),A=q.normalize(A),e=V.readFileSync(A)),I?e:e.toString()},J.readBinary=function(A){var e=J.read(A,!0);return e.buffer||(e=new Uint8Array(e)),I(e.buffer),e},J.load=function(I){A(read(I))},J.thisProgram||(process.argv.length>1?J.thisProgram=process.argv[1].replace(/\\/g,"/"):J.thisProgram="unknown-program"),J.arguments=process.argv.slice(2),"undefined"!=typeof module&&(module.exports=J),process.on("uncaughtException",function(A){if(!(A instanceof S))throw A}),J.inspect=function(){return"[Emscripten Module object]"}}else if(T)J.print||(J.print=print),"undefined"!=typeof printErr&&(J.printErr=printErr),"undefined"!=typeof read?J.read=function(A){var I=Y(A);return I?M(I):read(A)}:J.read=function(){throw"no read() available"},J.readBinary=function(A){var e;return(e=Y(A))?e:"function"==typeof readbuffer?new Uint8Array(readbuffer(A)):(e=read(A,"binary"),I("object"==typeof e),e)},"undefined"!=typeof scriptArgs?J.arguments=scriptArgs:void 0!==arguments&&(J.arguments=arguments),"function"==typeof quit&&(J.quit=function(A,I){quit(A)});else{if(!x&&!X)throw new Error("Unknown runtime environment. Where are we?");J.read=function(A){try{var I=new XMLHttpRequest;return I.open("GET",A,!1),I.send(null),I.responseText}catch(I){var e=Y(A);if(e)return M(e);throw I}},X&&(J.readBinary=function(A){try{var I=new XMLHttpRequest;return I.open("GET",A,!1),I.responseType="arraybuffer",I.send(null),new Uint8Array(I.response)}catch(I){var e=Y(A);if(e)return e;throw I}}),J.readAsync=function(A,I,e){var g=new XMLHttpRequest;g.open("GET",A,!0),g.responseType="arraybuffer",g.onload=function(){if(200==g.status||0==g.status&&g.response)I(g.response);else{var i=Y(A);i?I(i.buffer):e()}},g.onerror=e,g.send(null)},void 0!==arguments&&(J.arguments=arguments),"undefined"!=typeof console?(J.print||(J.print=function(A){}),J.printErr||(J.printErr=function(A){})):J.print||(J.print=function(A){}),X&&(J.load=importScripts),void 0===J.setWindowTitle&&(J.setWindowTitle=function(A){document.title=A})}!J.load&&J.read&&(J.load=function(I){A(J.read(I))}),J.print||(J.print=function(){}),J.printErr||(J.printErr=J.print),J.arguments||(J.arguments=[]),J.thisProgram||(J.thisProgram="./this.program"),J.quit||(J.quit=function(A,I){throw I}),J.print=J.print,J.printErr=J.printErr,J.preRun=[],J.postRun=[];for(P in L)L.hasOwnProperty(P)&&(J[P]=L[P]);L=void 0;var j={setTempRet0:function(A){return tempRet0=A,A},getTempRet0:function(){return tempRet0},stackSave:function(){return EA},stackRestore:function(A){EA=A},getNativeTypeSize:function(A){switch(A){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:if("*"===A[A.length-1])return j.QUANTUM_SIZE;if("i"===A[0]){var e=parseInt(A.substr(1));return I(e%8==0),e/8}return 0}},getNativeFieldSize:function(A){return Math.max(j.getNativeTypeSize(A),j.QUANTUM_SIZE)},STACK_ALIGN:16,prepVararg:function(A,e){return"double"===e||"i64"===e?7&A&&(I(4==(7&A)),A+=4):I(0==(3&A)),A},getAlignSize:function(A,I,e){return e||"i64"!=A&&"double"!=A?A?Math.min(I||(A?j.getNativeFieldSize(A):0),j.QUANTUM_SIZE):Math.min(I,8):8},dynCall:function(A,I,e){return e&&e.length?J["dynCall_"+A].apply(null,[I].concat(e)):J["dynCall_"+A].call(null,I)},functionPointers:[null,null,null,null,null,null,null,null],addFunction:function(A){for(var I=0;I<j.functionPointers.length;I++)if(!j.functionPointers[I])return j.functionPointers[I]=A,1*(1+I);throw"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS."},removeFunction:function(A){j.functionPointers[(A-1)/1]=null},warnOnce:function(A){j.warnOnce.shown||(j.warnOnce.shown={}),j.warnOnce.shown[A]||(j.warnOnce.shown[A]=1,J.printErr(A))},funcWrappers:{},getFuncWrapper:function(A,e){if(A){I(e),j.funcWrappers[e]||(j.funcWrappers[e]={});var g=j.funcWrappers[e];return g[A]||(1===e.length?g[A]=function(){return j.dynCall(e,A)}:2===e.length?g[A]=function(I){return j.dynCall(e,A,[I])}:g[A]=function(){return j.dynCall(e,A,Array.prototype.slice.call(arguments))}),g[A]}},getCompilerSetting:function(A){throw"You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work"},stackAlloc:function(A){var I=EA;return EA=EA+A|0,EA=EA+15&-16,I},staticAlloc:function(A){var I=cA;return cA=cA+A|0,cA=cA+15&-16,I},dynamicAlloc:function(A){var I=rA[yA>>2],e=-16&(I+A+15|0);return rA[yA>>2]=e,e>=_A&&!y()?(rA[yA>>2]=I,0):I},alignMemory:function(A,I){return A=Math.ceil(A/(I||16))*(I||16)},makeBigInt:function(A,I,e){return e?+(A>>>0)+4294967296*+(I>>>0):+(A>>>0)+4294967296*+(0|I)},GLOBAL_BASE:8,QUANTUM_SIZE:4,__dummy__:0};J.Runtime=j;var Z,W,z=0,O=0;!function(){var A={stackSave:function(){j.stackSave()},stackRestore:function(){j.stackRestore()},arrayToC:function(A){var I=j.stackAlloc(A.length);return v(A,I),I},stringToC:function(A){var I=0;if(null!==A&&void 0!==A&&0!==A){var e=1+(A.length<<2);C(A,I=j.stackAlloc(e),e)}return I}},I={string:A.stringToC,array:A.arrayToC};W=function(A,g,i,B,t){var a=e(A),n=[],C=0;if(B)for(var o=0;o<B.length;o++){var c=I[i[o]];c?(0===C&&(C=j.stackSave()),n[o]=c(B[o])):n[o]=B[o]}var Q=a.apply(null,n);return"string"===g&&(Q=r(Q)),0!==C&&j.stackRestore(C),Q},Z=function(A,I,e){return function(){return W(A,I,e,arguments)}}}(),J.ccall=W,J.cwrap=Z,J.setValue=i,J.getValue=B;var $=2,AA=4;J.ALLOC_NORMAL=0,J.ALLOC_STACK=1,J.ALLOC_STATIC=$,J.ALLOC_DYNAMIC=3,J.ALLOC_NONE=AA,J.allocate=t,J.getMemory=function(A){return QA?DA?KA(A):j.dynamicAlloc(A):j.staticAlloc(A)},J.Pointer_stringify=r,J.AsciiToString=function(A){for(var I="";;){var e=gA[A++>>0];if(!e)return I;I+=String.fromCharCode(e)}},J.stringToAscii=function(A,I){return b(A,I,!1)};var IA="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;J.UTF8ArrayToString=a,J.UTF8ToString=function(A){return a(iA,A)},J.stringToUTF8Array=n,J.stringToUTF8=C,J.lengthBytesUTF8=o,"undefined"!=typeof TextDecoder&&new TextDecoder("utf-16le"),J.stackTrace=s;var eA,gA,iA,BA,tA,rA,aA,nA,CA,oA,cA,QA,EA,sA,hA,yA;oA=cA=EA=sA=hA=yA=0,QA=!1;var fA=J.TOTAL_STACK||5242880,_A=J.TOTAL_MEMORY||16777216;if(_A<fA&&J.printErr("TOTAL_MEMORY should be larger than TOTAL_STACK, was "+_A+"! (TOTAL_STACK="+fA+")"),eA=J.buffer?J.buffer:new ArrayBuffer(_A),J.HEAP8=gA=new Int8Array(eA),J.HEAP16=BA=new Int16Array(eA),J.HEAP32=rA=new Int32Array(eA),J.HEAPU8=iA=new Uint8Array(eA),J.HEAPU16=tA=new Uint16Array(eA),J.HEAPU32=aA=new Uint32Array(eA),J.HEAPF32=nA=new Float32Array(eA),J.HEAPF64=CA=new Float64Array(eA),rA[0]=1668509029,BA[1]=25459,115!==iA[2]||99!==iA[3])throw"Runtime error: expected the system to be little-endian!";J.HEAP=void 0,J.buffer=eA,J.HEAP8=gA,J.HEAP16=BA,J.HEAP32=rA,J.HEAPU8=iA,J.HEAPU16=tA,J.HEAPU32=aA,J.HEAPF32=nA,J.HEAPF64=CA;var pA=[],wA=[],lA=[],uA=[],dA=[],DA=!1,vA=!1;J.addOnPreRun=d,J.addOnInit=function(A){wA.unshift(A)},J.addOnPreMain=function(A){lA.unshift(A)},J.addOnExit=function(A){uA.unshift(A)},J.addOnPostRun=D,J.writeStringToMemory=function(A,I,e){j.warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");var g,i;e&&(i=I+o(A),g=gA[i]),C(A,I,1/0),e&&(gA[i]=g)},J.writeArrayToMemory=v,J.writeAsciiToMemory=b,Math.imul&&-5===Math.imul(4294967295,5)||(Math.imul=function(A,I){var e=65535&A,g=65535&I;return e*g+((A>>>16)*g+e*(I>>>16)<<16)|0}),Math.imul=Math.imul,Math.clz32||(Math.clz32=function(A){A>>>=0;for(var I=0;I<32;I++)if(A&1<<31-I)return I;return 32}),Math.clz32=Math.clz32,Math.trunc||(Math.trunc=function(A){return A<0?Math.ceil(A):Math.floor(A)}),Math.trunc=Math.trunc;var bA=Math.abs,kA=(Math.cos,Math.sin,Math.tan,Math.acos,Math.asin,Math.atan,Math.atan2,Math.exp,Math.log,Math.sqrt,Math.ceil),GA=Math.floor,FA=(Math.pow,Math.imul,Math.fround,Math.round,Math.min),mA=(Math.clz32,Math.trunc,0),MA=null,HA=null;J.addRunDependency=k,J.removeRunDependency=G,J.preloadedImages={},J.preloadedAudios={};var YA=null,SA=[function(){return J.getRandomValue()},function(){if(void 0===J.getRandomValue)try{var A="object"==typeof window?window:self,I=void 0!==A.crypto?A.crypto:A.msCrypto,e=function(){var A=new Uint32Array(1);return I.getRandomValues(A),A[0]>>>0};e(),J.getRandomValue=e}catch(A){try{var g=require("crypto"),i=function(){var A=g.randomBytes(4);return(A[0]<<24|A[1]<<16|A[2]<<8|A[3])>>>0};i(),J.getRandomValue=i}catch(A){throw"No secure random number generator found"}}}];oA=j.GLOBAL_BASE,cA=oA+35360,wA.push(),YA="data:application/octet-stream;base64,AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJuiVj8KyJ7BFw/SJ8u+Y8NXfrAXTxjM5sTgCiG1T/AXHF2pwPU3YT7o8C3YNEGcPKiBT+iw5zMZOx/13kqwDeuz///////////////////////////////////////9/7f///////////////////////////////////////3/u////////////////////////////////////////fwjJvPNn5glqO6fKhIWuZ7sr+JT+cvNuPPE2HV869U+l0YLmrX9SDlEfbD4rjGgFm2u9Qfur2YMfeSF+ExnN4FsirijXmC+KQs1l7yORRDdxLztN7M/7wLW824mBpdu16Ti1SPNbwlY5GdAFtvER8VmbTxmvpII/khiBbdrVXhyrQgIDo5iqB9i+b3BFAVuDEoyy5E6+hTEk4rT/1cN9DFVviXvydF2+crGWFjv+sd6ANRLHJacG3JuUJmnPdPGbwdJK8Z7BaZvk4yVPOIZHvu+11YyLxp3BD2WcrHfMoQwkdQIrWW8s6S2D5KZuqoR0StT7Qb3cqbBctVMRg9qI+Xar32buUlE+mBAytC1txjGoPyH7mMgnA7DkDu++x39Zv8KPqD3zC+DGJacKk0eRp9VvggPgUWPKBnBuDgpnKSkU/C/SRoUKtycmySZcOCEbLu0qxFr8bSxN37OVnRMNOFPeY6+LVHMKZaiydzy7Cmp25q7tRy7JwoE7NYIUhSxykmQD8Uyh6L+iATBCvEtmGqiRl/jQcItLwjC+VAajUWzHGFLv1hnoktEQqWVVJAaZ1iogcVeFNQ70uNG7MnCgahDI0NK4FsGkGVOrQVEIbDcemeuO30x3SCeoSJvhtbywNGNaycWzDBw5y4pB40qq2E5z42N3T8qcW6O4stbzby5o/LLvXe6Cj3RgLxdDb2OleHKr8KEUeMiE7DlkGggCx4woHmMj+v++kOm9gt7rbFCkFXnGsvej+b4rU3Lj8nhxxpxhJurOPifKB8LAIce4htEe6+DN1n3a6njRbu5/T331um8Xcqpn8AammMiixX1jCq4N+b4EmD8RG0ccEzULcRuEfQQj9XfbKJMkx0B7q8oyvL7JFQq+njxMDRCc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cHRvX2dlbmVyaWNoYXNoL2JsYWtlMmIvcmVmL2JsYWtlMmItcmVmLmMAY3J5cHRvX2dlbmVyaWNoYXNoX2JsYWtlMmJfX2ZpbmFsAG91dGxlbiA8PSBVSU5UOF9NQVgAY3J5cHRvX2dlbmVyaWNoYXNoL2JsYWtlMmIvcmVmL2dlbmVyaWNoYXNoX2JsYWtlMmIuYwBjcnlwdG9fZ2VuZXJpY2hhc2hfYmxha2UyYgBrZXlsZW4gPD0gVUlOVDhfTUFYAGNyeXB0b19nZW5lcmljaGFzaF9ibGFrZTJiX2luaXQAY3J5cHRvX2dlbmVyaWNoYXNoX2JsYWtlMmJfZmluYWwAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkYXJnb24yaWQAJGFyZ29uMmkAJHY9ACRtPQAsdD0ALHA9ACRhcmdvbjJpZCR2PQAkYXJnb24yaSR2PQAkYXJnb24yaWQkACRhcmdvbjJpJABhcmdvbjJpAFNpZ0VkMjU1MTkgbm8gRWQyNTUxOSBjb2xsaXNpb25zAQB7IHJldHVybiBNb2R1bGUuZ2V0UmFuZG9tVmFsdWUoKTsgfQB7IGlmIChNb2R1bGUuZ2V0UmFuZG9tVmFsdWUgPT09IHVuZGVmaW5lZCkgeyB0cnkgeyB2YXIgd2luZG93XyA9ICdvYmplY3QnID09PSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDogc2VsZjsgdmFyIGNyeXB0b18gPSB0eXBlb2Ygd2luZG93Xy5jcnlwdG8gIT09ICd1bmRlZmluZWQnID8gd2luZG93Xy5jcnlwdG8gOiB3aW5kb3dfLm1zQ3J5cHRvOyB2YXIgcmFuZG9tVmFsdWVzU3RhbmRhcmQgPSBmdW5jdGlvbigpIHsgdmFyIGJ1ZiA9IG5ldyBVaW50MzJBcnJheSgxKTsgY3J5cHRvXy5nZXRSYW5kb21WYWx1ZXMoYnVmKTsgcmV0dXJuIGJ1ZlswXSA+Pj4gMDsgfTsgcmFuZG9tVmFsdWVzU3RhbmRhcmQoKTsgTW9kdWxlLmdldFJhbmRvbVZhbHVlID0gcmFuZG9tVmFsdWVzU3RhbmRhcmQ7IH0gY2F0Y2ggKGUpIHsgdHJ5IHsgdmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpOyB2YXIgcmFuZG9tVmFsdWVOb2RlSlMgPSBmdW5jdGlvbigpIHsgdmFyIGJ1ZiA9IGNyeXB0by5yYW5kb21CeXRlcyg0KTsgcmV0dXJuIChidWZbMF0gPDwgMjQgfCBidWZbMV0gPDwgMTYgfCBidWZbMl0gPDwgOCB8IGJ1ZlszXSkgPj4+IDA7IH07IHJhbmRvbVZhbHVlTm9kZUpTKCk7IE1vZHVsZS5nZXRSYW5kb21WYWx1ZSA9IHJhbmRvbVZhbHVlTm9kZUpTOyB9IGNhdGNoIChlKSB7IHRocm93ICdObyBzZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgZm91bmQnOyB9IH0gfSB9AExpYnNvZGl1bURSR2J1Zl9sZW4gPD0gU0laRV9NQVgAcmFuZG9tYnl0ZXMvcmFuZG9tYnl0ZXMuYwByYW5kb21ieXRlcwBiNjRfcG9zIDw9IGI2NF9sZW4Ac29kaXVtL2NvZGVjcy5jAHNvZGl1bV9iaW4yYmFzZTY0ADEuMC4xNQ==";var RA=cA;cA+=16;var NA=t([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0],"i8",$),UA={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};yA=t(1,"i32",$),sA=(EA=j.alignMemory(cA))+fA,hA=j.alignMemory(sA),rA[yA>>2]=hA,QA=!0;var JA=!1;J.intArrayFromString=m,J.intArrayToString=M;var PA="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",LA="function"==typeof atob?atob:function(A){var I,e,g,i,B,t,r="",a=0;A=A.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{I=PA.indexOf(A.charAt(a++))<<2|(i=PA.indexOf(A.charAt(a++)))>>4,e=(15&i)<<4|(B=PA.indexOf(A.charAt(a++)))>>2,g=(3&B)<<6|(t=PA.indexOf(A.charAt(a++))),r+=String.fromCharCode(I),64!==B&&(r+=String.fromCharCode(e)),64!==t&&(r+=String.fromCharCode(g))}while(a<A.length);return r};J.asmGlobalArg={Math:Math,Int8Array:Int8Array,Int16Array:Int16Array,Int32Array:Int32Array,Uint8Array:Uint8Array,Uint16Array:Uint16Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,NaN:NaN,Infinity:1/0},J.asmLibraryArg={abort:U,assert:I,enlargeMemory:y,getTotalMemory:function(){return _A},abortOnCannotGrowMemory:h,___assert_fail:function(A,I,e,g){throw z=!0,"Assertion failed: "+r(A)+", at: "+[I?r(I):"unknown filename",e,g?r(g):"unknown function"]+" at "+s()},___setErrNo:F,_abort:function(){J.abort()},_emscripten_asm_const_i:function(A){return SA[A]()},_emscripten_memcpy_big:function(A,I,e){return iA.set(iA.subarray(I,I+e),A),A},_sysconf:function(A){switch(A){case 30:return 16384;case 85:return iA.length/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 80:case 81:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 79:return 0;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return"object"==typeof navigator?navigator.hardwareConcurrency||1:1}return F(UA.EINVAL),-1},DYNAMICTOP_PTR:yA,tempDoublePtr:RA,ABORT:z,STACKTOP:EA,STACK_MAX:sA,cttz_i8:NA};var xA=function(A,I,e){"";function g(A,I){A|=0,I|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0,P=0,L=0,x=0,X=0,K=0,T=0,V=0,q=0,j=0,Z=0,W=0,z=0,O=0,$=0,AA=0,IA=0,eA=0,gA=0,iA=0,BA=0;i=wi,B=wi=wi+63&-64,wi=wi+256|0,e=0;do{t=0|oe(I+(e<<3)|0),fi[(g=B+128+(e<<3)|0)>>2]=t,fi[g+4>>2]=vi,e=e+1|0}while(16!=(0|e));I=A,g=(e=B)+64|0;do{fi[e>>2]=fi[I>>2],e=e+4|0,I=I+4|0}while((0|e)<(0|g));for(fi[B+88>>2]=1595750129,fi[B+88+4>>2]=-1521486534,$=-1377402159^fi[A+64>>2],s=1359893119^fi[A+64+4>>2],t=725511199^fi[A+72>>2],p=-1694144372^fi[A+72+4>>2],o=-79577749^fi[A+80>>2],h=528734635^fi[A+80+4>>2],H=327033209^fi[A+88>>2],O=1541459225^fi[A+88+4>>2],fi[B+120>>2]=H,fi[B+120+4>>2]=O,e=0|Ig(0|(e=0|Ig(0|(R=0|Ig(0|(R=0|Ig(0|(f=0|fi[B+32>>2]),0|(g=0|fi[B+32+4>>2]),0|fi[B>>2],0|fi[B+4>>2])),0|vi,0|fi[B+128>>2],0|fi[B+128+4>>2])),0|(e=vi),0|(g=0|Ee(f^(K=0|Ig(0|(s=0|Ee($^R,s^e,32)),0|($=vi),-205731576,1779033703)),g^(N=vi),24)),0|(f=vi))),0|vi,0|fi[(R=B+128+8|0)>>2],0|fi[R+4>>2]),P=vi,fi[B>>2]=e,fi[B+4>>2]=P,$=0|Ee(s^e,$^P,16),s=vi,fi[B+96>>2]=$,fi[B+96+4>>2]=s,s=0|Ig(0|K,0|N,0|$,0|s),$=vi,fi[B+64>>2]=s,fi[B+64+4>>2]=$,$=0|Ee(g^s,f^$,63),fi[B+32>>2]=$,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(s=0|Ig(0|(s=0|Ig(0|($=0|fi[B+40>>2]),0|(f=0|fi[B+40+4>>2]),0|fi[B+8>>2],0|fi[B+8+4>>2])),0|vi,0|fi[(g=B+128+16|0)>>2],0|fi[g+4>>2])),p^(N=vi),32))^(N=0|Ig(0|(N=0|Ig(0|s,0|N,0|(f=0|Ee($^(K=0|Ig(0|p,0|(t=vi),-2067093701,-1150833019)),f^(v=vi),24)),0|($=vi))),0|vi,0|fi[(s=B+128+24|0)>>2],0|fi[s+4>>2])),t^(w=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,v=0|Ig(0|K,0|v,0|t,0|p),K=vi,fi[B+72>>2]=v,fi[B+72+4>>2]=K,K=0|Ee(f^v,$^K,63),$=vi,o=0|Ee((h=0|Ee(o^(y=0|Ig(0|(y=0|Ig(0|(v=0|fi[B+48>>2]),0|(f=0|fi[B+48+4>>2]),0|fi[B+16>>2],0|fi[B+16+4>>2])),0|vi,0|fi[(V=B+128+32|0)>>2],0|fi[V+4>>2])),h^(r=vi),32))^(r=0|Ig(0|(r=0|Ig(0|y,0|r,0|(f=0|Ee(v^(D=0|Ig(0|h,0|(o=vi),-23791573,1013904242)),f^(I=vi),24)),0|(v=vi))),0|vi,0|fi[(y=B+128+40|0)>>2],0|fi[y+4>>2])),o^(U=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,v=0|Ee(f^(I=0|Ig(0|D,0|I,0|o,0|h)),v^(D=vi),63),f=vi,O=0|Ee(H^(_=0|Ig(0|(_=0|Ig(0|(C=0|fi[B+56>>2]),0|(c=0|fi[B+56+4>>2]),0|fi[B+24>>2],0|fi[B+24+4>>2])),0|vi,0|fi[(E=B+128+48|0)>>2],0|fi[E+4>>2])),O^(z=vi),32),H=vi,C=0|Ee((c=0|Ee(C^(d=0|Ig(0|fi[B+88>>2],0|fi[B+88+4>>2],0|O,0|H)),c^(k=vi),24))^(k=0|Ig(0|d,0|k,0|(H=0|Ee(O^(z=0|Ig(0|(z=0|Ig(0|_,0|z,0|c,0|(C=vi))),0|vi,0|fi[(_=B+128+56|0)>>2],0|fi[_+4>>2])),H^(l=vi),16)),0|(O=vi))),C^(d=vi),63),c=vi,H=0|Ee((O=0|Ee(H^(P=0|Ig(0|(P=0|Ig(0|K,0|$,0|e,0|P)),0|vi,0|fi[(e=B+128+64|0)>>2],0|fi[e+4>>2])),O^(L=vi),32))^(L=0|Ig(0|(L=0|Ig(0|P,0|L,0|($=0|Ee(K^(D=0|Ig(0|I,0|D,0|O,0|(H=vi))),$^(I=vi),24)),0|(K=vi))),0|vi,0|fi[(P=B+128+72|0)>>2],0|fi[P+4>>2])),H^(W=vi),16),O=vi,fi[B+120>>2]=H,fi[B+120+4>>2]=O,O=0|Ig(0|D,0|I,0|H,0|O),H=vi,fi[B+80>>2]=O,fi[B+80+4>>2]=H,H=0|Ee($^O,K^H,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,w=0|Ig(0|v,0|f,0|N,0|w),O=0|fi[(N=B+128+80|0)>>2],$=0|fi[N+4>>2],w=0|Ig(0|w,0|vi,0|O,0|$),I=vi,k=0|Ig(0|(d=0|Ig(0|k,0|d,0|(D=0|Ee(fi[B+96>>2]^w,fi[B+96+4>>2]^I,32)),0|(u=vi))),0|(k=vi),0|(u=0|Ee(D^(I=0|Ig(0|(I=0|Ig(0|w,0|I,0|(f=0|Ee(v^d,f^k,24)),0|(v=vi))),0|vi,0|fi[(w=B+128+88|0)>>2],0|fi[w+4>>2])),u^(S=vi),16)),0|(D=vi)),d=vi,fi[B+88>>2]=k,fi[B+88+4>>2]=d,d=0|Ee(f^k,v^d,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,p=0|Ee(t^(U=0|Ig(0|(U=0|Ig(0|C,0|c,0|r,0|U)),0|vi,0|fi[(r=B+128+96|0)>>2],0|fi[r+4>>2])),p^(k=vi),32),t=vi,k=0|Ig(0|U,0|k,0|(c=0|Ee(C^(f=0|Ig(0|fi[B+64>>2],0|fi[B+64+4>>2],0|p,0|t)),c^(Q=vi),24)),0|(C=vi)),AA=0|fi[(U=B+128+104|0)>>2],Z=0|fi[U+4>>2],C=0|Ee(c^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(k=0|Ig(0|k,0|vi,0|AA,0|Z)),t^(b=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,l=0|Ig(0|(n=0|fi[B+32>>2]),0|(gA=0|fi[B+32+4>>2]),0|z,0|l),x=0|fi[(z=B+128+112|0)>>2],a=0|fi[z+4>>2],h=0|Ee(o^(l=0|Ig(0|l,0|vi,0|x,0|a)),h^(BA=vi),32),o=vi,BA=0|Ig(0|l,0|BA,0|(gA=0|Ee(n^(m=0|Ig(0|fi[B+72>>2],0|fi[B+72+4>>2],0|h,0|o)),gA^(X=vi),24)),0|(n=vi)),F=0|fi[(l=B+128+120|0)>>2],eA=0|fi[l+4>>2],u=0|Ee((D=0|Ee(u^(a=0|Ig(0|(W=0|Ig(0|L,0|W,0|(n=0|Ee(gA^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(BA=0|Ig(0|BA,0|vi,0|F,0|eA)),o^(J=vi),16)),0|(h=vi))),n^(m=vi),63)),0|(gA=vi))),0|vi,0|x,0|a)),D^(x=vi),32))^($=0|Ig(0|(x=0|Ig(0|a,0|x,0|(gA=0|Ee(n^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),gA^(Q=vi),24)),0|(n=vi))),0|vi,0|O,0|$)),u^(O=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,n=0|Ee(gA^Q,n^f,63),fi[B+32>>2]=n,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(S=0|Ig(0|(S=0|Ig(0|H,0|K,0|I,0|S)),0|vi,0|fi[V>>2],0|fi[V+4>>2])),p^(I=vi),32))^(I=0|Ig(0|(I=0|Ig(0|S,0|I,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|fi[e>>2],0|fi[e+4>>2])),t^(S=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,h=0|Ee(o^(b=0|Ig(0|(b=0|Ig(0|d,0|v,0|k,0|b)),0|vi,0|fi[P>>2],0|fi[P+4>>2])),h^(k=vi),32),o=vi,o=0|Ee(h^(eA=0|Ig(0|(k=0|Ig(0|b,0|k,0|(v=0|Ee(d^(n=0|Ig(0|fi[B+80>>2],0|fi[B+80+4>>2],0|h,0|o)),v^(gA=vi),24)),0|(d=vi))),0|vi,0|F,0|eA)),o^(F=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(gA=0|Ig(0|n,0|gA,0|o,0|h)),d^(n=vi),63),v=vi,Z=0|Ig(0|(J=0|Ig(0|C,0|c,0|BA,0|J)),0|vi,0|AA,0|Z),AA=vi,J=0|Ee(fi[B+120>>2]^Z,fi[B+120+4>>2]^AA,32),BA=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|fi[B+88>>2],0|fi[B+88+4>>2],0|J,0|BA)),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(BA=0|Ee(J^(AA=0|Ig(0|(AA=0|Ig(0|Z,0|AA,0|c,0|(C=vi))),0|vi,0|fi[E>>2],0|fi[E+4>>2])),BA^(Z=vi),16)),0|(J=vi))),C^(k=vi),63),c=vi,$=0|Ig(0|(O=0|Ig(0|(O=0|Ig(0|H,0|K,0|$,0|O)),0|vi,0|fi[R>>2],0|fi[R+4>>2])),0|($=vi),0|(K=0|Ee(H^(n=0|Ig(0|gA,0|n,0|(J=0|Ee(BA^O,J^$,32)),0|(BA=vi))),K^(gA=vi),24)),0|(H=vi)),O=0|fi[r>>2],x=0|fi[r+4>>2],BA=0|Ee(J^($=0|Ig(0|$,0|vi,0|O,0|x)),BA^(a=vi),16),J=vi,fi[B+120>>2]=BA,fi[B+120+4>>2]=J,J=0|Ig(0|n,0|gA,0|BA,0|J),BA=vi,fi[B+80>>2]=J,fi[B+80+4>>2]=BA,H=0|Ee(K^J,H^BA,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,S=0|Ig(0|d,0|v,0|I,0|S),I=0|fi[B+128>>2],gA=0|fi[B+128+4>>2],n=0|Ig(0|(S=0|Ig(0|S,0|vi,0|I,0|gA)),0|(n=vi),0|(v=0|Ee(d^(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^S,D^n,32)),0|(u=vi))),v^(b=vi),24)),0|(d=vi)),S=0|fi[g>>2],W=0|fi[g+4>>2],b=0|Ig(0|k,0|b,0|(u=0|Ee(D^(n=0|Ig(0|n,0|vi,0|S,0|W)),u^(L=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,F=0|Ig(0|C,0|c,0|eA,0|F),eA=0|fi[w>>2],iA=0|fi[w+4>>2],C=0|Ee((c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^(F=0|Ig(0|F,0|vi,0|eA,0|iA)),p^(Y=vi),32)),0|(t=vi))),c^(Q=vi),24))^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(Y=0|Ig(0|(Y=0|Ig(0|F,0|Y,0|c,0|(C=vi))),0|vi,0|fi[_>>2],0|fi[_+4>>2])),t^(F=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,Z=0|Ig(0|(j=0|fi[B+32>>2]),0|(T=0|fi[B+32+4>>2]),0|AA,0|Z),AA=0|fi[y>>2],G=0|fi[y+4>>2],IA=0|Ig(0|(Z=0|Ig(0|Z,0|vi,0|AA,0|G)),0|(IA=vi),0|(T=0|Ee(j^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^Z,h^IA,32)),0|(o=vi))),T^(X=vi),24)),0|(j=vi)),Z=0|fi[s>>2],M=0|fi[s+4>>2],u=0|Ee((D=0|Ee(u^(iA=0|Ig(0|(a=0|Ig(0|$,0|a,0|(j=0|Ee(T^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(IA=0|Ig(0|IA,0|vi,0|Z,0|M)),o^(q=vi),16)),0|(h=vi))),j^(m=vi),63)),0|(T=vi))),0|vi,0|eA,0|iA)),D^(eA=vi),32))^(eA=0|Ig(0|(eA=0|Ig(0|iA,0|eA,0|(T=0|Ee(j^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),T^(Q=vi),24)),0|(j=vi))),0|vi,0|fi[e>>2],0|fi[e+4>>2])),u^(iA=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,j=0|Ee(T^Q,j^f,63),fi[B+32>>2]=j,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(x=0|Ig(0|(L=0|Ig(0|H,0|K,0|n,0|L)),0|vi,0|O,0|x)),p^(O=vi),32))^(gA=0|Ig(0|(O=0|Ig(0|x,0|O,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|I,0|gA)),t^(I=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,o=0|Ee((h=0|Ee(o^(G=0|Ig(0|(F=0|Ig(0|d,0|v,0|Y,0|F)),0|vi,0|AA,0|G)),h^(AA=vi),32))^(W=0|Ig(0|(AA=0|Ig(0|G,0|AA,0|(v=0|Ee(d^(BA=0|Ig(0|J,0|BA,0|h,0|(o=vi))),v^(J=vi),24)),0|(d=vi))),0|vi,0|S,0|W)),o^(S=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(J=0|Ig(0|BA,0|J,0|o,0|h)),d^(BA=vi),63),v=vi,q=0|Ig(0|(q=0|Ig(0|C,0|c,0|IA,0|q)),0|vi,0|fi[l>>2],0|fi[l+4>>2]),IA=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(AA=0|Ee(fi[B+120>>2]^q,fi[B+120+4>>2]^IA,32)),0|(G=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(G=0|Ee(AA^(IA=0|Ig(0|(IA=0|Ig(0|q,0|IA,0|c,0|(C=vi))),0|vi,0|fi[U>>2],0|fi[U+4>>2])),G^(q=vi),16)),0|(AA=vi))),C^(k=vi),63),c=vi,G=0|Ee((AA=0|Ee(G^(iA=0|Ig(0|(iA=0|Ig(0|H,0|K,0|eA,0|iA)),0|vi,0|fi[N>>2],0|fi[N+4>>2])),AA^(eA=vi),32))^(eA=0|Ig(0|(eA=0|Ig(0|iA,0|eA,0|(K=0|Ee(H^(BA=0|Ig(0|J,0|BA,0|AA,0|(G=vi))),K^(J=vi),24)),0|(H=vi))),0|vi,0|fi[z>>2],0|fi[z+4>>2])),G^(iA=vi),16),AA=vi,fi[B+120>>2]=G,fi[B+120+4>>2]=AA,AA=0|Ig(0|BA,0|J,0|G,0|AA),G=vi,fi[B+80>>2]=AA,fi[B+80+4>>2]=G,H=0|Ee(K^AA,H^G,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,b=0|Ig(0|(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^(M=0|Ig(0|(I=0|Ig(0|d,0|v,0|gA,0|I)),0|vi,0|Z,0|M)),D^(Z=vi),32)),0|(u=vi))),0|(b=vi),0|(u=0|Ee(D^(Z=0|Ig(0|(Z=0|Ig(0|M,0|Z,0|(v=0|Ee(d^k,v^b,24)),0|(d=vi))),0|vi,0|fi[E>>2],0|fi[E+4>>2])),u^(M=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,S=0|Ig(0|C,0|c,0|W,0|S),W=0|fi[_>>2],I=0|fi[_+4>>2],gA=0|Ig(0|(S=0|Ig(0|S,0|vi,0|W,0|I)),0|(gA=vi),0|(c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^S,p^gA,32)),0|(t=vi))),c^(Q=vi),24)),0|(C=vi)),S=0|fi[R>>2],J=0|fi[R+4>>2],C=0|Ee(c^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(gA=0|Ig(0|gA,0|vi,0|S,0|J)),t^(BA=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,q=0|Ig(0|(F=0|fi[B+32>>2]),0|(Y=0|fi[B+32+4>>2]),0|IA,0|q),IA=0|fi[P>>2],O=0|fi[P+4>>2],u=0|Ee((D=0|Ee(u^(I=0|Ig(0|(iA=0|Ig(0|eA,0|iA,0|(F=0|Ee((Y=0|Ee(F^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^(q=0|Ig(0|q,0|vi,0|IA,0|O)),h^(x=vi),32)),0|(o=vi))),Y^(X=vi),24))^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(x=0|Ig(0|(x=0|Ig(0|q,0|x,0|Y,0|(F=vi))),0|vi,0|fi[V>>2],0|fi[V+4>>2])),o^(q=vi),16)),0|(h=vi))),F^(m=vi),63)),0|(Y=vi))),0|vi,0|W,0|I)),D^(W=vi),32))^(O=0|Ig(0|(W=0|Ig(0|I,0|W,0|(Y=0|Ee(F^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),Y^(Q=vi),24)),0|(F=vi))),0|vi,0|IA,0|O)),u^(IA=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,F=0|Ee(Y^Q,F^f,63),fi[B+32>>2]=F,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(M=0|Ig(0|(M=0|Ig(0|H,0|K,0|Z,0|M)),0|vi,0|fi[s>>2],0|fi[s+4>>2])),p^(Z=vi),32))^(J=0|Ig(0|(Z=0|Ig(0|M,0|Z,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|S,0|J)),t^(S=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,o=0|Ee((h=0|Ee(o^(BA=0|Ig(0|(BA=0|Ig(0|d,0|v,0|gA,0|BA)),0|vi,0|fi[U>>2],0|fi[U+4>>2])),h^(gA=vi),32))^(gA=0|Ig(0|(gA=0|Ig(0|BA,0|gA,0|(v=0|Ee(d^(G=0|Ig(0|AA,0|G,0|h,0|(o=vi))),v^(AA=vi),24)),0|(d=vi))),0|vi,0|fi[r>>2],0|fi[r+4>>2])),o^(BA=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(AA=0|Ig(0|G,0|AA,0|o,0|h)),d^(G=vi),63),v=vi,q=0|Ig(0|(q=0|Ig(0|C,0|c,0|x,0|q)),0|vi,0|fi[w>>2],0|fi[w+4>>2]),x=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(Z=0|Ee(fi[B+120>>2]^q,fi[B+120+4>>2]^x,32)),0|(M=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(M=0|Ee(Z^(x=0|Ig(0|(x=0|Ig(0|q,0|x,0|c,0|(C=vi))),0|vi,0|fi[z>>2],0|fi[z+4>>2])),M^(q=vi),16)),0|(Z=vi))),C^(k=vi),63),c=vi,M=0|Ee((Z=0|Ee(M^(IA=0|Ig(0|(IA=0|Ig(0|H,0|K,0|O,0|IA)),0|vi,0|fi[g>>2],0|fi[g+4>>2])),Z^(O=vi),32))^(O=0|Ig(0|(O=0|Ig(0|IA,0|O,0|(K=0|Ee(H^(G=0|Ig(0|AA,0|G,0|Z,0|(M=vi))),K^(AA=vi),24)),0|(H=vi))),0|vi,0|fi[E>>2],0|fi[E+4>>2])),M^(IA=vi),16),Z=vi,fi[B+120>>2]=M,fi[B+120+4>>2]=Z,Z=0|Ig(0|G,0|AA,0|M,0|Z),M=vi,fi[B+80>>2]=Z,fi[B+80+4>>2]=M,H=0|Ee(K^Z,H^M,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,S=0|Ig(0|d,0|v,0|J,0|S),J=0|fi[y>>2],AA=0|fi[y+4>>2],G=0|Ig(0|(S=0|Ig(0|S,0|vi,0|J,0|AA)),0|(G=vi),0|(v=0|Ee(d^(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^S,D^G,32)),0|(u=vi))),v^(b=vi),24)),0|(d=vi)),S=0|fi[N>>2],F=0|fi[N+4>>2],b=0|Ig(0|k,0|b,0|(u=0|Ee(D^(G=0|Ig(0|G,0|vi,0|S,0|F)),u^(Y=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,BA=0|Ig(0|C,0|c,0|gA,0|BA),gA=0|fi[V>>2],W=0|fi[V+4>>2],I=0|Ig(0|(BA=0|Ig(0|BA,0|vi,0|gA,0|W)),0|(I=vi),0|(c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^BA,p^I,32)),0|(t=vi))),c^(Q=vi),24)),0|(C=vi)),BA=0|fi[B+128>>2],iA=0|fi[B+128+4>>2],C=0|Ee(c^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(I=0|Ig(0|I,0|vi,0|BA,0|iA)),t^(eA=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,q=0|Ig(0|(L=0|fi[B+32>>2]),0|(n=0|fi[B+32+4>>2]),0|x,0|q),x=0|fi[l>>2],j=0|fi[l+4>>2],u=0|Ee((D=0|Ee(u^(IA=0|Ig(0|(IA=0|Ig(0|O,0|IA,0|(L=0|Ee((n=0|Ee(L^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^(q=0|Ig(0|q,0|vi,0|x,0|j)),h^(T=vi),32)),0|(o=vi))),n^(X=vi),24))^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(T=0|Ig(0|(T=0|Ig(0|q,0|T,0|n,0|(L=vi))),0|vi,0|fi[e>>2],0|fi[e+4>>2])),o^(q=vi),16)),0|(h=vi))),L^(m=vi),63)),0|(n=vi))),0|vi,0|fi[P>>2],0|fi[P+4>>2])),D^(O=vi),32))^(iA=0|Ig(0|(O=0|Ig(0|IA,0|O,0|(n=0|Ee(L^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),n^(Q=vi),24)),0|(L=vi))),0|vi,0|BA,0|iA)),u^(BA=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,L=0|Ee(n^Q,L^f,63),fi[B+32>>2]=L,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(AA=0|Ig(0|(Y=0|Ig(0|H,0|K,0|G,0|Y)),0|vi,0|J,0|AA)),p^(J=vi),32))^(J=0|Ig(0|(J=0|Ig(0|AA,0|J,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|fi[_>>2],0|fi[_+4>>2])),t^(AA=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,o=0|Ee((h=0|Ee(o^(eA=0|Ig(0|(eA=0|Ig(0|d,0|v,0|I,0|eA)),0|vi,0|fi[g>>2],0|fi[g+4>>2])),h^(I=vi),32))^(W=0|Ig(0|(I=0|Ig(0|eA,0|I,0|(v=0|Ee(d^(M=0|Ig(0|Z,0|M,0|h,0|(o=vi))),v^(Z=vi),24)),0|(d=vi))),0|vi,0|gA,0|W)),o^(gA=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(Z=0|Ig(0|M,0|Z,0|o,0|h)),d^(M=vi),63),v=vi,F=0|Ig(0|(q=0|Ig(0|C,0|c,0|T,0|q)),0|vi,0|S,0|F),S=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(q=0|Ee(fi[B+120>>2]^F,fi[B+120+4>>2]^S,32)),0|(T=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(T=0|Ee(q^(j=0|Ig(0|(S=0|Ig(0|F,0|S,0|c,0|(C=vi))),0|vi,0|x,0|j)),T^(x=vi),16)),0|(q=vi))),C^(k=vi),63),c=vi,T=0|Ee((q=0|Ee(T^(BA=0|Ig(0|(BA=0|Ig(0|H,0|K,0|iA,0|BA)),0|vi,0|fi[z>>2],0|fi[z+4>>2])),q^(iA=vi),32))^(iA=0|Ig(0|(iA=0|Ig(0|BA,0|iA,0|(K=0|Ee(H^(M=0|Ig(0|Z,0|M,0|q,0|(T=vi))),K^(Z=vi),24)),0|(H=vi))),0|vi,0|fi[R>>2],0|fi[R+4>>2])),T^(BA=vi),16),q=vi,fi[B+120>>2]=T,fi[B+120+4>>2]=q,q=0|Ig(0|M,0|Z,0|T,0|q),T=vi,fi[B+80>>2]=q,fi[B+80+4>>2]=T,H=0|Ee(K^q,H^T,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,AA=0|Ig(0|d,0|v,0|J,0|AA),J=0|fi[w>>2],Z=0|fi[w+4>>2],M=0|Ig(0|(AA=0|Ig(0|AA,0|vi,0|J,0|Z)),0|(M=vi),0|(v=0|Ee(d^(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^AA,D^M,32)),0|(u=vi))),v^(b=vi),24)),0|(d=vi)),AA=0|fi[r>>2],S=0|fi[r+4>>2],b=0|Ig(0|k,0|b,0|(u=0|Ee(D^(M=0|Ig(0|M,0|vi,0|AA,0|S)),u^(F=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,gA=0|Ig(0|C,0|c,0|W,0|gA),W=0|fi[E>>2],I=0|fi[E+4>>2],eA=0|Ig(0|(gA=0|Ig(0|gA,0|vi,0|W,0|I)),0|(eA=vi),0|(c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^gA,p^eA,32)),0|(t=vi))),c^(Q=vi),24)),0|(C=vi)),gA=0|fi[e>>2],Y=0|fi[e+4>>2],C=0|Ee(c^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(eA=0|Ig(0|eA,0|vi,0|gA,0|Y)),t^(G=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,x=0|Ig(0|(L=0|fi[B+32>>2]),0|(n=0|fi[B+32+4>>2]),0|j,0|x),j=0|fi[s>>2],O=0|fi[s+4>>2],IA=0|Ig(0|(x=0|Ig(0|x,0|vi,0|j,0|O)),0|(IA=vi),0|(n=0|Ee(L^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^x,h^IA,32)),0|(o=vi))),n^(X=vi),24)),0|(L=vi)),x=0|fi[U>>2],a=0|fi[U+4>>2],u=0|Ee((D=0|Ee(u^(BA=0|Ig(0|(BA=0|Ig(0|iA,0|BA,0|(L=0|Ee(n^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(IA=0|Ig(0|IA,0|vi,0|x,0|a)),o^($=vi),16)),0|(h=vi))),L^(m=vi),63)),0|(n=vi))),0|vi,0|fi[g>>2],0|fi[g+4>>2])),D^(iA=vi),32))^(S=0|Ig(0|(iA=0|Ig(0|BA,0|iA,0|(n=0|Ee(L^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),n^(Q=vi),24)),0|(L=vi))),0|vi,0|AA,0|S)),u^(AA=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,L=0|Ee(n^Q,L^f,63),fi[B+32>>2]=L,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(I=0|Ig(0|(F=0|Ig(0|H,0|K,0|M,0|F)),0|vi,0|W,0|I)),p^(W=vi),32))^(W=0|Ig(0|(W=0|Ig(0|I,0|W,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|fi[N>>2],0|fi[N+4>>2])),t^(I=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,o=0|Ee((h=0|Ee(o^(G=0|Ig(0|(G=0|Ig(0|d,0|v,0|eA,0|G)),0|vi,0|fi[B+128>>2],0|fi[B+128+4>>2])),h^(eA=vi),32))^(Z=0|Ig(0|(eA=0|Ig(0|G,0|eA,0|(v=0|Ee(d^(T=0|Ig(0|q,0|T,0|h,0|(o=vi))),v^(q=vi),24)),0|(d=vi))),0|vi,0|J,0|Z)),o^(J=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(q=0|Ig(0|T,0|q,0|o,0|h)),d^(T=vi),63),v=vi,Y=0|Ig(0|($=0|Ig(0|C,0|c,0|IA,0|$)),0|vi,0|gA,0|Y),gA=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|($=0|Ee(fi[B+120>>2]^Y,fi[B+120+4>>2]^gA,32)),0|(IA=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(IA=0|Ee($^(O=0|Ig(0|(gA=0|Ig(0|Y,0|gA,0|c,0|(C=vi))),0|vi,0|j,0|O)),IA^(j=vi),16)),0|($=vi))),C^(k=vi),63),c=vi,IA=0|Ee(($=0|Ee(IA^(AA=0|Ig(0|(AA=0|Ig(0|H,0|K,0|S,0|AA)),0|vi,0|fi[V>>2],0|fi[V+4>>2])),$^(S=vi),32))^(a=0|Ig(0|(S=0|Ig(0|AA,0|S,0|(K=0|Ee(H^(T=0|Ig(0|q,0|T,0|$,0|(IA=vi))),K^(q=vi),24)),0|(H=vi))),0|vi,0|x,0|a)),IA^(x=vi),16),$=vi,fi[B+120>>2]=IA,fi[B+120+4>>2]=$,$=0|Ig(0|T,0|q,0|IA,0|$),IA=vi,fi[B+80>>2]=$,fi[B+80+4>>2]=IA,H=0|Ee(K^$,H^IA,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,W=0|Ig(0|(I=0|Ig(0|(I=0|Ig(0|d,0|v,0|W,0|I)),0|vi,0|fi[_>>2],0|fi[_+4>>2])),0|(W=vi),0|(v=0|Ee(d^(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^I,D^W,32)),0|(u=vi))),v^(b=vi),24)),0|(d=vi)),I=0|fi[y>>2],q=0|fi[y+4>>2],b=0|Ig(0|k,0|b,0|(u=0|Ee(D^(W=0|Ig(0|W,0|vi,0|I,0|q)),u^(T=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,J=0|Ig(0|C,0|c,0|Z,0|J),Z=0|fi[l>>2],S=0|fi[l+4>>2],AA=0|Ig(0|(J=0|Ig(0|J,0|vi,0|Z,0|S)),0|(AA=vi),0|(c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^J,p^AA,32)),0|(t=vi))),c^(Q=vi),24)),0|(C=vi)),J=0|fi[z>>2],gA=0|fi[z+4>>2],C=0|Ee(c^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(AA=0|Ig(0|AA,0|vi,0|J,0|gA)),t^(Y=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,j=0|Ig(0|(eA=0|fi[B+32>>2]),0|(G=0|fi[B+32+4>>2]),0|O,0|j),O=0|fi[R>>2],F=0|fi[R+4>>2],u=0|Ee((D=0|Ee(u^(x=0|Ig(0|(x=0|Ig(0|a,0|x,0|(eA=0|Ee((G=0|Ee(eA^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^(j=0|Ig(0|j,0|vi,0|O,0|F)),h^(M=vi),32)),0|(o=vi))),G^(X=vi),24))^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(M=0|Ig(0|(M=0|Ig(0|j,0|M,0|G,0|(eA=vi))),0|vi,0|fi[P>>2],0|fi[P+4>>2])),o^(j=vi),16)),0|(h=vi))),eA^(m=vi),63)),0|(G=vi))),0|vi,0|fi[r>>2],0|fi[r+4>>2])),D^(a=vi),32))^(q=0|Ig(0|(a=0|Ig(0|x,0|a,0|(G=0|Ee(eA^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),G^(Q=vi),24)),0|(eA=vi))),0|vi,0|I,0|q)),u^(I=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,eA=0|Ee(G^Q,eA^f,63),fi[B+32>>2]=eA,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(F=0|Ig(0|(T=0|Ig(0|H,0|K,0|W,0|T)),0|vi,0|O,0|F)),p^(O=vi),32))^(S=0|Ig(0|(O=0|Ig(0|F,0|O,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|Z,0|S)),t^(Z=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,J=0|Ig(0|(gA=0|Ig(0|(Y=0|Ig(0|d,0|v,0|AA,0|Y)),0|vi,0|J,0|gA)),0|(J=vi),0|(v=0|Ee(d^(IA=0|Ig(0|$,0|IA,0|(h=0|Ee(o^gA,h^J,32)),0|(o=vi))),v^($=vi),24)),0|(d=vi)),gA=0|fi[U>>2],Y=0|fi[U+4>>2],o=0|Ee(h^(J=0|Ig(0|J,0|vi,0|gA,0|Y)),o^(AA=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^($=0|Ig(0|IA,0|$,0|o,0|h)),d^(IA=vi),63),v=vi,j=0|Ig(0|(j=0|Ig(0|C,0|c,0|M,0|j)),0|vi,0|fi[V>>2],0|fi[V+4>>2]),M=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(O=0|Ee(fi[B+120>>2]^j,fi[B+120+4>>2]^M,32)),0|(F=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(F=0|Ee(O^(M=0|Ig(0|(M=0|Ig(0|j,0|M,0|c,0|(C=vi))),0|vi,0|fi[N>>2],0|fi[N+4>>2])),F^(j=vi),16)),0|(O=vi))),C^(k=vi),63),c=vi,q=0|Ig(0|(I=0|Ig(0|(I=0|Ig(0|H,0|K,0|q,0|I)),0|vi,0|fi[B+128>>2],0|fi[B+128+4>>2])),0|(q=vi),0|(K=0|Ee(H^(IA=0|Ig(0|$,0|IA,0|(O=0|Ee(F^I,O^q,32)),0|(F=vi))),K^($=vi),24)),0|(H=vi)),I=0|fi[_>>2],T=0|fi[_+4>>2],F=0|Ee(O^(q=0|Ig(0|q,0|vi,0|I,0|T)),F^(W=vi),16),O=vi,fi[B+120>>2]=F,fi[B+120+4>>2]=O,O=0|Ig(0|IA,0|$,0|F,0|O),F=vi,fi[B+80>>2]=O,fi[B+80+4>>2]=F,H=0|Ee(K^O,H^F,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,S=0|Ig(0|(Z=0|Ig(0|(Z=0|Ig(0|d,0|v,0|S,0|Z)),0|vi,0|fi[E>>2],0|fi[E+4>>2])),0|(S=vi),0|(v=0|Ee(d^(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^Z,D^S,32)),0|(u=vi))),v^(b=vi),24)),0|(d=vi)),Z=0|fi[s>>2],$=0|fi[s+4>>2],b=0|Ig(0|k,0|b,0|(u=0|Ee(D^(S=0|Ig(0|S,0|vi,0|Z,0|$)),u^(IA=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,AA=0|Ig(0|C,0|c,0|J,0|AA),J=0|fi[P>>2],eA=0|fi[P+4>>2],C=0|Ee((c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^(AA=0|Ig(0|AA,0|vi,0|J,0|eA)),p^(G=vi),32)),0|(t=vi))),c^(Q=vi),24))^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(G=0|Ig(0|(G=0|Ig(0|AA,0|G,0|c,0|(C=vi))),0|vi,0|fi[g>>2],0|fi[g+4>>2])),t^(AA=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,M=0|Ig(0|(j=0|Ig(0|(j=0|Ig(0|(a=0|fi[B+32>>2]),0|(x=0|fi[B+32+4>>2]),0|M,0|j)),0|vi,0|fi[e>>2],0|fi[e+4>>2])),0|(M=vi),0|(x=0|Ee(a^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^j,h^M,32)),0|(o=vi))),x^(X=vi),24)),0|(a=vi)),j=0|fi[w>>2],L=0|fi[w+4>>2],u=0|Ee((D=0|Ee(u^(Y=0|Ig(0|(W=0|Ig(0|q,0|W,0|(a=0|Ee(x^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(M=0|Ig(0|M,0|vi,0|j,0|L)),o^(n=vi),16)),0|(h=vi))),a^(m=vi),63)),0|(x=vi))),0|vi,0|gA,0|Y)),D^(gA=vi),32))^(L=0|Ig(0|(gA=0|Ig(0|Y,0|gA,0|(x=0|Ee(a^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),x^(Q=vi),24)),0|(a=vi))),0|vi,0|j,0|L)),u^(j=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,a=0|Ee(x^Q,a^f,63),fi[B+32>>2]=a,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(T=0|Ig(0|(IA=0|Ig(0|H,0|K,0|S,0|IA)),0|vi,0|I,0|T)),p^(I=vi),32))^(I=0|Ig(0|(I=0|Ig(0|T,0|I,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|fi[z>>2],0|fi[z+4>>2])),t^(T=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,o=0|Ee((h=0|Ee(o^(AA=0|Ig(0|(AA=0|Ig(0|d,0|v,0|G,0|AA)),0|vi,0|fi[r>>2],0|fi[r+4>>2])),h^(G=vi),32))^(G=0|Ig(0|(G=0|Ig(0|AA,0|G,0|(v=0|Ee(d^(F=0|Ig(0|O,0|F,0|h,0|(o=vi))),v^(O=vi),24)),0|(d=vi))),0|vi,0|fi[R>>2],0|fi[R+4>>2])),o^(AA=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(O=0|Ig(0|F,0|O,0|o,0|h)),d^(F=vi),63),v=vi,$=0|Ig(0|(n=0|Ig(0|C,0|c,0|M,0|n)),0|vi,0|Z,0|$),Z=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(n=0|Ee(fi[B+120>>2]^$,fi[B+120+4>>2]^Z,32)),0|(M=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(M=0|Ee(n^(eA=0|Ig(0|(Z=0|Ig(0|$,0|Z,0|c,0|(C=vi))),0|vi,0|J,0|eA)),M^(J=vi),16)),0|(n=vi))),C^(k=vi),63),c=vi,M=0|Ee((n=0|Ee(M^(j=0|Ig(0|(j=0|Ig(0|H,0|K,0|L,0|j)),0|vi,0|fi[y>>2],0|fi[y+4>>2])),n^(L=vi),32))^(L=0|Ig(0|(L=0|Ig(0|j,0|L,0|(K=0|Ee(H^(F=0|Ig(0|O,0|F,0|n,0|(M=vi))),K^(O=vi),24)),0|(H=vi))),0|vi,0|fi[B+128>>2],0|fi[B+128+4>>2])),M^(j=vi),16),n=vi,fi[B+120>>2]=M,fi[B+120+4>>2]=n,n=0|Ig(0|F,0|O,0|M,0|n),M=vi,fi[B+80>>2]=n,fi[B+80+4>>2]=M,H=0|Ee(K^n,H^M,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,T=0|Ig(0|d,0|v,0|I,0|T),I=0|fi[l>>2],O=0|fi[l+4>>2],b=0|Ig(0|(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^(T=0|Ig(0|T,0|vi,0|I,0|O)),D^(F=vi),32)),0|(u=vi))),0|(b=vi),0|(u=0|Ee(D^(F=0|Ig(0|(F=0|Ig(0|T,0|F,0|(v=0|Ee(d^k,v^b,24)),0|(d=vi))),0|vi,0|fi[V>>2],0|fi[V+4>>2])),u^(T=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,AA=0|Ig(0|C,0|c,0|G,0|AA),G=0|fi[e>>2],Z=0|fi[e+4>>2],$=0|Ig(0|(AA=0|Ig(0|AA,0|vi,0|G,0|Z)),0|($=vi),0|(c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^AA,p^$,32)),0|(t=vi))),c^(Q=vi),24)),0|(C=vi)),AA=0|fi[E>>2],IA=0|fi[E+4>>2],C=0|Ee(c^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^($=0|Ig(0|$,0|vi,0|AA,0|IA)),t^(S=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,J=0|Ig(0|(a=0|fi[B+32>>2]),0|(x=0|fi[B+32+4>>2]),0|eA,0|J),eA=0|fi[g>>2],gA=0|fi[g+4>>2],u=0|Ee((D=0|Ee(u^(IA=0|Ig(0|(j=0|Ig(0|L,0|j,0|(a=0|Ee((x=0|Ee(a^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^(J=0|Ig(0|J,0|vi,0|eA,0|gA)),h^(Y=vi),32)),0|(o=vi))),x^(X=vi),24))^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(Y=0|Ig(0|(Y=0|Ig(0|J,0|Y,0|x,0|(a=vi))),0|vi,0|fi[N>>2],0|fi[N+4>>2])),o^(J=vi),16)),0|(h=vi))),a^(m=vi),63)),0|(x=vi))),0|vi,0|AA,0|IA)),D^(AA=vi),32))^(O=0|Ig(0|(AA=0|Ig(0|IA,0|AA,0|(x=0|Ee(a^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),x^(Q=vi),24)),0|(a=vi))),0|vi,0|I,0|O)),u^(I=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,a=0|Ee(x^Q,a^f,63),fi[B+32>>2]=a,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(T=0|Ig(0|(T=0|Ig(0|H,0|K,0|F,0|T)),0|vi,0|fi[z>>2],0|fi[z+4>>2])),p^(F=vi),32))^(F=0|Ig(0|(F=0|Ig(0|T,0|F,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|fi[P>>2],0|fi[P+4>>2])),t^(T=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,o=0|Ee((h=0|Ee(o^(S=0|Ig(0|(S=0|Ig(0|d,0|v,0|$,0|S)),0|vi,0|fi[w>>2],0|fi[w+4>>2])),h^($=vi),32))^($=0|Ig(0|($=0|Ig(0|S,0|$,0|(v=0|Ee(d^(M=0|Ig(0|n,0|M,0|h,0|(o=vi))),v^(n=vi),24)),0|(d=vi))),0|vi,0|fi[s>>2],0|fi[s+4>>2])),o^(S=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(n=0|Ig(0|M,0|n,0|o,0|h)),d^(M=vi),63),v=vi,J=0|Ig(0|(J=0|Ig(0|C,0|c,0|Y,0|J)),0|vi,0|fi[B+128>>2],0|fi[B+128+4>>2]),Y=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(a=0|Ee(fi[B+120>>2]^J,fi[B+120+4>>2]^Y,32)),0|(x=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(x=0|Ee(a^(Z=0|Ig(0|(Y=0|Ig(0|J,0|Y,0|c,0|(C=vi))),0|vi,0|G,0|Z)),x^(G=vi),16)),0|(a=vi))),C^(k=vi),63),c=vi,x=0|Ee((a=0|Ee(x^(I=0|Ig(0|(I=0|Ig(0|H,0|K,0|O,0|I)),0|vi,0|fi[r>>2],0|fi[r+4>>2])),a^(O=vi),32))^(gA=0|Ig(0|(O=0|Ig(0|I,0|O,0|(K=0|Ee(H^(M=0|Ig(0|n,0|M,0|a,0|(x=vi))),K^(n=vi),24)),0|(H=vi))),0|vi,0|eA,0|gA)),x^(eA=vi),16),a=vi,fi[B+120>>2]=x,fi[B+120+4>>2]=a,a=0|Ig(0|M,0|n,0|x,0|a),x=vi,fi[B+80>>2]=a,fi[B+80+4>>2]=x,H=0|Ee(K^a,H^x,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,F=0|Ig(0|(T=0|Ig(0|(T=0|Ig(0|d,0|v,0|F,0|T)),0|vi,0|fi[U>>2],0|fi[U+4>>2])),0|(F=vi),0|(v=0|Ee(d^(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^T,D^F,32)),0|(u=vi))),v^(b=vi),24)),0|(d=vi)),T=0|fi[_>>2],n=0|fi[_+4>>2],b=0|Ig(0|k,0|b,0|(u=0|Ee(D^(F=0|Ig(0|F,0|vi,0|T,0|n)),u^(M=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,S=0|Ig(0|C,0|c,0|$,0|S),$=0|fi[R>>2],O=0|fi[R+4>>2],I=0|Ig(0|(S=0|Ig(0|S,0|vi,0|$,0|O)),0|(I=vi),0|(c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^S,p^I,32)),0|(t=vi))),c^(Q=vi),24)),0|(C=vi)),S=0|fi[V>>2],Y=0|fi[V+4>>2],C=0|Ee(c^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(I=0|Ig(0|I,0|vi,0|S,0|Y)),t^(J=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,G=0|Ig(0|(AA=0|fi[B+32>>2]),0|(IA=0|fi[B+32+4>>2]),0|Z,0|G),Z=0|fi[N>>2],j=0|fi[N+4>>2],L=0|Ig(0|(G=0|Ig(0|G,0|vi,0|Z,0|j)),0|(L=vi),0|(IA=0|Ee(AA^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^G,h^L,32)),0|(o=vi))),IA^(X=vi),24)),0|(AA=vi)),G=0|fi[y>>2],W=0|fi[y+4>>2],u=0|Ee((D=0|Ee(u^(j=0|Ig(0|(eA=0|Ig(0|gA,0|eA,0|(AA=0|Ee(IA^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(L=0|Ig(0|L,0|vi,0|G,0|W)),o^(q=vi),16)),0|(h=vi))),AA^(m=vi),63)),0|(IA=vi))),0|vi,0|Z,0|j)),D^(Z=vi),32))^(Z=0|Ig(0|(Z=0|Ig(0|j,0|Z,0|(IA=0|Ee(AA^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),IA^(Q=vi),24)),0|(AA=vi))),0|vi,0|fi[g>>2],0|fi[g+4>>2])),u^(j=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,AA=0|Ee(IA^Q,AA^f,63),fi[B+32>>2]=AA,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(M=0|Ig(0|(M=0|Ig(0|H,0|K,0|F,0|M)),0|vi,0|fi[e>>2],0|fi[e+4>>2])),p^(F=vi),32))^(Y=0|Ig(0|(F=0|Ig(0|M,0|F,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|S,0|Y)),t^(S=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,o=0|Ee((h=0|Ee(o^(n=0|Ig(0|(J=0|Ig(0|d,0|v,0|I,0|J)),0|vi,0|T,0|n)),h^(T=vi),32))^(T=0|Ig(0|(T=0|Ig(0|n,0|T,0|(v=0|Ee(d^(x=0|Ig(0|a,0|x,0|h,0|(o=vi))),v^(a=vi),24)),0|(d=vi))),0|vi,0|fi[E>>2],0|fi[E+4>>2])),o^(n=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(a=0|Ig(0|x,0|a,0|o,0|h)),d^(x=vi),63),v=vi,O=0|Ig(0|(q=0|Ig(0|C,0|c,0|L,0|q)),0|vi,0|$,0|O),$=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(q=0|Ee(fi[B+120>>2]^O,fi[B+120+4>>2]^$,32)),0|(L=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(L=0|Ee(q^(W=0|Ig(0|($=0|Ig(0|O,0|$,0|c,0|(C=vi))),0|vi,0|G,0|W)),L^(G=vi),16)),0|(q=vi))),C^(k=vi),63),c=vi,L=0|Ee((q=0|Ee(L^(j=0|Ig(0|(j=0|Ig(0|H,0|K,0|Z,0|j)),0|vi,0|fi[l>>2],0|fi[l+4>>2])),q^(Z=vi),32))^(Z=0|Ig(0|(Z=0|Ig(0|j,0|Z,0|(K=0|Ee(H^(x=0|Ig(0|a,0|x,0|q,0|(L=vi))),K^(a=vi),24)),0|(H=vi))),0|vi,0|fi[w>>2],0|fi[w+4>>2])),L^(j=vi),16),q=vi,fi[B+120>>2]=L,fi[B+120+4>>2]=q,q=0|Ig(0|x,0|a,0|L,0|q),L=vi,fi[B+80>>2]=q,fi[B+80+4>>2]=L,H=0|Ee(K^q,H^L,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,b=0|Ig(0|(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^(S=0|Ig(0|(S=0|Ig(0|d,0|v,0|Y,0|S)),0|vi,0|fi[P>>2],0|fi[P+4>>2])),D^(Y=vi),32)),0|(u=vi))),0|(b=vi),0|(u=0|Ee(D^(Y=0|Ig(0|(Y=0|Ig(0|S,0|Y,0|(v=0|Ee(d^k,v^b,24)),0|(d=vi))),0|vi,0|fi[z>>2],0|fi[z+4>>2])),u^(S=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,n=0|Ig(0|C,0|c,0|T,0|n),T=0|fi[s>>2],a=0|fi[s+4>>2],C=0|Ee((c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^(n=0|Ig(0|n,0|vi,0|T,0|a)),p^(x=vi),32)),0|(t=vi))),c^(Q=vi),24))^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(x=0|Ig(0|(x=0|Ig(0|n,0|x,0|c,0|(C=vi))),0|vi,0|fi[r>>2],0|fi[r+4>>2])),t^(n=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,W=0|Ig(0|(G=0|Ig(0|(G=0|Ig(0|($=0|fi[B+32>>2]),0|(O=0|fi[B+32+4>>2]),0|W,0|G)),0|vi,0|fi[U>>2],0|fi[U+4>>2])),0|(W=vi),0|(O=0|Ee($^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^G,h^W,32)),0|(o=vi))),O^(X=vi),24)),0|($=vi)),G=0|fi[B+128>>2],J=0|fi[B+128+4>>2],u=0|Ee((D=0|Ee(u^(J=0|Ig(0|(j=0|Ig(0|Z,0|j,0|($=0|Ee(O^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(W=0|Ig(0|W,0|vi,0|G,0|J)),o^(I=vi),16)),0|(h=vi))),$^(m=vi),63)),0|(O=vi))),0|vi,0|G,0|J)),D^(G=vi),32))^(G=0|Ig(0|(G=0|Ig(0|J,0|G,0|(O=0|Ee($^(f=0|Ig(0|Q,0|f,0|D,0|(u=vi))),O^(Q=vi),24)),0|($=vi))),0|vi,0|fi[R>>2],0|fi[R+4>>2])),u^(J=vi),16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,Q=0|Ig(0|f,0|Q,0|u,0|D),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,$=0|Ee(O^Q,$^f,63),fi[B+32>>2]=$,fi[B+32+4>>2]=vi,t=0|Ee((p=0|Ee(t^(S=0|Ig(0|(S=0|Ig(0|H,0|K,0|Y,0|S)),0|vi,0|fi[g>>2],0|fi[g+4>>2])),p^(Y=vi),32))^(a=0|Ig(0|(Y=0|Ig(0|S,0|Y,0|(K=0|Ee(H^(m=0|Ig(0|X,0|m,0|p,0|(t=vi))),K^(X=vi),24)),0|(H=vi))),0|vi,0|T,0|a)),t^(T=vi),16),p=vi,fi[B+104>>2]=t,fi[B+104+4>>2]=p,X=0|Ig(0|m,0|X,0|t,0|p),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,H=0|Ee(K^X,H^m,63),K=vi,o=0|Ee((h=0|Ee(o^(n=0|Ig(0|(n=0|Ig(0|d,0|v,0|x,0|n)),0|vi,0|fi[V>>2],0|fi[V+4>>2])),h^(x=vi),32))^(x=0|Ig(0|(x=0|Ig(0|n,0|x,0|(v=0|Ee(d^(L=0|Ig(0|q,0|L,0|h,0|(o=vi))),v^(q=vi),24)),0|(d=vi))),0|vi,0|fi[y>>2],0|fi[y+4>>2])),o^(n=vi),16),h=vi,fi[B+112>>2]=o,fi[B+112+4>>2]=h,d=0|Ee(v^(q=0|Ig(0|L,0|q,0|o,0|h)),d^(L=vi),63),v=vi,I=0|Ig(0|(I=0|Ig(0|C,0|c,0|W,0|I)),0|vi,0|fi[E>>2],0|fi[E+4>>2]),W=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(Y=0|Ee(fi[B+120>>2]^I,fi[B+120+4>>2]^W,32)),0|(S=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(S=0|Ee(Y^(W=0|Ig(0|(W=0|Ig(0|I,0|W,0|c,0|(C=vi))),0|vi,0|fi[_>>2],0|fi[_+4>>2])),S^(I=vi),16)),0|(Y=vi))),C^(k=vi),63),c=vi,J=0|Ig(0|H,0|K,0|G,0|J),G=0|fi[e>>2],e=0|fi[e+4>>2],$=0|Ig(0|(J=0|Ig(0|J,0|vi,0|G,0|e)),0|($=vi),0|(K=0|Ee(H^(L=0|Ig(0|q,0|L,0|(Y=0|Ee(S^J,Y^$,32)),0|(S=vi))),K^(q=vi),24)),0|(H=vi)),J=0|fi[P>>2],P=0|fi[P+4>>2],S=0|Ee(Y^($=0|Ig(0|$,0|vi,0|J,0|P)),S^(O=vi),16),Y=vi,fi[B+120>>2]=S,fi[B+120+4>>2]=Y,Y=0|Ig(0|L,0|q,0|S,0|Y),S=vi,fi[B+80>>2]=Y,fi[B+80+4>>2]=S,H=0|Ee(K^Y,H^S,63),K=vi,fi[B+40>>2]=H,fi[B+40+4>>2]=K,T=0|Ig(0|d,0|v,0|a,0|T),a=0|fi[N>>2],N=0|fi[N+4>>2],b=0|Ig(0|(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^(T=0|Ig(0|T,0|vi,0|a,0|N)),D^(q=vi),32)),0|(u=vi))),0|(b=vi),0|(u=0|Ee(D^(q=0|Ig(0|(q=0|Ig(0|T,0|q,0|(v=0|Ee(d^k,v^b,24)),0|(d=vi))),0|vi,0|fi[w>>2],0|fi[w+4>>2])),u^(T=vi),16)),0|(D=vi)),k=vi,fi[B+88>>2]=b,fi[B+88+4>>2]=k,d=0|Ee(v^b,d^k,63),v=vi,fi[B+48>>2]=d,fi[B+48+4>>2]=v,x=0|Ig(0|(n=0|Ig(0|(n=0|Ig(0|C,0|c,0|x,0|n)),0|vi,0|fi[r>>2],0|fi[r+4>>2])),0|(x=vi),0|(c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^n,p^x,32)),0|(t=vi))),c^(Q=vi),24)),0|(C=vi)),n=0|fi[U>>2],U=0|fi[U+4>>2],C=0|Ee(c^(Q=0|Ig(0|f,0|Q,0|(t=0|Ee(p^(x=0|Ig(0|x,0|vi,0|n,0|U)),t^(L=vi),16)),0|(p=vi))),C^(f=vi),63),c=vi,fi[B+56>>2]=C,fi[B+56+4>>2]=c,I=0|Ig(0|(j=0|fi[B+32>>2]),0|(Z=0|fi[B+32+4>>2]),0|W,0|I),W=0|fi[z>>2],z=0|fi[z+4>>2],F=0|Ig(0|(I=0|Ig(0|I,0|vi,0|W,0|z)),0|(F=vi),0|(Z=0|Ee(j^(m=0|Ig(0|X,0|m,0|(h=0|Ee(o^I,h^F,32)),0|(o=vi))),Z^(X=vi),24)),0|(j=vi)),I=0|fi[l>>2],l=0|fi[l+4>>2],Q=0|Ig(0|(f=0|Ig(0|Q,0|f,0|(D=0|Ee(u^(z=0|Ig(0|(O=0|Ig(0|$,0|O,0|(j=0|Ee(Z^(X=0|Ig(0|m,0|X,0|(o=0|Ee(h^(F=0|Ig(0|F,0|vi,0|I,0|l)),o^(M=vi),16)),0|(h=vi))),j^(m=vi),63)),0|(Z=vi))),0|vi,0|W,0|z)),D^(W=vi),32)),0|(u=vi))),0|(Q=vi),0|(u=0|Ee(D^(N=0|Ig(0|(W=0|Ig(0|z,0|W,0|(Z=0|Ee(j^f,Z^Q,24)),0|(j=vi))),0|vi,0|a,0|N)),u^(a=vi),16)),0|(D=vi)),f=vi,fi[B+64>>2]=Q,fi[B+64+4>>2]=f,j=0|Ee(Z^Q,j^f,63),fi[B+32>>2]=j,fi[B+32+4>>2]=vi,X=0|Ig(0|(m=0|Ig(0|X,0|m,0|(p=0|Ee(t^(V=0|Ig(0|(T=0|Ig(0|H,0|K,0|q,0|T)),0|vi,0|fi[V>>2],0|fi[V+4>>2])),p^(T=vi),32)),0|(t=vi))),0|(X=vi),0|(t=0|Ee(p^(e=0|Ig(0|(T=0|Ig(0|V,0|T,0|(K=0|Ee(H^m,K^X,24)),0|(H=vi))),0|vi,0|G,0|e)),t^(G=vi),16)),0|(p=vi)),m=vi,fi[B+72>>2]=X,fi[B+72+4>>2]=m,m=0|Ee(K^X,H^m,63),H=vi,d=0|Ee((v=0|Ee(d^(S=0|Ig(0|Y,0|S,0|(h=0|Ee(o^(P=0|Ig(0|(L=0|Ig(0|d,0|v,0|x,0|L)),0|vi,0|J,0|P)),h^(J=vi),32)),0|(o=vi))),v^(Y=vi),24))^(Y=0|Ig(0|S,0|Y,0|(o=0|Ee(h^(l=0|Ig(0|(J=0|Ig(0|P,0|J,0|v,0|(d=vi))),0|vi,0|I,0|l)),o^(I=vi),16)),0|(h=vi))),d^(S=vi),63),v=vi,U=0|Ig(0|(M=0|Ig(0|C,0|c,0|F,0|M)),0|vi,0|n,0|U),n=vi,C=0|Ee((c=0|Ee(C^(k=0|Ig(0|b,0|k,0|(M=0|Ee(fi[B+120>>2]^U,fi[B+120+4>>2]^n,32)),0|(F=vi))),c^(b=vi),24))^(b=0|Ig(0|k,0|b,0|(F=0|Ee(M^(E=0|Ig(0|(n=0|Ig(0|U,0|n,0|c,0|(C=vi))),0|vi,0|fi[E>>2],0|fi[E+4>>2])),F^(n=vi),16)),0|(M=vi))),C^(k=vi),63),c=vi,r=0|Ig(0|(a=0|Ig(0|(R=0|Ig(0|(a=0|Ig(0|m,0|H,0|N,0|a)),0|vi,0|fi[R>>2],0|fi[R+4>>2])),0|(a=vi),0|(H=0|Ee(m^(S=0|Ig(0|Y,0|S,0|(M=0|Ee(F^R,M^a,32)),0|(F=vi))),H^(Y=vi),24)),0|(m=vi))),0|vi,0|fi[r>>2],0|fi[r+4>>2]),a=vi,fi[B>>2]=r,fi[B+4>>2]=a,F=0|Ee(M^r,F^a,16),M=vi,fi[B+120>>2]=F,fi[B+120+4>>2]=M,M=0|Ig(0|S,0|Y,0|F,0|M),F=vi,fi[B+80>>2]=M,fi[B+80+4>>2]=F,F=0|Ee(H^M,m^F,63),fi[B+40>>2]=F,fi[B+40+4>>2]=vi,g=0|Ig(0|(e=0|Ig(0|(G=0|Ig(0|(G=0|Ig(0|d,0|v,0|e,0|G)),0|vi,0|fi[B+128>>2],0|fi[B+128+4>>2])),0|(e=vi),0|(v=0|Ee(d^(k=0|Ig(0|b,0|k,0|(D=0|Ee(u^G,D^e,32)),0|(u=vi))),v^(b=vi),24)),0|(d=vi))),0|vi,0|fi[g>>2],0|fi[g+4>>2]),e=vi,fi[B+8>>2]=g,fi[B+8+4>>2]=e,u=0|Ee(D^g,u^e,16),D=vi,fi[B+96>>2]=u,fi[B+96+4>>2]=D,D=0|Ig(0|k,0|b,0|u,0|D),u=vi,fi[B+88>>2]=D,fi[B+88+4>>2]=u,u=0|Ee(v^D,d^u,63),fi[B+48>>2]=u,fi[B+48+4>>2]=vi,_=0|Ig(0|(I=0|Ig(0|(w=0|Ig(0|(I=0|Ig(0|C,0|c,0|l,0|I)),0|vi,0|fi[w>>2],0|fi[w+4>>2])),0|(I=vi),0|(c=0|Ee(C^(f=0|Ig(0|Q,0|f,0|(p=0|Ee(t^w,p^I,32)),0|(t=vi))),c^(Q=vi),24)),0|(C=vi))),0|vi,0|fi[_>>2],0|fi[_+4>>2]),I=vi,fi[B+16>>2]=_,fi[B+16+4>>2]=I,I=0|Ee(p^_,t^I,16),t=vi,fi[B+104>>2]=I,fi[B+104+4>>2]=t,t=0|Ig(0|f,0|Q,0|I,0|t),I=vi,fi[B+64>>2]=t,fi[B+64+4>>2]=I,C=0|Ee(c^t,C^I,63),fi[B+56>>2]=C,fi[B+56+4>>2]=vi,h=0|Ee(o^(y=0|Ig(0|(n=0|Ig(0|(C=0|fi[B+32>>2]),0|(c=0|fi[B+32+4>>2]),0|E,0|n)),0|vi,0|fi[y>>2],0|fi[y+4>>2])),h^(n=vi),32),o=vi,s=0|Ig(0|(n=0|Ig(0|y,0|n,0|(c=0|Ee(C^(E=0|Ig(0|fi[B+72>>2],0|fi[B+72+4>>2],0|h,0|o)),c^(Q=vi),24)),0|(C=vi))),0|vi,0|fi[s>>2],0|fi[s+4>>2]),n=vi,fi[B+24>>2]=s,fi[B+24+4>>2]=n,n=0|Ee(h^s,o^n,16),o=vi,fi[B+112>>2]=n,fi[B+112+4>>2]=o,o=0|Ig(0|E,0|Q,0|n,0|o),n=vi,fi[B+72>>2]=o,fi[B+72+4>>2]=n,n=0|Ee(c^o,C^n,63),fi[B+32>>2]=n,fi[B+32+4>>2]=vi,I=a^fi[A+4>>2]^I,fi[A>>2]=r^fi[A>>2]^t,fi[A+4>>2]=I,I=1;BA=A+(I<<3)|0,iA=B+(I+8<<3)|0,e=e^fi[BA+4>>2]^fi[iA+4>>2],fi[BA>>2]=g^fi[BA>>2]^fi[iA>>2],fi[BA+4>>2]=e,8!=(0|(e=I+1|0));)I=e,g=0|fi[B+(e<<3)>>2],e=0|fi[B+(e<<3)+4>>2];wi=i}function i(A,I,e,g){A|=0,e|=0,g|=0;var i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0,P=0,L=0,x=0,X=0,K=0,T=0,V=0,q=0,j=0,Z=0,W=0,z=0,O=0,$=0,AA=0,IA=0,eA=0,gA=0,iA=0,BA=0,tA=0,rA=0,aA=0,nA=0,CA=0,oA=0,cA=0,QA=0,EA=0,sA=0,hA=0,yA=0,fA=0,_A=0,pA=0,wA=0,lA=0,uA=0,dA=0,DA=0,vA=0,bA=0,kA=0,GA=0,FA=0,mA=0,MA=0,HA=0,YA=0,SA=0,RA=0,NA=0,UA=0,JA=0,PA=0,LA=0,xA=0,XA=0,KA=0,TA=0,VA=0,qA=0,jA=0,ZA=0,WA=0,zA=0,OA=0,$A=0,AI=0,II=0,eI=0,gI=0,iI=0,BI=0,tI=0,rI=0,aI=0,nI=0,CI=0,oI=0,cI=0,QI=0,EI=0,sI=0,hI=0,yI=0,fI=0,_I=0,pI=0,wI=0,lI=0,uI=0,dI=0,DI=0,vI=0,bI=0,kI=0,GI=0,FI=0,mI=0,MI=0,YI=0,SI=0,RI=0,NI=0,UI=0,JI=0,PI=0,LI=0,xI=0,XI=0,KI=0,TI=0,VI=0,qI=0,jI=0,ZI=0,WI=0,zI=0,OI=0,$I=0,Ae=0,Ie=0,ee=0,ge=0,ie=0,Be=0,te=0,re=0,ae=0,ne=0,Ce=0,oe=0,ce=0,Qe=0,Ee=0,se=0;ZA=0|fe(0|yi[(I|=0)>>0],0|yi[I+1>>0],0|yi[I+2>>0]),oI=0|Ue(0|(oI=0|HI(I+2|0)),0|vi,5),d=0|Ue(0|(d=0|fe(0|yi[I+5>>0],0|yi[I+6>>0],0|yi[I+7>>0])),0|vi,2),aI=0|Ue(0|(aI=0|HI(I+7|0)),0|vi,7),C=0|Ue(0|(C=0|HI(I+10|0)),0|vi,4),H=0|Ue(0|(H=0|fe(0|yi[I+13>>0],0|yi[I+14>>0],0|yi[I+15>>0])),0|vi,1),G=0|Ue(0|(G=0|HI(I+15|0)),0|vi,6),eA=0|Ue(0|(eA=0|fe(0|yi[I+18>>0],0|yi[I+19>>0],0|yi[I+20>>0])),0|vi,3),tI=0|fe(0|yi[I+21>>0],0|yi[I+22>>0],0|yi[I+23>>0]),M=0|Ue(0|(M=0|HI(I+23|0)),0|vi,5),se=0|Ue(0|(se=0|fe(0|yi[I+26>>0],0|yi[I+27>>0],0|yi[I+28>>0])),0|vi,2),c=0|Ue(0|(c=0|HI(I+28|0)),0|vi,7),fA=vi,fI=0|fe(0|yi[e>>0],0|yi[e+1>>0],0|yi[e+2>>0]),MA=0|Ue(0|(MA=0|HI(e+2|0)),0|vi,5),VA=0|Ue(0|(VA=0|fe(0|yi[e+5>>0],0|yi[e+6>>0],0|yi[e+7>>0])),0|vi,2),AA=0|Ue(0|(AA=0|HI(e+7|0)),0|vi,7),J=0|Ue(0|(J=0|HI(e+10|0)),0|vi,4),yA=0|Ue(0|(yA=0|fe(0|yi[e+13>>0],0|yi[e+14>>0],0|yi[e+15>>0])),0|vi,1),wA=0|Ue(0|(wA=0|HI(e+15|0)),0|vi,6),sI=0|Ue(0|(sI=0|fe(0|yi[e+18>>0],0|yi[e+19>>0],0|yi[e+20>>0])),0|vi,3),oA=0|fe(0|yi[e+21>>0],0|yi[e+22>>0],0|yi[e+23>>0]),U=0|Ue(0|(U=0|HI(e+23|0)),0|vi,5),HA=0|Ue(0|(HA=0|fe(0|yi[e+26>>0],0|yi[e+27>>0],0|yi[e+28>>0])),0|vi,2),w=0|Ue(0|(w=0|HI(e+28|0)),0|vi,7),EA=vi,T=0|fe(0|yi[g>>0],0|yi[g+1>>0],0|yi[g+2>>0]),cA=0|Ue(0|(cA=0|HI(g+2|0)),0|vi,5),hA=0|Ue(0|(hA=0|fe(0|yi[g+5>>0],0|yi[g+6>>0],0|yi[g+7>>0])),0|vi,2),NA=0|Ue(0|(NA=0|HI(g+7|0)),0|vi,7),CA=0|Ue(0|(CA=0|HI(g+10|0)),0|vi,4),bA=0|Ue(0|(bA=0|fe(0|yi[g+13>>0],0|yi[g+14>>0],0|yi[g+15>>0])),0|vi,1),gI=0|Ue(0|(gI=0|HI(g+15|0)),0|vi,6),B=0|Ue(0|(B=0|fe(0|yi[g+18>>0],0|yi[g+19>>0],0|yi[g+20>>0])),0|vi,3),LA=0|fe(0|yi[g+21>>0],0|yi[g+22>>0],0|yi[g+23>>0]),k=0|Ue(0|(k=0|HI(g+23|0)),0|vi,5),PA=0|Ue(0|(PA=0|fe(0|yi[g+26>>0],0|yi[g+27>>0],0|yi[g+28>>0])),0|vi,2),I=0|Ue(0|(I=0|HI(g+28|0)),0|vi,7),t=vi,QA=0|Ig(2097151&T|0,0,0|(QA=0|he(2097151&fI|0,0,2097151&ZA|0,0)),0|vi),T=vi,Ee=0|he(2097151&MA|0,0,2097151&ZA|0,0),Qe=vi,ce=0|he(2097151&fI|0,0,2097151&oI|0,0),f=vi,rA=0|he(2097151&VA|0,0,2097151&ZA|0,0),sA=vi,hA=0|Ig(0|(sA=0|Ig(0|(x=0|Ig(0|(aA=0|he(2097151&MA|0,0,2097151&oI|0,0)),0|(re=vi),0|(x=0|he(2097151&fI|0,0,2097151&d|0,0)),0|vi)),0|vi,0|rA,0|sA)),0|vi,2097151&hA|0,0),sA=vi,rA=0|he(2097151&AA|0,0,2097151&ZA|0,0),x=vi,re=0|he(2097151&VA|0,0,2097151&oI|0,0),aA=vi,oe=0|he(2097151&MA|0,0,2097151&d|0,0),Ce=vi,ne=0|he(2097151&fI|0,0,2097151&aI|0,0),ae=vi,vA=0|he(2097151&J|0,0,2097151&ZA|0,0),nA=vi,OI=0|he(2097151&AA|0,0,2097151&oI|0,0),W=vi,Ae=0|he(2097151&VA|0,0,2097151&d|0,0),DA=vi,CA=0|Ig(0|(nA=0|Ig(0|(W=0|Ig(0|(DA=0|Ig(0|($I=0|Ig(0|(Ie=0|he(2097151&MA|0,0,2097151&aI|0,0)),0|(ee=vi),0|($I=0|he(2097151&fI|0,0,2097151&C|0,0)),0|vi)),0|vi,0|Ae,0|DA)),0|vi,0|OI,0|W)),0|vi,0|vA,0|nA)),0|vi,2097151&CA|0,0),nA=vi,vA=0|he(2097151&yA|0,0,2097151&ZA|0,0),W=vi,OI=0|he(2097151&J|0,0,2097151&oI|0,0),DA=vi,Ae=0|he(2097151&AA|0,0,2097151&d|0,0),$I=vi,ee=0|he(2097151&VA|0,0,2097151&aI|0,0),Ie=vi,te=0|he(2097151&MA|0,0,2097151&C|0,0),Be=vi,ie=0|he(2097151&fI|0,0,2097151&H|0,0),ge=vi,j=0|he(2097151&wA|0,0,2097151&ZA|0,0),zA=vi,JI=0|he(2097151&yA|0,0,2097151&oI|0,0),D=vi,LI=0|he(2097151&J|0,0,2097151&d|0,0),q=vi,XI=0|he(2097151&AA|0,0,2097151&aI|0,0),PI=vi,TI=0|he(2097151&VA|0,0,2097151&C|0,0),xI=vi,gI=0|Ig(0|(zA=0|Ig(0|(D=0|Ig(0|(q=0|Ig(0|(PI=0|Ig(0|(xI=0|Ig(0|(KI=0|Ig(0|(VI=0|he(2097151&MA|0,0,2097151&H|0,0)),0|(qI=vi),0|(KI=0|he(2097151&fI|0,0,2097151&G|0,0)),0|vi)),0|vi,0|TI,0|xI)),0|vi,0|XI,0|PI)),0|vi,0|LI,0|q)),0|vi,0|JI,0|D)),0|vi,0|j,0|zA)),0|vi,2097151&gI|0,0),zA=vi,j=0|he(2097151&sI|0,0,2097151&ZA|0,0),D=vi,JI=0|he(2097151&wA|0,0,2097151&oI|0,0),q=vi,LI=0|he(2097151&yA|0,0,2097151&d|0,0),PI=vi,XI=0|he(2097151&J|0,0,2097151&aI|0,0),xI=vi,TI=0|he(2097151&AA|0,0,2097151&C|0,0),KI=vi,qI=0|he(2097151&VA|0,0,2097151&H|0,0),VI=vi,zI=0|he(2097151&MA|0,0,2097151&G|0,0),WI=vi,ZI=0|he(2097151&fI|0,0,2097151&eA|0,0),jI=vi,uI=0|he(2097151&oA|0,0,2097151&ZA|0,0),g=vi,r=0|he(2097151&sI|0,0,2097151&oI|0,0),xA=vi,wI=0|he(2097151&wA|0,0,2097151&d|0,0),lI=vi,DI=0|he(2097151&yA|0,0,2097151&aI|0,0),_A=vi,bI=0|he(2097151&J|0,0,2097151&C|0,0),dI=vi,GI=0|he(2097151&AA|0,0,2097151&H|0,0),vI=vi,mI=0|he(2097151&VA|0,0,2097151&G|0,0),kI=vi,LA=0|Ig(0|(xA=0|Ig(0|(g=0|Ig(0|(lI=0|Ig(0|(_A=0|Ig(0|(dI=0|Ig(0|(vI=0|Ig(0|(kI=0|Ig(0|(FI=0|Ig(0|(MI=0|he(2097151&MA|0,0,2097151&eA|0,0)),0|(YI=vi),0|(FI=0|he(2097151&fI|0,0,2097151&tI|0,0)),0|vi)),0|vi,0|mI,0|kI)),0|vi,0|GI,0|vI)),0|vi,0|bI,0|dI)),0|vi,0|DI,0|_A)),0|vi,0|wI,0|lI)),0|vi,0|uI,0|g)),0|vi,0|r,0|xA)),0|vi,2097151&LA|0,0),xA=vi,r=0|he(2097151&U|0,0,2097151&ZA|0,0),g=vi,uI=0|he(2097151&oA|0,0,2097151&oI|0,0),lI=vi,wI=0|he(2097151&sI|0,0,2097151&d|0,0),_A=vi,DI=0|he(2097151&wA|0,0,2097151&aI|0,0),dI=vi,bI=0|he(2097151&yA|0,0,2097151&C|0,0),vI=vi,GI=0|he(2097151&J|0,0,2097151&H|0,0),kI=vi,mI=0|he(2097151&AA|0,0,2097151&G|0,0),FI=vi,YI=0|he(2097151&VA|0,0,2097151&eA|0,0),MI=vi,UI=0|he(2097151&MA|0,0,2097151&tI|0,0),NI=vi,RI=0|he(2097151&fI|0,0,2097151&M|0,0),SI=vi,WA=0|he(2097151&HA|0,0,2097151&ZA|0,0),JA=vi,OA=0|he(2097151&U|0,0,2097151&oI|0,0),iI=vi,z=0|he(2097151&oA|0,0,2097151&d|0,0),O=vi,K=0|he(2097151&sI|0,0,2097151&aI|0,0),X=vi,CI=0|he(2097151&wA|0,0,2097151&C|0,0),nI=vi,RA=0|he(2097151&yA|0,0,2097151&H|0,0),SA=vi,eI=0|he(2097151&J|0,0,2097151&G|0,0),II=vi,FA=0|he(2097151&AA|0,0,2097151&eA|0,0),GA=vi,KA=0|he(2097151&VA|0,0,2097151&tI|0,0),XA=vi,PA=0|Ig(0|(JA=0|Ig(0|(iI=0|Ig(0|(X=0|Ig(0|(O=0|Ig(0|(nI=0|Ig(0|(SA=0|Ig(0|(II=0|Ig(0|(GA=0|Ig(0|(XA=0|Ig(0|(P=0|Ig(0|(pI=0|he(2097151&MA|0,0,2097151&M|0,0)),0|(S=vi),0|(P=0|he(2097151&fI|0,0,2097151&se|0,0)),0|vi)),0|vi,0|KA,0|XA)),0|vi,0|FA,0|GA)),0|vi,0|eI,0|II)),0|vi,0|RA,0|SA)),0|vi,0|CI,0|nI)),0|vi,0|z,0|O)),0|vi,0|K,0|X)),0|vi,0|OA,0|iI)),0|vi,0|WA,0|JA)),0|vi,2097151&PA|0,0),JA=vi,ZA=0|he(0|w,0|EA,2097151&ZA|0,0),WA=vi,iI=0|he(2097151&HA|0,0,2097151&oI|0,0),OA=vi,X=0|he(2097151&U|0,0,2097151&d|0,0),K=vi,O=0|he(2097151&oA|0,0,2097151&aI|0,0),z=vi,nI=0|he(2097151&sI|0,0,2097151&C|0,0),CI=vi,SA=0|he(2097151&wA|0,0,2097151&H|0,0),RA=vi,II=0|he(2097151&yA|0,0,2097151&G|0,0),eI=vi,GA=0|he(2097151&J|0,0,2097151&eA|0,0),FA=vi,XA=0|he(2097151&AA|0,0,2097151&tI|0,0),KA=vi,P=0|he(2097151&VA|0,0,2097151&M|0,0),S=vi,pI=0|he(2097151&MA|0,0,2097151&se|0,0),_I=vi,fI=0|he(2097151&fI|0,0,0|c,0|fA),yI=vi,oI=0|he(0|w,0|EA,2097151&oI|0,0),cI=vi,$A=0|he(2097151&HA|0,0,2097151&d|0,0),p=vi,R=0|he(2097151&U|0,0,2097151&aI|0,0),AI=vi,QI=0|he(2097151&oA|0,0,2097151&C|0,0),_=vi,E=0|he(2097151&sI|0,0,2097151&H|0,0),BI=vi,s=0|he(2097151&wA|0,0,2097151&G|0,0),EI=vi,BA=0|he(2097151&yA|0,0,2097151&eA|0,0),u=vi,IA=0|he(2097151&J|0,0,2097151&tI|0,0),tA=vi,mA=0|he(2097151&AA|0,0,2097151&M|0,0),L=vi,cI=0|Ig(0|(p=0|Ig(0|(AI=0|Ig(0|(BI=0|Ig(0|(_=0|Ig(0|(EI=0|Ig(0|(u=0|Ig(0|(tA=0|Ig(0|(L=0|Ig(0|(MA=0|Ig(0|(rI=0|he(2097151&VA|0,0,2097151&se|0,0)),0|(TA=vi),0|(MA=0|he(2097151&MA|0,0,0|c,0|fA)),0|vi)),0|vi,0|mA,0|L)),0|vi,0|IA,0|tA)),0|vi,0|BA,0|u)),0|vi,0|s,0|EI)),0|vi,0|QI,0|_)),0|vi,0|E,0|BI)),0|vi,0|R,0|AI)),0|vi,0|$A,0|p)),0|vi,0|oI,0|cI),oI=vi,d=0|he(0|w,0|EA,2097151&d|0,0),p=vi,$A=0|he(2097151&HA|0,0,2097151&aI|0,0),AI=vi,R=0|he(2097151&U|0,0,2097151&C|0,0),BI=vi,E=0|he(2097151&oA|0,0,2097151&H|0,0),_=vi,QI=0|he(2097151&sI|0,0,2097151&G|0,0),EI=vi,s=0|he(2097151&wA|0,0,2097151&eA|0,0),u=vi,BA=0|he(2097151&yA|0,0,2097151&tI|0,0),tA=vi,IA=0|he(2097151&J|0,0,2097151&M|0,0),L=vi,mA=0|he(2097151&AA|0,0,2097151&se|0,0),MA=vi,VA=0|he(2097151&VA|0,0,0|c,0|fA),TA=vi,aI=0|he(0|w,0|EA,2097151&aI|0,0),rI=vi,qA=0|he(2097151&HA|0,0,2097151&C|0,0),a=vi,o=0|he(2097151&U|0,0,2097151&H|0,0),jA=vi,V=0|he(2097151&oA|0,0,2097151&G|0,0),F=vi,Z=0|he(2097151&sI|0,0,2097151&eA|0,0),i=vi,uA=0|he(2097151&wA|0,0,2097151&tI|0,0),h=vi,pA=0|he(2097151&yA|0,0,2097151&M|0,0),n=vi,rI=0|Ig(0|(a=0|Ig(0|(jA=0|Ig(0|(i=0|Ig(0|(F=0|Ig(0|(h=0|Ig(0|(n=0|Ig(0|(AA=0|Ig(0|(hI=0|he(2097151&J|0,0,2097151&se|0,0)),0|(Q=vi),0|(AA=0|he(2097151&AA|0,0,0|c,0|fA)),0|vi)),0|vi,0|pA,0|n)),0|vi,0|uA,0|h)),0|vi,0|V,0|F)),0|vi,0|Z,0|i)),0|vi,0|o,0|jA)),0|vi,0|qA,0|a)),0|vi,0|aI,0|rI),aI=vi,C=0|he(0|w,0|EA,2097151&C|0,0),a=vi,qA=0|he(2097151&HA|0,0,2097151&H|0,0),jA=vi,o=0|he(2097151&U|0,0,2097151&G|0,0),i=vi,Z=0|he(2097151&oA|0,0,2097151&eA|0,0),F=vi,V=0|he(2097151&sI|0,0,2097151&tI|0,0),h=vi,uA=0|he(2097151&wA|0,0,2097151&M|0,0),n=vi,pA=0|he(2097151&yA|0,0,2097151&se|0,0),AA=vi,J=0|he(2097151&J|0,0,0|c,0|fA),Q=vi,H=0|he(0|w,0|EA,2097151&H|0,0),hI=vi,gA=0|he(2097151&HA|0,0,2097151&G|0,0),YA=vi,kA=0|he(2097151&U|0,0,2097151&eA|0,0),v=vi,$=0|he(2097151&oA|0,0,2097151&tI|0,0),y=vi,b=0|he(2097151&sI|0,0,2097151&M|0,0),dA=vi,hI=0|Ig(0|(YA=0|Ig(0|(v=0|Ig(0|(dA=0|Ig(0|(y=0|Ig(0|(e=0|Ig(0|(Y=0|he(2097151&wA|0,0,2097151&se|0,0)),0|(lA=vi),0|(e=0|he(2097151&yA|0,0,0|c,0|fA)),0|vi)),0|vi,0|$,0|y)),0|vi,0|b,0|dA)),0|vi,0|kA,0|v)),0|vi,0|gA,0|YA)),0|vi,0|H,0|hI),H=vi,G=0|he(0|w,0|EA,2097151&G|0,0),YA=vi,gA=0|he(2097151&HA|0,0,2097151&eA|0,0),v=vi,kA=0|he(2097151&U|0,0,2097151&tI|0,0),dA=vi,b=0|he(2097151&oA|0,0,2097151&M|0,0),y=vi,$=0|he(2097151&sI|0,0,2097151&se|0,0),e=vi,wA=0|he(2097151&wA|0,0,0|c,0|fA),lA=vi,eA=0|he(0|w,0|EA,2097151&eA|0,0),Y=vi,yA=0|he(2097151&HA|0,0,2097151&tI|0,0),N=vi,UA=0|he(2097151&U|0,0,2097151&M|0,0),m=vi,l=0|he(2097151&oA|0,0,2097151&se|0,0),iA=vi,Y=0|Ig(0|(N=0|Ig(0|(m=0|Ig(0|(iA=0|Ig(0|(sI=0|he(2097151&sI|0,0,0|c,0|fA)),0|vi,0|l,0|iA)),0|vi,0|UA,0|m)),0|vi,0|yA,0|N)),0|vi,0|eA,0|Y),eA=vi,tI=0|he(0|w,0|EA,2097151&tI|0,0),N=vi,yA=0|he(2097151&HA|0,0,2097151&M|0,0),m=vi,UA=0|he(2097151&U|0,0,2097151&se|0,0),iA=vi,oA=0|he(2097151&oA|0,0,0|c,0|fA),l=vi,M=0|he(0|w,0|EA,2097151&M|0,0),sI=vi,sI=0|Ig(0|(U=0|Ig(0|he(2097151&HA|0,0,2097151&se|0,0),0|vi,0|(U=0|he(2097151&U|0,0,0|c,0|fA)),0|vi)),0|vi,0|M,0|sI),M=vi,HA=0|Ig(0|(se=0|he(0|w,0|EA,2097151&se|0,0)),0|(U=vi),0|(HA=0|he(2097151&HA|0,0,0|c,0|fA)),0|vi),U=vi,fA=0|he(0|w,0|EA,0|c,0|fA),c=vi,EA=0|Ue(0|(EA=0|Ig(0|QA,0|T,1048576,0)),0|vi,21),w=vi,cA=0|Ig(0|(cA=0|Ig(0|(f=0|Ig(0|Ee,0|Qe,0|ce,0|f)),0|vi,2097151&cA|0,0)),0|vi,0|EA,0|w),f=vi,w=0|Ag(0|QA,0|T,0|(w=0|Se(0|EA,0|w,21)),0|vi),T=vi,QA=0|Ue(0|(QA=0|Ig(0|hA,0|sA,1048576,0)),0|vi,21),EA=vi,NA=0|Ig(0|(NA=0|Ig(0|(x=0|Ig(0|(aA=0|Ig(0|(ae=0|Ig(0|oe,0|Ce,0|ne,0|ae)),0|vi,0|re,0|aA)),0|vi,0|rA,0|x)),0|vi,2097151&NA|0,0)),0|vi,0|QA,0|EA),x=vi,EA=0|Se(0|QA,0|EA,21),QA=vi,rA=0|be(0|(rA=0|Ig(0|CA,0|nA,1048576,0)),0|vi,21),aA=vi,bA=0|Ig(0|(bA=0|Ig(0|(W=0|Ig(0|(DA=0|Ig(0|($I=0|Ig(0|(Ie=0|Ig(0|(ge=0|Ig(0|te,0|Be,0|ie,0|ge)),0|vi,0|ee,0|Ie)),0|vi,0|Ae,0|$I)),0|vi,0|OI,0|DA)),0|vi,0|vA,0|W)),0|vi,2097151&bA|0,0)),0|vi,0|rA,0|aA),W=vi,aA=0|Se(0|rA,0|aA,21),rA=vi,vA=0|be(0|(vA=0|Ig(0|gI,0|zA,1048576,0)),0|vi,21),DA=vi,B=0|Ig(0|(B=0|Ig(0|(D=0|Ig(0|(q=0|Ig(0|(PI=0|Ig(0|(xI=0|Ig(0|(KI=0|Ig(0|(VI=0|Ig(0|(jI=0|Ig(0|zI,0|WI,0|ZI,0|jI)),0|vi,0|qI,0|VI)),0|vi,0|TI,0|KI)),0|vi,0|XI,0|xI)),0|vi,0|LI,0|PI)),0|vi,0|JI,0|q)),0|vi,0|j,0|D)),0|vi,2097151&B|0,0)),0|vi,0|vA,0|DA),D=vi,DA=0|Se(0|vA,0|DA,21),vA=vi,j=0|be(0|(j=0|Ig(0|LA,0|xA,1048576,0)),0|vi,21),q=vi,g=0|Ig(0|(g=0|Ig(0|(g=0|Ig(0|(_A=0|Ig(0|(lI=0|Ig(0|(dI=0|Ig(0|(vI=0|Ig(0|(kI=0|Ig(0|(FI=0|Ig(0|(MI=0|Ig(0|(SI=0|Ig(0|UI,0|NI,0|RI,0|SI)),0|vi,0|YI,0|MI)),0|vi,0|mI,0|FI)),0|vi,0|GI,0|kI)),0|vi,0|bI,0|vI)),0|vi,0|DI,0|dI)),0|vi,0|uI,0|lI)),0|vi,0|wI,0|_A)),0|vi,0|r,0|g)),0|vi,2097151&k|0,0)),0|vi,0|j,0|q),k=vi,q=0|Se(0|j,0|q,21),j=vi,r=0|be(0|(r=0|Ig(0|PA,0|JA,1048576,0)),0|vi,21),_A=vi,t=0|Ig(0|(t=0|Ig(0|(OA=0|Ig(0|(WA=0|Ig(0|(K=0|Ig(0|(CI=0|Ig(0|(z=0|Ig(0|(RA=0|Ig(0|(eI=0|Ig(0|(FA=0|Ig(0|(KA=0|Ig(0|(S=0|Ig(0|(yI=0|Ig(0|pI,0|_I,0|fI,0|yI)),0|vi,0|P,0|S)),0|vi,0|XA,0|KA)),0|vi,0|GA,0|FA)),0|vi,0|II,0|eI)),0|vi,0|SA,0|RA)),0|vi,0|O,0|z)),0|vi,0|nI,0|CI)),0|vi,0|X,0|K)),0|vi,0|ZA,0|WA)),0|vi,0|iI,0|OA)),0|vi,0|I,0|t)),0|vi,0|r,0|_A),I=vi,_A=0|Se(0|r,0|_A,21),r=vi,OA=0|be(0|(OA=0|Ig(0|cI,0|oI,1048576,0)),0|vi,21),iI=vi,p=0|Ig(0|(p=0|Ig(0|(AI=0|Ig(0|(BI=0|Ig(0|(EI=0|Ig(0|(_=0|Ig(0|(u=0|Ig(0|(tA=0|Ig(0|(L=0|Ig(0|(TA=0|Ig(0|mA,0|MA,0|VA,0|TA)),0|vi,0|IA,0|L)),0|vi,0|BA,0|tA)),0|vi,0|s,0|u)),0|vi,0|E,0|_)),0|vi,0|QI,0|EI)),0|vi,0|R,0|BI)),0|vi,0|$A,0|AI)),0|vi,0|d,0|p)),0|vi,0|OA,0|iI),d=vi,iI=0|Se(0|OA,0|iI,21),OA=vi,AI=0|be(0|(AI=0|Ig(0|rI,0|aI,1048576,0)),0|vi,21),$A=vi,a=0|Ig(0|(a=0|Ig(0|(jA=0|Ig(0|(i=0|Ig(0|(h=0|Ig(0|(F=0|Ig(0|(n=0|Ig(0|(Q=0|Ig(0|pA,0|AA,0|J,0|Q)),0|vi,0|uA,0|n)),0|vi,0|Z,0|F)),0|vi,0|V,0|h)),0|vi,0|o,0|i)),0|vi,0|qA,0|jA)),0|vi,0|C,0|a)),0|vi,0|AI,0|$A),C=vi,$A=0|Se(0|AI,0|$A,21),AI=vi,jA=0|be(0|(jA=0|Ig(0|hI,0|H,1048576,0)),0|vi,21),qA=vi,YA=0|Ig(0|(YA=0|Ig(0|(v=0|Ig(0|(dA=0|Ig(0|(e=0|Ig(0|(lA=0|Ig(0|b,0|y,0|wA,0|lA)),0|vi,0|$,0|e)),0|vi,0|kA,0|dA)),0|vi,0|gA,0|v)),0|vi,0|G,0|YA)),0|vi,0|jA,0|qA),G=vi,qA=0|Se(0|jA,0|qA,21),jA=vi,v=0|be(0|(v=0|Ig(0|Y,0|eA,1048576,0)),0|vi,21),gA=vi,N=0|Ig(0|(N=0|Ig(0|(m=0|Ig(0|(l=0|Ig(0|UA,0|iA,0|oA,0|l)),0|vi,0|yA,0|m)),0|vi,0|tI,0|N)),0|vi,0|v,0|gA),tI=vi,gA=0|Ag(0|Y,0|eA,0|(gA=0|Se(0|v,0|gA,21)),0|vi),eA=vi,U=0|Ig(0|HA,0|U,0|(Y=0|be(0|(Y=0|Ig(0|sI,0|M,1048576,0)),0|vi,21)),0|(v=vi)),HA=vi,v=0|Ag(0|sI,0|M,0|(v=0|Se(0|Y,0|v,21)),0|vi),M=vi,m=0|Ag(0|fA,0|c,0|(m=0|Se(0|(sI=0|be(0|(sI=0|Ig(0|fA,0|c,1048576,0)),0|vi,21)),0|(Y=vi),21)),0|vi),c=vi,l=0|Ag(0|cA,0|f,0|(l=0|Se(0|(fA=0|Ue(0|(fA=0|Ig(0|cA,0|f,1048576,0)),0|vi,21)),0|(yA=vi),21)),0|vi),f=vi,iA=0|Ag(0|NA,0|x,0|(iA=0|Se(0|(cA=0|be(0|(cA=0|Ig(0|NA,0|x,1048576,0)),0|vi,21)),0|(oA=vi),21)),0|vi),x=vi,dA=0|Ag(0|bA,0|W,0|(dA=0|Se(0|(NA=0|be(0|(NA=0|Ig(0|bA,0|W,1048576,0)),0|vi,21)),0|(UA=vi),21)),0|vi),W=vi,e=0|Se(0|(bA=0|be(0|(bA=0|Ig(0|B,0|D,1048576,0)),0|vi,21)),0|(kA=vi),21),$=vi,y=0|Se(0|(lA=0|be(0|(lA=0|Ig(0|g,0|k,1048576,0)),0|vi,21)),0|(wA=vi),21),b=vi,h=0|Se(0|(i=0|be(0|(i=0|Ig(0|t,0|I,1048576,0)),0|vi,21)),0|(o=vi),21),V=vi,n=0|Se(0|(F=0|be(0|(F=0|Ig(0|p,0|d,1048576,0)),0|vi,21)),0|(Z=vi),21),uA=vi,AA=0|Se(0|(Q=0|be(0|(Q=0|Ig(0|a,0|C,1048576,0)),0|vi,21)),0|(J=vi),21),pA=vi,eA=0|Ig(0|(BI=0|be(0|(BI=0|Ig(0|YA,0|G,1048576,0)),0|vi,21)),0|(R=vi),0|gA,0|eA),gA=vi,R=0|Ag(0|YA,0|G,0|(R=0|Se(0|BI,0|R,21)),0|vi),G=vi,M=0|Ig(0|(YA=0|be(0|(YA=0|Ig(0|N,0|tI,1048576,0)),0|vi,21)),0|(BI=vi),0|v,0|M),v=vi,BI=0|Ag(0|N,0|tI,0|(BI=0|Se(0|YA,0|BI,21)),0|vi),tI=vi,c=0|Ig(0|(N=0|be(0|(N=0|Ig(0|U,0|HA,1048576,0)),0|vi,21)),0|(YA=vi),0|m,0|c),m=vi,YA=0|Ag(0|U,0|HA,0|(YA=0|Se(0|N,0|YA,21)),0|vi),HA=vi,U=0|he(0|sI,0|Y,666643,0),N=vi,EI=0|he(0|sI,0|Y,470296,0),QI=vi,_=0|he(0|sI,0|Y,654183,0),E=vi,u=0|he(0|sI,0|Y,-997805,-1),s=vi,tA=0|he(0|sI,0|Y,136657,0),BA=vi,J=0|Ig(0|(jA=0|Ag(0|(Y=0|Ig(0|hI,0|H,0|(Y=0|he(0|sI,0|Y,-683901,-1)),0|vi)),0|vi,0|qA,0|jA)),0|vi,0|Q,0|J),Q=vi,jA=0|he(0|c,0|m,666643,0),qA=vi,Y=0|he(0|c,0|m,470296,0),H=vi,hI=0|he(0|c,0|m,654183,0),sI=vi,L=0|he(0|c,0|m,-997805,-1),IA=vi,TA=0|he(0|c,0|m,136657,0),VA=vi,m=0|he(0|c,0|m,-683901,-1),c=vi,MA=0|he(0|YA,0|HA,666643,0),mA=vi,WA=0|he(0|YA,0|HA,470296,0),ZA=vi,K=0|he(0|YA,0|HA,654183,0),X=vi,CI=0|he(0|YA,0|HA,-997805,-1),nI=vi,z=0|he(0|YA,0|HA,136657,0),O=vi,HA=0|he(0|YA,0|HA,-683901,-1),YA=vi,Z=0|Ig(0|(AI=0|Ag(0|(YA=0|Ig(0|(VA=0|Ig(0|(s=0|Ig(0|rI,0|aI,0|u,0|s)),0|vi,0|TA,0|VA)),0|vi,0|HA,0|YA)),0|vi,0|$A,0|AI)),0|vi,0|F,0|Z),F=vi,AI=0|he(0|M,0|v,666643,0),$A=vi,YA=0|he(0|M,0|v,470296,0),HA=vi,VA=0|he(0|M,0|v,654183,0),TA=vi,s=0|he(0|M,0|v,-997805,-1),u=vi,aI=0|he(0|M,0|v,136657,0),rI=vi,v=0|he(0|M,0|v,-683901,-1),M=vi,RA=0|he(0|BI,0|tI,666643,0),SA=vi,eI=0|he(0|BI,0|tI,470296,0),II=vi,FA=0|he(0|BI,0|tI,654183,0),GA=vi,KA=0|he(0|BI,0|tI,-997805,-1),XA=vi,S=0|he(0|BI,0|tI,136657,0),P=vi,tI=0|he(0|BI,0|tI,-683901,-1),BI=vi,o=0|Ig(0|(OA=0|Ag(0|(BI=0|Ig(0|(rI=0|Ig(0|(nI=0|Ig(0|(oI=0|Ig(0|(QI=0|Ig(0|hI,0|sI,0|EI,0|QI)),0|vi,0|cI,0|oI)),0|vi,0|CI,0|nI)),0|vi,0|aI,0|rI)),0|vi,0|tI,0|BI)),0|vi,0|iI,0|OA)),0|vi,0|i,0|o),i=vi,vA=0|Ag(0|(UA=0|Ig(0|(OA=0|Ig(0|gI,0|zA,0|(OA=0|he(0|eA,0|gA,666643,0)),0|vi)),0|vi,0|NA,0|UA)),0|vi,0|DA,0|vA),DA=vi,UA=0|he(0|eA,0|gA,470296,0),NA=vi,OA=0|he(0|eA,0|gA,654183,0),zA=vi,j=0|Ag(0|(kA=0|Ig(0|(xA=0|Ig(0|(zA=0|Ig(0|($A=0|Ig(0|eI,0|II,0|AI,0|$A)),0|vi,0|OA,0|zA)),0|vi,0|LA,0|xA)),0|vi,0|bA,0|kA)),0|vi,0|q,0|j),q=vi,kA=0|he(0|eA,0|gA,-997805,-1),bA=vi,xA=0|he(0|eA,0|gA,136657,0),LA=vi,r=0|Ag(0|(wA=0|Ig(0|(JA=0|Ig(0|(LA=0|Ig(0|(XA=0|Ig(0|(TA=0|Ig(0|(qA=0|Ig(0|WA,0|ZA,0|jA,0|qA)),0|vi,0|VA,0|TA)),0|vi,0|KA,0|XA)),0|vi,0|xA,0|LA)),0|vi,0|PA,0|JA)),0|vi,0|lA,0|wA)),0|vi,0|_A,0|r),_A=vi,gA=0|he(0|eA,0|gA,-683901,-1),eA=vi,wA=0|be(0|(wA=0|Ig(0|vA,0|DA,1048576,0)),0|vi,21),lA=vi,$=0|Ig(0|($=0|Ag(0|(D=0|Ig(0|(SA=0|Ig(0|UA,0|NA,0|RA,0|SA)),0|vi,0|B,0|D)),0|vi,0|e,0|$)),0|vi,0|wA,0|lA),e=vi,lA=0|Se(0|wA,0|lA,21),wA=vi,D=0|be(0|(D=0|Ig(0|j,0|q,1048576,0)),0|vi,21),B=vi,b=0|Ig(0|(b=0|Ag(0|(k=0|Ig(0|(bA=0|Ig(0|(GA=0|Ig(0|(mA=0|Ig(0|YA,0|HA,0|MA,0|mA)),0|vi,0|FA,0|GA)),0|vi,0|kA,0|bA)),0|vi,0|g,0|k)),0|vi,0|y,0|b)),0|vi,0|D,0|B),y=vi,B=0|Se(0|D,0|B,21),D=vi,k=0|be(0|(k=0|Ig(0|r,0|_A,1048576,0)),0|vi,21),g=vi,V=0|Ig(0|(V=0|Ag(0|(I=0|Ig(0|(eA=0|Ig(0|(P=0|Ig(0|(u=0|Ig(0|(X=0|Ig(0|(N=0|Ig(0|Y,0|H,0|U,0|N)),0|vi,0|K,0|X)),0|vi,0|s,0|u)),0|vi,0|S,0|P)),0|vi,0|gA,0|eA)),0|vi,0|t,0|I)),0|vi,0|h,0|V)),0|vi,0|k,0|g),h=vi,g=0|Se(0|k,0|g,21),k=vi,I=0|be(0|(I=0|Ig(0|o,0|i,1048576,0)),0|vi,21),t=vi,uA=0|Ig(0|(uA=0|Ag(0|(d=0|Ig(0|(M=0|Ig(0|(O=0|Ig(0|(E=0|Ig(0|L,0|IA,0|_,0|E)),0|vi,0|z,0|O)),0|vi,0|v,0|M)),0|vi,0|p,0|d)),0|vi,0|n,0|uA)),0|vi,0|I,0|t),n=vi,t=0|Ag(0|o,0|i,0|(t=0|Se(0|I,0|t,21)),0|vi),i=vi,o=0|be(0|(o=0|Ig(0|Z,0|F,1048576,0)),0|vi,21),I=vi,pA=0|Ig(0|(pA=0|Ag(0|(C=0|Ig(0|(BA=0|Ig(0|m,0|c,0|tA,0|BA)),0|vi,0|a,0|C)),0|vi,0|AA,0|pA)),0|vi,0|o,0|I),AA=vi,I=0|Ag(0|Z,0|F,0|(I=0|Se(0|o,0|I,21)),0|vi),F=vi,G=0|Ig(0|(Z=0|be(0|(Z=0|Ig(0|J,0|Q,1048576,0)),0|vi,21)),0|(o=vi),0|R,0|G),R=vi,o=0|Ag(0|J,0|Q,0|(o=0|Se(0|Z,0|o,21)),0|vi),Q=vi,C=0|Se(0|(J=0|be(0|(J=0|Ig(0|$,0|e,1048576,0)),0|vi,21)),0|(Z=vi),21),a=vi,c=0|Se(0|(BA=0|be(0|(BA=0|Ig(0|b,0|y,1048576,0)),0|vi,21)),0|(tA=vi),21),m=vi,i=0|Ig(0|(d=0|be(0|(d=0|Ig(0|V,0|h,1048576,0)),0|vi,21)),0|(p=vi),0|t,0|i),t=vi,p=0|Ag(0|V,0|h,0|(p=0|Se(0|d,0|p,21)),0|vi),h=vi,F=0|Ig(0|(V=0|be(0|(V=0|Ig(0|uA,0|n,1048576,0)),0|vi,21)),0|(d=vi),0|I,0|F),I=vi,d=0|Ag(0|uA,0|n,0|(d=0|Se(0|V,0|d,21)),0|vi),n=vi,Q=0|Ig(0|(uA=0|be(0|(uA=0|Ig(0|pA,0|AA,1048576,0)),0|vi,21)),0|(V=vi),0|o,0|Q),o=vi,V=0|Ag(0|pA,0|AA,0|(V=0|Se(0|uA,0|V,21)),0|vi),AA=vi,pA=0|Ig(0|dA,0|W,0|(pA=0|he(0|G,0|R,666643,0)),0|vi),W=vi,dA=0|he(0|G,0|R,470296,0),uA=vi,M=0|he(0|G,0|R,654183,0),v=vi,O=0|he(0|G,0|R,-997805,-1),z=vi,E=0|he(0|G,0|R,136657,0),_=vi,k=0|Ag(0|(tA=0|Ig(0|(R=0|Ig(0|r,0|_A,0|(R=0|he(0|G,0|R,-683901,-1)),0|vi)),0|vi,0|BA,0|tA)),0|vi,0|g,0|k),g=vi,tA=0|he(0|Q,0|o,666643,0),BA=vi,R=0|Ig(0|pA,0|W,0|(R=0|he(0|Q,0|o,470296,0)),0|vi),W=vi,pA=0|he(0|Q,0|o,654183,0),_A=vi,r=0|he(0|Q,0|o,-997805,-1),G=vi,IA=0|he(0|Q,0|o,136657,0),L=vi,o=0|he(0|Q,0|o,-683901,-1),Q=vi,eA=0|Ig(0|iA,0|x,0|(eA=0|he(0|V,0|AA,666643,0)),0|vi),x=vi,iA=0|he(0|V,0|AA,470296,0),gA=vi,P=0|Ig(0|R,0|W,0|(P=0|he(0|V,0|AA,654183,0)),0|vi),W=vi,R=0|he(0|V,0|AA,-997805,-1),S=vi,u=0|he(0|V,0|AA,136657,0),s=vi,AA=0|he(0|V,0|AA,-683901,-1),V=vi,D=0|Ag(0|(V=0|Ig(0|(L=0|Ig(0|(Z=0|Ig(0|(z=0|Ig(0|j,0|q,0|O,0|z)),0|vi,0|J,0|Z)),0|vi,0|IA,0|L)),0|vi,0|AA,0|V)),0|vi,0|B,0|D),B=vi,V=0|he(0|F,0|I,666643,0),AA=vi,L=0|Ig(0|eA,0|x,0|(L=0|he(0|F,0|I,470296,0)),0|vi),x=vi,eA=0|he(0|F,0|I,654183,0),IA=vi,Z=0|Ig(0|P,0|W,0|(Z=0|he(0|F,0|I,-997805,-1)),0|vi),W=vi,P=0|he(0|F,0|I,136657,0),J=vi,I=0|he(0|F,0|I,-683901,-1),F=vi,z=0|he(0|d,0|n,666643,0),O=vi,q=0|he(0|d,0|n,470296,0),j=vi,X=0|he(0|d,0|n,654183,0),K=vi,N=0|he(0|d,0|n,-997805,-1),U=vi,H=0|he(0|d,0|n,136657,0),Y=vi,n=0|he(0|d,0|n,-683901,-1),d=vi,d=0|Ig(0|(J=0|Ig(0|(S=0|Ig(0|(_A=0|Ig(0|(wA=0|Ag(0|(uA=0|Ig(0|vA,0|DA,0|dA,0|uA)),0|vi,0|lA,0|wA)),0|vi,0|pA,0|_A)),0|vi,0|R,0|S)),0|vi,0|P,0|J)),0|vi,0|n,0|d),n=vi,T=0|Ig(0|(J=0|he(0|i,0|t,666643,0)),0|vi,0|w,0|T),w=vi,J=0|he(0|i,0|t,470296,0),P=vi,S=0|he(0|i,0|t,654183,0),R=vi,j=0|Ig(0|(R=0|Ig(0|(AA=0|Ig(0|(QA=0|Ag(0|(sA=0|Ig(0|fA,0|yA,0|hA,0|sA)),0|vi,0|EA,0|QA)),0|vi,0|V,0|AA)),0|vi,0|S,0|R)),0|vi,0|q,0|j),q=vi,R=0|he(0|i,0|t,-997805,-1),S=vi,AA=0|he(0|i,0|t,136657,0),V=vi,U=0|Ig(0|(V=0|Ig(0|(IA=0|Ig(0|(gA=0|Ig(0|(BA=0|Ig(0|(rA=0|Ag(0|(nA=0|Ig(0|cA,0|oA,0|CA,0|nA)),0|vi,0|aA,0|rA)),0|vi,0|tA,0|BA)),0|vi,0|iA,0|gA)),0|vi,0|eA,0|IA)),0|vi,0|AA,0|V)),0|vi,0|N,0|U),N=vi,t=0|he(0|i,0|t,-683901,-1),i=vi,V=0|be(0|(V=0|Ig(0|T,0|w,1048576,0)),0|vi,21),AA=vi,O=0|Ig(0|(O=0|Ig(0|(P=0|Ig(0|l,0|f,0|J,0|P)),0|vi,0|z,0|O)),0|vi,0|V,0|AA),z=vi,AA=0|Ag(0|T,0|w,0|(AA=0|Se(0|V,0|AA,21)),0|vi),w=vi,T=0|be(0|(T=0|Ig(0|j,0|q,1048576,0)),0|vi,21),V=vi,K=0|Ig(0|(K=0|Ig(0|(S=0|Ig(0|L,0|x,0|R,0|S)),0|vi,0|X,0|K)),0|vi,0|T,0|V),X=vi,V=0|Se(0|T,0|V,21),T=vi,S=0|be(0|(S=0|Ig(0|U,0|N,1048576,0)),0|vi,21),R=vi,Y=0|Ig(0|(Y=0|Ig(0|(i=0|Ig(0|Z,0|W,0|t,0|i)),0|vi,0|H,0|Y)),0|vi,0|S,0|R),H=vi,R=0|Se(0|S,0|R,21),S=vi,i=0|be(0|(i=0|Ig(0|d,0|n,1048576,0)),0|vi,21),t=vi,F=0|Ig(0|(F=0|Ig(0|(s=0|Ig(0|(a=0|Ag(0|(G=0|Ig(0|(v=0|Ig(0|$,0|e,0|M,0|v)),0|vi,0|r,0|G)),0|vi,0|C,0|a)),0|vi,0|u,0|s)),0|vi,0|I,0|F)),0|vi,0|i,0|t),I=vi,t=0|Ag(0|d,0|n,0|(t=0|Se(0|i,0|t,21)),0|vi),n=vi,d=0|be(0|(d=0|Ig(0|D,0|B,1048576,0)),0|vi,21),i=vi,m=0|Ig(0|(m=0|Ag(0|(y=0|Ig(0|(_=0|Ig(0|o,0|Q,0|E,0|_)),0|vi,0|b,0|y)),0|vi,0|c,0|m)),0|vi,0|d,0|i),c=vi,i=0|Ag(0|D,0|B,0|(i=0|Se(0|d,0|i,21)),0|vi),B=vi,h=0|Ig(0|p,0|h,0|(D=0|be(0|(D=0|Ig(0|k,0|g,1048576,0)),0|vi,21)),0|(d=vi)),p=vi,d=0|Se(0|D,0|d,21),D=vi,_=0|Se(0|(y=0|be(0|(y=0|Ig(0|O,0|z,1048576,0)),0|vi,21)),0|(b=vi),21),E=vi,s=0|Se(0|(Q=0|be(0|(Q=0|Ig(0|K,0|X,1048576,0)),0|vi,21)),0|(o=vi),21),u=vi,n=0|Ig(0|t,0|n,0|(a=0|be(0|(a=0|Ig(0|Y,0|H,1048576,0)),0|vi,21)),0|(C=vi)),t=vi,C=0|Se(0|a,0|C,21),a=vi,B=0|Ig(0|i,0|B,0|(G=0|be(0|(G=0|Ig(0|F,0|I,1048576,0)),0|vi,21)),0|(r=vi)),i=vi,r=0|Ag(0|F,0|I,0|(r=0|Se(0|G,0|r,21)),0|vi),I=vi,v=0|Ag(0|m,0|c,0|(v=0|Se(0|(F=0|be(0|(F=0|Ig(0|m,0|c,1048576,0)),0|vi,21)),0|(G=vi),21)),0|vi),c=vi,e=0|Ag(0|h,0|p,0|(e=0|Se(0|(m=0|be(0|(m=0|Ig(0|h,0|p,1048576,0)),0|vi,21)),0|(M=vi),21)),0|vi),p=vi,h=0|Ig(0|AA,0|w,0|(h=0|he(0|m,0|M,666643,0)),0|vi),w=vi,AA=0|he(0|m,0|M,470296,0),$=vi,W=0|he(0|m,0|M,654183,0),Z=vi,x=0|he(0|m,0|M,-997805,-1),L=vi,P=0|he(0|m,0|M,136657,0),J=vi,M=0|he(0|m,0|M,-683901,-1),m=vi,f=0|be(0|h,0|w,21),l=vi,E=0|Ig(0|(E=0|Ag(0|(z=0|Ig(0|AA,0|$,0|O,0|z)),0|vi,0|_,0|E)),0|vi,0|f,0|l),_=vi,l=0|Ag(0|h,0|w,0|(l=0|Se(0|f,0|l,21)),0|vi),w=vi,h=0|be(0|E,0|_,21),f=vi,b=0|Ig(0|(b=0|Ig(0|(T=0|Ag(0|(q=0|Ig(0|W,0|Z,0|j,0|q)),0|vi,0|V,0|T)),0|vi,0|y,0|b)),0|vi,0|h,0|f),y=vi,f=0|Ag(0|E,0|_,0|(f=0|Se(0|h,0|f,21)),0|vi),_=vi,E=0|be(0|b,0|y,21),h=vi,u=0|Ig(0|(u=0|Ag(0|(L=0|Ig(0|K,0|X,0|x,0|L)),0|vi,0|s,0|u)),0|vi,0|E,0|h),s=vi,h=0|Ag(0|b,0|y,0|(h=0|Se(0|E,0|h,21)),0|vi),y=vi,b=0|be(0|u,0|s,21),E=vi,o=0|Ig(0|(o=0|Ig(0|(S=0|Ag(0|(N=0|Ig(0|P,0|J,0|U,0|N)),0|vi,0|R,0|S)),0|vi,0|Q,0|o)),0|vi,0|b,0|E),Q=vi,E=0|Ag(0|u,0|s,0|(E=0|Se(0|b,0|E,21)),0|vi),s=vi,u=0|be(0|o,0|Q,21),b=vi,a=0|Ig(0|(a=0|Ag(0|(m=0|Ig(0|Y,0|H,0|M,0|m)),0|vi,0|C,0|a)),0|vi,0|u,0|b),C=vi,b=0|Ag(0|o,0|Q,0|(b=0|Se(0|u,0|b,21)),0|vi),Q=vi,t=0|Ig(0|n,0|t,0|(o=0|be(0|a,0|C,21)),0|(u=vi)),n=vi,u=0|Ag(0|a,0|C,0|(u=0|Se(0|o,0|u,21)),0|vi),C=vi,I=0|Ig(0|(a=0|be(0|t,0|n,21)),0|(o=vi),0|r,0|I),r=vi,o=0|Ag(0|t,0|n,0|(o=0|Se(0|a,0|o,21)),0|vi),n=vi,i=0|Ig(0|B,0|i,0|(t=0|be(0|I,0|r,21)),0|(a=vi)),B=vi,a=0|Ag(0|I,0|r,0|(a=0|Se(0|t,0|a,21)),0|vi),r=vi,c=0|Ig(0|(I=0|be(0|i,0|B,21)),0|(t=vi),0|v,0|c),v=vi,t=0|Ag(0|i,0|B,0|(t=0|Se(0|I,0|t,21)),0|vi),B=vi,i=0|be(0|c,0|v,21),I=vi,D=0|Ig(0|(D=0|Ag(0|(g=0|Ig(0|F,0|G,0|k,0|g)),0|vi,0|d,0|D)),0|vi,0|i,0|I),d=vi,I=0|Ag(0|c,0|v,0|(I=0|Se(0|i,0|I,21)),0|vi),v=vi,p=0|Ig(0|(c=0|be(0|D,0|d,21)),0|(i=vi),0|e,0|p),e=vi,i=0|Ag(0|D,0|d,0|(i=0|Se(0|c,0|i,21)),0|vi),d=vi,g=0|Ag(0|p,0|e,0|(g=0|Se(0|(D=0|be(0|p,0|e,21)),0|(c=vi),21)),0|vi),e=vi,w=0|Ig(0|(p=0|he(0|D,0|c,666643,0)),0|vi,0|l,0|w),l=vi,p=0|Ig(0|f,0|_,0|(p=0|he(0|D,0|c,470296,0)),0|vi),_=vi,f=0|Ig(0|h,0|y,0|(f=0|he(0|D,0|c,654183,0)),0|vi),y=vi,h=0|Ig(0|E,0|s,0|(h=0|he(0|D,0|c,-997805,-1)),0|vi),s=vi,E=0|Ig(0|b,0|Q,0|(E=0|he(0|D,0|c,136657,0)),0|vi),Q=vi,c=0|Ig(0|u,0|C,0|(c=0|he(0|D,0|c,-683901,-1)),0|vi),C=vi,_=0|Ig(0|p,0|_,0|(u=0|be(0|w,0|l,21)),0|(D=vi)),p=vi,D=0|Ag(0|w,0|l,0|(D=0|Se(0|u,0|D,21)),0|vi),l=vi,y=0|Ig(0|f,0|y,0|(w=0|be(0|_,0|p,21)),0|(u=vi)),f=vi,u=0|Ag(0|_,0|p,0|(u=0|Se(0|w,0|u,21)),0|vi),p=vi,s=0|Ig(0|h,0|s,0|(_=0|be(0|y,0|f,21)),0|(w=vi)),h=vi,w=0|Ag(0|y,0|f,0|(w=0|Se(0|_,0|w,21)),0|vi),f=vi,Q=0|Ig(0|E,0|Q,0|(y=0|be(0|s,0|h,21)),0|(_=vi)),E=vi,_=0|Ag(0|s,0|h,0|(_=0|Se(0|y,0|_,21)),0|vi),h=vi,C=0|Ig(0|c,0|C,0|(s=0|be(0|Q,0|E,21)),0|(y=vi)),c=vi,y=0|Ag(0|Q,0|E,0|(y=0|Se(0|s,0|y,21)),0|vi),E=vi,n=0|Ig(0|(Q=0|be(0|C,0|c,21)),0|(s=vi),0|o,0|n),o=vi,s=0|Ag(0|C,0|c,0|(s=0|Se(0|Q,0|s,21)),0|vi),c=vi,r=0|Ig(0|(C=0|be(0|n,0|o,21)),0|(Q=vi),0|a,0|r),a=vi,Q=0|Ag(0|n,0|o,0|(Q=0|Se(0|C,0|Q,21)),0|vi),o=vi,B=0|Ig(0|(n=0|be(0|r,0|a,21)),0|(C=vi),0|t,0|B),t=vi,C=0|Ag(0|r,0|a,0|(C=0|Se(0|n,0|C,21)),0|vi),a=vi,v=0|Ig(0|(r=0|be(0|B,0|t,21)),0|(n=vi),0|I,0|v),I=vi,n=0|Ag(0|B,0|t,0|(n=0|Se(0|r,0|n,21)),0|vi),t=vi,d=0|Ig(0|(B=0|be(0|v,0|I,21)),0|(r=vi),0|i,0|d),i=vi,r=0|Ag(0|v,0|I,0|(r=0|Se(0|B,0|r,21)),0|vi),I=vi,e=0|Ig(0|(v=0|be(0|d,0|i,21)),0|(B=vi),0|g,0|e),g=vi,B=0|Ag(0|d,0|i,0|(B=0|Se(0|v,0|B,21)),0|vi),i=vi,yi[A>>0]=D,d=0|Ue(0|D,0|l,8),yi[A+1>>0]=d,l=0|Ue(0|D,0|l,16),D=vi,d=0|Se(0|u,0|p,5),yi[A+2>>0]=d|l,l=0|Ue(0|u,0|p,3),yi[A+3>>0]=l,l=0|Ue(0|u,0|p,11),yi[A+4>>0]=l,p=0|Ue(0|u,0|p,19),u=vi,l=0|Se(0|w,0|f,2),yi[A+5>>0]=l|p,p=0|Ue(0|w,0|f,6),yi[A+6>>0]=p,f=0|Ue(0|w,0|f,14),w=vi,p=0|Se(0|_,0|h,7),yi[A+7>>0]=p|f,f=0|Ue(0|_,0|h,1),yi[A+8>>0]=f,f=0|Ue(0|_,0|h,9),yi[A+9>>0]=f,h=0|Ue(0|_,0|h,17),_=vi,f=0|Se(0|y,0|E,4),yi[A+10>>0]=f|h,h=0|Ue(0|y,0|E,4),yi[A+11>>0]=h,h=0|Ue(0|y,0|E,12),yi[A+12>>0]=h,E=0|Ue(0|y,0|E,20),y=vi,h=0|Se(0|s,0|c,1),yi[A+13>>0]=h|E,E=0|Ue(0|s,0|c,7),yi[A+14>>0]=E,c=0|Ue(0|s,0|c,15),s=vi,E=0|Se(0|Q,0|o,6),yi[A+15>>0]=E|c,c=0|Ue(0|Q,0|o,2),yi[A+16>>0]=c,c=0|Ue(0|Q,0|o,10),yi[A+17>>0]=c,o=0|Ue(0|Q,0|o,18),Q=vi,c=0|Se(0|C,0|a,3),yi[A+18>>0]=c|o,o=0|Ue(0|C,0|a,5),yi[A+19>>0]=o,a=0|Ue(0|C,0|a,13),yi[A+20>>0]=a,yi[A+21>>0]=n,a=0|Ue(0|n,0|t,8),yi[A+22>>0]=a,t=0|Ue(0|n,0|t,16),n=vi,a=0|Se(0|r,0|I,5),yi[A+23>>0]=a|t,t=0|Ue(0|r,0|I,3),yi[A+24>>0]=t,t=0|Ue(0|r,0|I,11),yi[A+25>>0]=t,I=0|Ue(0|r,0|I,19),r=vi,t=0|Se(0|B,0|i,2),yi[A+26>>0]=t|I,I=0|Ue(0|B,0|i,6),yi[A+27>>0]=I,i=0|Ue(0|B,0|i,14),B=vi,I=0|Se(0|e,0|g,7),yi[A+28>>0]=i|I,I=0|Ue(0|e,0|g,1),yi[A+29>>0]=I,I=0|Ue(0|e,0|g,9),yi[A+30>>0]=I,g=0|Ue(0|e,0|g,17),yi[A+31>>0]=g}function B(A,I,e,g){A|=0,g|=0;var i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0;ge(e|=0,I|=0),i=A,B=(I=g)+64|0;do{fi[I>>2]=fi[i>>2],I=I+4|0,i=i+4|0}while((0|I)<(0|B));for(y=0,I=0|fi[e>>2],i=0|fi[e+4>>2];;){if(d=0|fi[g+32>>2],s=0|fi[g+32+4>>2],r=0|Ee(d,s,14),v=vi,u=0|Ee(d,s,18),v^=vi,b=0|Ee(d,s,41),h=0|fi[g+40>>2],C=0|fi[g+40+4>>2],n=0|fi[g+48>>2],R=0|fi[g+48+4>>2],Q=304+(y<<3)|0,o=0|fi[Q>>2],Q=0|fi[Q+4>>2],w=0|fi[g+56>>2],_=0|fi[g+56+4>>2],v=0|Ig(0|I,0|i,u^r^b|0,v^vi|0),Q=0|Ig(0|v,0|vi,0|o,0|Q),Q=0|Ig(0|Q,0|vi,(n^h)&d^n|0,(R^C)&s^R|0),_=0|Ig(0|Q,0|vi,0|w,0|_),w=vi,Q=0|Ig(0|_,0|w,0|fi[g+24>>2],0|fi[g+24+4>>2]),o=vi,fi[g+24>>2]=Q,fi[g+24+4>>2]=o,v=0|fi[g>>2],b=0|fi[g+4>>2],r=0|Ee(v,b,28),u=vi,a=0|Ee(v,b,34),u^=vi,p=0|Ee(v,b,39),D=0|fi[g+8>>2],m=0|fi[g+8+4>>2],k=0|fi[g+16>>2],M=0|fi[g+16+4>>2],u=0|Ig(0|_,0|w,a^r^p|0,u^vi|0),u=0|Ig(0|u,0|vi,(k|D)&v|k&D|0,(M|m)&b|M&m|0),p=vi,fi[g+56>>2]=u,fi[g+56+4>>2]=p,r=0|Ee(Q,o,14),a=vi,w=0|Ee(Q,o,18),a^=vi,_=0|Ee(Q,o,41),t=1|y,l=0|fi[304+(t<<3)>>2],S=0|fi[304+(t<<3)+4>>2],a=0|Ig(0|fi[e+(t<<3)>>2],0|fi[e+(t<<3)+4>>2],w^r^_|0,a^vi|0),S=0|Ig(0|a,0|vi,0|l,0|S),S=0|Ig(0|S,0|vi,(h^d)&Q^h|0,(C^s)&o^C|0),R=0|Ig(0|S,0|vi,0|n,0|R),n=vi,M=0|Ig(0|R,0|n,0|k,0|M),k=vi,fi[g+16>>2]=M,fi[g+16+4>>2]=k,S=0|Ee(u,p,28),l=vi,a=0|Ee(u,p,34),l^=vi,_=0|Ee(u,p,39),l=0|Ig(0|R,0|n,a^S^_|0,l^vi|0),l=0|Ig(0|l,0|vi,(D|v)&u|D&v|0,(m|b)&p|m&b|0),_=vi,fi[g+48>>2]=l,fi[g+48+4>>2]=_,S=0|Ee(M,k,14),a=vi,n=0|Ee(M,k,18),a^=vi,R=0|Ee(M,k,41),r=2|y,w=0|fi[304+(r<<3)>>2],c=0|fi[304+(r<<3)+4>>2],a=0|Ig(0|fi[e+(r<<3)>>2],0|fi[e+(r<<3)+4>>2],n^S^R|0,a^vi|0),c=0|Ig(0|a,0|vi,0|w,0|c),s=0|Ig(0|c,0|vi,(d^Q)&M^d|0,(s^o)&k^s|0),C=0|Ig(0|s,0|vi,0|h,0|C),h=vi,m=0|Ig(0|C,0|h,0|D,0|m),D=vi,fi[g+8>>2]=m,fi[g+8+4>>2]=D,s=0|Ee(l,_,28),d=vi,c=0|Ee(l,_,34),d^=vi,w=0|Ee(l,_,39),d=0|Ig(0|C,0|h,c^s^w|0,d^vi|0),d=0|Ig(0|d,0|vi,(v|u)&l|v&u|0,(b|p)&_|b&p|0),w=vi,fi[g+40>>2]=d,fi[g+40+4>>2]=w,s=0|Ee(m,D,14),c=vi,h=0|Ee(m,D,18),c^=vi,C=0|Ee(m,D,41),a=3|y,R=0|fi[304+(a<<3)>>2],S=0|fi[304+(a<<3)+4>>2],n=0|fi[g+32>>2],E=0|fi[g+32+4>>2],c=0|Ig(0|fi[e+(a<<3)>>2],0|fi[e+(a<<3)+4>>2],h^s^C|0,c^vi|0),S=0|Ig(0|c,0|vi,0|R,0|S),o=0|Ig(0|S,0|vi,(Q^M)&m^Q|0,(o^k)&D^o|0),E=0|Ig(0|o,0|vi,0|n,0|E),n=vi,b=0|Ig(0|E,0|n,0|v,0|b),v=vi,fi[g>>2]=b,fi[g+4>>2]=v,o=0|Ee(d,w,28),Q=vi,S=0|Ee(d,w,34),Q^=vi,R=0|Ee(d,w,39),Q=0|Ig(0|E,0|n,S^o^R|0,Q^vi|0),p=0|Ig(0|Q,0|vi,(u|l)&d|u&l|0,(p|_)&w|p&_|0),u=vi,fi[g+32>>2]=p,fi[g+32+4>>2]=u,Q=0|Ee(b,v,14),R=vi,o=0|Ee(b,v,18),R^=vi,S=0|Ee(b,v,41),n=4|y,E=0|fi[304+(n<<3)>>2],c=0|fi[304+(n<<3)+4>>2],C=0|fi[g+24>>2],s=0|fi[g+24+4>>2],R=0|Ig(0|fi[e+(n<<3)>>2],0|fi[e+(n<<3)+4>>2],o^Q^S|0,R^vi|0),c=0|Ig(0|R,0|vi,0|E,0|c),k=0|Ig(0|c,0|vi,(M^m)&b^M|0,(k^D)&v^k|0),s=0|Ig(0|k,0|vi,0|C,0|s),C=vi,k=0|Ig(0|s,0|C,0|fi[g+56>>2],0|fi[g+56+4>>2]),M=vi,fi[g+56>>2]=k,fi[g+56+4>>2]=M,c=0|Ee(p,u,28),E=vi,R=0|Ee(p,u,34),E^=vi,S=0|Ee(p,u,39),E=0|Ig(0|s,0|C,R^c^S|0,E^vi|0),_=0|Ig(0|E,0|vi,(l|d)&p|l&d|0,(_|w)&u|_&w|0),l=vi,fi[g+24>>2]=_,fi[g+24+4>>2]=l,E=0|Ee(k,M,14),S=vi,c=0|Ee(k,M,18),S^=vi,R=0|Ee(k,M,41),C=5|y,s=0|fi[304+(C<<3)>>2],Q=0|fi[304+(C<<3)+4>>2],o=0|fi[g+16>>2],h=0|fi[g+16+4>>2],S=0|Ig(0|fi[e+(C<<3)>>2],0|fi[e+(C<<3)+4>>2],c^E^R|0,S^vi|0),Q=0|Ig(0|S,0|vi,0|s,0|Q),D=0|Ig(0|Q,0|vi,(m^b)&k^m|0,(D^v)&M^D|0),h=0|Ig(0|D,0|vi,0|o,0|h),o=vi,D=0|Ig(0|h,0|o,0|fi[g+48>>2],0|fi[g+48+4>>2]),m=vi,fi[g+48>>2]=D,fi[g+48+4>>2]=m,Q=0|Ee(_,l,28),s=vi,S=0|Ee(_,l,34),s^=vi,R=0|Ee(_,l,39),s=0|Ig(0|h,0|o,S^Q^R|0,s^vi|0),w=0|Ig(0|s,0|vi,(d|p)&_|d&p|0,(w|u)&l|w&u|0),d=vi,fi[g+16>>2]=w,fi[g+16+4>>2]=d,s=0|Ee(D,m,14),R=vi,Q=0|Ee(D,m,18),R^=vi,S=0|Ee(D,m,41),o=6|y,h=0|fi[304+(o<<3)>>2],E=0|fi[304+(o<<3)+4>>2],c=0|fi[g+8>>2],I=0|fi[g+8+4>>2],R=0|Ig(0|fi[e+(o<<3)>>2],0|fi[e+(o<<3)+4>>2],Q^s^S|0,R^vi|0),E=0|Ig(0|R,0|vi,0|h,0|E),v=0|Ig(0|E,0|vi,(b^k)&D^b|0,(v^M)&m^v|0),I=0|Ig(0|v,0|vi,0|c,0|I),c=vi,v=0|Ig(0|I,0|c,0|fi[g+40>>2],0|fi[g+40+4>>2]),b=vi,fi[g+40>>2]=v,fi[g+40+4>>2]=b,E=0|Ee(w,d,28),h=vi,R=0|Ee(w,d,34),h^=vi,S=0|Ee(w,d,39),h=0|Ig(0|I,0|c,R^E^S|0,h^vi|0),u=0|Ig(0|h,0|vi,(p|_)&w|p&_|0,(u|l)&d|u&l|0),p=vi,fi[g+8>>2]=u,fi[g+8+4>>2]=p,h=0|Ee(v,b,14),S=vi,E=0|Ee(v,b,18),S^=vi,R=0|Ee(v,b,41),c=7|y,I=0|fi[304+(c<<3)>>2],s=0|fi[304+(c<<3)+4>>2],Q=0|fi[g>>2],i=0|fi[g+4>>2],S=0|Ig(0|fi[e+(c<<3)>>2],0|fi[e+(c<<3)+4>>2],E^h^R|0,S^vi|0),s=0|Ig(0|S,0|vi,0|I,0|s),M=0|Ig(0|s,0|vi,(k^D)&v^k|0,(M^m)&b^M|0),i=0|Ig(0|M,0|vi,0|Q,0|i),Q=vi,M=0|Ig(0|i,0|Q,0|fi[g+32>>2],0|fi[g+32+4>>2]),k=vi,fi[g+32>>2]=M,fi[g+32+4>>2]=k,s=0|Ee(u,p,28),I=vi,S=0|Ee(u,p,34),I^=vi,R=0|Ee(u,p,39),I=0|Ig(0|i,0|Q,S^s^R|0,I^vi|0),l=0|Ig(0|I,0|vi,(_|w)&u|_&w|0,(l|d)&p|l&d|0),_=vi,fi[g>>2]=l,fi[g+4>>2]=_,I=0|Ee(M,k,14),R=vi,s=0|Ee(M,k,18),R^=vi,S=0|Ee(M,k,41),Q=8|y,i=0|fi[304+(Q<<3)>>2],h=0|fi[304+(Q<<3)+4>>2],E=0|fi[g+56>>2],B=0|fi[g+56+4>>2],R=0|Ig(0|fi[e+(Q<<3)>>2],0|fi[e+(Q<<3)+4>>2],s^I^S|0,R^vi|0),h=0|Ig(0|R,0|vi,0|i,0|h),m=0|Ig(0|h,0|vi,(D^v)&M^D|0,(m^b)&k^m|0),B=0|Ig(0|m,0|vi,0|E,0|B),E=vi,m=0|Ig(0|B,0|E,0|fi[g+24>>2],0|fi[g+24+4>>2]),D=vi,fi[g+24>>2]=m,fi[g+24+4>>2]=D,h=0|Ee(l,_,28),i=vi,R=0|Ee(l,_,34),i^=vi,S=0|Ee(l,_,39),i=0|Ig(0|B,0|E,R^h^S|0,i^vi|0),d=0|Ig(0|i,0|vi,(w|u)&l|w&u|0,(d|p)&_|d&p|0),w=vi,fi[g+56>>2]=d,fi[g+56+4>>2]=w,i=0|Ee(m,D,14),S=vi,h=0|Ee(m,D,18),S^=vi,R=0|Ee(m,D,41),E=9|y,B=0|fi[304+(E<<3)>>2],I=0|fi[304+(E<<3)+4>>2],s=0|fi[g+48>>2],f=0|fi[g+48+4>>2],S=0|Ig(0|fi[e+(E<<3)>>2],0|fi[e+(E<<3)+4>>2],h^i^R|0,S^vi|0),I=0|Ig(0|S,0|vi,0|B,0|I),b=0|Ig(0|I,0|vi,(v^M)&m^v|0,(b^k)&D^b|0),f=0|Ig(0|b,0|vi,0|s,0|f),s=vi,b=0|Ig(0|f,0|s,0|fi[g+16>>2],0|fi[g+16+4>>2]),v=vi,fi[g+16>>2]=b,fi[g+16+4>>2]=v,I=0|Ee(d,w,28),B=vi,S=0|Ee(d,w,34),B^=vi,R=0|Ee(d,w,39),B=0|Ig(0|f,0|s,S^I^R|0,B^vi|0),p=0|Ig(0|B,0|vi,(u|l)&d|u&l|0,(p|_)&w|p&_|0),u=vi,fi[g+48>>2]=p,fi[g+48+4>>2]=u,B=0|Ee(b,v,14),R=vi,I=0|Ee(b,v,18),R^=vi,S=0|Ee(b,v,41),s=10|y,f=0|fi[304+(s<<3)>>2],i=0|fi[304+(s<<3)+4>>2],h=0|fi[g+40>>2],G=0|fi[g+40+4>>2],R=0|Ig(0|fi[e+(s<<3)>>2],0|fi[e+(s<<3)+4>>2],I^B^S|0,R^vi|0),i=0|Ig(0|R,0|vi,0|f,0|i),k=0|Ig(0|i,0|vi,(M^m)&b^M|0,(k^D)&v^k|0),G=0|Ig(0|k,0|vi,0|h,0|G),h=vi,k=0|Ig(0|G,0|h,0|fi[g+8>>2],0|fi[g+8+4>>2]),M=vi,fi[g+8>>2]=k,fi[g+8+4>>2]=M,i=0|Ee(p,u,28),f=vi,R=0|Ee(p,u,34),f^=vi,S=0|Ee(p,u,39),f=0|Ig(0|G,0|h,R^i^S|0,f^vi|0),_=0|Ig(0|f,0|vi,(l|d)&p|l&d|0,(_|w)&u|_&w|0),l=vi,fi[g+40>>2]=_,fi[g+40+4>>2]=l,f=0|Ee(k,M,14),S=vi,i=0|Ee(k,M,18),S^=vi,R=0|Ee(k,M,41),h=11|y,G=0|fi[304+(h<<3)>>2],B=0|fi[304+(h<<3)+4>>2],I=0|fi[g+32>>2],U=0|fi[g+32+4>>2],S=0|Ig(0|fi[e+(h<<3)>>2],0|fi[e+(h<<3)+4>>2],i^f^R|0,S^vi|0),B=0|Ig(0|S,0|vi,0|G,0|B),D=0|Ig(0|B,0|vi,(m^b)&k^m|0,(D^v)&M^D|0),U=0|Ig(0|D,0|vi,0|I,0|U),I=vi,D=0|Ig(0|U,0|I,0|fi[g>>2],0|fi[g+4>>2]),m=vi,fi[g>>2]=D,fi[g+4>>2]=m,B=0|Ee(_,l,28),G=vi,S=0|Ee(_,l,34),G^=vi,R=0|Ee(_,l,39),G=0|Ig(0|U,0|I,S^B^R|0,G^vi|0),w=0|Ig(0|G,0|vi,(d|p)&_|d&p|0,(w|u)&l|w&u|0),d=vi,fi[g+32>>2]=w,fi[g+32+4>>2]=d,G=0|Ee(D,m,14),R=vi,B=0|Ee(D,m,18),R^=vi,S=0|Ee(D,m,41),I=12|y,U=0|fi[304+(I<<3)>>2],f=0|fi[304+(I<<3)+4>>2],i=0|fi[g+24>>2],H=0|fi[g+24+4>>2],R=0|Ig(0|fi[e+(I<<3)>>2],0|fi[e+(I<<3)+4>>2],B^G^S|0,R^vi|0),f=0|Ig(0|R,0|vi,0|U,0|f),v=0|Ig(0|f,0|vi,(b^k)&D^b|0,(v^M)&m^v|0),H=0|Ig(0|v,0|vi,0|i,0|H),i=vi,v=0|Ig(0|H,0|i,0|fi[g+56>>2],0|fi[g+56+4>>2]),b=vi,fi[g+56>>2]=v,fi[g+56+4>>2]=b,f=0|Ee(w,d,28),U=vi,R=0|Ee(w,d,34),U^=vi,S=0|Ee(w,d,39),U=0|Ig(0|H,0|i,R^f^S|0,U^vi|0),u=0|Ig(0|U,0|vi,(p|_)&w|p&_|0,(u|l)&d|u&l|0),p=vi,fi[g+24>>2]=u,fi[g+24+4>>2]=p,U=0|Ee(v,b,14),S=vi,f=0|Ee(v,b,18),S^=vi,R=0|Ee(v,b,41),i=13|y,H=0|fi[304+(i<<3)>>2],G=0|fi[304+(i<<3)+4>>2],B=0|fi[g+16>>2],N=0|fi[g+16+4>>2],S=0|Ig(0|fi[e+(i<<3)>>2],0|fi[e+(i<<3)+4>>2],f^U^R|0,S^vi|0),G=0|Ig(0|S,0|vi,0|H,0|G),M=0|Ig(0|G,0|vi,(k^D)&v^k|0,(M^m)&b^M|0),N=0|Ig(0|M,0|vi,0|B,0|N),B=vi,M=0|Ig(0|N,0|B,0|fi[g+48>>2],0|fi[g+48+4>>2]),k=vi,fi[g+48>>2]=M,fi[g+48+4>>2]=k,G=0|Ee(u,p,28),H=vi,S=0|Ee(u,p,34),H^=vi,R=0|Ee(u,p,39),H=0|Ig(0|N,0|B,S^G^R|0,H^vi|0),l=0|Ig(0|H,0|vi,(_|w)&u|_&w|0,(l|d)&p|l&d|0),_=vi,fi[g+16>>2]=l,fi[g+16+4>>2]=_,H=0|Ee(M,k,14),R=vi,G=0|Ee(M,k,18),R^=vi,S=0|Ee(M,k,41),B=14|y,N=0|fi[304+(B<<3)>>2],U=0|fi[304+(B<<3)+4>>2],f=0|fi[g+8>>2],Y=0|fi[g+8+4>>2],R=0|Ig(0|fi[e+(B<<3)>>2],0|fi[e+(B<<3)+4>>2],G^H^S|0,R^vi|0),U=0|Ig(0|R,0|vi,0|N,0|U),m=0|Ig(0|U,0|vi,(D^v)&M^D|0,(m^b)&k^m|0),Y=0|Ig(0|m,0|vi,0|f,0|Y),f=vi,m=0|Ig(0|Y,0|f,0|fi[g+40>>2],0|fi[g+40+4>>2]),D=vi,fi[g+40>>2]=m,fi[g+40+4>>2]=D,U=0|Ee(l,_,28),N=vi,R=0|Ee(l,_,34),N^=vi,S=0|Ee(l,_,39),N=0|Ig(0|Y,0|f,R^U^S|0,N^vi|0),d=0|Ig(0|N,0|vi,(w|u)&l|w&u|0,(d|p)&_|d&p|0),w=vi,fi[g+8>>2]=d,fi[g+8+4>>2]=w,N=0|Ee(m,D,14),S=vi,U=0|Ee(m,D,18),S^=vi,R=0|Ee(m,D,41),f=15|y,Y=0|fi[304+(f<<3)>>2],H=0|fi[304+(f<<3)+4>>2],G=0|fi[g>>2],F=0|fi[g+4>>2],S=0|Ig(0|fi[e+(f<<3)>>2],0|fi[e+(f<<3)+4>>2],U^N^R|0,S^vi|0),H=0|Ig(0|S,0|vi,0|Y,0|H),b=0|Ig(0|H,0|vi,(v^M)&m^v|0,(b^k)&D^b|0),F=0|Ig(0|b,0|vi,0|G,0|F),G=vi,b=0|Ig(0|F,0|G,0|fi[g+32>>2],0|fi[g+32+4>>2]),fi[g+32>>2]=b,fi[g+32+4>>2]=vi,b=0|Ee(d,w,28),D=vi,k=0|Ee(d,w,34),D^=vi,v=0|Ee(d,w,39),D=0|Ig(0|F,0|G,k^b^v|0,D^vi|0),_=0|Ig(0|D,0|vi,(u|l)&d|u&l|0,(p|_)&w|p&_|0),fi[g>>2]=_,fi[g+4>>2]=vi,64==(0|y)){I=0;break}if(Y=0|fi[e+(B<<3)>>2],M=0|fi[e+(B<<3)+4>>2],N=0|Ee(Y,M,19),v=vi,m=0|Ee(Y,M,61),H=vi,M=0|Ue(0|Y,0|M,6),H=0|Ig(M^N^m|0,vi^v^H|0,0|fi[e+(E<<3)>>2],0|fi[e+(E<<3)+4>>2]),v=vi,m=0|fi[e+(t<<3)>>2],N=0|fi[e+(t<<3)+4>>2],M=0|Ee(m,N,1),Y=vi,F=0|Ee(m,N,8),S=vi,k=0|Ue(0|m,0|N,7),S^=vi^Y,Y=e+(y<<3)|0,Y=0|Ig(0|H,0|v,0|fi[Y>>2],0|fi[Y+4>>2]),S=0|Ig(0|Y,0|vi,k^M^F|0,0|S),F=vi,y=y+16|0,M=e+(y<<3)|0,fi[M>>2]=S,fi[M+4>>2]=F,M=0|fi[e+(f<<3)>>2],k=0|fi[e+(f<<3)+4>>2],Y=0|Ee(M,k,19),v=vi,H=0|Ee(M,k,61),G=vi,k=0|Ue(0|M,0|k,6),G=0|Ig(k^Y^H|0,vi^v^G|0,0|fi[e+(t+9<<3)>>2],0|fi[e+(t+9<<3)+4>>2]),v=vi,H=0|fi[e+(t+1<<3)>>2],Y=0|fi[e+(t+1<<3)+4>>2],k=0|Ee(H,Y,1),M=vi,U=0|Ee(H,Y,8),R=vi,b=0|Ue(0|H,0|Y,7),R^=vi^M,N=0|Ig(0|G,0|v,0|m,0|N),R=0|Ig(0|N,0|vi,b^k^U|0,0|R),U=vi,fi[e+(t+16<<3)>>2]=R,fi[e+(t+16<<3)+4>>2]=U,k=0|Ee(S,F,19),b=vi,N=0|Ee(S,F,61),m=vi,F=0|Ue(0|S,0|F,6),m=0|Ig(F^k^N|0,vi^b^m|0,0|fi[e+(h<<3)>>2],0|fi[e+(h<<3)+4>>2]),b=vi,N=0|fi[e+(a<<3)>>2],k=0|fi[e+(a<<3)+4>>2],F=0|Ee(N,k,1),S=vi,v=0|Ee(N,k,8),G=vi,M=0|Ue(0|N,0|k,7),G^=vi^S,Y=0|Ig(0|m,0|b,0|H,0|Y),G=0|Ig(0|Y,0|vi,M^F^v|0,0|G),v=vi,fi[e+(r+16<<3)>>2]=G,fi[e+(r+16<<3)+4>>2]=v,F=0|Ee(R,U,19),M=vi,Y=0|Ee(R,U,61),H=vi,U=0|Ue(0|R,0|U,6),H=0|Ig(U^F^Y|0,vi^M^H|0,0|fi[e+(a+9<<3)>>2],0|fi[e+(a+9<<3)+4>>2]),M=vi,Y=0|fi[e+(a+1<<3)>>2],F=0|fi[e+(a+1<<3)+4>>2],U=0|Ee(Y,F,1),R=vi,b=0|Ee(Y,F,8),m=vi,S=0|Ue(0|Y,0|F,7),m^=vi^R,k=0|Ig(0|H,0|M,0|N,0|k),m=0|Ig(0|k,0|vi,S^U^b|0,0|m),b=vi,fi[e+(a+16<<3)>>2]=m,fi[e+(a+16<<3)+4>>2]=b,U=0|Ee(G,v,19),S=vi,k=0|Ee(G,v,61),N=vi,v=0|Ue(0|G,0|v,6),N=0|Ig(v^U^k|0,vi^S^N|0,0|fi[e+(i<<3)>>2],0|fi[e+(i<<3)+4>>2]),S=vi,k=0|fi[e+(C<<3)>>2],U=0|fi[e+(C<<3)+4>>2],v=0|Ee(k,U,1),G=vi,M=0|Ee(k,U,8),H=vi,R=0|Ue(0|k,0|U,7),H^=vi^G,F=0|Ig(0|N,0|S,0|Y,0|F),H=0|Ig(0|F,0|vi,R^v^M|0,0|H),M=vi,fi[e+(n+16<<3)>>2]=H,fi[e+(n+16<<3)+4>>2]=M,v=0|Ee(m,b,19),R=vi,F=0|Ee(m,b,61),Y=vi,b=0|Ue(0|m,0|b,6),Y=0|Ig(b^v^F|0,vi^R^Y|0,0|fi[e+(C+9<<3)>>2],0|fi[e+(C+9<<3)+4>>2]),R=vi,F=0|fi[e+(C+1<<3)>>2],v=0|fi[e+(C+1<<3)+4>>2],b=0|Ee(F,v,1),m=vi,S=0|Ee(F,v,8),N=vi,G=0|Ue(0|F,0|v,7),N^=vi^m,U=0|Ig(0|Y,0|R,0|k,0|U),N=0|Ig(0|U,0|vi,G^b^S|0,0|N),S=vi,fi[e+(C+16<<3)>>2]=N,fi[e+(C+16<<3)+4>>2]=S,b=0|Ee(H,M,19),G=vi,U=0|Ee(H,M,61),k=vi,M=0|Ue(0|H,0|M,6),k=0|Ig(M^b^U|0,vi^G^k|0,0|fi[e+(f<<3)>>2],0|fi[e+(f<<3)+4>>2]),G=vi,U=0|fi[e+(c<<3)>>2],b=0|fi[e+(c<<3)+4>>2],M=0|Ee(U,b,1),H=vi,R=0|Ee(U,b,8),Y=vi,m=0|Ue(0|U,0|b,7),Y^=vi^H,v=0|Ig(0|k,0|G,0|F,0|v),Y=0|Ig(0|v,0|vi,m^M^R|0,0|Y),R=vi,fi[e+(o+16<<3)>>2]=Y,fi[e+(o+16<<3)+4>>2]=R,M=0|Ee(N,S,19),m=vi,v=0|Ee(N,S,61),F=vi,S=0|Ue(0|N,0|S,6),F=0|Ig(S^M^v|0,vi^m^F|0,0|fi[e+(c+9<<3)>>2],0|fi[e+(c+9<<3)+4>>2]),m=vi,v=0|fi[e+(c+1<<3)>>2],M=0|fi[e+(c+1<<3)+4>>2],S=0|Ee(v,M,1),N=vi,G=0|Ee(v,M,8),k=vi,H=0|Ue(0|v,0|M,7),k^=vi^N,b=0|Ig(0|F,0|m,0|U,0|b),k=0|Ig(0|b,0|vi,H^S^G|0,0|k),G=vi,fi[e+(c+16<<3)>>2]=k,fi[e+(c+16<<3)+4>>2]=G,S=0|Ee(Y,R,19),H=vi,b=0|Ee(Y,R,61),U=vi,R=0|Ue(0|Y,0|R,6),U=0|Ig(R^S^b|0,vi^H^U|0,0|fi[e+(Q+9<<3)>>2],0|fi[e+(Q+9<<3)+4>>2]),H=vi,b=0|fi[e+(E<<3)>>2],S=0|fi[e+(E<<3)+4>>2],R=0|Ee(b,S,1),Y=vi,m=0|Ee(b,S,8),F=vi,N=0|Ue(0|b,0|S,7),F^=vi^Y,M=0|Ig(0|U,0|H,0|v,0|M),F=0|Ig(0|M,0|vi,N^R^m|0,0|F),m=vi,fi[e+(Q+16<<3)>>2]=F,fi[e+(Q+16<<3)+4>>2]=m,R=0|Ee(k,G,19),N=vi,M=0|Ee(k,G,61),v=vi,G=0|Ue(0|k,0|G,6),v=0|Ig(G^R^M|0,vi^N^v|0,0|fi[e+(E+9<<3)>>2],0|fi[e+(E+9<<3)+4>>2]),N=vi,M=0|fi[e+(E+1<<3)>>2],R=0|fi[e+(E+1<<3)+4>>2],G=0|Ee(M,R,1),k=vi,H=0|Ee(M,R,8),U=vi,Y=0|Ue(0|M,0|R,7),U^=vi^k,S=0|Ig(0|v,0|N,0|b,0|S),U=0|Ig(0|S,0|vi,Y^G^H|0,0|U),H=vi,fi[e+(E+16<<3)>>2]=U,fi[e+(E+16<<3)+4>>2]=H,G=0|Ee(F,m,19),Y=vi,S=0|Ee(F,m,61),b=vi,m=0|Ue(0|F,0|m,6),b=0|Ig(m^G^S|0,vi^Y^b|0,0|fi[e+(s+9<<3)>>2],0|fi[e+(s+9<<3)+4>>2]),Y=vi,S=0|fi[e+(h<<3)>>2],G=0|fi[e+(h<<3)+4>>2],m=0|Ee(S,G,1),F=vi,N=0|Ee(S,G,8),v=vi,k=0|Ue(0|S,0|G,7),v^=vi^F,R=0|Ig(0|b,0|Y,0|M,0|R),v=0|Ig(0|R,0|vi,k^m^N|0,0|v),N=vi,fi[e+(s+16<<3)>>2]=v,fi[e+(s+16<<3)+4>>2]=N,m=0|Ee(U,H,19),k=vi,R=0|Ee(U,H,61),M=vi,H=0|Ue(0|U,0|H,6),M=0|Ig(H^m^R|0,vi^k^M|0,0|fi[e+(h+9<<3)>>2],0|fi[e+(h+9<<3)+4>>2]),k=vi,R=0|fi[e+(h+1<<3)>>2],m=0|fi[e+(h+1<<3)+4>>2],H=0|Ee(R,m,1),U=vi,Y=0|Ee(R,m,8),b=vi,F=0|Ue(0|R,0|m,7),b^=vi^U,G=0|Ig(0|M,0|k,0|S,0|G),b=0|Ig(0|G,0|vi,F^H^Y|0,0|b),Y=vi,fi[e+(h+16<<3)>>2]=b,fi[e+(h+16<<3)+4>>2]=Y,H=0|Ee(v,N,19),F=vi,G=0|Ee(v,N,61),S=vi,N=0|Ue(0|v,0|N,6),S=0|Ig(N^H^G|0,vi^F^S|0,0|fi[e+(I+9<<3)>>2],0|fi[e+(I+9<<3)+4>>2]),F=vi,G=0|fi[e+(i<<3)>>2],H=0|fi[e+(i<<3)+4>>2],N=0|Ee(G,H,1),v=vi,k=0|Ee(G,H,8),M=vi,U=0|Ue(0|G,0|H,7),M^=vi^v,m=0|Ig(0|S,0|F,0|R,0|m),M=0|Ig(0|m,0|vi,U^N^k|0,0|M),k=vi,fi[e+(I+16<<3)>>2]=M,fi[e+(I+16<<3)+4>>2]=k,N=0|Ee(b,Y,19),I=vi,U=0|Ee(b,Y,61),m=vi,Y=0|Ue(0|b,0|Y,6),m=0|Ig(Y^N^U|0,vi^I^m|0,0|fi[e+(i+9<<3)>>2],0|fi[e+(i+9<<3)+4>>2]),I=vi,U=0|fi[e+(i+1<<3)>>2],N=0|fi[e+(i+1<<3)+4>>2],Y=0|Ee(U,N,1),b=vi,R=0|Ee(U,N,8),F=vi,S=0|Ue(0|U,0|N,7),F^=vi^b,H=0|Ig(0|m,0|I,0|G,0|H),F=0|Ig(0|H,0|vi,S^Y^R|0,0|F),R=vi,fi[e+(i+16<<3)>>2]=F,fi[e+(i+16<<3)+4>>2]=R,Y=0|Ee(M,k,19),S=vi,H=0|Ee(M,k,61),G=vi,I=0|Ue(0|M,0|k,6),G=0|Ig(I^Y^H|0,vi^S^G|0,0|fi[e+(B+9<<3)>>2],0|fi[e+(B+9<<3)+4>>2]),S=vi,H=0|fi[e+(f<<3)>>2],Y=0|fi[e+(f<<3)+4>>2],I=0|Ee(H,Y,1),k=vi,M=0|Ee(H,Y,8),i=vi,m=0|Ue(0|H,0|Y,7),i^=vi^k,N=0|Ig(0|G,0|S,0|U,0|N),i=0|Ig(0|N,0|vi,m^I^M|0,0|i),fi[e+(B+16<<3)>>2]=i,fi[e+(B+16<<3)+4>>2]=vi,i=0|Ee(F,R,19),M=vi,I=0|Ee(F,R,61),m=vi,R=0|Ue(0|F,0|R,6),m=0|Ig(R^i^I|0,vi^M^m|0,0|fi[e+(f+9<<3)>>2],0|fi[e+(f+9<<3)+4>>2]),M=vi,I=0|fi[e+(f+1<<3)>>2],i=0|fi[e+(f+1<<3)+4>>2],R=0|Ee(I,i,1),F=vi,N=0|Ee(I,i,8),U=vi,S=0|Ue(0|I,0|i,7),U^=vi^F,Y=0|Ig(0|m,0|M,0|H,0|Y),U=0|Ig(0|Y,0|vi,S^R^N|0,0|U),fi[e+(f+16<<3)>>2]=U,fi[e+(f+16<<3)+4>>2]=vi,(0|y)>=80){I=0;break}}do{N=g+(I<<3)|0,N=0|Ig(0|fi[(U=A+(I<<3)|0)>>2],0|fi[U+4>>2],0|fi[N>>2],0|fi[N+4>>2]),fi[U>>2]=N,fi[U+4>>2]=vi,I=I+1|0}while(8!=(0|I))}function t(A){A|=0;var I=0,e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0;w=wi,Q=wi=wi+63&-64,wi=wi+16|0;do{if(A>>>0<245){if(c=A>>>0<11?16:A+11&-8,(C=0|fi[8682])>>>(c>>>3)&3|0)return A=34768+((C>>>(c>>>3)&1^1)+(c>>>3)<<1<<2)|0,I=0|fi[A+8>>2],e=0|fi[I+8>>2],(0|A)==(0|e)?fi[8682]=C&~(1<<(C>>>(c>>>3)&1^1)+(c>>>3)):(fi[e+12>>2]=A,fi[A+8>>2]=e),p=(C>>>(c>>>3)&1^1)+(c>>>3)<<3,fi[I+4>>2]=3|p,fi[I+p+4>>2]=1|fi[I+p+4>>2],p=I+8|0,wi=w,0|p;if(o=0|fi[8684],c>>>0>o>>>0){if(C>>>(c>>>3)|0)return A=C>>>(c>>>3)<<(c>>>3)&(2<<(c>>>3)|0-(2<<(c>>>3))),i=((A&0-A)-1|0)>>>(((A&0-A)-1|0)>>>12&16),g=i>>>(i>>>5&8)>>>(i>>>(i>>>5&8)>>>2&4),g=(i>>>5&8|((A&0-A)-1|0)>>>12&16|i>>>(i>>>5&8)>>>2&4|g>>>1&2|g>>>(g>>>1&2)>>>1&1)+(g>>>(g>>>1&2)>>>(g>>>(g>>>1&2)>>>1&1))|0,i=0|fi[34768+(g<<1<<2)+8>>2],A=0|fi[i+8>>2],(34768+(g<<1<<2)|0)==(0|A)?(fi[8682]=C&~(1<<g),A=C&~(1<<g)):(fi[A+12>>2]=34768+(g<<1<<2),fi[34768+(g<<1<<2)+8>>2]=A,A=C),fi[i+4>>2]=3|c,fi[i+c+4>>2]=(g<<3)-c|1,fi[i+c+((g<<3)-c)>>2]=(g<<3)-c,0|o&&(e=0|fi[8687],A&1<<(o>>>3)?(A=0|fi[34768+(o>>>3<<1<<2)+8>>2],I=34768+(o>>>3<<1<<2)+8|0):(fi[8682]=A|1<<(o>>>3),A=34768+(o>>>3<<1<<2)|0,I=34768+(o>>>3<<1<<2)+8|0),fi[I>>2]=e,fi[A+12>>2]=e,fi[e+8>>2]=A,fi[e+12>>2]=34768+(o>>>3<<1<<2)),fi[8684]=(g<<3)-c,fi[8687]=i+c,p=i+8|0,wi=w,0|p;if(n=0|fi[8683]){if(I=((n&0-n)-1|0)>>>(((n&0-n)-1|0)>>>12&16),A=I>>>(I>>>5&8)>>>(I>>>(I>>>5&8)>>>2&4),A=0|fi[35032+((I>>>5&8|((n&0-n)-1|0)>>>12&16|I>>>(I>>>5&8)>>>2&4|A>>>1&2|A>>>(A>>>1&2)>>>1&1)+(A>>>(A>>>1&2)>>>(A>>>(A>>>1&2)>>>1&1))<<2)>>2],I=(-8&fi[A+4>>2])-c|0,e=0|fi[A+16+((0==(0|fi[A+16>>2])&1)<<2)>>2]){do{I=(a=(r=(-8&fi[e+4>>2])-c|0)>>>0<I>>>0)?r:I,A=a?e:A,e=0|fi[e+16+((0==(0|fi[e+16>>2])&1)<<2)>>2]}while(0!=(0|e));a=A,t=I}else a=A,t=I;if(r=a+c|0,a>>>0<r>>>0){i=0|fi[a+24>>2],A=0|fi[a+12>>2];do{if((0|A)==(0|a)){if(I=a+20|0,!((A=0|fi[I>>2])||(I=a+16|0,A=0|fi[I>>2]))){I=0;break}for(;;)if(e=A+20|0,0|(g=0|fi[e>>2]))A=g,I=e;else{if(e=A+16|0,!(g=0|fi[e>>2]))break;A=g,I=e}fi[I>>2]=0,I=A}else I=0|fi[a+8>>2],fi[I+12>>2]=A,fi[A+8>>2]=I,I=A}while(0);do{if(0|i){if(A=0|fi[a+28>>2],(0|a)==(0|fi[35032+(A<<2)>>2])){if(fi[35032+(A<<2)>>2]=I,!I){fi[8683]=n&~(1<<A);break}}else if(fi[i+16+(((0|fi[i+16>>2])!=(0|a)&1)<<2)>>2]=I,!I)break;fi[I+24>>2]=i,0|(A=0|fi[a+16>>2])&&(fi[I+16>>2]=A,fi[A+24>>2]=I),0|(A=0|fi[a+20>>2])&&(fi[I+20>>2]=A,fi[A+24>>2]=I)}}while(0);return t>>>0<16?(p=t+c|0,fi[a+4>>2]=3|p,fi[(p=a+p+4|0)>>2]=1|fi[p>>2]):(fi[a+4>>2]=3|c,fi[r+4>>2]=1|t,fi[r+t>>2]=t,0|o&&(e=0|fi[8687],C&1<<(o>>>3)?(A=0|fi[34768+(o>>>3<<1<<2)+8>>2],I=34768+(o>>>3<<1<<2)+8|0):(fi[8682]=C|1<<(o>>>3),A=34768+(o>>>3<<1<<2)|0,I=34768+(o>>>3<<1<<2)+8|0),fi[I>>2]=e,fi[A+12>>2]=e,fi[e+8>>2]=A,fi[e+12>>2]=34768+(o>>>3<<1<<2)),fi[8684]=t,fi[8687]=r),p=a+8|0,wi=w,0|p}}}}else if(A>>>0<=4294967231){if(c=A+11&-8,a=0|fi[8683]){r=(A+11|0)>>>8?c>>>0>16777215?31:c>>>(7+(r=14-((520192+(r=(A+11|0)>>>8<<((1048320+((A+11|0)>>>8)|0)>>>16&8))|0)>>>16&4|(1048320+((A+11|0)>>>8)|0)>>>16&8|(245760+(r<<((r+520192|0)>>>16&4))|0)>>>16&2)+(r<<((r+520192|0)>>>16&4)<<((245760+(r<<((r+520192|0)>>>16&4))|0)>>>16&2)>>>15)|0)|0)&1|r<<1:0,I=0|fi[35032+(r<<2)>>2];A:do{if(I)for(A=0,e=0-c|0,t=c<<(31==(0|r)?0:25-(r>>>1)|0),i=0;;){if((g=(-8&fi[I+4>>2])-c|0)>>>0<e>>>0){if(!g){A=I,e=0,g=I,_=61;break A}A=I,e=g}if(g=0|fi[I+20>>2],I=0|fi[I+16+(t>>>31<<2)>>2],i=0==(0|g)|(0|g)==(0|I)?i:g,g=0==(0|I)){I=i,_=57;break}t<<=1&(1^g)}else I=0,A=0,e=0-c|0,_=57}while(0);if(57==(0|_)){if(0==(0|I)&0==(0|A)){if(A=2<<r,!(a&(A|0-A)))break;C=(a&(A|0-A)&0-(a&(A|0-A)))-1|0,A=0,I=0|fi[35032+((C>>>(C>>>12&16)>>>5&8|C>>>12&16|(o=C>>>(C>>>12&16)>>>(C>>>(C>>>12&16)>>>5&8))>>>2&4|o>>>(o>>>2&4)>>>1&2|(I=o>>>(o>>>2&4)>>>(o>>>(o>>>2&4)>>>1&2))>>>1&1)+(I>>>(I>>>1&1))<<2)>>2]}I?(g=I,_=61):(r=A,t=e)}if(61==(0|_))for(;;){if(_=0,I=(-8&fi[g+4>>2])-c|0,o=I>>>0<e>>>0,I=o?I:e,A=o?g:A,!(g=0|fi[g+16+((0==(0|fi[g+16>>2])&1)<<2)>>2])){r=A,t=I;break}e=I,_=61}if(0!=(0|r)?t>>>0<((0|fi[8684])-c|0)>>>0:0){if(B=r+c|0,r>>>0>=B>>>0)return p=0,wi=w,0|p;i=0|fi[r+24>>2],A=0|fi[r+12>>2];do{if((0|A)==(0|r)){if(I=r+20|0,!((A=0|fi[I>>2])||(I=r+16|0,A=0|fi[I>>2]))){A=0;break}for(;;)if(e=A+20|0,0|(g=0|fi[e>>2]))A=g,I=e;else{if(e=A+16|0,!(g=0|fi[e>>2]))break;A=g,I=e}fi[I>>2]=0}else p=0|fi[r+8>>2],fi[p+12>>2]=A,fi[A+8>>2]=p}while(0);do{if(i){if(I=0|fi[r+28>>2],(0|r)==(0|fi[35032+(I<<2)>>2])){if(fi[35032+(I<<2)>>2]=A,!A){fi[8683]=a&~(1<<I),g=a&~(1<<I);break}}else if(fi[i+16+(((0|fi[i+16>>2])!=(0|r)&1)<<2)>>2]=A,!A){g=a;break}fi[A+24>>2]=i,0|(I=0|fi[r+16>>2])&&(fi[A+16>>2]=I,fi[I+24>>2]=A),(I=0|fi[r+20>>2])?(fi[A+20>>2]=I,fi[I+24>>2]=A,g=a):g=a}else g=a}while(0);do{if(t>>>0>=16){if(fi[r+4>>2]=3|c,fi[B+4>>2]=1|t,fi[B+t>>2]=t,e=t>>>3,t>>>0<256){(A=0|fi[8682])&1<<e?(A=0|fi[34768+(e<<1<<2)+8>>2],I=34768+(e<<1<<2)+8|0):(fi[8682]=A|1<<e,A=34768+(e<<1<<2)|0,I=34768+(e<<1<<2)+8|0),fi[I>>2]=B,fi[A+12>>2]=B,fi[B+8>>2]=A,fi[B+12>>2]=34768+(e<<1<<2);break}if(A=t>>>8,A=A?t>>>0>16777215?31:t>>>(7+(A=14-((520192+(A<<((A+1048320|0)>>>16&8))|0)>>>16&4|(A+1048320|0)>>>16&8|(245760+(p=A<<((A+1048320|0)>>>16&8)<<((520192+(A<<((A+1048320|0)>>>16&8))|0)>>>16&4))|0)>>>16&2)+(p<<((p+245760|0)>>>16&2)>>>15)|0)|0)&1|A<<1:0,e=35032+(A<<2)|0,fi[B+28>>2]=A,fi[B+16+4>>2]=0,fi[B+16>>2]=0,I=1<<A,!(g&I)){fi[8683]=g|I,fi[e>>2]=B,fi[B+24>>2]=e,fi[B+12>>2]=B,fi[B+8>>2]=B;break}for(I=t<<(31==(0|A)?0:25-(A>>>1)|0),e=0|fi[e>>2];;){if((-8&fi[e+4>>2]|0)==(0|t)){_=97;break}if(g=e+16+(I>>>31<<2)|0,!(A=0|fi[g>>2])){_=96;break}I<<=1,e=A}if(96==(0|_)){fi[g>>2]=B,fi[B+24>>2]=e,fi[B+12>>2]=B,fi[B+8>>2]=B;break}if(97==(0|_)){p=0|fi[(_=e+8|0)>>2],fi[p+12>>2]=B,fi[_>>2]=B,fi[B+8>>2]=p,fi[B+12>>2]=e,fi[B+24>>2]=0;break}}else p=t+c|0,fi[r+4>>2]=3|p,fi[(p=r+p+4|0)>>2]=1|fi[p>>2]}while(0);return p=r+8|0,wi=w,0|p}}}else c=-1}while(0);if((e=0|fi[8684])>>>0>=c>>>0)return A=e-c|0,I=0|fi[8687],A>>>0>15?(p=I+c|0,fi[8687]=p,fi[8684]=A,fi[p+4>>2]=1|A,fi[p+A>>2]=A,fi[I+4>>2]=3|c):(fi[8684]=0,fi[8687]=0,fi[I+4>>2]=3|e,fi[I+e+4>>2]=1|fi[I+e+4>>2]),p=I+8|0,wi=w,0|p;if((i=0|fi[8685])>>>0>c>>>0)return f=i-c|0,fi[8685]=f,p=0|fi[8688],_=p+c|0,fi[8688]=_,fi[_+4>>2]=1|f,fi[p+4>>2]=3|c,p=p+8|0,wi=w,0|p;if(0|fi[8800]?A=0|fi[8802]:(fi[8802]=4096,fi[8801]=4096,fi[8803]=-1,fi[8804]=-1,fi[8805]=0,fi[8793]=0,fi[Q>>2]=-16&Q^1431655768,fi[8800]=-16&Q^1431655768,A=4096),t=c+48|0,r=c+47|0,n=A+r|0,a=0-A|0,(n&a)>>>0<=c>>>0)return p=0,wi=w,0|p;if(0|(A=0|fi[8792])?((Q=0|fi[8790])+(n&a)|0)>>>0<=Q>>>0?1:(Q+(n&a)|0)>>>0>A>>>0:0)return p=0,wi=w,0|p;A:do{if(4&fi[8793])A=0,_=133;else{e=0|fi[8688];I:do{if(e){for(I=35176;!((A=0|fi[I>>2])>>>0<=e>>>0?(E=I+4|0,(A+(0|fi[E>>2])|0)>>>0>e>>>0):0);){if(!(A=0|fi[I+8>>2])){_=118;break I}I=A}if((n-i&a)>>>0<2147483647)if((0|(A=0|pI(n-i&a|0)))==((0|fi[I>>2])+(0|fi[E>>2])|0)){if(-1!=(0|A)){t=n-i&a,B=A,_=135;break A}A=n-i&a}else g=A,e=n-i&a,_=126;else A=0}else _=118}while(0);do{if(118==(0|_))if(-1!=(0|(I=0|pI(0)))?(h=0|fi[8801],h=(0==(h+-1&I|0)?0:(h+-1+I&0-h)-I|0)+(n&a)|0,s=0|fi[8790],h>>>0>c>>>0&h>>>0<2147483647):0){if(0|(E=0|fi[8792])?(h+s|0)>>>0<=s>>>0|(h+s|0)>>>0>E>>>0:0){A=0;break}if((0|(A=0|pI(0|h)))==(0|I)){t=h,B=I,_=135;break A}g=A,e=h,_=126}else A=0}while(0);do{if(126==(0|_)){if(I=0-e|0,!(t>>>0>e>>>0&e>>>0<2147483647&-1!=(0|g))){if(-1==(0|g)){A=0;break}t=e,B=g,_=135;break A}if(A=0|fi[8802],(A=r-e+A&0-A)>>>0>=2147483647){t=e,B=g,_=135;break A}if(-1==(0|pI(0|A))){pI(0|I),A=0;break}t=A+e|0,B=g,_=135;break A}}while(0);fi[8793]=4|fi[8793],_=133}}while(0);if(!(133==(0|_)?(n&a)>>>0<2147483647:0)||(B=0|pI(n&a|0),y=0|pI(0),f=(y-B|0)>>>0>(c+40|0)>>>0,-1==(0|B)|1^f|B>>>0<y>>>0&-1!=(0|B)&-1!=(0|y)^1)||(t=f?y-B|0:A,_=135),135==(0|_)){A=(0|fi[8790])+t|0,fi[8790]=A,A>>>0>(0|fi[8791])>>>0&&(fi[8791]=A),a=0|fi[8688];do{if(a){for(A=35176;;){if(I=0|fi[A>>2],e=A+4|0,g=0|fi[e>>2],(0|B)==(I+g|0)){_=145;break}if(!(i=0|fi[A+8>>2]))break;A=i}if((145==(0|_)?0==(8&fi[A+12>>2]|0):0)?a>>>0<B>>>0&a>>>0>=I>>>0:0){fi[e>>2]=g+t,_=0==(a+8&7|0)?0:0-(a+8)&7,p=(0|fi[8685])+(t-_)|0,fi[8688]=a+_,fi[8685]=p,fi[a+_+4>>2]=1|p,fi[a+_+p+4>>2]=40,fi[8689]=fi[8804];break}for(B>>>0<(0|fi[8686])>>>0&&(fi[8686]=B),e=B+t|0,A=35176;;){if((0|fi[A>>2])==(0|e)){_=153;break}if(!(I=0|fi[A+8>>2]))break;A=I}if(153==(0|_)?0==(8&fi[A+12>>2]|0):0){fi[A>>2]=B,fi[(C=A+4|0)>>2]=(0|fi[C>>2])+t,n=(C=B+(0==(7&(C=B+8|0)|0)?0:0-C&7)|0)+c|0,r=(A=e+(0==(e+8&7|0)?0:0-(e+8)&7)|0)-C-c|0,fi[C+4>>2]=3|c;do{if((0|A)!=(0|a)){if((0|A)==(0|fi[8687])){p=(0|fi[8684])+r|0,fi[8684]=p,fi[8687]=n,fi[n+4>>2]=1|p,fi[n+p>>2]=p;break}if(1==(3&(t=0|fi[A+4>>2])|0)){A:do{if(t>>>0<256){if(I=0|fi[A+8>>2],(0|(e=0|fi[A+12>>2]))==(0|I)){fi[8682]=fi[8682]&~(1<<(t>>>3));break}fi[I+12>>2]=e,fi[e+8>>2]=I;break}B=0|fi[A+24>>2],I=0|fi[A+12>>2];do{if((0|I)==(0|A)){if(I=0|fi[A+16+4>>2])i=A+16+4|0;else{if(!(I=0|fi[A+16>>2])){I=0;break}i=A+16|0}for(;;)if(e=I+20|0,0|(g=0|fi[e>>2]))I=g,i=e;else{if(e=I+16|0,!(g=0|fi[e>>2]))break;I=g,i=e}fi[i>>2]=0}else p=0|fi[A+8>>2],fi[p+12>>2]=I,fi[I+8>>2]=p}while(0);if(!B)break;e=0|fi[A+28>>2];do{if((0|A)==(0|fi[35032+(e<<2)>>2])){if(fi[35032+(e<<2)>>2]=I,0|I)break;fi[8683]=fi[8683]&~(1<<e);break A}if(fi[B+16+(((0|fi[B+16>>2])!=(0|A)&1)<<2)>>2]=I,!I)break A}while(0);if(fi[I+24>>2]=B,0|(e=0|fi[A+16>>2])&&(fi[I+16>>2]=e,fi[e+24>>2]=I),!(e=0|fi[A+16+4>>2]))break;fi[I+20>>2]=e,fi[e+24>>2]=I}while(0);A=A+(-8&t)|0,i=(-8&t)+r|0}else i=r;if(e=A+4|0,fi[e>>2]=-2&fi[e>>2],fi[n+4>>2]=1|i,fi[n+i>>2]=i,e=i>>>3,i>>>0<256){(A=0|fi[8682])&1<<e?(A=0|fi[34768+(e<<1<<2)+8>>2],I=34768+(e<<1<<2)+8|0):(fi[8682]=A|1<<e,A=34768+(e<<1<<2)|0,I=34768+(e<<1<<2)+8|0),fi[I>>2]=n,fi[A+12>>2]=n,fi[n+8>>2]=A,fi[n+12>>2]=34768+(e<<1<<2);break}A=i>>>8;do{if(A){if(i>>>0>16777215){A=31;break}A=i>>>(7+(A=14-((520192+(A<<((A+1048320|0)>>>16&8))|0)>>>16&4|(A+1048320|0)>>>16&8|(245760+(p=A<<((A+1048320|0)>>>16&8)<<((520192+(A<<((A+1048320|0)>>>16&8))|0)>>>16&4))|0)>>>16&2)+(p<<((p+245760|0)>>>16&2)>>>15)|0)|0)&1|A<<1}else A=0}while(0);if(g=35032+(A<<2)|0,fi[n+28>>2]=A,fi[n+16+4>>2]=0,fi[n+16>>2]=0,I=0|fi[8683],e=1<<A,!(I&e)){fi[8683]=I|e,fi[g>>2]=n,fi[n+24>>2]=g,fi[n+12>>2]=n,fi[n+8>>2]=n;break}for(I=i<<(31==(0|A)?0:25-(A>>>1)|0),e=0|fi[g>>2];;){if((-8&fi[e+4>>2]|0)==(0|i)){_=194;break}if(g=e+16+(I>>>31<<2)|0,!(A=0|fi[g>>2])){_=193;break}I<<=1,e=A}if(193==(0|_)){fi[g>>2]=n,fi[n+24>>2]=e,fi[n+12>>2]=n,fi[n+8>>2]=n;break}if(194==(0|_)){p=0|fi[(_=e+8|0)>>2],fi[p+12>>2]=n,fi[_>>2]=n,fi[n+8>>2]=p,fi[n+12>>2]=e,fi[n+24>>2]=0;break}}else p=(0|fi[8685])+r|0,fi[8685]=p,fi[8688]=n,fi[n+4>>2]=1|p}while(0);return p=C+8|0,wi=w,0|p}for(A=35176;!((I=0|fi[A>>2])>>>0<=a>>>0?(p=I+(0|fi[A+4>>2])|0)>>>0>a>>>0:0);)A=0|fi[A+8>>2];i=(i=p+-47+(0==(p+-47+8&7|0)?0:0-(p+-47+8)&7)|0)>>>0<(a+16|0)>>>0?a:i,_=B+(A=0==(7&(A=B+8|0)|0)?0:0-A&7)|0,A=t+-40-A|0,fi[8688]=_,fi[8685]=A,fi[_+4>>2]=1|A,fi[_+A+4>>2]=40,fi[8689]=fi[8804],fi[i+4>>2]=27,fi[i+8>>2]=fi[8794],fi[i+8+4>>2]=fi[8795],fi[i+8+8>>2]=fi[8796],fi[i+8+12>>2]=fi[8797],fi[8794]=B,fi[8795]=t,fi[8797]=0,fi[8796]=i+8,A=i+24|0;do{_=A,fi[(A=A+4|0)>>2]=7}while((_+8|0)>>>0<p>>>0);if((0|i)!=(0|a)){if(fi[i+4>>2]=-2&fi[i+4>>2],fi[a+4>>2]=i-a|1,fi[i>>2]=i-a,(i-a|0)>>>0<256){e=34768+((i-a|0)>>>3<<1<<2)|0,(A=0|fi[8682])&1<<((i-a|0)>>>3)?(A=0|fi[e+8>>2],I=e+8|0):(fi[8682]=A|1<<((i-a|0)>>>3),A=e,I=e+8|0),fi[I>>2]=a,fi[A+12>>2]=a,fi[a+8>>2]=A,fi[a+12>>2]=e;break}if(A=(i-a|0)>>>8?(i-a|0)>>>0>16777215?31:(i-a|0)>>>(7+(A=14-((520192+(A=(i-a|0)>>>8<<((1048320+((i-a|0)>>>8)|0)>>>16&8))|0)>>>16&4|(1048320+((i-a|0)>>>8)|0)>>>16&8|(245760+(A<<((A+520192|0)>>>16&4))|0)>>>16&2)+(A<<((A+520192|0)>>>16&4)<<((245760+(A<<((A+520192|0)>>>16&4))|0)>>>16&2)>>>15)|0)|0)&1|A<<1:0,g=35032+(A<<2)|0,fi[a+28>>2]=A,fi[a+20>>2]=0,fi[a+16>>2]=0,I=0|fi[8683],e=1<<A,!(I&e)){fi[8683]=I|e,fi[g>>2]=a,fi[a+24>>2]=g,fi[a+12>>2]=a,fi[a+8>>2]=a;break}for(I=i-a<<(31==(0|A)?0:25-(A>>>1)|0),e=0|fi[g>>2];;){if((-8&fi[e+4>>2]|0)==(i-a|0)){_=216;break}if(g=e+16+(I>>>31<<2)|0,!(A=0|fi[g>>2])){_=215;break}I<<=1,e=A}if(215==(0|_)){fi[g>>2]=a,fi[a+24>>2]=e,fi[a+12>>2]=a,fi[a+8>>2]=a;break}if(216==(0|_)){p=0|fi[(_=e+8|0)>>2],fi[p+12>>2]=a,fi[_>>2]=a,fi[a+8>>2]=p,fi[a+12>>2]=e,fi[a+24>>2]=0;break}}}else{0==(0|(p=0|fi[8686]))|B>>>0<p>>>0&&(fi[8686]=B),fi[8794]=B,fi[8795]=t,fi[8797]=0,fi[8691]=fi[8800],fi[8690]=-1,A=0;do{fi[12+(p=34768+(A<<1<<2)|0)>>2]=p,fi[p+8>>2]=p,A=A+1|0}while(32!=(0|A));_=B+(p=0==(7&(p=B+8|0)|0)?0:0-p&7)|0,p=t+-40-p|0,fi[8688]=_,fi[8685]=p,fi[_+4>>2]=1|p,fi[_+p+4>>2]=40,fi[8689]=fi[8804]}}while(0);if((A=0|fi[8685])>>>0>c>>>0)return f=A-c|0,fi[8685]=f,p=0|fi[8688],_=p+c|0,fi[8688]=_,fi[_+4>>2]=1|f,fi[p+4>>2]=3|c,p=p+8|0,wi=w,0|p}return fi[8202]=12,p=0,wi=w,0|p}function r(A){var I=0,e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0,P=0,L=0,x=0,X=0,K=0,T=0,V=0,q=0,j=0,Z=0,W=0,z=0,O=0,$=0,AA=0,IA=0,eA=0,gA=0,iA=0,BA=0,tA=0,rA=0,aA=0,nA=0,CA=0,oA=0,cA=0,QA=0,EA=0,sA=0;L=0|fe(0|yi[(A|=0)>>0],0|yi[A+1>>0],0|yi[A+2>>0]),e=0|Ue(0|(e=0|HI(A+2|0)),0|vi,5),x=0|Ue(0|(x=0|fe(0|yi[A+5>>0],0|yi[A+6>>0],0|yi[A+7>>0])),0|vi,2),T=0|Ue(0|(T=0|HI(A+7|0)),0|vi,7),w=0|Ue(0|(w=0|HI(A+10|0)),0|vi,4),q=0|Ue(0|(q=0|fe(0|yi[A+13>>0],0|yi[A+14>>0],0|yi[A+15>>0])),0|vi,1),P=0|Ue(0|(P=0|HI(A+15|0)),0|vi,6),gA=0|Ue(0|(gA=0|fe(0|yi[A+18>>0],0|yi[A+19>>0],0|yi[A+20>>0])),0|vi,3),CA=0|fe(0|yi[A+21>>0],0|yi[A+22>>0],0|yi[A+23>>0]),AA=0|Ue(0|(AA=0|HI(A+23|0)),0|vi,5),nA=0|Ue(0|(nA=0|fe(0|yi[A+26>>0],0|yi[A+27>>0],0|yi[A+28>>0])),0|vi,2),f=0|Ue(0|(f=0|HI(A+28|0)),0|vi,7),EA=0|Ue(0|(EA=0|HI(A+31|0)),0|vi,4),_=0|Ue(0|(_=0|fe(0|yi[A+34>>0],0|yi[A+35>>0],0|yi[A+36>>0])),0|vi,1),d=0|Ue(0|(d=0|HI(A+36|0)),0|vi,6),Q=0|Ue(0|(Q=0|fe(0|yi[A+39>>0],0|yi[A+40>>0],0|yi[A+41>>0])),0|vi,3),Z=0|fe(0|yi[A+42>>0],0|yi[A+43>>0],0|yi[A+44>>0]),U=0|Ue(0|(U=0|HI(A+44|0)),0|vi,5),z=0|Ue(0|(z=0|fe(0|yi[A+47>>0],0|yi[A+48>>0],0|yi[A+49>>0])),0|vi,2),sA=0|Ue(0|(sA=0|HI(A+49|0)),0|vi,7),p=0|Ue(0|(p=0|HI(A+52|0)),0|vi,4),y=0|Ue(0|(y=0|fe(0|yi[A+55>>0],0|yi[A+56>>0],0|yi[A+57>>0])),0|vi,1),B=0|Ue(0|(B=0|HI(A+57|0)),0|vi,6),t=0|he(0|(m=0|Ue(0|(m=0|HI(A+60|0)),0|vi,3)),0|(I=vi),666643,0),g=vi,BA=0|he(0|m,0|I,470296,0),n=vi,J=0|he(0|m,0|I,654183,0),C=vi,G=0|he(0|m,0|I,-997805,-1),Y=vi,Q=0|Ig(0|(a=0|he(0|m,0|I,136657,0)),0|vi,2097151&Q|0,0),a=vi,Z=0|Ig(0|(I=0|he(0|m,0|I,-683901,-1)),0|vi,2097151&Z|0,0),I=vi,m=0|he(2097151&B|0,0,666643,0),v=vi,h=0|he(2097151&B|0,0,470296,0),b=vi,i=0|he(2097151&B|0,0,654183,0),c=vi,D=0|he(2097151&B|0,0,-997805,-1),M=vi,j=0|he(2097151&B|0,0,136657,0),F=vi,B=0|Ig(0|Q,0|a,0|(B=0|he(2097151&B|0,0,-683901,-1)),0|vi),a=vi,Q=0|he(2097151&y|0,0,666643,0),o=vi,H=0|he(2097151&y|0,0,470296,0),l=vi,u=0|he(2097151&y|0,0,654183,0),K=vi,oA=0|he(2097151&y|0,0,-997805,-1),iA=vi,E=0|he(2097151&y|0,0,136657,0),W=vi,F=0|Ig(0|(Y=0|Ig(0|(d=0|Ig(0|(y=0|he(2097151&y|0,0,-683901,-1)),0|vi,2097151&d|0,0)),0|vi,0|G,0|Y)),0|vi,0|j,0|F),j=vi,Y=0|he(2097151&p|0,0,666643,0),G=vi,d=0|he(2097151&p|0,0,470296,0),y=vi,tA=0|he(2097151&p|0,0,654183,0),r=vi,N=0|he(2097151&p|0,0,-997805,-1),s=vi,QA=0|he(2097151&p|0,0,136657,0),cA=vi,p=0|he(2097151&p|0,0,-683901,-1),V=vi,k=0|he(2097151&sA|0,0,666643,0),X=vi,IA=0|he(2097151&sA|0,0,470296,0),eA=vi,$=0|he(2097151&sA|0,0,654183,0),O=vi,aA=0|he(2097151&sA|0,0,-997805,-1),rA=vi,S=0|he(2097151&sA|0,0,136657,0),R=vi,c=0|Ig(0|(n=0|Ig(0|(iA=0|Ig(0|(cA=0|Ig(0|(EA=0|Ig(0|(sA=0|he(2097151&sA|0,0,-683901,-1)),0|vi,2097151&EA|0,0)),0|vi,0|QA,0|cA)),0|vi,0|oA,0|iA)),0|vi,0|BA,0|n)),0|vi,0|i,0|c),i=vi,P=0|Ig(0|(n=0|he(2097151&z|0,0,666643,0)),0|vi,2097151&P|0,0),n=vi,BA=0|he(2097151&z|0,0,470296,0),iA=vi,G=0|Ig(0|(eA=0|Ig(0|(CA=0|Ig(0|(oA=0|he(2097151&z|0,0,654183,0)),0|vi,2097151&CA|0,0)),0|vi,0|IA,0|eA)),0|vi,0|Y,0|G),Y=vi,eA=0|he(2097151&z|0,0,-997805,-1),IA=vi,v=0|Ig(0|(l=0|Ig(0|(r=0|Ig(0|(rA=0|Ig(0|(nA=0|Ig(0|(CA=0|he(2097151&z|0,0,136657,0)),0|vi,2097151&nA|0,0)),0|vi,0|aA,0|rA)),0|vi,0|tA,0|r)),0|vi,0|H,0|l)),0|vi,0|m,0|v),m=vi,z=0|he(2097151&z|0,0,-683901,-1),l=vi,H=0|Ue(0|(H=0|Ig(0|P,0|n,1048576,0)),0|vi,21),r=vi,X=0|Ig(0|(X=0|Ig(0|(gA=0|Ig(0|BA,0|iA,2097151&gA|0,0)),0|vi,0|k,0|X)),0|vi,0|H,0|r),k=vi,r=0|Ag(0|P,0|n,0|(r=0|Se(0|H,0|r,21)),0|vi),n=vi,P=0|Ue(0|(P=0|Ig(0|G,0|Y,1048576,0)),0|vi,21),H=vi,o=0|Ig(0|(o=0|Ig(0|(y=0|Ig(0|(O=0|Ig(0|(AA=0|Ig(0|eA,0|IA,2097151&AA|0,0)),0|vi,0|$,0|O)),0|vi,0|d,0|y)),0|vi,0|Q,0|o)),0|vi,0|P,0|H),Q=vi,H=0|Se(0|P,0|H,21),P=vi,y=0|be(0|(y=0|Ig(0|v,0|m,1048576,0)),0|vi,21),d=vi,b=0|Ig(0|(b=0|Ig(0|(g=0|Ig(0|(K=0|Ig(0|(s=0|Ig(0|(R=0|Ig(0|(f=0|Ig(0|z,0|l,2097151&f|0,0)),0|vi,0|S,0|R)),0|vi,0|N,0|s)),0|vi,0|u,0|K)),0|vi,0|t,0|g)),0|vi,0|h,0|b)),0|vi,0|y,0|d),h=vi,d=0|Se(0|y,0|d,21),y=vi,g=0|be(0|(g=0|Ig(0|c,0|i,1048576,0)),0|vi,21),t=vi,M=0|Ig(0|(M=0|Ig(0|(C=0|Ig(0|(W=0|Ig(0|(_=0|Ig(0|p,0|V,2097151&_|0,0)),0|vi,0|E,0|W)),0|vi,0|J,0|C)),0|vi,0|D,0|M)),0|vi,0|g,0|t),D=vi,t=0|Ag(0|c,0|i,0|(t=0|Se(0|g,0|t,21)),0|vi),i=vi,a=0|Ig(0|B,0|a,0|(c=0|be(0|(c=0|Ig(0|F,0|j,1048576,0)),0|vi,21)),0|(g=vi)),B=vi,g=0|Ag(0|F,0|j,0|(g=0|Se(0|c,0|g,21)),0|vi),j=vi,U=0|Ig(0|(F=0|be(0|(F=0|Ig(0|Z,0|I,1048576,0)),0|vi,21)),0|(c=vi),2097151&U|0,0),C=vi,c=0|Ag(0|Z,0|I,0|(c=0|Se(0|F,0|c,21)),0|vi),I=vi,J=0|Ag(0|X,0|k,0|(J=0|Se(0|(Z=0|Ue(0|(Z=0|Ig(0|X,0|k,1048576,0)),0|vi,21)),0|(F=vi),21)),0|vi),k=vi,E=0|Se(0|(X=0|be(0|(X=0|Ig(0|o,0|Q,1048576,0)),0|vi,21)),0|(W=vi),21),_=vi,i=0|Ig(0|(V=0|be(0|(V=0|Ig(0|b,0|h,1048576,0)),0|vi,21)),0|(p=vi),0|t,0|i),t=vi,p=0|Ag(0|b,0|h,0|(p=0|Se(0|V,0|p,21)),0|vi),h=vi,j=0|Ig(0|(b=0|be(0|(b=0|Ig(0|M,0|D,1048576,0)),0|vi,21)),0|(V=vi),0|g,0|j),g=vi,V=0|Ag(0|M,0|D,0|(V=0|Se(0|b,0|V,21)),0|vi),D=vi,I=0|Ig(0|(M=0|be(0|(M=0|Ig(0|a,0|B,1048576,0)),0|vi,21)),0|(b=vi),0|c,0|I),c=vi,b=0|Ag(0|a,0|B,0|(b=0|Se(0|M,0|b,21)),0|vi),B=vi,q=0|Ig(0|(a=0|he(0|U,0|C,666643,0)),0|vi,2097151&q|0,0),a=vi,M=0|Ig(0|r,0|n,0|(M=0|he(0|U,0|C,470296,0)),0|vi),n=vi,r=0|Ig(0|J,0|k,0|(r=0|he(0|U,0|C,654183,0)),0|vi),k=vi,J=0|he(0|U,0|C,-997805,-1),K=vi,u=0|he(0|U,0|C,136657,0),s=vi,y=0|Ag(0|(W=0|Ig(0|(m=0|Ig(0|(C=0|he(0|U,0|C,-683901,-1)),0|vi,0|v,0|m)),0|vi,0|X,0|W)),0|vi,0|d,0|y),d=vi,w=0|Ig(0|(W=0|he(0|I,0|c,666643,0)),0|vi,2097151&w|0,0),W=vi,X=0|Ig(0|q,0|a,0|(X=0|he(0|I,0|c,470296,0)),0|vi),a=vi,q=0|Ig(0|M,0|n,0|(q=0|he(0|I,0|c,654183,0)),0|vi),n=vi,M=0|Ig(0|r,0|k,0|(M=0|he(0|I,0|c,-997805,-1)),0|vi),k=vi,r=0|he(0|I,0|c,136657,0),m=vi,c=0|he(0|I,0|c,-683901,-1),I=vi,T=0|Ig(0|(v=0|he(0|b,0|B,666643,0)),0|vi,2097151&T|0,0),v=vi,C=0|Ig(0|w,0|W,0|(C=0|he(0|b,0|B,470296,0)),0|vi),W=vi,w=0|Ig(0|X,0|a,0|(w=0|he(0|b,0|B,654183,0)),0|vi),a=vi,X=0|Ig(0|q,0|n,0|(X=0|he(0|b,0|B,-997805,-1)),0|vi),n=vi,q=0|Ig(0|M,0|k,0|(q=0|he(0|b,0|B,136657,0)),0|vi),k=vi,B=0|he(0|b,0|B,-683901,-1),b=vi,b=0|Ig(0|(m=0|Ig(0|(K=0|Ig(0|(P=0|Ag(0|(Y=0|Ig(0|Z,0|F,0|G,0|Y)),0|vi,0|H,0|P)),0|vi,0|J,0|K)),0|vi,0|r,0|m)),0|vi,0|B,0|b),B=vi,x=0|Ig(0|(m=0|he(0|j,0|g,666643,0)),0|vi,2097151&x|0,0),m=vi,r=0|Ig(0|T,0|v,0|(r=0|he(0|j,0|g,470296,0)),0|vi),v=vi,T=0|Ig(0|C,0|W,0|(T=0|he(0|j,0|g,654183,0)),0|vi),W=vi,C=0|Ig(0|w,0|a,0|(C=0|he(0|j,0|g,-997805,-1)),0|vi),a=vi,w=0|Ig(0|X,0|n,0|(w=0|he(0|j,0|g,136657,0)),0|vi),n=vi,g=0|Ig(0|q,0|k,0|(g=0|he(0|j,0|g,-683901,-1)),0|vi),k=vi,q=0|he(0|V,0|D,666643,0),j=vi,X=0|he(0|V,0|D,470296,0),K=vi,J=0|he(0|V,0|D,654183,0),P=vi,H=0|he(0|V,0|D,-997805,-1),Y=vi,G=0|he(0|V,0|D,136657,0),F=vi,D=0|Ig(0|w,0|n,0|(D=0|he(0|V,0|D,-683901,-1)),0|vi),n=vi,L=0|Ig(0|(w=0|he(0|i,0|t,666643,0)),0|vi,2097151&L|0,0),w=vi,V=0|he(0|i,0|t,470296,0),Z=vi,K=0|Ig(0|(M=0|Ig(0|x,0|m,0|(M=0|he(0|i,0|t,654183,0)),0|vi)),0|vi,0|X,0|K),X=vi,M=0|he(0|i,0|t,-997805,-1),m=vi,Y=0|Ig(0|(x=0|Ig(0|T,0|W,0|(x=0|he(0|i,0|t,136657,0)),0|vi)),0|vi,0|H,0|Y),H=vi,t=0|he(0|i,0|t,-683901,-1),i=vi,x=0|be(0|(x=0|Ig(0|L,0|w,1048576,0)),0|vi,21),W=vi,j=0|Ig(0|(j=0|Ig(0|(e=0|Ig(0|V,0|Z,2097151&e|0,0)),0|vi,0|q,0|j)),0|vi,0|x,0|W),q=vi,W=0|Ag(0|L,0|w,0|(W=0|Se(0|x,0|W,21)),0|vi),w=vi,L=0|be(0|(L=0|Ig(0|K,0|X,1048576,0)),0|vi,21),x=vi,P=0|Ig(0|(P=0|Ig(0|(m=0|Ig(0|r,0|v,0|M,0|m)),0|vi,0|J,0|P)),0|vi,0|L,0|x),J=vi,x=0|Se(0|L,0|x,21),L=vi,m=0|be(0|(m=0|Ig(0|Y,0|H,1048576,0)),0|vi,21),M=vi,F=0|Ig(0|(F=0|Ig(0|(i=0|Ig(0|C,0|a,0|t,0|i)),0|vi,0|G,0|F)),0|vi,0|m,0|M),G=vi,M=0|Se(0|m,0|M,21),m=vi,k=0|Ig(0|g,0|k,0|(i=0|be(0|(i=0|Ig(0|D,0|n,1048576,0)),0|vi,21)),0|(t=vi)),g=vi,t=0|Ag(0|D,0|n,0|(t=0|Se(0|i,0|t,21)),0|vi),n=vi,D=0|be(0|(D=0|Ig(0|b,0|B,1048576,0)),0|vi,21),i=vi,I=0|Ig(0|(I=0|Ig(0|(_=0|Ag(0|(Q=0|Ig(0|u,0|s,0|o,0|Q)),0|vi,0|E,0|_)),0|vi,0|c,0|I)),0|vi,0|D,0|i),c=vi,i=0|Ag(0|b,0|B,0|(i=0|Se(0|D,0|i,21)),0|vi),B=vi,h=0|Ig(0|(b=0|be(0|(b=0|Ig(0|y,0|d,1048576,0)),0|vi,21)),0|(D=vi),0|p,0|h),p=vi,D=0|Ag(0|y,0|d,0|(D=0|Se(0|b,0|D,21)),0|vi),d=vi,_=0|Se(0|(y=0|be(0|(y=0|Ig(0|j,0|q,1048576,0)),0|vi,21)),0|(b=vi),21),E=vi,s=0|Se(0|(Q=0|be(0|(Q=0|Ig(0|P,0|J,1048576,0)),0|vi,21)),0|(o=vi),21),u=vi,n=0|Ig(0|t,0|n,0|(a=0|be(0|(a=0|Ig(0|F,0|G,1048576,0)),0|vi,21)),0|(C=vi)),t=vi,C=0|Se(0|a,0|C,21),a=vi,B=0|Ig(0|i,0|B,0|(v=0|be(0|(v=0|Ig(0|k,0|g,1048576,0)),0|vi,21)),0|(r=vi)),i=vi,r=0|Ag(0|k,0|g,0|(r=0|Se(0|v,0|r,21)),0|vi),g=vi,d=0|Ig(0|D,0|d,0|(k=0|be(0|(k=0|Ig(0|I,0|c,1048576,0)),0|vi,21)),0|(v=vi)),D=vi,v=0|Ag(0|I,0|c,0|(v=0|Se(0|k,0|v,21)),0|vi),c=vi,e=0|Ag(0|h,0|p,0|(e=0|Se(0|(I=0|be(0|(I=0|Ig(0|h,0|p,1048576,0)),0|vi,21)),0|(k=vi),21)),0|vi),p=vi,h=0|Ig(0|W,0|w,0|(h=0|he(0|I,0|k,666643,0)),0|vi),w=vi,W=0|he(0|I,0|k,470296,0),Z=vi,V=0|he(0|I,0|k,654183,0),T=vi,U=0|he(0|I,0|k,-997805,-1),N=vi,R=0|he(0|I,0|k,136657,0),S=vi,k=0|he(0|I,0|k,-683901,-1),I=vi,f=0|be(0|h,0|w,21),l=vi,E=0|Ig(0|(E=0|Ag(0|(q=0|Ig(0|W,0|Z,0|j,0|q)),0|vi,0|_,0|E)),0|vi,0|f,0|l),_=vi,l=0|Ag(0|h,0|w,0|(l=0|Se(0|f,0|l,21)),0|vi),w=vi,h=0|be(0|E,0|_,21),f=vi,b=0|Ig(0|(b=0|Ig(0|(L=0|Ag(0|(X=0|Ig(0|V,0|T,0|K,0|X)),0|vi,0|x,0|L)),0|vi,0|y,0|b)),0|vi,0|h,0|f),y=vi,f=0|Ag(0|E,0|_,0|(f=0|Se(0|h,0|f,21)),0|vi),_=vi,E=0|be(0|b,0|y,21),h=vi,u=0|Ig(0|(u=0|Ag(0|(N=0|Ig(0|P,0|J,0|U,0|N)),0|vi,0|s,0|u)),0|vi,0|E,0|h),s=vi,h=0|Ag(0|b,0|y,0|(h=0|Se(0|E,0|h,21)),0|vi),y=vi,b=0|be(0|u,0|s,21),E=vi,o=0|Ig(0|(o=0|Ig(0|(m=0|Ag(0|(H=0|Ig(0|R,0|S,0|Y,0|H)),0|vi,0|M,0|m)),0|vi,0|Q,0|o)),0|vi,0|b,0|E),Q=vi,E=0|Ag(0|u,0|s,0|(E=0|Se(0|b,0|E,21)),0|vi),s=vi,u=0|be(0|o,0|Q,21),b=vi,a=0|Ig(0|(a=0|Ag(0|(I=0|Ig(0|F,0|G,0|k,0|I)),0|vi,0|C,0|a)),0|vi,0|u,0|b),C=vi,b=0|Ag(0|o,0|Q,0|(b=0|Se(0|u,0|b,21)),0|vi),Q=vi,t=0|Ig(0|n,0|t,0|(o=0|be(0|a,0|C,21)),0|(u=vi)),n=vi,u=0|Ag(0|a,0|C,0|(u=0|Se(0|o,0|u,21)),0|vi),C=vi,g=0|Ig(0|(a=0|be(0|t,0|n,21)),0|(o=vi),0|r,0|g),r=vi,o=0|Ag(0|t,0|n,0|(o=0|Se(0|a,0|o,21)),0|vi),n=vi,i=0|Ig(0|B,0|i,0|(t=0|be(0|g,0|r,21)),0|(a=vi)),B=vi,a=0|Ag(0|g,0|r,0|(a=0|Se(0|t,0|a,21)),0|vi),r=vi,c=0|Ig(0|(g=0|be(0|i,0|B,21)),0|(t=vi),0|v,0|c),v=vi,t=0|Ag(0|i,0|B,0|(t=0|Se(0|g,0|t,21)),0|vi),B=vi,D=0|Ig(0|d,0|D,0|(i=0|be(0|c,0|v,21)),0|(g=vi)),d=vi,g=0|Ag(0|c,0|v,0|(g=0|Se(0|i,0|g,21)),0|vi),v=vi,p=0|Ig(0|(c=0|be(0|D,0|d,21)),0|(i=vi),0|e,0|p),e=vi,i=0|Ag(0|D,0|d,0|(i=0|Se(0|c,0|i,21)),0|vi),d=vi,I=0|Ag(0|p,0|e,0|(I=0|Se(0|(D=0|be(0|p,0|e,21)),0|(c=vi),21)),0|vi),e=vi,w=0|Ig(0|(p=0|he(0|D,0|c,666643,0)),0|vi,0|l,0|w),l=vi,p=0|Ig(0|f,0|_,0|(p=0|he(0|D,0|c,470296,0)),0|vi),_=vi,f=0|Ig(0|h,0|y,0|(f=0|he(0|D,0|c,654183,0)),0|vi),y=vi,h=0|Ig(0|E,0|s,0|(h=0|he(0|D,0|c,-997805,-1)),0|vi),s=vi,E=0|Ig(0|b,0|Q,0|(E=0|he(0|D,0|c,136657,0)),0|vi),Q=vi,c=0|Ig(0|u,0|C,0|(c=0|he(0|D,0|c,-683901,-1)),0|vi),C=vi,_=0|Ig(0|p,0|_,0|(u=0|be(0|w,0|l,21)),0|(D=vi)),p=vi,D=0|Ag(0|w,0|l,0|(D=0|Se(0|u,0|D,21)),0|vi),l=vi,y=0|Ig(0|f,0|y,0|(w=0|be(0|_,0|p,21)),0|(u=vi)),f=vi,u=0|Ag(0|_,0|p,0|(u=0|Se(0|w,0|u,21)),0|vi),p=vi,s=0|Ig(0|h,0|s,0|(_=0|be(0|y,0|f,21)),0|(w=vi)),h=vi,w=0|Ag(0|y,0|f,0|(w=0|Se(0|_,0|w,21)),0|vi),f=vi,Q=0|Ig(0|E,0|Q,0|(y=0|be(0|s,0|h,21)),0|(_=vi)),E=vi,_=0|Ag(0|s,0|h,0|(_=0|Se(0|y,0|_,21)),0|vi),h=vi,C=0|Ig(0|c,0|C,0|(s=0|be(0|Q,0|E,21)),0|(y=vi)),c=vi,y=0|Ag(0|Q,0|E,0|(y=0|Se(0|s,0|y,21)),0|vi),E=vi,n=0|Ig(0|(Q=0|be(0|C,0|c,21)),0|(s=vi),0|o,0|n),o=vi,s=0|Ag(0|C,0|c,0|(s=0|Se(0|Q,0|s,21)),0|vi),c=vi,r=0|Ig(0|(C=0|be(0|n,0|o,21)),0|(Q=vi),0|a,0|r),a=vi,Q=0|Ag(0|n,0|o,0|(Q=0|Se(0|C,0|Q,21)),0|vi),o=vi,B=0|Ig(0|(n=0|be(0|r,0|a,21)),0|(C=vi),0|t,0|B),t=vi,C=0|Ag(0|r,0|a,0|(C=0|Se(0|n,0|C,21)),0|vi),a=vi,v=0|Ig(0|(r=0|be(0|B,0|t,21)),0|(n=vi),0|g,0|v),g=vi,n=0|Ag(0|B,0|t,0|(n=0|Se(0|r,0|n,21)),0|vi),t=vi,d=0|Ig(0|(B=0|be(0|v,0|g,21)),0|(r=vi),0|i,0|d),i=vi,r=0|Ag(0|v,0|g,0|(r=0|Se(0|B,0|r,21)),0|vi),g=vi,e=0|Ig(0|(v=0|be(0|d,0|i,21)),0|(B=vi),0|I,0|e),I=vi,B=0|Ag(0|d,0|i,0|(B=0|Se(0|v,0|B,21)),0|vi),i=vi,yi[A>>0]=D,d=0|Ue(0|D,0|l,8),yi[A+1>>0]=d,l=0|Ue(0|D,0|l,16),D=vi,d=0|Se(0|u,0|p,5),yi[A+2>>0]=d|l,l=0|Ue(0|u,0|p,3),yi[A+3>>0]=l,l=0|Ue(0|u,0|p,11),yi[A+4>>0]=l,p=0|Ue(0|u,0|p,19),u=vi,l=0|Se(0|w,0|f,2),yi[A+5>>0]=l|p,p=0|Ue(0|w,0|f,6),yi[A+6>>0]=p,f=0|Ue(0|w,0|f,14),w=vi,p=0|Se(0|_,0|h,7),yi[A+7>>0]=p|f,f=0|Ue(0|_,0|h,1),yi[A+8>>0]=f,f=0|Ue(0|_,0|h,9),yi[A+9>>0]=f,h=0|Ue(0|_,0|h,17),_=vi,f=0|Se(0|y,0|E,4),yi[A+10>>0]=f|h,h=0|Ue(0|y,0|E,4),yi[A+11>>0]=h,h=0|Ue(0|y,0|E,12),yi[A+12>>0]=h,E=0|Ue(0|y,0|E,20),y=vi,h=0|Se(0|s,0|c,1),yi[A+13>>0]=h|E,E=0|Ue(0|s,0|c,7),yi[A+14>>0]=E,c=0|Ue(0|s,0|c,15),s=vi,E=0|Se(0|Q,0|o,6),yi[A+15>>0]=E|c,c=0|Ue(0|Q,0|o,2),yi[A+16>>0]=c,c=0|Ue(0|Q,0|o,10),yi[A+17>>0]=c,o=0|Ue(0|Q,0|o,18),Q=vi,c=0|Se(0|C,0|a,3),yi[A+18>>0]=c|o,o=0|Ue(0|C,0|a,5),yi[A+19>>0]=o,a=0|Ue(0|C,0|a,13),yi[A+20>>0]=a,yi[A+21>>0]=n,a=0|Ue(0|n,0|t,8),yi[A+22>>0]=a,t=0|Ue(0|n,0|t,16),n=vi,a=0|Se(0|r,0|g,5),yi[A+23>>0]=a|t,t=0|Ue(0|r,0|g,3),yi[A+24>>0]=t,t=0|Ue(0|r,0|g,11),yi[A+25>>0]=t,g=0|Ue(0|r,0|g,19),r=vi,t=0|Se(0|B,0|i,2),yi[A+26>>0]=t|g,g=0|Ue(0|B,0|i,6),yi[A+27>>0]=g,i=0|Ue(0|B,0|i,14),B=vi,g=0|Se(0|e,0|I,7),yi[A+28>>0]=i|g,g=0|Ue(0|e,0|I,1),yi[A+29>>0]=g,g=0|Ue(0|e,0|I,9),yi[A+30>>0]=g,I=0|Ue(0|e,0|I,17),yi[A+31>>0]=I}function a(A,I,e){A|=0,e|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0,P=0,L=0,x=0,X=0,K=0,T=0,V=0,q=0,j=0,Z=0,W=0,z=0,O=0,$=0,AA=0,IA=0,eA=0,gA=0,iA=0,BA=0,tA=0,rA=0,aA=0,nA=0,CA=0,oA=0,cA=0,QA=0,EA=0,sA=0,hA=0,yA=0,fA=0,_A=0,pA=0,wA=0,lA=0,uA=0,dA=0,DA=0,vA=0,bA=0,kA=0,GA=0,FA=0,mA=0,MA=0,HA=0,YA=0,SA=0,RA=0,NA=0,UA=0,JA=0,PA=0,LA=0,xA=0,XA=0,KA=0,TA=0,VA=0,qA=0,jA=0,ZA=0,WA=0,zA=0,OA=0,$A=0,AI=0,II=0,eI=0,gI=0,iI=0,BI=0,tI=0,rI=0,aI=0,nI=0,CI=0,oI=0,cI=0,QI=0,EI=0,sI=0,hI=0,yI=0,fI=0,_I=0,pI=0,wI=0,lI=0,uI=0,dI=0,DI=0,vI=0,bI=0,kI=0,GI=0,FI=0,mI=0,MI=0,HI=0,YI=0,SI=0,RI=0,NI=0,UI=0,JI=0,PI=0,LI=0,xI=0,XI=0,KI=0,TI=0,VI=0,qI=0,jI=0,ZI=0,WI=0,zI=0,OI=0,$I=0,Ae=0,Ie=0,ee=0,ge=0,ie=0,Be=0,te=0,re=0,ae=0,ne=0,Ce=0,oe=0,ce=0,Qe=0,Ee=0,se=0,ye=0,fe=0,_e=0,pe=0,we=0,le=0,ue=0,de=0,De=0,ve=0,ke=0,Ge=0,Fe=0,me=0,Me=0,He=0,Ye=0,Re=0,Ne=0,Ue=0,Je=0,Pe=0,Le=0,xe=0;Q=0|fi[(I|=0)>>2],c=0|fi[I+4>>2],n=0|fi[I+8>>2],gA=0|fi[I+12>>2],N=0|fi[I+16>>2],R=0|fi[I+20>>2],B=0|fi[I+24>>2],eA=0|fi[I+28>>2],S=0|fi[I+32>>2],s=0|fi[I+36>>2],M=0|fi[e>>2],Le=0|fi[e+4>>2],Ae=0|fi[e+8>>2],hI=0|fi[e+12>>2],MA=0|fi[e+16>>2],re=0|fi[e+20>>2],bI=0|fi[e+24>>2],XA=0|fi[e+28>>2],iA=0|fi[e+32>>2],xe=0|fi[e+36>>2],Je=0|he(0|M,((0|M)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),Ue=vi,we=0|he(0|Le,((0|Le)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),pe=vi,fI=0|he(0|Ae,((0|Ae)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),yI=vi,YA=0|he(0|hI,((0|hI)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),HA=vi,Ce=0|he(0|MA,((0|MA)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),ne=vi,FI=0|he(0|re,((0|re)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),GI=vi,VA=0|he(0|bI,((0|bI)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),TA=vi,rA=0|he(0|XA,((0|XA)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),tA=vi,J=0|he(0|iA,((0|iA)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),U=vi,Q=0|he(0|xe,((0|xe)<0)<<31>>31|0,0|Q,((0|Q)<0)<<31>>31|0),C=vi,Ie=0|he(0|M,((0|M)<0)<<31>>31|0,0|c,((0|c)<0)<<31>>31|0),ee=vi,lI=0|he(0|Le,((0|Le)<0)<<31>>31|0,c<<1|0,((c<<1|0)<0)<<31>>31|0),wI=vi,RA=0|he(0|Ae,((0|Ae)<0)<<31>>31|0,0|c,((0|c)<0)<<31>>31|0),SA=vi,ce=0|he(0|hI,((0|hI)<0)<<31>>31|0,c<<1|0,((c<<1|0)<0)<<31>>31|0),oe=vi,MI=0|he(0|MA,((0|MA)<0)<<31>>31|0,0|c,((0|c)<0)<<31>>31|0),mI=vi,jA=0|he(0|re,((0|re)<0)<<31>>31|0,c<<1|0,((c<<1|0)<0)<<31>>31|0),qA=vi,nA=0|he(0|bI,((0|bI)<0)<<31>>31|0,0|c,((0|c)<0)<<31>>31|0),aA=vi,L=0|he(0|XA,((0|XA)<0)<<31>>31|0,c<<1|0,((c<<1|0)<0)<<31>>31|0),P=vi,f=0|he(0|iA,((0|iA)<0)<<31>>31|0,0|c,((0|c)<0)<<31>>31|0),y=vi,c=0|he(19*xe|0,0|(e=((19*xe|0)<0)<<31>>31),c<<1|0,((c<<1|0)<0)<<31>>31|0),E=vi,pI=0|he(0|M,((0|M)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),_I=vi,PA=0|he(0|Le,((0|Le)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),JA=vi,Ee=0|he(0|Ae,((0|Ae)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),Qe=vi,YI=0|he(0|hI,((0|hI)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),HI=vi,WA=0|he(0|MA,((0|MA)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),ZA=vi,oA=0|he(0|re,((0|re)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),CA=vi,X=0|he(0|bI,((0|bI)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),x=vi,p=0|he(0|XA,((0|XA)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),_=vi,ue=0|he(19*iA|0,0|(BA=((19*iA|0)<0)<<31>>31),0|n,((0|n)<0)<<31>>31|0),le=vi,n=0|he(19*xe|0,0|e,0|n,((0|n)<0)<<31>>31|0),a=vi,UA=0|he(0|M,((0|M)<0)<<31>>31|0,0|gA,((0|gA)<0)<<31>>31|0),NA=vi,_e=0|he(0|Le,((0|Le)<0)<<31>>31|0,gA<<1|0,((gA<<1|0)<0)<<31>>31|0),fe=vi,RI=0|he(0|Ae,((0|Ae)<0)<<31>>31|0,0|gA,((0|gA)<0)<<31>>31|0),SI=vi,OA=0|he(0|hI,((0|hI)<0)<<31>>31|0,gA<<1|0,((gA<<1|0)<0)<<31>>31|0),zA=vi,QA=0|he(0|MA,((0|MA)<0)<<31>>31|0,0|gA,((0|gA)<0)<<31>>31|0),cA=vi,T=0|he(0|re,((0|re)<0)<<31>>31|0,gA<<1|0,((gA<<1|0)<0)<<31>>31|0),K=vi,l=0|he(0|bI,((0|bI)<0)<<31>>31|0,0|gA,((0|gA)<0)<<31>>31|0),w=vi,De=0|he(19*XA|0,0|(KA=((19*XA|0)<0)<<31>>31),gA<<1|0,((gA<<1|0)<0)<<31>>31|0),de=vi,xI=0|he(19*iA|0,0|BA,0|gA,((0|gA)<0)<<31>>31|0),LI=vi,gA=0|he(19*xe|0,0|e,gA<<1|0,((gA<<1|0)<0)<<31>>31|0),i=vi,ye=0|he(0|M,((0|M)<0)<<31>>31|0,0|N,((0|N)<0)<<31>>31|0),se=vi,PI=0|he(0|Le,((0|Le)<0)<<31>>31|0,0|N,((0|N)<0)<<31>>31|0),JI=vi,AI=0|he(0|Ae,((0|Ae)<0)<<31>>31|0,0|N,((0|N)<0)<<31>>31|0),$A=vi,sA=0|he(0|hI,((0|hI)<0)<<31>>31|0,0|N,((0|N)<0)<<31>>31|0),EA=vi,q=0|he(0|MA,((0|MA)<0)<<31>>31|0,0|N,((0|N)<0)<<31>>31|0),V=vi,d=0|he(0|re,((0|re)<0)<<31>>31|0,0|N,((0|N)<0)<<31>>31|0),u=vi,ke=0|he(19*bI|0,0|(kI=((19*bI|0)<0)<<31>>31),0|N,((0|N)<0)<<31>>31|0),ve=vi,KI=0|he(19*XA|0,0|KA,0|N,((0|N)<0)<<31>>31|0),XI=vi,tI=0|he(19*iA|0,0|BA,0|N,((0|N)<0)<<31>>31|0),BI=vi,N=0|he(19*xe|0,0|e,0|N,((0|N)<0)<<31>>31|0),g=vi,UI=0|he(0|M,((0|M)<0)<<31>>31|0,0|R,((0|R)<0)<<31>>31|0),NI=vi,iI=0|he(0|Le,((0|Le)<0)<<31>>31|0,R<<1|0,((R<<1|0)<0)<<31>>31|0),gI=vi,yA=0|he(0|Ae,((0|Ae)<0)<<31>>31|0,0|R,((0|R)<0)<<31>>31|0),hA=vi,Z=0|he(0|hI,((0|hI)<0)<<31>>31|0,R<<1|0,((R<<1|0)<0)<<31>>31|0),j=vi,v=0|he(0|MA,((0|MA)<0)<<31>>31|0,0|R,((0|R)<0)<<31>>31|0),D=vi,Fe=0|he(19*re|0,0|(ae=((19*re|0)<0)<<31>>31),R<<1|0,((R<<1|0)<0)<<31>>31|0),Ge=vi,VI=0|he(19*bI|0,0|kI,0|R,((0|R)<0)<<31>>31|0),TI=vi,aI=0|he(19*XA|0,0|KA,R<<1|0,((R<<1|0)<0)<<31>>31|0),rI=vi,dA=0|he(19*iA|0,0|BA,0|R,((0|R)<0)<<31>>31|0),uA=vi,I=0|he(19*xe|0,0|e,R<<1|0,((R<<1|0)<0)<<31>>31|0),R=vi,eI=0|he(0|M,((0|M)<0)<<31>>31|0,0|B,((0|B)<0)<<31>>31|0),II=vi,wA=0|he(0|Le,((0|Le)<0)<<31>>31|0,0|B,((0|B)<0)<<31>>31|0),pA=vi,z=0|he(0|Ae,((0|Ae)<0)<<31>>31|0,0|B,((0|B)<0)<<31>>31|0),W=vi,k=0|he(0|hI,((0|hI)<0)<<31>>31|0,0|B,((0|B)<0)<<31>>31|0),b=vi,Me=0|he(19*MA|0,((19*MA|0)<0)<<31>>31|0,0|B,((0|B)<0)<<31>>31|0),me=vi,jI=0|he(19*re|0,0|ae,0|B,((0|B)<0)<<31>>31|0),qI=vi,CI=0|he(19*bI|0,0|kI,0|B,((0|B)<0)<<31>>31|0),nI=vi,vA=0|he(19*XA|0,0|KA,0|B,((0|B)<0)<<31>>31|0),DA=vi,o=0|he(19*iA|0,0|BA,0|B,((0|B)<0)<<31>>31|0),h=vi,B=0|he(19*xe|0,0|e,0|B,((0|B)<0)<<31>>31|0),lA=vi,_A=0|he(0|M,((0|M)<0)<<31>>31|0,0|eA,((0|eA)<0)<<31>>31|0),fA=vi,IA=0|he(0|Le,((0|Le)<0)<<31>>31|0,eA<<1|0,((eA<<1|0)<0)<<31>>31|0),AA=vi,F=0|he(0|Ae,((0|Ae)<0)<<31>>31|0,0|eA,((0|eA)<0)<<31>>31|0),G=vi,Ye=0|he(19*hI|0,((19*hI|0)<0)<<31>>31|0,eA<<1|0,((eA<<1|0)<0)<<31>>31|0),He=vi,WI=0|he(19*MA|0,((19*MA|0)<0)<<31>>31|0,0|eA,((0|eA)<0)<<31>>31|0),ZI=vi,cI=0|he(19*re|0,0|ae,eA<<1|0,((eA<<1|0)<0)<<31>>31|0),oI=vi,kA=0|he(19*bI|0,0|kI,0|eA,((0|eA)<0)<<31>>31|0),bA=vi,ie=0|he(19*XA|0,0|KA,eA<<1|0,((eA<<1|0)<0)<<31>>31|0),ge=vi,dI=0|he(19*iA|0,0|BA,0|eA,((0|eA)<0)<<31>>31|0),uI=vi,eA=0|he(19*xe|0,0|e,eA<<1|0,((eA<<1|0)<0)<<31>>31|0),r=vi,$=0|he(0|M,((0|M)<0)<<31>>31|0,0|S,((0|S)<0)<<31>>31|0),O=vi,Y=0|he(0|Le,((0|Le)<0)<<31>>31|0,0|S,((0|S)<0)<<31>>31|0),H=vi,Ne=0|he(19*Ae|0,((19*Ae|0)<0)<<31>>31|0,0|S,((0|S)<0)<<31>>31|0),Re=vi,OI=0|he(19*hI|0,((19*hI|0)<0)<<31>>31|0,0|S,((0|S)<0)<<31>>31|0),zI=vi,EI=0|he(19*MA|0,((19*MA|0)<0)<<31>>31|0,0|S,((0|S)<0)<<31>>31|0),QI=vi,FA=0|he(19*re|0,0|ae,0|S,((0|S)<0)<<31>>31|0),GA=vi,te=0|he(19*bI|0,0|kI,0|S,((0|S)<0)<<31>>31|0),Be=vi,vI=0|he(19*XA|0,0|KA,0|S,((0|S)<0)<<31>>31|0),DI=vi,xA=0|he(19*iA|0,0|BA,0|S,((0|S)<0)<<31>>31|0),LA=vi,S=0|he(19*xe|0,0|e,0|S,((0|S)<0)<<31>>31|0),t=vi,M=0|he(0|M,((0|M)<0)<<31>>31|0,0|s,((0|s)<0)<<31>>31|0),m=vi,Le=0|he(19*Le|0,((19*Le|0)<0)<<31>>31|0,s<<1|0,((s<<1|0)<0)<<31>>31|0),Pe=vi,Ae=0|he(19*Ae|0,((19*Ae|0)<0)<<31>>31|0,0|s,((0|s)<0)<<31>>31|0),$I=vi,hI=0|he(19*hI|0,((19*hI|0)<0)<<31>>31|0,s<<1|0,((s<<1|0)<0)<<31>>31|0),sI=vi,MA=0|he(19*MA|0,((19*MA|0)<0)<<31>>31|0,0|s,((0|s)<0)<<31>>31|0),mA=vi,ae=0|he(19*re|0,0|ae,s<<1|0,((s<<1|0)<0)<<31>>31|0),re=vi,kI=0|he(19*bI|0,0|kI,0|s,((0|s)<0)<<31>>31|0),bI=vi,KA=0|he(19*XA|0,0|KA,s<<1|0,((s<<1|0)<0)<<31>>31|0),XA=vi,BA=0|he(19*iA|0,0|BA,0|s,((0|s)<0)<<31>>31|0),iA=vi,s=0|he(19*xe|0,0|e,s<<1|0,((s<<1|0)<0)<<31>>31|0),e=vi,E=0|Ig(0|(le=0|Ig(0|(de=0|Ig(0|(ve=0|Ig(0|(Ge=0|Ig(0|(me=0|Ig(0|(He=0|Ig(0|(Re=0|Ig(0|(Ue=0|Ig(0|Le,0|Pe,0|Je,0|Ue)),0|vi,0|Ne,0|Re)),0|vi,0|Ye,0|He)),0|vi,0|Me,0|me)),0|vi,0|Fe,0|Ge)),0|vi,0|ke,0|ve)),0|vi,0|De,0|de)),0|vi,0|ue,0|le)),0|vi,0|c,0|E),c=vi,ee=0|Ig(0|we,0|pe,0|Ie,0|ee),Ie=vi,R=0|Ig(0|(h=0|Ig(0|(ge=0|Ig(0|(Be=0|Ig(0|(re=0|Ig(0|(ne=0|Ig(0|(oe=0|Ig(0|(Qe=0|Ig(0|(se=0|Ig(0|_e,0|fe,0|ye,0|se)),0|vi,0|Ee,0|Qe)),0|vi,0|ce,0|oe)),0|vi,0|Ce,0|ne)),0|vi,0|ae,0|re)),0|vi,0|te,0|Be)),0|vi,0|ie,0|ge)),0|vi,0|o,0|h)),0|vi,0|I,0|R),I=vi,h=0|be(0|(h=0|Ig(0|E,0|c,33554432,0)),0|vi,26),o=vi,a=0|Ig(0|(a=0|Ig(0|(LI=0|Ig(0|(XI=0|Ig(0|(TI=0|Ig(0|(qI=0|Ig(0|(ZI=0|Ig(0|(zI=0|Ig(0|($I=0|Ig(0|ee,0|Ie,0|Ae,0|$I)),0|vi,0|OI,0|zI)),0|vi,0|WI,0|ZI)),0|vi,0|jI,0|qI)),0|vi,0|VI,0|TI)),0|vi,0|KI,0|XI)),0|vi,0|xI,0|LI)),0|vi,0|n,0|a)),0|vi,0|h,0|o),n=vi,o=0|Ag(0|E,0|c,0|(o=0|Se(0|h,0|o,26)),0|vi),c=vi,E=0|be(0|(E=0|Ig(0|R,0|I,33554432,0)),0|vi,26),h=vi,lA=0|Ig(0|(lA=0|Ig(0|(uI=0|Ig(0|(DI=0|Ig(0|(bI=0|Ig(0|(GI=0|Ig(0|(mI=0|Ig(0|(HI=0|Ig(0|(SI=0|Ig(0|(NI=0|Ig(0|PI,0|JI,0|UI,0|NI)),0|vi,0|RI,0|SI)),0|vi,0|YI,0|HI)),0|vi,0|MI,0|mI)),0|vi,0|FI,0|GI)),0|vi,0|kI,0|bI)),0|vi,0|vI,0|DI)),0|vi,0|dI,0|uI)),0|vi,0|B,0|lA)),0|vi,0|E,0|h),B=vi,h=0|Ag(0|R,0|I,0|(h=0|Se(0|E,0|h,26)),0|vi),I=vi,R=0|be(0|(R=0|Ig(0|a,0|n,16777216,0)),0|vi,25),E=vi,i=0|Ig(0|(i=0|Ig(0|(BI=0|Ig(0|(rI=0|Ig(0|(nI=0|Ig(0|(oI=0|Ig(0|(QI=0|Ig(0|(sI=0|Ig(0|(yI=0|Ig(0|(_I=0|Ig(0|lI,0|wI,0|pI,0|_I)),0|vi,0|fI,0|yI)),0|vi,0|hI,0|sI)),0|vi,0|EI,0|QI)),0|vi,0|cI,0|oI)),0|vi,0|CI,0|nI)),0|vi,0|aI,0|rI)),0|vi,0|tI,0|BI)),0|vi,0|gA,0|i)),0|vi,0|R,0|E),gA=vi,E=0|Ag(0|a,0|n,0|(E=0|Se(0|R,0|E,25)),0|vi),n=vi,a=0|be(0|(a=0|Ig(0|lA,0|B,16777216,0)),0|vi,25),R=vi,r=0|Ig(0|(r=0|Ig(0|(LA=0|Ig(0|(XA=0|Ig(0|(TA=0|Ig(0|(qA=0|Ig(0|(ZA=0|Ig(0|(zA=0|Ig(0|($A=0|Ig(0|(II=0|Ig(0|iI,0|gI,0|eI,0|II)),0|vi,0|AI,0|$A)),0|vi,0|OA,0|zA)),0|vi,0|WA,0|ZA)),0|vi,0|jA,0|qA)),0|vi,0|VA,0|TA)),0|vi,0|KA,0|XA)),0|vi,0|xA,0|LA)),0|vi,0|eA,0|r)),0|vi,0|a,0|R),eA=vi,R=0|Ag(0|lA,0|B,0|(R=0|Se(0|a,0|R,25)),0|vi),B=vi,lA=0|be(0|(lA=0|Ig(0|i,0|gA,33554432,0)),0|vi,26),a=vi,g=0|Ig(0|(g=0|Ig(0|(uA=0|Ig(0|(DA=0|Ig(0|(bA=0|Ig(0|(GA=0|Ig(0|(mA=0|Ig(0|(HA=0|Ig(0|(SA=0|Ig(0|(NA=0|Ig(0|PA,0|JA,0|UA,0|NA)),0|vi,0|RA,0|SA)),0|vi,0|YA,0|HA)),0|vi,0|MA,0|mA)),0|vi,0|FA,0|GA)),0|vi,0|kA,0|bA)),0|vi,0|vA,0|DA)),0|vi,0|dA,0|uA)),0|vi,0|N,0|g)),0|vi,0|lA,0|a),N=vi,a=0|Ag(0|i,0|gA,0|(a=0|Se(0|lA,0|a,26)),0|vi),gA=0|be(0|(gA=0|Ig(0|r,0|eA,33554432,0)),0|vi,26),i=vi,t=0|Ig(0|(t=0|Ig(0|(iA=0|Ig(0|(tA=0|Ig(0|(aA=0|Ig(0|(CA=0|Ig(0|(cA=0|Ig(0|(EA=0|Ig(0|(hA=0|Ig(0|(fA=0|Ig(0|wA,0|pA,0|_A,0|fA)),0|vi,0|yA,0|hA)),0|vi,0|sA,0|EA)),0|vi,0|QA,0|cA)),0|vi,0|oA,0|CA)),0|vi,0|nA,0|aA)),0|vi,0|rA,0|tA)),0|vi,0|BA,0|iA)),0|vi,0|S,0|t)),0|vi,0|gA,0|i),S=vi,i=0|Ag(0|r,0|eA,0|(i=0|Se(0|gA,0|i,26)),0|vi),I=0|Ig(0|(eA=0|be(0|(eA=0|Ig(0|g,0|N,16777216,0)),0|vi,25)),0|(r=vi),0|h,0|I),h=vi,r=0|Ag(0|g,0|N,0|(r=0|Se(0|eA,0|r,25)),0|vi),N=0|be(0|(N=0|Ig(0|t,0|S,16777216,0)),0|vi,25),g=vi,e=0|Ig(0|(e=0|Ig(0|(U=0|Ig(0|(P=0|Ig(0|(x=0|Ig(0|(K=0|Ig(0|(V=0|Ig(0|(j=0|Ig(0|(W=0|Ig(0|(O=0|Ig(0|IA,0|AA,0|$,0|O)),0|vi,0|z,0|W)),0|vi,0|Z,0|j)),0|vi,0|q,0|V)),0|vi,0|T,0|K)),0|vi,0|X,0|x)),0|vi,0|L,0|P)),0|vi,0|J,0|U)),0|vi,0|s,0|e)),0|vi,0|N,0|g),s=vi,g=0|Ag(0|t,0|S,0|(g=0|Se(0|N,0|g,25)),0|vi),B=0|Ig(0|R,0|B,0|(S=0|be(0|(S=0|Ig(0|I,0|h,33554432,0)),0|vi,26)),0|(t=vi)),t=0|Ag(0|I,0|h,0|(t=0|Se(0|S,0|t,26)),0|vi),h=0|be(0|(h=0|Ig(0|e,0|s,33554432,0)),0|vi,26),I=vi,C=0|Ig(0|(C=0|Ig(0|(y=0|Ig(0|(_=0|Ig(0|(w=0|Ig(0|(u=0|Ig(0|(D=0|Ig(0|(b=0|Ig(0|(G=0|Ig(0|(m=0|Ig(0|Y,0|H,0|M,0|m)),0|vi,0|F,0|G)),0|vi,0|k,0|b)),0|vi,0|v,0|D)),0|vi,0|d,0|u)),0|vi,0|l,0|w)),0|vi,0|p,0|_)),0|vi,0|f,0|y)),0|vi,0|Q,0|C)),0|vi,0|h,0|I),Q=vi,I=0|Ag(0|e,0|s,0|(I=0|Se(0|h,0|I,26)),0|vi),c=0|Ig(0|(h=0|he(0|(s=0|be(0|(s=0|Ig(0|C,0|Q,16777216,0)),0|vi,25)),0|(e=vi),19,0)),0|vi,0|o,0|c),o=vi,e=0|Ag(0|C,0|Q,0|(e=0|Se(0|s,0|e,25)),0|vi),n=0|Ig(0|E,0|n,0|(Q=0|be(0|(Q=0|Ig(0|c,0|o,33554432,0)),0|vi,26)),0|(C=vi)),C=0|Ag(0|c,0|o,0|(C=0|Se(0|Q,0|C,26)),0|vi),fi[A>>2]=C,fi[A+4>>2]=n,fi[A+8>>2]=a,fi[A+12>>2]=r,fi[A+16>>2]=t,fi[A+20>>2]=B,fi[A+24>>2]=i,fi[A+28>>2]=g,fi[A+32>>2]=I,fi[A+36>>2]=e}function n(A,I,e){A|=0,e|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0;g=wi,i=wi=wi+63&-64,wi=wi+2048|0,Og(i+1024|0,I|=0),RI(i+1024|0,A),Og(i,i+1024|0),RI(i,e),A=0;do{f=0|fi[i+1024+((4|(I=A<<4))<<3)>>2],w=0|fi[i+1024+((4|I)<<3)+4>>2],u=0|JI(0|fi[i+1024+(I<<3)>>2],0|fi[i+1024+(I<<3)+4>>2],f,w),G=vi,l=0|Ee(fi[i+1024+((12|I)<<3)>>2]^u,fi[i+1024+((12|I)<<3)+4>>2]^G,32),y=vi,y=0|Ee(l^(G=0|JI(u,G,w=0|Ee(f^(v=0|JI(0|fi[i+1024+((8|I)<<3)>>2],0|fi[i+1024+((8|I)<<3)+4>>2],l,y)),w^(E=vi),24),f=vi)),y^(u=vi),16),l=vi,fi[i+1024+((12|I)<<3)>>2]=y,fi[i+1024+((12|I)<<3)+4>>2]=l,E=0|JI(v,E,y,l),v=vi,fi[i+1024+((8|I)<<3)>>2]=E,fi[i+1024+((8|I)<<3)+4>>2]=v,v=0|Ee(w^E,f^v,63),fi[i+1024+((4|I)<<3)>>2]=v,fi[i+1024+((4|I)<<3)+4>>2]=vi,v=0|fi[i+1024+((5|I)<<3)>>2],f=0|fi[i+1024+((5|I)<<3)+4>>2],E=0|JI(0|fi[i+1024+((1|I)<<3)>>2],0|fi[i+1024+((1|I)<<3)+4>>2],v,f),w=vi,h=0|Ee(fi[i+1024+((13|I)<<3)>>2]^E,fi[i+1024+((13|I)<<3)+4>>2]^w,32),C=vi,Q=0|JI(d=0|JI(0|fi[i+1024+((9|I)<<3)>>2],0|fi[i+1024+((9|I)<<3)+4>>2],h,C),Q=vi,C=0|Ee(h^(w=0|JI(E,w,f=0|Ee(v^d,f^Q,24),v=vi)),C^(E=vi),16),h=vi),d=vi,fi[i+1024+((9|I)<<3)>>2]=Q,fi[i+1024+((9|I)<<3)+4>>2]=d,d=0|Ee(f^Q,v^d,63),v=vi,Q=0|fi[i+1024+((6|I)<<3)>>2],f=0|fi[i+1024+((6|I)<<3)+4>>2],t=0|JI(0|fi[i+1024+((2|I)<<3)>>2],0|fi[i+1024+((2|I)<<3)+4>>2],Q,f),s=vi,c=0|Ee(fi[i+1024+((14|I)<<3)>>2]^t,fi[i+1024+((14|I)<<3)+4>>2]^s,32),r=vi,Q=0|Ee((f=0|Ee(Q^(k=0|JI(0|fi[i+1024+((10|I)<<3)>>2],0|fi[i+1024+((10|I)<<3)+4>>2],c,r)),f^(b=vi),24))^(b=0|JI(k,b,r=0|Ee(c^(s=0|JI(t,s,f,Q=vi)),r^(t=vi),16),c=vi)),Q^(k=vi),63),f=vi,a=0|fi[i+1024+((7|I)<<3)>>2],n=0|fi[i+1024+((7|I)<<3)+4>>2],B=0|JI(0|fi[i+1024+((3|I)<<3)>>2],0|fi[i+1024+((3|I)<<3)+4>>2],a,n),o=vi,F=0|Ee(fi[i+1024+((15|I)<<3)>>2]^B,fi[i+1024+((15|I)<<3)+4>>2]^o,32),D=vi,a=0|Ee((n=0|Ee(a^(p=0|JI(0|fi[i+1024+((11|I)<<3)>>2],0|fi[i+1024+((11|I)<<3)+4>>2],F,D)),n^(_=vi),24))^(_=0|JI(p,_,D=0|Ee(F^(o=0|JI(B,o,n,a=vi)),D^(B=vi),16),F=vi)),a^(p=vi),63),n=vi,G=0|JI(u=0|JI(G,u,d,v),G=vi,v=0|Ee(d^(k=0|JI(b,k,F=0|Ee(D^u,F^G,32),D=vi)),v^(b=vi),24),d=vi),u=vi,fi[i+1024+(I<<3)>>2]=G,fi[i+1024+(I<<3)+4>>2]=u,u=0|Ee(F^G,D^u,16),D=vi,fi[i+1024+((15|I)<<3)>>2]=u,fi[i+1024+((15|I)<<3)+4>>2]=D,D=0|JI(k,b,u,D),u=vi,fi[i+1024+((10|I)<<3)>>2]=D,fi[i+1024+((10|I)<<3)+4>>2]=u,u=0|Ee(v^D,d^u,63),fi[i+1024+((5|I)<<3)>>2]=u,fi[i+1024+((5|I)<<3)+4>>2]=vi,w=0|JI(E=0|JI(w,E,Q,f),w=vi,f=0|Ee(Q^(p=0|JI(_,p,l=0|Ee(y^E,l^w,32),y=vi)),f^(_=vi),24),Q=vi),E=vi,fi[i+1024+((1|I)<<3)>>2]=w,fi[i+1024+((1|I)<<3)+4>>2]=E,E=0|Ee(l^w,y^E,16),y=vi,fi[i+1024+((12|I)<<3)>>2]=E,fi[i+1024+((12|I)<<3)+4>>2]=y,y=0|JI(p,_,E,y),E=vi,fi[i+1024+((11|I)<<3)>>2]=y,fi[i+1024+((11|I)<<3)+4>>2]=E,E=0|Ee(f^y,Q^E,63),fi[i+1024+((6|I)<<3)>>2]=E,fi[i+1024+((6|I)<<3)+4>>2]=vi,h=0|Ee(C^(t=0|JI(s,t,a,n)),h^(s=vi),32),C=vi,s=0|JI(t,s,n=0|Ee(a^(E=0|JI(0|fi[i+1024+((8|I)<<3)>>2],0|fi[i+1024+((8|I)<<3)+4>>2],h,C)),n^(Q=vi),24),a=vi),t=vi,fi[i+1024+((2|I)<<3)>>2]=s,fi[i+1024+((2|I)<<3)+4>>2]=t,t=0|Ee(h^s,C^t,16),C=vi,fi[i+1024+((13|I)<<3)>>2]=t,fi[i+1024+((13|I)<<3)+4>>2]=C,C=0|JI(E,Q,t,C),t=vi,fi[i+1024+((8|I)<<3)>>2]=C,fi[i+1024+((8|I)<<3)+4>>2]=t,t=0|Ee(n^C,a^t,63),fi[i+1024+((7|I)<<3)>>2]=t,fi[i+1024+((7|I)<<3)+4>>2]=vi,c=0|Ee(r^(B=0|JI(o,B,t=0|fi[i+1024+((4|I)<<3)>>2],a=0|fi[i+1024+((4|I)<<3)+4>>2])),c^(o=vi),32),r=vi,o=0|JI(B,o,a=0|Ee(t^(C=0|JI(0|fi[i+1024+((9|I)<<3)>>2],0|fi[i+1024+((9|I)<<3)+4>>2],c,r)),a^(n=vi),24),t=vi),B=vi,fi[i+1024+((3|I)<<3)>>2]=o,fi[i+1024+((3|I)<<3)+4>>2]=B,B=0|Ee(c^o,r^B,16),r=vi,fi[i+1024+((14|I)<<3)>>2]=B,fi[i+1024+((14|I)<<3)+4>>2]=r,r=0|JI(C,n,B,r),B=vi,fi[i+1024+((9|I)<<3)>>2]=r,fi[i+1024+((9|I)<<3)+4>>2]=B,B=0|Ee(a^r,t^B,63),fi[i+1024+((4|I)<<3)>>2]=B,fi[i+1024+((4|I)<<3)+4>>2]=vi,A=A+1|0}while(8!=(0|A));A=0;do{h=0|fi[(Q=i+1024+(32+(F=A<<1)<<3)|0)>>2],Q=0|fi[Q+4>>2],C=0|JI(0|fi[i+1024+(F<<3)>>2],0|fi[i+1024+(F<<3)+4>>2],h,Q),B=vi,c=0|Ee(fi[(c=i+1024+(F+96<<3)|0)>>2]^C,fi[c+4>>2]^B,32),y=vi,y=0|Ee(c^(B=0|JI(C,B,Q=0|Ee(h^(a=0|JI(0|fi[(a=i+1024+(F+64<<3)|0)>>2],0|fi[a+4>>2],c,y)),Q^(w=vi),24),h=vi)),y^(C=vi),16),c=vi,fi[(f=i+1024+(F+96<<3)|0)>>2]=y,fi[f+4>>2]=c,w=0|JI(a,w,y,c),a=vi,fi[(f=i+1024+(F+64<<3)|0)>>2]=w,fi[f+4>>2]=a,a=0|Ee(Q^w,h^a,63),fi[(h=i+1024+(F+32<<3)|0)>>2]=a,fi[h+4>>2]=vi,a=0|fi[(h=i+1024+(F+33<<3)|0)>>2],h=0|fi[h+4>>2],w=0|JI(0|fi[i+1024+((1|F)<<3)>>2],0|fi[i+1024+((1|F)<<3)+4>>2],a,h),Q=vi,f=0|Ee(fi[(f=i+1024+(F+97<<3)|0)>>2]^w,fi[f+4>>2]^Q,32),d=vi,k=0|JI(o=0|JI(0|fi[(o=i+1024+(F+65<<3)|0)>>2],0|fi[o+4>>2],f,d),k=vi,d=0|Ee(f^(Q=0|JI(w,Q,h=0|Ee(a^o,h^k,24),a=vi)),d^(w=vi),16),f=vi),o=vi,fi[(p=i+1024+(F+65<<3)|0)>>2]=k,fi[p+4>>2]=o,o=0|Ee(h^k,a^o,63),a=vi,k=i+1024+(F+16<<3)|0,p=0|fi[(h=i+1024+(F+48<<3)|0)>>2],h=0|fi[h+4>>2],k=0|JI(0|fi[k>>2],0|fi[k+4>>2],p,h),_=vi,l=0|Ee(fi[(l=i+1024+(F+112<<3)|0)>>2]^k,fi[l+4>>2]^_,32),b=vi,p=0|Ee((h=0|Ee(p^(t=0|JI(0|fi[(t=i+1024+(F+80<<3)|0)>>2],0|fi[t+4>>2],l,b)),h^(r=vi),24))^(r=0|JI(t,r,b=0|Ee(l^(_=0|JI(k,_,h,p=vi)),b^(k=vi),16),l=vi)),p^(t=vi),63),h=vi,G=i+1024+(F+17<<3)|0,v=0|fi[(D=i+1024+(F+49<<3)|0)>>2],D=0|fi[D+4>>2],G=0|JI(0|fi[G>>2],0|fi[G+4>>2],v,D),u=vi,I=0|Ee(fi[(I=i+1024+(F+113<<3)|0)>>2]^G,fi[I+4>>2]^u,32),n=vi,v=0|Ee((D=0|Ee(v^(E=0|JI(0|fi[(E=i+1024+(F+81<<3)|0)>>2],0|fi[E+4>>2],I,n)),D^(s=vi),24))^(s=0|JI(E,s,n=0|Ee(I^(u=0|JI(G,u,D,v=vi)),n^(G=vi),16),I=vi)),v^(E=vi),63),D=vi,B=0|JI(C=0|JI(B,C,o,a),B=vi,a=0|Ee(o^(t=0|JI(r,t,I=0|Ee(n^C,I^B,32),n=vi)),a^(r=vi),24),o=vi),C=vi,fi[i+1024+(F<<3)>>2]=B,fi[i+1024+(F<<3)+4>>2]=C,C=0|Ee(I^B,n^C,16),n=vi,fi[(B=i+1024+(F+113<<3)|0)>>2]=C,fi[B+4>>2]=n,n=0|JI(t,r,C,n),C=vi,fi[(r=i+1024+(F+80<<3)|0)>>2]=n,fi[r+4>>2]=C,C=0|Ee(a^n,o^C,63),fi[(o=i+1024+(F+33<<3)|0)>>2]=C,fi[o+4>>2]=vi,Q=0|JI(w=0|JI(Q,w,p,h),Q=vi,h=0|Ee(p^(E=0|JI(s,E,c=0|Ee(y^w,c^Q,32),y=vi)),h^(s=vi),24),p=vi),w=vi,fi[i+1024+((1|F)<<3)>>2]=Q,fi[i+1024+((1|F)<<3)+4>>2]=w,w=0|Ee(c^Q,y^w,16),y=vi,fi[(Q=i+1024+(F+96<<3)|0)>>2]=w,fi[Q+4>>2]=y,y=0|JI(E,s,w,y),w=vi,fi[(s=i+1024+(F+81<<3)|0)>>2]=y,fi[s+4>>2]=w,w=0|Ee(h^y,p^w,63),fi[(p=i+1024+(F+48<<3)|0)>>2]=w,fi[p+4>>2]=vi,f=0|Ee(d^(k=0|JI(_,k,v,D)),f^(_=vi),32),d=vi,_=0|JI(k,_,D=0|Ee(v^(p=0|JI(0|fi[(p=i+1024+(F+64<<3)|0)>>2],0|fi[p+4>>2],f,d)),D^(w=vi),24),v=vi),k=vi,fi[(y=i+1024+(F+16<<3)|0)>>2]=_,fi[y+4>>2]=k,k=0|Ee(f^_,d^k,16),d=vi,fi[(_=i+1024+(F+97<<3)|0)>>2]=k,fi[_+4>>2]=d,d=0|JI(p,w,k,d),k=vi,fi[(w=i+1024+(F+64<<3)|0)>>2]=d,fi[w+4>>2]=k,k=0|Ee(D^d,v^k,63),fi[(v=i+1024+(F+49<<3)|0)>>2]=k,fi[v+4>>2]=vi,l=0|Ee(b^(G=0|JI(u,G,k=0|fi[(v=i+1024+(F+32<<3)|0)>>2],v=0|fi[v+4>>2])),l^(u=vi),32),b=vi,u=0|JI(G,u,v=0|Ee(k^(d=0|JI(0|fi[(d=i+1024+(F+65<<3)|0)>>2],0|fi[d+4>>2],l,b)),v^(D=vi),24),k=vi),G=vi,fi[(w=i+1024+(F+17<<3)|0)>>2]=u,fi[w+4>>2]=G,G=0|Ee(l^u,b^G,16),b=vi,fi[(u=i+1024+(F+112<<3)|0)>>2]=G,fi[u+4>>2]=b,b=0|JI(d,D,G,b),G=vi,fi[(D=i+1024+(F+65<<3)|0)>>2]=b,fi[D+4>>2]=G,G=0|Ee(v^b,k^G,63),fi[(F=i+1024+(F+32<<3)|0)>>2]=G,fi[F+4>>2]=vi,A=A+1|0}while(8!=(0|A));Og(e,i),RI(e,i+1024|0),wi=g}function C(A,I,e){A|=0,e|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0;g=wi,i=wi=wi+63&-64,wi=wi+2048|0,Og(i+1024|0,I|=0),RI(i+1024|0,A),Og(i,i+1024|0),A=0;do{f=0|fi[i+1024+((4|(I=A<<4))<<3)>>2],w=0|fi[i+1024+((4|I)<<3)+4>>2],u=0|JI(0|fi[i+1024+(I<<3)>>2],0|fi[i+1024+(I<<3)+4>>2],f,w),G=vi,l=0|Ee(fi[i+1024+((12|I)<<3)>>2]^u,fi[i+1024+((12|I)<<3)+4>>2]^G,32),y=vi,y=0|Ee(l^(G=0|JI(u,G,w=0|Ee(f^(v=0|JI(0|fi[i+1024+((8|I)<<3)>>2],0|fi[i+1024+((8|I)<<3)+4>>2],l,y)),w^(E=vi),24),f=vi)),y^(u=vi),16),l=vi,fi[i+1024+((12|I)<<3)>>2]=y,fi[i+1024+((12|I)<<3)+4>>2]=l,E=0|JI(v,E,y,l),v=vi,fi[i+1024+((8|I)<<3)>>2]=E,fi[i+1024+((8|I)<<3)+4>>2]=v,v=0|Ee(w^E,f^v,63),fi[i+1024+((4|I)<<3)>>2]=v,fi[i+1024+((4|I)<<3)+4>>2]=vi,v=0|fi[i+1024+((5|I)<<3)>>2],f=0|fi[i+1024+((5|I)<<3)+4>>2],E=0|JI(0|fi[i+1024+((1|I)<<3)>>2],0|fi[i+1024+((1|I)<<3)+4>>2],v,f),w=vi,h=0|Ee(fi[i+1024+((13|I)<<3)>>2]^E,fi[i+1024+((13|I)<<3)+4>>2]^w,32),C=vi,Q=0|JI(d=0|JI(0|fi[i+1024+((9|I)<<3)>>2],0|fi[i+1024+((9|I)<<3)+4>>2],h,C),Q=vi,C=0|Ee(h^(w=0|JI(E,w,f=0|Ee(v^d,f^Q,24),v=vi)),C^(E=vi),16),h=vi),d=vi,fi[i+1024+((9|I)<<3)>>2]=Q,fi[i+1024+((9|I)<<3)+4>>2]=d,d=0|Ee(f^Q,v^d,63),v=vi,Q=0|fi[i+1024+((6|I)<<3)>>2],f=0|fi[i+1024+((6|I)<<3)+4>>2],t=0|JI(0|fi[i+1024+((2|I)<<3)>>2],0|fi[i+1024+((2|I)<<3)+4>>2],Q,f),s=vi,c=0|Ee(fi[i+1024+((14|I)<<3)>>2]^t,fi[i+1024+((14|I)<<3)+4>>2]^s,32),r=vi,Q=0|Ee((f=0|Ee(Q^(k=0|JI(0|fi[i+1024+((10|I)<<3)>>2],0|fi[i+1024+((10|I)<<3)+4>>2],c,r)),f^(b=vi),24))^(b=0|JI(k,b,r=0|Ee(c^(s=0|JI(t,s,f,Q=vi)),r^(t=vi),16),c=vi)),Q^(k=vi),63),f=vi,a=0|fi[i+1024+((7|I)<<3)>>2],n=0|fi[i+1024+((7|I)<<3)+4>>2],B=0|JI(0|fi[i+1024+((3|I)<<3)>>2],0|fi[i+1024+((3|I)<<3)+4>>2],a,n),o=vi,F=0|Ee(fi[i+1024+((15|I)<<3)>>2]^B,fi[i+1024+((15|I)<<3)+4>>2]^o,32),D=vi,a=0|Ee((n=0|Ee(a^(p=0|JI(0|fi[i+1024+((11|I)<<3)>>2],0|fi[i+1024+((11|I)<<3)+4>>2],F,D)),n^(_=vi),24))^(_=0|JI(p,_,D=0|Ee(F^(o=0|JI(B,o,n,a=vi)),D^(B=vi),16),F=vi)),a^(p=vi),63),n=vi,G=0|JI(u=0|JI(G,u,d,v),G=vi,v=0|Ee(d^(k=0|JI(b,k,F=0|Ee(D^u,F^G,32),D=vi)),v^(b=vi),24),d=vi),u=vi,fi[i+1024+(I<<3)>>2]=G,fi[i+1024+(I<<3)+4>>2]=u,u=0|Ee(F^G,D^u,16),D=vi,fi[i+1024+((15|I)<<3)>>2]=u,fi[i+1024+((15|I)<<3)+4>>2]=D,D=0|JI(k,b,u,D),u=vi,fi[i+1024+((10|I)<<3)>>2]=D,fi[i+1024+((10|I)<<3)+4>>2]=u,u=0|Ee(v^D,d^u,63),fi[i+1024+((5|I)<<3)>>2]=u,fi[i+1024+((5|I)<<3)+4>>2]=vi,w=0|JI(E=0|JI(w,E,Q,f),w=vi,f=0|Ee(Q^(p=0|JI(_,p,l=0|Ee(y^E,l^w,32),y=vi)),f^(_=vi),24),Q=vi),E=vi,fi[i+1024+((1|I)<<3)>>2]=w,fi[i+1024+((1|I)<<3)+4>>2]=E,E=0|Ee(l^w,y^E,16),y=vi,fi[i+1024+((12|I)<<3)>>2]=E,fi[i+1024+((12|I)<<3)+4>>2]=y,y=0|JI(p,_,E,y),E=vi,fi[i+1024+((11|I)<<3)>>2]=y,fi[i+1024+((11|I)<<3)+4>>2]=E,E=0|Ee(f^y,Q^E,63),fi[i+1024+((6|I)<<3)>>2]=E,fi[i+1024+((6|I)<<3)+4>>2]=vi,h=0|Ee(C^(t=0|JI(s,t,a,n)),h^(s=vi),32),C=vi,s=0|JI(t,s,n=0|Ee(a^(E=0|JI(0|fi[i+1024+((8|I)<<3)>>2],0|fi[i+1024+((8|I)<<3)+4>>2],h,C)),n^(Q=vi),24),a=vi),t=vi,fi[i+1024+((2|I)<<3)>>2]=s,fi[i+1024+((2|I)<<3)+4>>2]=t,t=0|Ee(h^s,C^t,16),C=vi,fi[i+1024+((13|I)<<3)>>2]=t,fi[i+1024+((13|I)<<3)+4>>2]=C,C=0|JI(E,Q,t,C),t=vi,fi[i+1024+((8|I)<<3)>>2]=C,fi[i+1024+((8|I)<<3)+4>>2]=t,t=0|Ee(n^C,a^t,63),fi[i+1024+((7|I)<<3)>>2]=t,fi[i+1024+((7|I)<<3)+4>>2]=vi,c=0|Ee(r^(B=0|JI(o,B,t=0|fi[i+1024+((4|I)<<3)>>2],a=0|fi[i+1024+((4|I)<<3)+4>>2])),c^(o=vi),32),r=vi,o=0|JI(B,o,a=0|Ee(t^(C=0|JI(0|fi[i+1024+((9|I)<<3)>>2],0|fi[i+1024+((9|I)<<3)+4>>2],c,r)),a^(n=vi),24),t=vi),B=vi,fi[i+1024+((3|I)<<3)>>2]=o,fi[i+1024+((3|I)<<3)+4>>2]=B,B=0|Ee(c^o,r^B,16),r=vi,fi[i+1024+((14|I)<<3)>>2]=B,fi[i+1024+((14|I)<<3)+4>>2]=r,r=0|JI(C,n,B,r),B=vi,fi[i+1024+((9|I)<<3)>>2]=r,fi[i+1024+((9|I)<<3)+4>>2]=B,B=0|Ee(a^r,t^B,63),fi[i+1024+((4|I)<<3)>>2]=B,fi[i+1024+((4|I)<<3)+4>>2]=vi,A=A+1|0}while(8!=(0|A));A=0;do{h=0|fi[(Q=i+1024+(32+(F=A<<1)<<3)|0)>>2],Q=0|fi[Q+4>>2],C=0|JI(0|fi[i+1024+(F<<3)>>2],0|fi[i+1024+(F<<3)+4>>2],h,Q),B=vi,c=0|Ee(fi[(c=i+1024+(F+96<<3)|0)>>2]^C,fi[c+4>>2]^B,32),y=vi,y=0|Ee(c^(B=0|JI(C,B,Q=0|Ee(h^(a=0|JI(0|fi[(a=i+1024+(F+64<<3)|0)>>2],0|fi[a+4>>2],c,y)),Q^(w=vi),24),h=vi)),y^(C=vi),16),c=vi,fi[(f=i+1024+(F+96<<3)|0)>>2]=y,fi[f+4>>2]=c,w=0|JI(a,w,y,c),a=vi,fi[(f=i+1024+(F+64<<3)|0)>>2]=w,fi[f+4>>2]=a,a=0|Ee(Q^w,h^a,63),fi[(h=i+1024+(F+32<<3)|0)>>2]=a,fi[h+4>>2]=vi,a=0|fi[(h=i+1024+(F+33<<3)|0)>>2],h=0|fi[h+4>>2],w=0|JI(0|fi[i+1024+((1|F)<<3)>>2],0|fi[i+1024+((1|F)<<3)+4>>2],a,h),Q=vi,f=0|Ee(fi[(f=i+1024+(F+97<<3)|0)>>2]^w,fi[f+4>>2]^Q,32),d=vi,k=0|JI(o=0|JI(0|fi[(o=i+1024+(F+65<<3)|0)>>2],0|fi[o+4>>2],f,d),k=vi,d=0|Ee(f^(Q=0|JI(w,Q,h=0|Ee(a^o,h^k,24),a=vi)),d^(w=vi),16),f=vi),o=vi,fi[(p=i+1024+(F+65<<3)|0)>>2]=k,fi[p+4>>2]=o,o=0|Ee(h^k,a^o,63),a=vi,k=i+1024+(F+16<<3)|0,p=0|fi[(h=i+1024+(F+48<<3)|0)>>2],h=0|fi[h+4>>2],k=0|JI(0|fi[k>>2],0|fi[k+4>>2],p,h),_=vi,l=0|Ee(fi[(l=i+1024+(F+112<<3)|0)>>2]^k,fi[l+4>>2]^_,32),b=vi,p=0|Ee((h=0|Ee(p^(t=0|JI(0|fi[(t=i+1024+(F+80<<3)|0)>>2],0|fi[t+4>>2],l,b)),h^(r=vi),24))^(r=0|JI(t,r,b=0|Ee(l^(_=0|JI(k,_,h,p=vi)),b^(k=vi),16),l=vi)),p^(t=vi),63),h=vi,G=i+1024+(F+17<<3)|0,v=0|fi[(D=i+1024+(F+49<<3)|0)>>2],D=0|fi[D+4>>2],G=0|JI(0|fi[G>>2],0|fi[G+4>>2],v,D),u=vi,I=0|Ee(fi[(I=i+1024+(F+113<<3)|0)>>2]^G,fi[I+4>>2]^u,32),n=vi,v=0|Ee((D=0|Ee(v^(E=0|JI(0|fi[(E=i+1024+(F+81<<3)|0)>>2],0|fi[E+4>>2],I,n)),D^(s=vi),24))^(s=0|JI(E,s,n=0|Ee(I^(u=0|JI(G,u,D,v=vi)),n^(G=vi),16),I=vi)),v^(E=vi),63),D=vi,B=0|JI(C=0|JI(B,C,o,a),B=vi,a=0|Ee(o^(t=0|JI(r,t,I=0|Ee(n^C,I^B,32),n=vi)),a^(r=vi),24),o=vi),C=vi,fi[i+1024+(F<<3)>>2]=B,fi[i+1024+(F<<3)+4>>2]=C,C=0|Ee(I^B,n^C,16),n=vi,fi[(B=i+1024+(F+113<<3)|0)>>2]=C,fi[B+4>>2]=n,n=0|JI(t,r,C,n),C=vi,fi[(r=i+1024+(F+80<<3)|0)>>2]=n,fi[r+4>>2]=C,C=0|Ee(a^n,o^C,63),fi[(o=i+1024+(F+33<<3)|0)>>2]=C,fi[o+4>>2]=vi,Q=0|JI(w=0|JI(Q,w,p,h),Q=vi,h=0|Ee(p^(E=0|JI(s,E,c=0|Ee(y^w,c^Q,32),y=vi)),h^(s=vi),24),p=vi),w=vi,fi[i+1024+((1|F)<<3)>>2]=Q,fi[i+1024+((1|F)<<3)+4>>2]=w,w=0|Ee(c^Q,y^w,16),y=vi,fi[(Q=i+1024+(F+96<<3)|0)>>2]=w,fi[Q+4>>2]=y,y=0|JI(E,s,w,y),w=vi,fi[(s=i+1024+(F+81<<3)|0)>>2]=y,fi[s+4>>2]=w,w=0|Ee(h^y,p^w,63),fi[(p=i+1024+(F+48<<3)|0)>>2]=w,fi[p+4>>2]=vi,f=0|Ee(d^(k=0|JI(_,k,v,D)),f^(_=vi),32),d=vi,_=0|JI(k,_,D=0|Ee(v^(p=0|JI(0|fi[(p=i+1024+(F+64<<3)|0)>>2],0|fi[p+4>>2],f,d)),D^(w=vi),24),v=vi),k=vi,fi[(y=i+1024+(F+16<<3)|0)>>2]=_,fi[y+4>>2]=k,k=0|Ee(f^_,d^k,16),d=vi,fi[(_=i+1024+(F+97<<3)|0)>>2]=k,fi[_+4>>2]=d,d=0|JI(p,w,k,d),k=vi,fi[(w=i+1024+(F+64<<3)|0)>>2]=d,fi[w+4>>2]=k,k=0|Ee(D^d,v^k,63),fi[(v=i+1024+(F+49<<3)|0)>>2]=k,fi[v+4>>2]=vi,l=0|Ee(b^(G=0|JI(u,G,k=0|fi[(v=i+1024+(F+32<<3)|0)>>2],v=0|fi[v+4>>2])),l^(u=vi),32),b=vi,u=0|JI(G,u,v=0|Ee(k^(d=0|JI(0|fi[(d=i+1024+(F+65<<3)|0)>>2],0|fi[d+4>>2],l,b)),v^(D=vi),24),k=vi),G=vi,fi[(w=i+1024+(F+17<<3)|0)>>2]=u,fi[w+4>>2]=G,G=0|Ee(l^u,b^G,16),b=vi,fi[(u=i+1024+(F+112<<3)|0)>>2]=G,fi[u+4>>2]=b,b=0|JI(d,D,G,b),G=vi,fi[(D=i+1024+(F+65<<3)|0)>>2]=b,fi[D+4>>2]=G,G=0|Ee(v^b,k^G,63),fi[(F=i+1024+(F+32<<3)|0)>>2]=G,fi[F+4>>2]=vi,A=A+1|0}while(8!=(0|A));Og(e,i),RI(e,i+1024|0),wi=g}function o(A,I){A|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0,P=0,L=0,x=0,X=0,K=0,T=0,V=0,q=0,j=0,Z=0,W=0,z=0,O=0,$=0,AA=0,IA=0,eA=0,gA=0,iA=0,BA=0,tA=0,rA=0,aA=0,nA=0,CA=0,oA=0,cA=0,QA=0,EA=0,sA=0,hA=0,yA=0,fA=0,_A=0,pA=0,wA=0,lA=0,uA=0,dA=0,DA=0,vA=0,bA=0,kA=0,GA=0,FA=0,mA=0,MA=0,HA=0,YA=0,SA=0,RA=0,NA=0,UA=0,JA=0,PA=0,LA=0,xA=0,XA=0,KA=0,TA=0,VA=0,qA=0,jA=0,ZA=0,WA=0,zA=0,OA=0,$A=0,AI=0,II=0,eI=0;C=0|fi[(I|=0)>>2],c=0|fi[I+4>>2],n=0|fi[I+8>>2],i=0|fi[I+12>>2],_=0|fi[I+16>>2],f=0|fi[I+20>>2],B=0|fi[I+24>>2],p=0|fi[I+28>>2],y=0|fi[I+32>>2],s=0|fi[I+36>>2],AI=0|he(0|C,((0|C)<0)<<31>>31|0,0|C,((0|C)<0)<<31>>31|0),$A=vi,KA=0|he(C<<1|0,0|(Q=((C<<1|0)<0)<<31>>31),0|c,((0|c)<0)<<31>>31|0),XA=vi,UA=0|he(0|n,((0|n)<0)<<31>>31|0,C<<1|0,0|Q),NA=vi,kA=0|he(0|i,((0|i)<0)<<31>>31|0,C<<1|0,0|Q),bA=vi,hA=0|he(0|_,((0|_)<0)<<31>>31|0,C<<1|0,0|Q),sA=vi,tA=0|he(0|f,((0|f)<0)<<31>>31|0,C<<1|0,0|Q),BA=vi,W=0|he(0|B,((0|B)<0)<<31>>31|0,C<<1|0,0|Q),Z=vi,P=0|he(0|p,((0|p)<0)<<31>>31|0,C<<1|0,0|Q),J=vi,F=0|he(0|y,((0|y)<0)<<31>>31|0,C<<1|0,0|Q),G=vi,Q=0|he(0|s,((0|s)<0)<<31>>31|0,C<<1|0,0|Q),C=vi,RA=0|he(c<<1|0,0|(E=((c<<1|0)<0)<<31>>31),0|c,((0|c)<0)<<31>>31|0),SA=vi,vA=0|he(c<<1|0,0|E,0|n,((0|n)<0)<<31>>31|0),DA=vi,pA=0|he(i<<1|0,0|(w=((i<<1|0)<0)<<31>>31),c<<1|0,0|E),_A=vi,CA=0|he(0|_,((0|_)<0)<<31>>31|0,c<<1|0,0|E),nA=vi,O=0|he(f<<1|0,((f<<1|0)<0)<<31>>31|0,c<<1|0,0|E),z=vi,x=0|he(0|B,((0|B)<0)<<31>>31|0,c<<1|0,0|E),L=vi,M=0|he(p<<1|0,((p<<1|0)<0)<<31>>31|0,c<<1|0,0|E),m=vi,o=0|he(0|y,((0|y)<0)<<31>>31|0,c<<1|0,0|E),h=vi,E=0|he(38*s|0,0|(I=((38*s|0)<0)<<31>>31),c<<1|0,0|E),c=vi,fA=0|he(0|n,((0|n)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),yA=vi,aA=0|he(n<<1|0,((n<<1|0)<0)<<31>>31|0,0|i,((0|i)<0)<<31>>31|0),rA=vi,AA=0|he(0|_,((0|_)<0)<<31>>31|0,n<<1|0,((n<<1|0)<0)<<31>>31|0),$=vi,V=0|he(0|f,((0|f)<0)<<31>>31|0,n<<1|0,((n<<1|0)<0)<<31>>31|0),T=vi,U=0|he(0|B,((0|B)<0)<<31>>31|0,n<<1|0,((n<<1|0)<0)<<31>>31|0),N=vi,d=0|he(0|p,((0|p)<0)<<31>>31|0,n<<1|0,((n<<1|0)<0)<<31>>31|0),u=vi,jA=0|he(19*y|0,0|(j=((19*y|0)<0)<<31>>31),n<<1|0,((n<<1|0)<0)<<31>>31|0),qA=vi,n=0|he(38*s|0,0|I,0|n,((0|n)<0)<<31>>31|0),a=vi,eA=0|he(i<<1|0,0|w,0|i,((0|i)<0)<<31>>31|0),IA=vi,K=0|he(i<<1|0,0|w,0|_,((0|_)<0)<<31>>31|0),X=vi,Y=0|he(f<<1|0,((f<<1|0)<0)<<31>>31|0,i<<1|0,0|w),H=vi,k=0|he(0|B,((0|B)<0)<<31>>31|0,i<<1|0,0|w),b=vi,WA=0|he(38*p|0,0|(EA=((38*p|0)<0)<<31>>31),i<<1|0,0|w),ZA=vi,PA=0|he(19*y|0,0|j,i<<1|0,0|w),JA=vi,w=0|he(38*s|0,0|I,i<<1|0,0|w),i=vi,R=0|he(0|_,((0|_)<0)<<31>>31|0,0|_,((0|_)<0)<<31>>31|0),S=vi,v=0|he(_<<1|0,((_<<1|0)<0)<<31>>31|0,0|f,((0|f)<0)<<31>>31|0),D=vi,OA=0|he(19*B|0,((19*B|0)<0)<<31>>31|0,_<<1|0,((_<<1|0)<0)<<31>>31|0),zA=vi,xA=0|he(38*p|0,0|EA,0|_,((0|_)<0)<<31>>31|0),LA=vi,FA=0|he(19*y|0,0|j,_<<1|0,((_<<1|0)<0)<<31>>31|0),GA=vi,_=0|he(38*s|0,0|I,0|_,((0|_)<0)<<31>>31|0),g=vi,eI=0|he(38*f|0,((38*f|0)<0)<<31>>31|0,0|f,((0|f)<0)<<31>>31|0),II=vi,VA=0|he(19*B|0,((19*B|0)<0)<<31>>31|0,f<<1|0,((f<<1|0)<0)<<31>>31|0),TA=vi,MA=0|he(38*p|0,0|EA,f<<1|0,((f<<1|0)<0)<<31>>31|0),mA=vi,lA=0|he(19*y|0,0|j,f<<1|0,((f<<1|0)<0)<<31>>31|0),wA=vi,f=0|he(38*s|0,0|I,f<<1|0,((f<<1|0)<0)<<31>>31|0),e=vi,YA=0|he(19*B|0,((19*B|0)<0)<<31>>31|0,0|B,((0|B)<0)<<31>>31|0),HA=vi,dA=0|he(38*p|0,0|EA,0|B,((0|B)<0)<<31>>31|0),uA=vi,cA=0|he(19*y|0,0|j,B<<1|0,((B<<1|0)<0)<<31>>31|0),oA=vi,B=0|he(38*s|0,0|I,0|B,((0|B)<0)<<31>>31|0),l=vi,EA=0|he(38*p|0,0|EA,0|p,((0|p)<0)<<31>>31|0),QA=vi,iA=0|he(19*y|0,0|j,p<<1|0,((p<<1|0)<0)<<31>>31|0),gA=vi,p=0|he(38*s|0,0|I,p<<1|0,((p<<1|0)<0)<<31>>31|0),r=vi,j=0|he(19*y|0,0|j,0|y,((0|y)<0)<<31>>31|0),q=vi,y=0|he(38*s|0,0|I,0|y,((0|y)<0)<<31>>31|0),t=vi,s=0|he(38*s|0,0|I,0|s,((0|s)<0)<<31>>31|0),I=vi,c=0|Ig(0|(qA=0|Ig(0|(ZA=0|Ig(0|(zA=0|Ig(0|($A=0|Ig(0|eI,0|II,0|AI,0|$A)),0|vi,0|OA,0|zA)),0|vi,0|WA,0|ZA)),0|vi,0|jA,0|qA)),0|vi,0|E,0|c),E=vi,a=0|Ig(0|(JA=0|Ig(0|(LA=0|Ig(0|(XA=0|Ig(0|VA,0|TA,0|KA,0|XA)),0|vi,0|xA,0|LA)),0|vi,0|PA,0|JA)),0|vi,0|n,0|a),n=vi,i=0|Ig(0|(GA=0|Ig(0|(mA=0|Ig(0|(HA=0|Ig(0|(SA=0|Ig(0|UA,0|NA,0|RA,0|SA)),0|vi,0|YA,0|HA)),0|vi,0|MA,0|mA)),0|vi,0|FA,0|GA)),0|vi,0|w,0|i),w=vi,g=0|Ig(0|(wA=0|Ig(0|(uA=0|Ig(0|(DA=0|Ig(0|kA,0|bA,0|vA,0|DA)),0|vi,0|dA,0|uA)),0|vi,0|lA,0|wA)),0|vi,0|_,0|g),_=vi,e=0|Ig(0|(oA=0|Ig(0|(QA=0|Ig(0|(sA=0|Ig(0|(yA=0|Ig(0|pA,0|_A,0|fA,0|yA)),0|vi,0|hA,0|sA)),0|vi,0|EA,0|QA)),0|vi,0|cA,0|oA)),0|vi,0|f,0|e),f=vi,l=0|Ig(0|(gA=0|Ig(0|(BA=0|Ig(0|(rA=0|Ig(0|CA,0|nA,0|aA,0|rA)),0|vi,0|tA,0|BA)),0|vi,0|iA,0|gA)),0|vi,0|B,0|l),B=vi,r=0|Ig(0|(q=0|Ig(0|(Z=0|Ig(0|(z=0|Ig(0|($=0|Ig(0|eA,0|IA,0|AA,0|$)),0|vi,0|O,0|z)),0|vi,0|W,0|Z)),0|vi,0|j,0|q)),0|vi,0|p,0|r),p=vi,t=0|Ig(0|(J=0|Ig(0|(L=0|Ig(0|(X=0|Ig(0|V,0|T,0|K,0|X)),0|vi,0|x,0|L)),0|vi,0|P,0|J)),0|vi,0|y,0|t),y=vi,I=0|Ig(0|(G=0|Ig(0|(m=0|Ig(0|(H=0|Ig(0|(S=0|Ig(0|U,0|N,0|R,0|S)),0|vi,0|Y,0|H)),0|vi,0|M,0|m)),0|vi,0|F,0|G)),0|vi,0|s,0|I),s=vi,C=0|Ig(0|(h=0|Ig(0|(u=0|Ig(0|(D=0|Ig(0|k,0|b,0|v,0|D)),0|vi,0|d,0|u)),0|vi,0|o,0|h)),0|vi,0|Q,0|C),Q=vi,E=0|Se(0|c,0|E,1),c=vi,n=0|Se(0|a,0|n,1),a=vi,w=0|Se(0|i,0|w,1),i=vi,_=0|Se(0|g,0|_,1),g=vi,f=0|Se(0|e,0|f,1),e=vi,B=0|Se(0|l,0|B,1),l=vi,p=0|Se(0|r,0|p,1),r=vi,y=0|Se(0|t,0|y,1),t=vi,s=0|Se(0|I,0|s,1),I=vi,Q=0|Se(0|C,0|Q,1),C=vi,a=0|Ig(0|(h=0|be(0|(h=0|Ig(0|E,0|c,33554432,0)),0|vi,26)),0|(o=vi),0|n,0|a),n=vi,o=0|Ag(0|E,0|c,0|(o=0|Se(0|h,0|o,26)),0|vi),c=vi,l=0|Ig(0|(E=0|be(0|(E=0|Ig(0|f,0|e,33554432,0)),0|vi,26)),0|(h=vi),0|B,0|l),B=vi,h=0|Ag(0|f,0|e,0|(h=0|Se(0|E,0|h,26)),0|vi),e=vi,i=0|Ig(0|(f=0|be(0|(f=0|Ig(0|a,0|n,16777216,0)),0|vi,25)),0|(E=vi),0|w,0|i),w=vi,E=0|Ag(0|a,0|n,0|(E=0|Se(0|f,0|E,25)),0|vi),n=vi,r=0|Ig(0|(a=0|be(0|(a=0|Ig(0|l,0|B,16777216,0)),0|vi,25)),0|(f=vi),0|p,0|r),p=vi,f=0|Ag(0|l,0|B,0|(f=0|Se(0|a,0|f,25)),0|vi),B=vi,g=0|Ig(0|(l=0|be(0|(l=0|Ig(0|i,0|w,33554432,0)),0|vi,26)),0|(a=vi),0|_,0|g),_=vi,a=0|Ag(0|i,0|w,0|(a=0|Se(0|l,0|a,26)),0|vi),t=0|Ig(0|(w=0|be(0|(w=0|Ig(0|r,0|p,33554432,0)),0|vi,26)),0|(i=vi),0|y,0|t),y=vi,i=0|Ag(0|r,0|p,0|(i=0|Se(0|w,0|i,26)),0|vi),e=0|Ig(0|(p=0|be(0|(p=0|Ig(0|g,0|_,16777216,0)),0|vi,25)),0|(r=vi),0|h,0|e),h=vi,r=0|Ag(0|g,0|_,0|(r=0|Se(0|p,0|r,25)),0|vi),I=0|Ig(0|(_=0|be(0|(_=0|Ig(0|t,0|y,16777216,0)),0|vi,25)),0|(g=vi),0|s,0|I),s=vi,g=0|Ag(0|t,0|y,0|(g=0|Se(0|_,0|g,25)),0|vi),B=0|Ig(0|f,0|B,0|(y=0|be(0|(y=0|Ig(0|e,0|h,33554432,0)),0|vi,26)),0|(t=vi)),t=0|Ag(0|e,0|h,0|(t=0|Se(0|y,0|t,26)),0|vi),C=0|Ig(0|(h=0|be(0|(h=0|Ig(0|I,0|s,33554432,0)),0|vi,26)),0|(e=vi),0|Q,0|C),Q=vi,e=0|Ag(0|I,0|s,0|(e=0|Se(0|h,0|e,26)),0|vi),c=0|Ig(0|(h=0|he(0|(s=0|be(0|(s=0|Ig(0|C,0|Q,16777216,0)),0|vi,25)),0|(I=vi),19,0)),0|vi,0|o,0|c),o=vi,I=0|Ag(0|C,0|Q,0|(I=0|Se(0|s,0|I,25)),0|vi),n=0|Ig(0|E,0|n,0|(Q=0|be(0|(Q=0|Ig(0|c,0|o,33554432,0)),0|vi,26)),0|(C=vi)),C=0|Ag(0|c,0|o,0|(C=0|Se(0|Q,0|C,26)),0|vi),fi[A>>2]=C,fi[A+4>>2]=n,fi[A+8>>2]=a,fi[A+12>>2]=r,fi[A+16>>2]=t,fi[A+20>>2]=B,fi[A+24>>2]=i,fi[A+28>>2]=g,fi[A+32>>2]=e,fi[A+36>>2]=I}function c(A,I){A|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0,P=0,L=0,x=0,X=0,K=0,T=0,V=0,q=0,j=0,Z=0,W=0,z=0,O=0,$=0,AA=0,IA=0,eA=0,gA=0,iA=0,BA=0,tA=0,rA=0,aA=0,nA=0,CA=0,oA=0,cA=0,QA=0,EA=0,sA=0,hA=0,yA=0,fA=0,_A=0,pA=0,wA=0,lA=0,uA=0,dA=0,DA=0,vA=0,bA=0,kA=0,GA=0,FA=0,mA=0,MA=0,HA=0,YA=0,SA=0,RA=0,NA=0,UA=0,JA=0,PA=0,LA=0,xA=0,XA=0,KA=0,TA=0,VA=0,qA=0,jA=0,ZA=0,WA=0,zA=0,OA=0,$A=0,AI=0,II=0,eI=0;C=0|fi[(I|=0)>>2],E=0|fi[I+4>>2],n=0|fi[I+8>>2],i=0|fi[I+12>>2],b=0|fi[I+16>>2],e=0|fi[I+20>>2],B=0|fi[I+24>>2],U=0|fi[I+28>>2],D=0|fi[I+32>>2],s=0|fi[I+36>>2],AI=0|he(0|C,((0|C)<0)<<31>>31|0,0|C,((0|C)<0)<<31>>31|0),$A=vi,MA=0|he(C<<1|0,0|(Q=((C<<1|0)<0)<<31>>31),0|E,((0|E)<0)<<31>>31|0),mA=vi,VA=0|he(0|n,((0|n)<0)<<31>>31|0,C<<1|0,0|Q),TA=vi,KA=0|he(0|i,((0|i)<0)<<31>>31|0,C<<1|0,0|Q),XA=vi,UA=0|he(0|b,((0|b)<0)<<31>>31|0,C<<1|0,0|Q),NA=vi,lA=0|he(0|e,((0|e)<0)<<31>>31|0,C<<1|0,0|Q),wA=vi,iA=0|he(0|B,((0|B)<0)<<31>>31|0,C<<1|0,0|Q),gA=vi,L=0|he(0|U,((0|U)<0)<<31>>31|0,C<<1|0,0|Q),P=vi,G=0|he(0|D,((0|D)<0)<<31>>31|0,C<<1|0,0|Q),k=vi,Q=0|he(0|s,((0|s)<0)<<31>>31|0,C<<1|0,0|Q),C=vi,yA=0|he(E<<1|0,0|(c=((E<<1|0)<0)<<31>>31),0|E,((0|E)<0)<<31>>31|0),fA=vi,$=0|he(E<<1|0,0|c,0|n,((0|n)<0)<<31>>31|0),AA=vi,xA=0|he(i<<1|0,0|(J=((i<<1|0)<0)<<31>>31),E<<1|0,0|c),LA=vi,vA=0|he(0|b,((0|b)<0)<<31>>31|0,E<<1|0,0|c),DA=vi,tA=0|he(e<<1|0,((e<<1|0)<0)<<31>>31|0,E<<1|0,0|c),BA=vi,X=0|he(0|B,((0|B)<0)<<31>>31|0,E<<1|0,0|c),x=vi,m=0|he(U<<1|0,((U<<1|0)<0)<<31>>31|0,E<<1|0,0|c),F=vi,f=0|he(0|D,((0|D)<0)<<31>>31|0,E<<1|0,0|c),y=vi,c=0|he(38*s|0,0|(I=((38*s|0)<0)<<31>>31),E<<1|0,0|c),E=vi,PA=0|he(0|n,((0|n)<0)<<31>>31|0,0|n,((0|n)<0)<<31>>31|0),JA=vi,dA=0|he(n<<1|0,((n<<1|0)<0)<<31>>31|0,0|i,((0|i)<0)<<31>>31|0),uA=vi,aA=0|he(0|b,((0|b)<0)<<31>>31|0,n<<1|0,((n<<1|0)<0)<<31>>31|0),rA=vi,q=0|he(0|e,((0|e)<0)<<31>>31|0,n<<1|0,((n<<1|0)<0)<<31>>31|0),V=vi,N=0|he(0|B,((0|B)<0)<<31>>31|0,n<<1|0,((n<<1|0)<0)<<31>>31|0),R=vi,p=0|he(0|U,((0|U)<0)<<31>>31|0,n<<1|0,((n<<1|0)<0)<<31>>31|0),_=vi,jA=0|he(19*D|0,0|(eA=((19*D|0)<0)<<31>>31),n<<1|0,((n<<1|0)<0)<<31>>31|0),qA=vi,n=0|he(38*s|0,0|I,0|n,((0|n)<0)<<31>>31|0),a=vi,CA=0|he(i<<1|0,0|J,0|i,((0|i)<0)<<31>>31|0),nA=vi,T=0|he(i<<1|0,0|J,0|b,((0|b)<0)<<31>>31|0),K=vi,H=0|he(e<<1|0,((e<<1|0)<0)<<31>>31|0,i<<1|0,0|J),M=vi,d=0|he(0|B,((0|B)<0)<<31>>31|0,i<<1|0,0|J),u=vi,WA=0|he(38*U|0,0|(RA=((38*U|0)<0)<<31>>31),i<<1|0,0|J),ZA=vi,kA=0|he(19*D|0,0|eA,i<<1|0,0|J),bA=vi,J=0|he(38*s|0,0|I,i<<1|0,0|J),i=vi,S=0|he(0|b,((0|b)<0)<<31>>31|0,0|b,((0|b)<0)<<31>>31|0),Y=vi,l=0|he(b<<1|0,((b<<1|0)<0)<<31>>31|0,0|e,((0|e)<0)<<31>>31|0),w=vi,OA=0|he(19*B|0,((19*B|0)<0)<<31>>31|0,b<<1|0,((b<<1|0)<0)<<31>>31|0),zA=vi,FA=0|he(38*U|0,0|RA,0|b,((0|b)<0)<<31>>31|0),GA=vi,cA=0|he(19*D|0,0|eA,b<<1|0,((b<<1|0)<0)<<31>>31|0),oA=vi,b=0|he(38*s|0,0|I,0|b,((0|b)<0)<<31>>31|0),g=vi,eI=0|he(38*e|0,((38*e|0)<0)<<31>>31|0,0|e,((0|e)<0)<<31>>31|0),II=vi,YA=0|he(19*B|0,((19*B|0)<0)<<31>>31|0,e<<1|0,((e<<1|0)<0)<<31>>31|0),HA=vi,EA=0|he(38*U|0,0|RA,e<<1|0,((e<<1|0)<0)<<31>>31|0),QA=vi,W=0|he(19*D|0,0|eA,e<<1|0,((e<<1|0)<0)<<31>>31|0),Z=vi,e=0|he(38*s|0,0|I,e<<1|0,((e<<1|0)<0)<<31>>31|0),v=vi,hA=0|he(19*B|0,((19*B|0)<0)<<31>>31|0,0|B,((0|B)<0)<<31>>31|0),sA=vi,O=0|he(38*U|0,0|RA,0|B,((0|B)<0)<<31>>31|0),z=vi,o=0|he(19*D|0,0|eA,B<<1|0,((B<<1|0)<0)<<31>>31|0),h=vi,B=0|he(38*s|0,0|I,0|B,((0|B)<0)<<31>>31|0),j=vi,RA=0|he(38*U|0,0|RA,0|U,((0|U)<0)<<31>>31|0),SA=vi,pA=0|he(19*D|0,0|eA,U<<1|0,((U<<1|0)<0)<<31>>31|0),_A=vi,U=0|he(38*s|0,0|I,U<<1|0,((U<<1|0)<0)<<31>>31|0),r=vi,eA=0|he(19*D|0,0|eA,0|D,((0|D)<0)<<31>>31|0),IA=vi,D=0|he(38*s|0,0|I,0|D,((0|D)<0)<<31>>31|0),t=vi,s=0|he(38*s|0,0|I,0|s,((0|s)<0)<<31>>31|0),I=vi,E=0|Ig(0|(qA=0|Ig(0|(ZA=0|Ig(0|(zA=0|Ig(0|($A=0|Ig(0|eI,0|II,0|AI,0|$A)),0|vi,0|OA,0|zA)),0|vi,0|WA,0|ZA)),0|vi,0|jA,0|qA)),0|vi,0|c,0|E),c=vi,fA=0|Ig(0|VA,0|TA,0|yA,0|fA),yA=vi,AA=0|Ig(0|KA,0|XA,0|$,0|AA),$=vi,v=0|Ig(0|(h=0|Ig(0|(SA=0|Ig(0|(NA=0|Ig(0|(JA=0|Ig(0|xA,0|LA,0|PA,0|JA)),0|vi,0|UA,0|NA)),0|vi,0|RA,0|SA)),0|vi,0|o,0|h)),0|vi,0|e,0|v),e=vi,h=0|be(0|(h=0|Ig(0|E,0|c,33554432,0)),0|vi,26),o=vi,a=0|Ig(0|(a=0|Ig(0|(bA=0|Ig(0|(GA=0|Ig(0|(mA=0|Ig(0|YA,0|HA,0|MA,0|mA)),0|vi,0|FA,0|GA)),0|vi,0|kA,0|bA)),0|vi,0|n,0|a)),0|vi,0|h,0|o),n=vi,o=0|Ag(0|E,0|c,0|(o=0|Se(0|h,0|o,26)),0|vi),c=vi,E=0|be(0|(E=0|Ig(0|v,0|e,33554432,0)),0|vi,26),h=vi,j=0|Ig(0|(j=0|Ig(0|(_A=0|Ig(0|(wA=0|Ig(0|(uA=0|Ig(0|vA,0|DA,0|dA,0|uA)),0|vi,0|lA,0|wA)),0|vi,0|pA,0|_A)),0|vi,0|B,0|j)),0|vi,0|E,0|h),B=vi,h=0|Ag(0|v,0|e,0|(h=0|Se(0|E,0|h,26)),0|vi),e=vi,v=0|be(0|(v=0|Ig(0|a,0|n,16777216,0)),0|vi,25),E=vi,i=0|Ig(0|(i=0|Ig(0|(oA=0|Ig(0|(QA=0|Ig(0|(sA=0|Ig(0|fA,0|yA,0|hA,0|sA)),0|vi,0|EA,0|QA)),0|vi,0|cA,0|oA)),0|vi,0|J,0|i)),0|vi,0|v,0|E),J=vi,E=0|Ag(0|a,0|n,0|(E=0|Se(0|v,0|E,25)),0|vi),n=vi,a=0|be(0|(a=0|Ig(0|j,0|B,16777216,0)),0|vi,25),v=vi,r=0|Ig(0|(r=0|Ig(0|(IA=0|Ig(0|(gA=0|Ig(0|(BA=0|Ig(0|(rA=0|Ig(0|CA,0|nA,0|aA,0|rA)),0|vi,0|tA,0|BA)),0|vi,0|iA,0|gA)),0|vi,0|eA,0|IA)),0|vi,0|U,0|r)),0|vi,0|a,0|v),U=vi,v=0|Ag(0|j,0|B,0|(v=0|Se(0|a,0|v,25)),0|vi),B=vi,j=0|be(0|(j=0|Ig(0|i,0|J,33554432,0)),0|vi,26),a=vi,g=0|Ig(0|(g=0|Ig(0|(Z=0|Ig(0|(z=0|Ig(0|AA,0|$,0|O,0|z)),0|vi,0|W,0|Z)),0|vi,0|b,0|g)),0|vi,0|j,0|a),b=vi,a=0|Ag(0|i,0|J,0|(a=0|Se(0|j,0|a,26)),0|vi),J=0|be(0|(J=0|Ig(0|r,0|U,33554432,0)),0|vi,26),i=vi,t=0|Ig(0|(t=0|Ig(0|(P=0|Ig(0|(x=0|Ig(0|(K=0|Ig(0|q,0|V,0|T,0|K)),0|vi,0|X,0|x)),0|vi,0|L,0|P)),0|vi,0|D,0|t)),0|vi,0|J,0|i),D=vi,i=0|Ag(0|r,0|U,0|(i=0|Se(0|J,0|i,26)),0|vi),e=0|Ig(0|(U=0|be(0|(U=0|Ig(0|g,0|b,16777216,0)),0|vi,25)),0|(r=vi),0|h,0|e),h=vi,r=0|Ag(0|g,0|b,0|(r=0|Se(0|U,0|r,25)),0|vi),b=0|be(0|(b=0|Ig(0|t,0|D,16777216,0)),0|vi,25),g=vi,I=0|Ig(0|(I=0|Ig(0|(k=0|Ig(0|(F=0|Ig(0|(M=0|Ig(0|(Y=0|Ig(0|N,0|R,0|S,0|Y)),0|vi,0|H,0|M)),0|vi,0|m,0|F)),0|vi,0|G,0|k)),0|vi,0|s,0|I)),0|vi,0|b,0|g),s=vi,g=0|Ag(0|t,0|D,0|(g=0|Se(0|b,0|g,25)),0|vi),B=0|Ig(0|v,0|B,0|(D=0|be(0|(D=0|Ig(0|e,0|h,33554432,0)),0|vi,26)),0|(t=vi)),t=0|Ag(0|e,0|h,0|(t=0|Se(0|D,0|t,26)),0|vi),h=0|be(0|(h=0|Ig(0|I,0|s,33554432,0)),0|vi,26),e=vi,C=0|Ig(0|(C=0|Ig(0|(y=0|Ig(0|(_=0|Ig(0|(w=0|Ig(0|d,0|u,0|l,0|w)),0|vi,0|p,0|_)),0|vi,0|f,0|y)),0|vi,0|Q,0|C)),0|vi,0|h,0|e),Q=vi,e=0|Ag(0|I,0|s,0|(e=0|Se(0|h,0|e,26)),0|vi),c=0|Ig(0|(h=0|he(0|(s=0|be(0|(s=0|Ig(0|C,0|Q,16777216,0)),0|vi,25)),0|(I=vi),19,0)),0|vi,0|o,0|c),o=vi,I=0|Ag(0|C,0|Q,0|(I=0|Se(0|s,0|I,25)),0|vi),n=0|Ig(0|E,0|n,0|(Q=0|be(0|(Q=0|Ig(0|c,0|o,33554432,0)),0|vi,26)),0|(C=vi)),C=0|Ag(0|c,0|o,0|(C=0|Se(0|Q,0|C,26)),0|vi),fi[A>>2]=C,fi[A+4>>2]=n,fi[A+8>>2]=a,fi[A+12>>2]=r,fi[A+16>>2]=t,fi[A+20>>2]=B,fi[A+24>>2]=i,fi[A+28>>2]=g,fi[A+32>>2]=e,fi[A+36>>2]=I}function Q(A){var I=0,e=0,g=0,i=0,B=0,t=0,r=0,a=0;if(A|=0){I=0|fi[8686],a=A+-8+(-8&(e=0|fi[A+-4>>2]))|0;do{if(1&e)r=A+-8|0,I=-8&e,t=A+-8|0;else{if(g=0|fi[A+-8>>2],!(3&e))return;if(t=A+-8+(0-g)|0,B=g+(-8&e)|0,t>>>0<I>>>0)return;if((0|t)==(0|fi[8687])){if(3!=(3&(A=0|fi[a+4>>2])|0)){r=t,I=B;break}return fi[8684]=B,fi[a+4>>2]=-2&A,fi[t+4>>2]=1|B,void(fi[t+B>>2]=B)}if(g>>>0<256){if(A=0|fi[t+8>>2],(0|(I=0|fi[t+12>>2]))==(0|A)){fi[8682]=fi[8682]&~(1<<(g>>>3)),r=t,I=B;break}fi[A+12>>2]=I,fi[I+8>>2]=A,r=t,I=B;break}i=0|fi[t+24>>2],A=0|fi[t+12>>2];do{if((0|A)==(0|t)){if(A=0|fi[t+16+4>>2])g=t+16+4|0;else{if(!(A=0|fi[t+16>>2])){A=0;break}g=t+16|0}for(;;)if(I=A+20|0,0|(e=0|fi[I>>2]))A=e,g=I;else{if(I=A+16|0,!(e=0|fi[I>>2]))break;A=e,g=I}fi[g>>2]=0}else r=0|fi[t+8>>2],fi[r+12>>2]=A,fi[A+8>>2]=r}while(0);if(i){if(I=0|fi[t+28>>2],(0|t)==(0|fi[35032+(I<<2)>>2])){if(fi[35032+(I<<2)>>2]=A,!A){fi[8683]=fi[8683]&~(1<<I),r=t,I=B;break}}else if(fi[i+16+(((0|fi[i+16>>2])!=(0|t)&1)<<2)>>2]=A,!A){r=t,I=B;break}fi[A+24>>2]=i,0|(I=0|fi[t+16>>2])&&(fi[A+16>>2]=I,fi[I+24>>2]=A),(I=0|fi[t+16+4>>2])?(fi[A+20>>2]=I,fi[I+24>>2]=A,r=t,I=B):(r=t,I=B)}else r=t,I=B}}while(0);if(!(t>>>0>=a>>>0)&&1&(e=0|fi[a+4>>2])){if(2&e)fi[a+4>>2]=-2&e,fi[r+4>>2]=1|I,fi[t+I>>2]=I,i=I;else{if(A=0|fi[8687],(0|a)==(0|fi[8688])){if(a=(0|fi[8685])+I|0,fi[8685]=a,fi[8688]=r,fi[r+4>>2]=1|a,(0|r)!=(0|A))return;return fi[8687]=0,void(fi[8684]=0)}if((0|a)==(0|A))return a=(0|fi[8684])+I|0,fi[8684]=a,fi[8687]=t,fi[r+4>>2]=1|a,void(fi[t+a>>2]=a);i=(-8&e)+I|0;do{if(e>>>0<256){if(I=0|fi[a+8>>2],(0|(A=0|fi[a+12>>2]))==(0|I)){fi[8682]=fi[8682]&~(1<<(e>>>3));break}fi[I+12>>2]=A,fi[A+8>>2]=I;break}B=0|fi[a+24>>2],A=0|fi[a+12>>2];do{if((0|A)==(0|a)){if(A=0|fi[a+16+4>>2])g=a+16+4|0;else{if(!(A=0|fi[a+16>>2])){I=0;break}g=a+16|0}for(;;)if(I=A+20|0,0|(e=0|fi[I>>2]))A=e,g=I;else{if(I=A+16|0,!(e=0|fi[I>>2]))break;A=e,g=I}fi[g>>2]=0,I=A}else I=0|fi[a+8>>2],fi[I+12>>2]=A,fi[A+8>>2]=I,I=A}while(0);if(0|B){if(A=0|fi[a+28>>2],(0|a)==(0|fi[35032+(A<<2)>>2])){if(fi[35032+(A<<2)>>2]=I,!I){fi[8683]=fi[8683]&~(1<<A);break}}else if(fi[B+16+(((0|fi[B+16>>2])!=(0|a)&1)<<2)>>2]=I,!I)break;fi[I+24>>2]=B,0|(A=0|fi[a+16>>2])&&(fi[I+16>>2]=A,fi[A+24>>2]=I),0|(A=0|fi[a+16+4>>2])&&(fi[I+20>>2]=A,fi[A+24>>2]=I)}}while(0);if(fi[r+4>>2]=1|i,fi[t+i>>2]=i,(0|r)==(0|fi[8687]))return void(fi[8684]=i)}if(e=i>>>3,i>>>0<256)return(A=0|fi[8682])&1<<e?(A=0|fi[34768+(e<<1<<2)+8>>2],I=34768+(e<<1<<2)+8|0):(fi[8682]=A|1<<e,A=34768+(e<<1<<2)|0,I=34768+(e<<1<<2)+8|0),fi[I>>2]=r,fi[A+12>>2]=r,fi[r+8>>2]=A,void(fi[r+12>>2]=34768+(e<<1<<2));g=35032+((A=(A=i>>>8)?i>>>0>16777215?31:i>>>(7+(A=14-((520192+(A<<((A+1048320|0)>>>16&8))|0)>>>16&4|(A+1048320|0)>>>16&8|(245760+(a=A<<((A+1048320|0)>>>16&8)<<((520192+(A<<((A+1048320|0)>>>16&8))|0)>>>16&4))|0)>>>16&2)+(a<<((a+245760|0)>>>16&2)>>>15)|0)|0)&1|A<<1:0)<<2)|0,fi[r+28>>2]=A,fi[r+20>>2]=0,fi[r+16>>2]=0,I=0|fi[8683],e=1<<A;do{if(I&e){for(I=i<<(31==(0|A)?0:25-(A>>>1)|0),e=0|fi[g>>2];;){if((-8&fi[e+4>>2]|0)==(0|i)){A=73;break}if(g=e+16+(I>>>31<<2)|0,!(A=0|fi[g>>2])){A=72;break}I<<=1,e=A}if(72==(0|A)){fi[g>>2]=r,fi[r+24>>2]=e,fi[r+12>>2]=r,fi[r+8>>2]=r;break}if(73==(0|A)){a=0|fi[(t=e+8|0)>>2],fi[a+12>>2]=r,fi[t>>2]=r,fi[r+8>>2]=a,fi[r+12>>2]=e,fi[r+24>>2]=0;break}}else fi[8683]=I|e,fi[g>>2]=r,fi[r+24>>2]=g,fi[r+12>>2]=r,fi[r+8>>2]=r}while(0);if(a=(0|fi[8690])-1|0,fi[8690]=a,!a){for(A=35184;A=0|fi[A>>2];)A=A+8|0;fi[8690]=-1}}}}function E(A,I){I|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0;e=0|fi[4+(A|=0)>>2];do{if(1&e)a=A,e=I;else{if(r=0|fi[A>>2],!(3&e))return;if((A+(0-r)|0)==(0|fi[8687])){if(3!=(3&(e=0|fi[A+I+4>>2])|0)){a=A+(0-r)|0,e=r+I|0;break}return fi[8684]=r+I,fi[A+I+4>>2]=-2&e,fi[A+(0-r)+4>>2]=r+I|1,void(fi[A+(0-r)+(r+I)>>2]=r+I)}if(r>>>0<256){if(e=0|fi[A+(0-r)+8>>2],(0|(g=0|fi[A+(0-r)+12>>2]))==(0|e)){fi[8682]=fi[8682]&~(1<<(r>>>3)),a=A+(0-r)|0,e=r+I|0;break}fi[e+12>>2]=g,fi[g+8>>2]=e,a=A+(0-r)|0,e=r+I|0;break}t=0|fi[A+(0-r)+24>>2],e=0|fi[A+(0-r)+12>>2];do{if((0|e)==(A+(0-r)|0)){if(g=A+(0-r)+16|0,e=0|fi[g+4>>2])g=g+4|0;else if(!(e=0|fi[g>>2])){e=0;break}for(;;)if(i=e+20|0,0|(B=0|fi[i>>2]))e=B,g=i;else{if(i=e+16|0,!(B=0|fi[i>>2]))break;e=B,g=i}fi[g>>2]=0}else a=0|fi[A+(0-r)+8>>2],fi[a+12>>2]=e,fi[e+8>>2]=a}while(0);if(t){if(g=0|fi[A+(0-r)+28>>2],(A+(0-r)|0)==(0|fi[35032+(g<<2)>>2])){if(fi[35032+(g<<2)>>2]=e,!e){fi[8683]=fi[8683]&~(1<<g),a=A+(0-r)|0,e=r+I|0;break}}else if(fi[t+16+(((0|fi[t+16>>2])!=(A+(0-r)|0)&1)<<2)>>2]=e,!e){a=A+(0-r)|0,e=r+I|0;break}fi[e+24>>2]=t,0|(g=0|fi[A+(0-r)+16>>2])&&(fi[e+16>>2]=g,fi[g+24>>2]=e),(g=0|fi[A+(0-r)+16+4>>2])?(fi[e+20>>2]=g,fi[g+24>>2]=e,a=A+(0-r)|0,e=r+I|0):(a=A+(0-r)|0,e=r+I|0)}else a=A+(0-r)|0,e=r+I|0}}while(0);if(2&(i=0|fi[A+I+4>>2]))fi[A+I+4>>2]=-2&i,fi[a+4>>2]=1|e,fi[a+e>>2]=e,t=e;else{if(g=0|fi[8687],(A+I|0)==(0|fi[8688])){if(I=(0|fi[8685])+e|0,fi[8685]=I,fi[8688]=a,fi[a+4>>2]=1|I,(0|a)!=(0|g))return;return fi[8687]=0,void(fi[8684]=0)}if((A+I|0)==(0|g))return I=(0|fi[8684])+e|0,fi[8684]=I,fi[8687]=a,fi[a+4>>2]=1|I,void(fi[a+I>>2]=I);t=(-8&i)+e|0;do{if(i>>>0<256){if(g=0|fi[A+I+8>>2],(0|(e=0|fi[A+I+12>>2]))==(0|g)){fi[8682]=fi[8682]&~(1<<(i>>>3));break}fi[g+12>>2]=e,fi[e+8>>2]=g;break}r=0|fi[A+I+24>>2],e=0|fi[A+I+12>>2];do{if((0|e)==(A+I|0)){if(e=0|fi[A+I+16+4>>2])B=A+I+16+4|0;else{if(!(e=0|fi[A+I+16>>2])){g=0;break}B=A+I+16|0}for(;;)if(g=e+20|0,0|(i=0|fi[g>>2]))e=i,B=g;else{if(g=e+16|0,!(i=0|fi[g>>2]))break;e=i,B=g}fi[B>>2]=0,g=e}else g=0|fi[A+I+8>>2],fi[g+12>>2]=e,fi[e+8>>2]=g,g=e}while(0);if(0|r){if(e=0|fi[A+I+28>>2],(A+I|0)==(0|fi[35032+(e<<2)>>2])){if(fi[35032+(e<<2)>>2]=g,!g){fi[8683]=fi[8683]&~(1<<e);break}}else if(fi[r+16+(((0|fi[r+16>>2])!=(A+I|0)&1)<<2)>>2]=g,!g)break;fi[g+24>>2]=r,0|(e=0|fi[A+I+16>>2])&&(fi[g+16>>2]=e,fi[e+24>>2]=g),0|(e=0|fi[A+I+16+4>>2])&&(fi[g+20>>2]=e,fi[e+24>>2]=g)}}while(0);if(fi[a+4>>2]=1|t,fi[a+t>>2]=t,(0|a)==(0|fi[8687]))return void(fi[8684]=t)}if(i=t>>>3,t>>>0<256)return(e=0|fi[8682])&1<<i?(e=0|fi[34768+(i<<1<<2)+8>>2],g=34768+(i<<1<<2)+8|0):(fi[8682]=e|1<<i,e=34768+(i<<1<<2)|0,g=34768+(i<<1<<2)+8|0),fi[g>>2]=a,fi[e+12>>2]=a,fi[a+8>>2]=e,void(fi[a+12>>2]=34768+(i<<1<<2));if(e=t>>>8,e=e?t>>>0>16777215?31:t>>>(7+(e=14-((520192+(e<<((e+1048320|0)>>>16&8))|0)>>>16&4|(e+1048320|0)>>>16&8|(245760+(I=e<<((e+1048320|0)>>>16&8)<<((520192+(e<<((e+1048320|0)>>>16&8))|0)>>>16&4))|0)>>>16&2)+(I<<((I+245760|0)>>>16&2)>>>15)|0)|0)&1|e<<1:0,B=35032+(e<<2)|0,fi[a+28>>2]=e,fi[a+20>>2]=0,fi[a+16>>2]=0,g=0|fi[8683],i=1<<e,!(g&i))return fi[8683]=g|i,fi[B>>2]=a,fi[a+24>>2]=B,fi[a+12>>2]=a,void(fi[a+8>>2]=a);for(g=t<<(31==(0|e)?0:25-(e>>>1)|0),i=0|fi[B>>2];;){if((-8&fi[i+4>>2]|0)==(0|t)){e=69;break}if(B=i+16+(g>>>31<<2)|0,!(e=0|fi[B>>2])){e=68;break}g<<=1,i=e}return 68==(0|e)?(fi[B>>2]=a,fi[a+24>>2]=i,fi[a+12>>2]=a,void(fi[a+8>>2]=a)):69==(0|e)?(A=i+8|0,I=0|fi[A>>2],fi[I+12>>2]=a,fi[A>>2]=a,fi[a+8>>2]=I,fi[a+12>>2]=i,void(fi[a+24>>2]=0)):void 0}function s(A,I,e,g,i){A|=0,I|=0,e|=0,g|=0;var B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0;if(o=0|oe(i|=0),Q=vi,B=0|oe(i+8|0),t=vi,g=0|Se(0|e,0|g,56),i=vi,(I+e+(0-(7&e))|0)==(0|I))s=2037671283^B,a=1952801890^t,c=1886610805^o,n=1936682341^Q,r=1852075885^B,h=1685025377^t,t=1852142177^o,B=1819895653^Q;else for(y=I,s=2037671283^B,a=1952801890^t,c=1886610805^o,C=1936682341^Q,n=1852075885^B,r=1685025377^t,t=1852142177^o,B=1819895653^Q;;){if(E=0|oe(y),f=vi,p=E^s,a^=f,C=0|Ig(0|c,0|C,0|n,0|r),h=vi,c=0|se(n,r,13),n=vi^h,h=0|se(C,h,32),s=vi,o=0|Ig(0|p,0|a,0|t,0|B),Q=vi,a=0|se(p,a,16),r=vi^Q,s=0|Ig(a^o|0,0|r,0|h,0|s),h=vi,r=0|se(a^o,r,21),a=h^vi,Q=0|Ig(0|o,0|Q,c^C|0,0|n),o=vi,n=0|se(c^C,n,17),B=vi^o,o=0|se(Q,o,32),t=vi,h=0|Ig(n^Q|0,0|B,0|s,0|h),C=vi,B=0|se(n^Q,B,13),Q=vi^C,C=0|se(h,C,32),n=vi,t=0|Ig(0|o,0|t,s^r|0,0|a),o=vi,a=0|se(s^r,a,16),r=vi^o,n=0|Ig(a^t|0,0|r,0|C,0|n),C=vi,r=0|se(a^t,r,21),a=C^vi,o=0|Ig(B^h|0,0|Q,0|t,0|o),t=vi,Q=0|se(B^h,Q,17),h=vi^t,t=0|se(o,t,32),B=vi,(0|(y=y+8|0))==(I+e+(0-(7&e))|0)){I=I+e+(0-(7&e))|0,s=n^r,c=n^E,n=C^f,r=Q^o;break}s=n^r,c=n^E,C^=f,n=Q^o,r=h}switch(7&e){case 7:g=0|Se(0|_i[I+6>>0],0,48)|g,i|=vi,_=5;break;case 6:_=5;break;case 5:_=6;break;case 4:_=7;break;case 3:_=8;break;case 2:_=9;break;case 1:_=10}5==(0|_)&&(p=0|Se(0|_i[I+5>>0],0,40),i|=vi,g|=p,_=6),6==(0|_)&&(i=0|_i[I+4>>0]|i,_=7),7==(0|_)&&(g|=p=0|Se(0|_i[I+3>>0],0,24),i|=vi,_=8),8==(0|_)&&(g|=p=0|Se(0|_i[I+2>>0],0,16),i|=vi,_=9),9==(0|_)&&(g|=p=0|Se(0|_i[I+1>>0],0,8),i|=vi,_=10),10==(0|_)&&(g=0|_i[I>>0]|g),y=g^s,e=i^a,Q=0|Ig(0|c,0|n,0|r,0|h),E=vi,s=0|se(r,h,13),I=vi^E,E=0|se(Q,E,32),_=vi,f=0|Ig(0|y,0|e,0|t,0|B),p=vi,_=0|Ig((h=0|se(y,e,16))^f|0,0|(e=vi^p),0|E,0|_),E=vi,e=0|se(h^f,e,21),h=E^vi,p=0|Ig(0|f,0|p,s^Q|0,0|I),f=vi,I=0|se(s^Q,I,17),Q=vi^f,f=0|se(p,f,32),s=vi,E=0|Ig(I^p|0,0|Q,0|_,0|E),y=vi,Q=0|se(I^p,Q,13),p=vi^y,y=0|se(E,y,32),I=vi,s=0|Ig(0|f,0|s,_^e|0,0|h),f=vi,I=0|Ig((h=0|se(_^e,h,16))^s|0,0|(e=vi^f),0|y,0|I),y=vi,e=0|se(h^s,e,21),h=y^vi,f=0|Ig(Q^E|0,0|p,0|s,0|f),s=vi,p=0|se(Q^E,p,17),E=vi^s,s=0|se(f,s,32),Q=vi,y=0|Ig(I^g|0,y^i|0,p^f|0,0|E),_=vi,E=0|se(p^f,E,13),f=vi^_,_=0|se(y,_,32),p=vi,Q=0|Ig(255^s|0,0|Q,I^e|0,0|h),s=vi,p=0|Ig((h=0|se(I^e,h,16))^Q|0,0|(e=vi^s),0|_,0|p),_=vi,e=0|se(h^Q,e,21),h=_^vi,s=0|Ig(0|Q,0|s,E^y|0,0|f),Q=vi,f=0|se(E^y,f,17),y=vi^Q,Q=0|se(s,Q,32),E=vi,_=0|Ig(f^s|0,0|y,0|p,0|_),I=vi,y=0|se(f^s,y,13),s=vi^I,I=0|se(_,I,32),f=vi,E=0|Ig(0|Q,0|E,p^e|0,0|h),Q=vi,f=0|Ig((h=0|se(p^e,h,16))^E|0,0|(e=vi^Q),0|I,0|f),I=vi,e=0|se(h^E,e,21),h=I^vi,Q=0|Ig(y^_|0,0|s,0|E,0|Q),E=vi,s=0|se(y^_,s,17),_=vi^E,E=0|se(Q,E,32),y=vi,I=0|Ig(s^Q|0,0|_,0|f,0|I),p=vi,_=0|se(s^Q,_,13),Q=vi^p,p=0|se(I,p,32),s=vi,y=0|Ig(0|E,0|y,f^e|0,0|h),E=vi,s=0|Ig((h=0|se(f^e,h,16))^y|0,0|(e=vi^E),0|p,0|s),p=vi,e=0|se(h^y,e,21),h=p^vi,E=0|Ig(_^I|0,0|Q,0|y,0|E),y=vi,Q=0|se(_^I,Q,17),I=vi^y,y=0|se(E,y,32),_=vi,p=0|Ig(Q^E|0,0|I,0|s,0|p),f=vi,I=0|se(Q^E,I,13),f^=vi,_=0|Ig(0|y,0|_,s^e|0,0|h),y=vi,h=0|se((h=0|se(s^e,h,16))^_,vi^y,21),e=vi,y=0|Ig(I^p|0,0|f,0|_,0|y),_=vi,f=0|se(I^p,f,17),p=vi,WI(A,h^y^f^(I=0|se(y,_,32)),e^_^p^vi)}function h(A,I,e,g,i){A|=0,I|=0,e|=0;var B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0,P=0,L=0,x=0,X=0,K=0,T=0,V=0,q=0,j=0,Z=0,W=0,z=0,O=0,$=0,AA=0,IA=0,eA=0,gA=0,iA=0,BA=0,tA=0,rA=0,aA=0,nA=0;if(L=wi,P=wi=wi+63&-64,wi=wi+64|0,!(0==(0|(g|=0))&0==(0|(i|=0)))){for(i>>>0>0|0==(0|i)&g>>>0>4294967295&&hi(),v=0|fi[A>>2],b=0|fi[A+4>>2],k=0|fi[A+8>>2],G=0|fi[A+12>>2],F=0|fi[A+16>>2],m=0|fi[A+20>>2],M=0|fi[A+24>>2],H=0|fi[A+28>>2],Y=0|fi[A+32>>2],S=0|fi[A+36>>2],R=0|fi[A+40>>2],N=0|fi[A+44>>2],U=0|fi[A+56>>2],J=0|fi[A+60>>2],B=0,u=0|fi[A+52>>2],w=0|fi[A+48>>2],d=i,D=g;;){if(l=d>>>0<0|0==(0|d)&D>>>0<64){g=(i=P)+64|0;do{yi[i>>0]=0,i=i+1|0}while((0|i)<(0|g));i=0;do{yi[P+i>>0]=0|yi[I+i>>0],i=i+1|0}while(0<d>>>0|0==(0|d)&i>>>0<D>>>0);B=e,I=P,e=P}i=v,g=b,t=k,r=G,a=F,n=m,C=M,o=H,c=Y,Q=S,E=R,s=J,h=U,y=u,f=w,_=N,p=20;do{V=0|$g((W=0|$g((aA=0|$g((Z=(W=0|$g((rA=i+a|0)^f,16))+c|0)^a,12))+rA^W,8))+Z^aA,7),nA=0|$g((K=0|$g((iA=0|$g((X=(K=0|$g((gA=g+n|0)^y,16))+Q|0)^n,12))+gA^K,8))+X^iA,7),BA=0|$g((T=0|$g(($=0|$g((z=(T=0|$g((O=t+C|0)^h,16))+E|0)^C,12))+O^T,8))+z^$,7),AA=0|$g((IA=0|$g((j=0|$g((x=(IA=0|$g((q=r+o|0)^s,16))+_|0)^o,12))+q^IA,8))+x^j,7),n=0|$g((E=(s=0|$g((i=(eA=0|$g((tA=0|$g(IA^nA+(aA+rA),16))+(T+z)^nA,12))+(nA+(aA+rA))|0)^tA,8))+(tA+(T+z))|0)^eA,7),C=0|$g((_=(f=0|$g((g=(z=0|$g((eA=0|$g(BA+(iA+gA)^W,16))+(IA+x)^BA,12))+(BA+(iA+gA))|0)^eA,8))+(eA+(IA+x))|0)^z,7),o=0|$g((c=(y=0|$g((t=(x=0|$g((z=0|$g(AA+($+O)^K,16))+(W+Z)^AA,12))+(AA+($+O))|0)^z,8))+(z+(W+Z))|0)^x,7),a=0|$g((Q=(h=0|$g((r=(x=0|$g((T=0|$g(j+q+V^T,16))+(K+X)^V,12))+(j+q+V)|0)^T,8))+(T+(K+X))|0)^x,7),p=p+-2|0}while(0!=(0|p));if(j=(0|ug(I))^i+v,Z=(0|ug(I+4|0))^g+b,W=(0|ug(I+8|0))^t+k,z=(0|ug(I+12|0))^r+G,O=(0|ug(I+16|0))^a+F,$=(0|ug(I+20|0))^n+m,AA=(0|ug(I+24|0))^C+M,IA=(0|ug(I+28|0))^o+H,eA=(0|ug(I+32|0))^c+Y,gA=(0|ug(I+36|0))^Q+S,iA=(0|ug(I+40|0))^E+R,BA=(0|ug(I+44|0))^_+N,tA=(0|ug(I+48|0))^f+w,rA=(0|ug(I+52|0))^y+u,aA=(0|ug(I+56|0))^h+U,nA=(0|ug(I+60|0))^s+J,g=w+1|0,i=(0==(0|g)&1)+u|0,Bg(e,j),Bg(e+4|0,Z),Bg(e+8|0,W),Bg(e+12|0,z),Bg(e+16|0,O),Bg(e+20|0,$),Bg(e+24|0,AA),Bg(e+28|0,IA),Bg(e+32|0,eA),Bg(e+36|0,gA),Bg(e+40|0,iA),Bg(e+44|0,BA),Bg(e+48|0,tA),Bg(e+52|0,rA),Bg(e+56|0,aA),Bg(e+60|0,nA),d>>>0<0|0==(0|d)&D>>>0<65)break;nA=0|Ig(0|D,0|d,-64,-1),I=I+64|0,e=e+64|0,u=i,w=g,d=vi,D=nA}if(l?0|D:0){I=0;do{yi[B+I>>0]=0|yi[e+I>>0],I=I+1|0}while((0|I)!=(0|D))}fi[A+48>>2]=g,fi[A+52>>2]=i}wi=L}function y(A,I,e,g){I|=0,e|=0,g|=0;var i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0;if(h=0|yi[80+(A|=0)>>0]?0:16777216,y=0|fi[A+4>>2],c=0|fi[A+8>>2],Q=0|fi[A+12>>2],E=0|fi[A+16>>2],a=0|fi[A+20>>2],r=0|fi[A+24>>2],t=0|fi[A+28>>2],B=0|fi[A+32>>2],i=0|fi[A+36>>2],g>>>0>0|0==(0|g)&e>>>0>15)for(s=0|fi[A>>2],C=e;;){if(l=(67108863&(0|ug(I)))+a|0,u=((0|ug(I+3|0))>>>2&67108863)+r|0,w=((0|ug(I+6|0))>>>4&67108863)+t|0,p=((0|ug(I+9|0))>>>6)+B|0,a=((0|ug(I+12|0))>>>8|h)+i|0,i=0|he(0|l,0,0|s,0),e=vi,t=0|he(0|u,0,5*E|0,0),e=0|Ig(0|t,0|vi,0|i,0|e),i=vi,t=0|he(0|w,0,5*Q|0,0),t=0|Ig(0|e,0|i,0|t,0|vi),i=vi,e=0|he(0|p,0,5*c|0,0),e=0|Ig(0|t,0|i,0|e,0|vi),i=vi,t=0|he(0|a,0,5*y|0,0),t=0|Ig(0|e,0|i,0|t,0|vi),i=vi,e=0|he(0|l,0,0|y,0),n=vi,_=0|he(0|u,0,0|s,0),n=0|Ig(0|_,0|vi,0|e,0|n),e=vi,_=0|he(0|w,0,5*E|0,0),_=0|Ig(0|n,0|e,0|_,0|vi),e=vi,n=0|he(0|p,0,5*Q|0,0),n=0|Ig(0|_,0|e,0|n,0|vi),e=vi,_=0|he(0|a,0,5*c|0,0),_=0|Ig(0|n,0|e,0|_,0|vi),e=vi,n=0|he(0|l,0,0|c,0),o=vi,f=0|he(0|u,0,0|y,0),o=0|Ig(0|f,0|vi,0|n,0|o),n=vi,f=0|he(0|w,0,0|s,0),f=0|Ig(0|o,0|n,0|f,0|vi),n=vi,o=0|he(0|p,0,5*E|0,0),o=0|Ig(0|f,0|n,0|o,0|vi),n=vi,f=0|he(0|a,0,5*Q|0,0),f=0|Ig(0|o,0|n,0|f,0|vi),n=vi,o=0|he(0|l,0,0|Q,0),B=vi,r=0|he(0|u,0,0|c,0),B=0|Ig(0|r,0|vi,0|o,0|B),o=vi,r=0|he(0|w,0,0|y,0),r=0|Ig(0|B,0|o,0|r,0|vi),o=vi,B=0|he(0|p,0,0|s,0),B=0|Ig(0|r,0|o,0|B,0|vi),o=vi,r=0|he(0|a,0,5*E|0,0),r=0|Ig(0|B,0|o,0|r,0|vi),o=vi,B=0|he(0|l,0,0|E,0),l=vi,u=0|he(0|u,0,0|Q,0),l=0|Ig(0|u,0|vi,0|B,0|l),B=vi,w=0|he(0|w,0,0|c,0),w=0|Ig(0|l,0|B,0|w,0|vi),B=vi,p=0|he(0|p,0,0|y,0),p=0|Ig(0|w,0|B,0|p,0|vi),B=vi,a=0|he(0|a,0,0|s,0),a=0|Ig(0|p,0|B,0|a,0|vi),B=vi,i=0|Ue(0|t,0|i,26),i=0|Ig(0|_,0|e,0|i,0),e=0|Ue(0|i,0|vi,26),e=0|Ig(0|f,0|n,0|e,0),n=0|Ue(0|e,0|vi,26),n=0|Ig(0|r,0|o,0|n,0),o=0|Ue(0|n,0|vi,26),o=0|Ig(0|a,0|B,0|o,0),B=0|Ue(0|o,0|vi,26),C=0|Ig(0|C,0|g,-16,-1),!((g=vi)>>>0>0|0==(0|g)&C>>>0>15)){a=(5*B|0)+t&67108863,r=(((5*B|0)+(67108863&t)|0)>>>26)+(67108863&i)|0,t=67108863&e,B=67108863&n,i=67108863&o;break}a=(5*B|0)+t&67108863,r=(((5*B|0)+(67108863&t)|0)>>>26)+(67108863&i)|0,t=67108863&e,B=67108863&n,i=67108863&o,I=I+16|0}fi[A+20>>2]=a,fi[A+24>>2]=r,fi[A+28>>2]=t,fi[A+32>>2]=B,fi[A+36>>2]=i}function f(A,I){A|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0;l=0|HI(I|=0),a=vi,w=0|Se(0|(w=0|fe(0|yi[I+4>>0],0|yi[I+5>>0],0|yi[I+6>>0])),0|vi,6),n=vi,p=0|Se(0|(p=0|fe(0|yi[I+7>>0],0|yi[I+8>>0],0|yi[I+9>>0])),0|vi,5),t=vi,y=0|Se(0|(y=0|fe(0|yi[I+10>>0],0|yi[I+11>>0],0|yi[I+12>>0])),0|vi,3),r=vi,h=0|Se(0|(h=0|fe(0|yi[I+13>>0],0|yi[I+14>>0],0|yi[I+15>>0])),0|vi,2),i=vi,g=0|HI(I+16|0),B=vi,Q=0|Se(0|(Q=0|fe(0|yi[I+20>>0],0|yi[I+21>>0],0|yi[I+22>>0])),0|vi,7),e=vi,_=0|Se(0|(_=0|fe(0|yi[I+23>>0],0|yi[I+24>>0],0|yi[I+25>>0])),0|vi,5),f=vi,o=0|Se(0|(o=0|fe(0|yi[I+26>>0],0|yi[I+27>>0],0|yi[I+28>>0])),0|vi,4),c=vi,a=0|Ig(19&(u=0|Ag(0,0,0|(I=0|Ue(0|(I=0|Ig(33554428&(s=0|Se(0|(s=0|fe(0|yi[I+29>>0],0|yi[I+30>>0],0|yi[I+31>>0])),0|vi,2))|0,0,16777216,0)),0|vi,25)),0|(E=vi)))|0,0,0|l,0|a),l=vi,E=0|Se(0|I,0|E,25),I=vi,t=0|Ig(0|(u=0|be(0|(u=0|Ig(0|w,0|n,16777216,0)),0|vi,25)),0|(D=vi),0|p,0|t),p=vi,D=0|Ag(0|w,0|n,0|(D=0|Se(0|u,0|D,25)),0|vi),n=vi,i=0|Ig(0|(w=0|be(0|(w=0|Ig(0|y,0|r,16777216,0)),0|vi,25)),0|(u=vi),0|h,0|i),h=vi,u=0|Ag(0|y,0|r,0|(u=0|Se(0|w,0|u,25)),0|vi),r=vi,e=0|Ig(0|Q,0|e,0|(y=0|be(0|(y=0|Ig(0|g,0|B,16777216,0)),0|vi,25)),0|(w=vi)),Q=vi,w=0|Ag(0|g,0|B,0|(w=0|Se(0|y,0|w,25)),0|vi),B=vi,c=0|Ig(0|(g=0|be(0|(g=0|Ig(0|_,0|f,16777216,0)),0|vi,25)),0|(y=vi),0|o,0|c),o=vi,y=0|Se(0|g,0|y,25),g=vi,n=0|Ig(0|D,0|n,0|(d=0|be(0|(d=0|Ig(0|a,0|l,33554432,0)),0|vi,26)),0|(C=vi)),C=0|Ag(0|a,0|l,0|(C=0|Se(0|d,0|C,26)),0|vi),r=0|Ig(0|u,0|r,0|(l=0|be(0|(l=0|Ig(0|t,0|p,33554432,0)),0|vi,26)),0|(a=vi)),a=0|Ag(0|t,0|p,0|(a=0|Se(0|l,0|a,26)),0|vi),B=0|Ig(0|w,0|B,0|(p=0|be(0|(p=0|Ig(0|i,0|h,33554432,0)),0|vi,26)),0|(t=vi)),t=0|Ag(0|i,0|h,0|(t=0|Se(0|p,0|t,26)),0|vi),g=0|Ag(0|(f=0|Ig(0|(h=0|be(0|(h=0|Ig(0|e,0|Q,33554432,0)),0|vi,26)),0|(i=vi),0|_,0|f)),0|vi,0|y,0|g),i=0|Ag(0|e,0|Q,0|(i=0|Se(0|h,0|i,26)),0|vi),I=0|Ag(0|(s=0|Ig(0|(Q=0|be(0|(Q=0|Ig(0|c,0|o,33554432,0)),0|vi,26)),0|(e=vi),33554428&s|0,0)),0|vi,0|E,0|I),e=0|Ag(0|c,0|o,0|(e=0|Se(0|Q,0|e,26)),0|vi),fi[A>>2]=C,fi[A+4>>2]=n,fi[A+8>>2]=a,fi[A+12>>2]=r,fi[A+16>>2]=t,fi[A+20>>2]=B,fi[A+24>>2]=i,fi[A+28>>2]=g,fi[A+32>>2]=e,fi[A+36>>2]=I}function _(A,I){A|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0;_=0|fi[(I|=0)>>2],f=0|fi[I+4>>2],y=0|fi[I+8>>2],h=0|fi[I+12>>2],s=0|fi[I+16>>2],C=0|fi[I+20>>2],Q=0|fi[I+24>>2],w=0|fi[I+28>>2],o=0|fi[I+32>>2],p=0|fi[I+36>>2],_=0|he(0|_,((0|_)<0)<<31>>31|0,121666,0),a=vi,f=0|he(0|f,((0|f)<0)<<31>>31|0,121666,0),n=vi,y=0|he(0|y,((0|y)<0)<<31>>31|0,121666,0),t=vi,h=0|he(0|h,((0|h)<0)<<31>>31|0,121666,0),r=vi,s=0|he(0|s,((0|s)<0)<<31>>31|0,121666,0),i=vi,C=0|he(0|C,((0|C)<0)<<31>>31|0,121666,0),B=vi,Q=0|he(0|Q,((0|Q)<0)<<31>>31|0,121666,0),e=vi,w=0|he(0|w,((0|w)<0)<<31>>31|0,121666,0),g=vi,o=0|he(0|o,((0|o)<0)<<31>>31|0,121666,0),c=vi,a=0|Ig(0|he(0|(l=0|be(0|(l=0|Ig(0|(p=0|he(0|p,((0|p)<0)<<31>>31|0,121666,0)),0|(I=vi),16777216,0)),0|vi,25)),0|(E=vi),19,0),0|vi,0|_,0|a),_=vi,E=0|Ag(0|p,0|I,0|(E=0|Se(0|l,0|E,25)),0|vi),I=vi,t=0|Ig(0|(p=0|be(0|(p=0|Ig(0|f,0|n,16777216,0)),0|vi,25)),0|(l=vi),0|y,0|t),y=vi,l=0|Ag(0|f,0|n,0|(l=0|Se(0|p,0|l,25)),0|vi),n=vi,i=0|Ig(0|(f=0|be(0|(f=0|Ig(0|h,0|r,16777216,0)),0|vi,25)),0|(p=vi),0|s,0|i),s=vi,p=0|Ag(0|h,0|r,0|(p=0|Se(0|f,0|p,25)),0|vi),r=vi,e=0|Ig(0|(h=0|be(0|(h=0|Ig(0|C,0|B,16777216,0)),0|vi,25)),0|(f=vi),0|Q,0|e),Q=vi,f=0|Ag(0|C,0|B,0|(f=0|Se(0|h,0|f,25)),0|vi),B=vi,c=0|Ig(0|(C=0|be(0|(C=0|Ig(0|w,0|g,16777216,0)),0|vi,25)),0|(h=vi),0|o,0|c),o=vi,h=0|Ag(0|w,0|g,0|(h=0|Se(0|C,0|h,25)),0|vi),g=vi,n=0|Ig(0|l,0|n,0|(w=0|be(0|(w=0|Ig(0|a,0|_,33554432,0)),0|vi,26)),0|(C=vi)),C=0|Ag(0|a,0|_,0|(C=0|Se(0|w,0|C,26)),0|vi),r=0|Ig(0|p,0|r,0|(_=0|be(0|(_=0|Ig(0|t,0|y,33554432,0)),0|vi,26)),0|(a=vi)),a=0|Ag(0|t,0|y,0|(a=0|Se(0|_,0|a,26)),0|vi),B=0|Ig(0|f,0|B,0|(y=0|be(0|(y=0|Ig(0|i,0|s,33554432,0)),0|vi,26)),0|(t=vi)),t=0|Ag(0|i,0|s,0|(t=0|Se(0|y,0|t,26)),0|vi),g=0|Ig(0|h,0|g,0|(s=0|be(0|(s=0|Ig(0|e,0|Q,33554432,0)),0|vi,26)),0|(i=vi)),i=0|Ag(0|e,0|Q,0|(i=0|Se(0|s,0|i,26)),0|vi),I=0|Ig(0|E,0|I,0|(Q=0|be(0|(Q=0|Ig(0|c,0|o,33554432,0)),0|vi,26)),0|(e=vi)),e=0|Ag(0|c,0|o,0|(e=0|Se(0|Q,0|e,26)),0|vi),fi[A>>2]=C,fi[A+4>>2]=n,fi[A+8>>2]=a,fi[A+12>>2]=r,fi[A+16>>2]=t,fi[A+20>>2]=B,fi[A+24>>2]=i,fi[A+28>>2]=g,fi[A+32>>2]=e,fi[A+36>>2]=I}function p(A,I,e,g,i){A|=0,e|=0,g|=0,i|=0;var B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0;if(!(I|=0))return g?i?(fi[i>>2]=0|A,fi[i+4>>2]=0&I,g=0,i=0,0|(vi=g,i)):(g=0,i=0,0|(vi=g,i)):(0|i&&(fi[i>>2]=(A>>>0)%(e>>>0),fi[i+4>>2]=0),g=0,i=(A>>>0)/(e>>>0)>>>0,0|(vi=g,i));do{if(e){if(0|g){if((t=(0|ki(0|g))-(0|ki(0|I))|0)>>>0<=31){c=t+1|0,r=A>>>((t+1|0)>>>0)&t-31>>31|I<<31-t,o=I>>>((t+1|0)>>>0)&t-31>>31,B=0,t=A<<31-t;break}return i?(fi[i>>2]=0|A,fi[i+4>>2]=I|0&I,g=0,i=0,0|(vi=g,i)):(g=0,i=0,0|(vi=g,i))}if(e-1&e|0){c=t=33+(0|ki(0|e))-(0|ki(0|I))|0,r=32-t-1>>31&I>>>((t-32|0)>>>0)|(I<<32-t|A>>>(t>>>0))&t-32>>31,o=t-32>>31&I>>>(t>>>0),B=A<<64-t&32-t>>31,t=(I<<64-t|A>>>((t-32|0)>>>0))&32-t>>31|A<<32-t&t-33>>31;break}return 0|i&&(fi[i>>2]=e-1&A,fi[i+4>>2]=0),1==(0|e)?(g=I|0&I,i=0|A,0|(vi=g,i)):(i=0|NI(0|e),g=I>>>(i>>>0)|0,i=I<<32-i|A>>>(i>>>0)|0,0|(vi=g,i))}if(!g)return 0|i&&(fi[i>>2]=(I>>>0)%(e>>>0),fi[i+4>>2]=0),g=0,i=(I>>>0)/(e>>>0)>>>0,0|(vi=g,i);if(!A)return 0|i&&(fi[i>>2]=0,fi[i+4>>2]=(I>>>0)%(g>>>0)),e=0,i=(I>>>0)/(g>>>0)>>>0,0|(vi=e,i);if(!(g-1&g))return 0|i&&(fi[i>>2]=0|A,fi[i+4>>2]=g-1&I|0&I),e=0,i=I>>>((0|NI(0|g))>>>0),0|(vi=e,i);if((t=(0|ki(0|g))-(0|ki(0|I))|0)>>>0<=30){c=t+1|0,r=I<<31-t|A>>>((t+1|0)>>>0),o=I>>>((t+1|0)>>>0),B=0,t=A<<31-t;break}return i?(fi[i>>2]=0|A,fi[i+4>>2]=I|0&I,g=0,i=0,0|(vi=g,i)):(g=0,i=0,0|(vi=g,i))}while(0);if(c){n=0|Ig(0|e,g|0&g|0,-1,-1),C=vi,a=t,I=o,A=c,t=0;do{E=a,a=B>>>31|a<<1,B=t|B<<1,Ag(0|n,0|C,0|(E=r<<1|E>>>31|0),0|(Q=r>>>31|I<<1|0)),t=1&(o=(c=vi)>>31|((0|c)<0?-1:0)<<1),r=0|Ag(0|E,0|Q,o&(0|e)|0,(((0|c)<0?-1:0)>>31|((0|c)<0?-1:0)<<1)&(g|0&g)|0),I=vi,A=A-1|0}while(0!=(0|A));A=0}else a=t,I=o,A=0,t=0;return 0|i&&(fi[i>>2]=r,fi[i+4>>2]=I),Q=(0|B)>>>31|a<<1|0&(0|B>>>31)|A,E=-2&(B<<1|0)|t,0|(vi=Q,E)}function w(A,I,e){A|=0,I|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0,P=0,L=0,x=0,X=0,K=0,T=0;v=0|ug(e|=0),b=0|ug(e+4|0),k=0|ug(e+8|0),G=0|ug(e+12|0),u=0|ug(e+16|0),d=0|ug(e+20|0),D=0|ug(e+24|0),_=0|ug(e+28|0),p=0|ug(I),w=0|ug(I+4|0),l=0|ug(I+8|0),f=0|ug(I+12|0),e=0,I=v,g=b,i=k,B=G,t=p,r=w,a=l,n=f,C=u,o=_,c=D,Q=d,E=1634760805,s=857760878,h=2036477234,y=1797285236;do{x=(0|$g((H=(0|$g((R=(0|$g((J=(0|$g(E+Q|0,7))^B)+E|0,9))^a)+J|0,13))^Q)+R|0,18))^E,U=(0|$g((T=(0|$g((M=(0|$g((S=(0|$g(I+s|0,7))^n)+s|0,9))^c)+S|0,13))^I)+M|0,18))^s,Y=(0|$g((L=(0|$g((K=(0|$g((m=(0|$g(t+h|0,7))^o)+h|0,9))^g)+m|0,13))^t)+K|0,18))^h,F=(0|$g((N=(0|$g((P=(0|$g((X=(0|$g(C+y|0,7))^i)+y|0,9))^r)+X|0,13))^C)+P|0,18))^y,E=(0|$g((i=(0|$g((g=(0|$g((I=(0|$g(X+x|0,7))^T)+x|0,9))^K)+I|0,13))^X)+g|0,18))^x,s=(0|$g((B=(0|$g((r=(0|$g((t=(0|$g(U+J|0,7))^L)+U|0,9))^P)+t|0,13))^J)+r|0,18))^U,h=(0|$g((n=(0|$g((a=(0|$g((C=(0|$g(Y+S|0,7))^N)+Y|0,9))^R)+C|0,13))^S)+a|0,18))^Y,y=(0|$g((o=(0|$g((c=(0|$g((Q=(0|$g(F+m|0,7))^H)+F|0,9))^M)+Q|0,13))^m)+c|0,18))^F,e=e+2|0}while((0|e)<20);Bg(A,E+1634760805|0),Bg(A+4|0,I+v|0),Bg(A+8|0,g+b|0),Bg(A+12|0,i+k|0),Bg(A+16|0,B+G|0),Bg(A+20|0,s+857760878|0),Bg(A+24|0,t+p|0),Bg(A+28|0,r+w|0),Bg(A+32|0,a+l|0),Bg(A+36|0,n+f|0),Bg(A+40|0,h+2036477234|0),Bg(A+44|0,C+u|0),Bg(A+48|0,Q+d|0),Bg(A+52|0,c+D|0),Bg(A+56|0,o+_|0),Bg(A+60|0,y+1797285236|0)}function l(A,I,e,g){A|=0,I|=0,e|=0;var i=0,B=0,t=0,r=0,a=0,n=0,C=0;switch(C=wi,r=wi=wi+63&-64,wi=wi+16|0,0|(g|=0)){case 2:if(I>>>0<13)g=-31;else{i=33732,B=(g=A)+13|0;do{yi[g>>0]=0|yi[i>>0],g=g+1|0,i=i+1|0}while((0|g)<(0|B));A=A+12|0,i=I+-12|0,B=6}break;case 1:if(I>>>0<12)g=-31;else{i=33745,B=(g=A)+12|0;do{yi[g>>0]=0|yi[i>>0],g=g+1|0,i=i+1|0}while((0|g)<(0|B));A=A+11|0,i=I+-11|0,B=6}break;default:g=-31}do{if(6==(0|B)&&!(g=0|O(e))){if(EI(r,19),g=0|TA(r),B=A+g|0,t=i-g|0,i>>>0<=g>>>0){g=-31;break}if(T(0|A,0|r,g+1|0),t>>>0>=4){if(yi[B>>0]=36,yi[B+1>>0]=109,yi[B+2>>0]=61,yi[B+3>>0]=0,EI(r,0|fi[e+44>>2]),i=0|TA(r),A=B+3+i|0,(t+-3|0)>>>0<=i>>>0){g=-31;break}if(T(B+3|0,0|r,i+1|0),(t+-3-i|0)>>>0>=4){if(yi[A>>0]=44,yi[A+1>>0]=116,yi[A+2>>0]=61,yi[A+3>>0]=0,EI(r,0|fi[e+40>>2]),g=0|TA(r),B=A+3+g|0,I=t+-3-i-3-g|0,(t+-3-i-3|0)>>>0<=g>>>0){g=-31;break}if(T(A+3|0,0|r,g+1|0),I>>>0>=4){if(yi[B>>0]=44,yi[B+1>>0]=112,yi[B+2>>0]=61,yi[B+3>>0]=0,EI(r,0|fi[e+48>>2]),i=0|TA(r),(I+-3|0)>>>0<=i>>>0){g=-31;break}if(T(B+3|0,0|r,i+1|0),g=B+3+i+1|0,((I+-3-i|0)>>>0>=2?(yi[B+3+i>>0]=36,yi[B+3+i+1>>0]=0,0!=(0|U(g,I+-3-i-1|0,0|fi[e+16>>2],0|fi[e+20>>2],3))):0)?(a=0|TA(g),(n=I+-3-i-1-a|0)>>>0>=2):0)return yi[g+a>>0]=36,yi[g+a+1>>0]=0,n=0!=(0|U(g+a+1|0,n+-1|0,0|fi[e>>2],0|fi[e+4>>2],3)),wi=C,0|(n?0:-31);g=-31}else g=-31}else g=-31}else g=-31}}while(0);return wi=C,0|g}function u(A,I,e,g){A|=0,I|=0,e|=0;var i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0,Y=0,S=0,R=0,N=0,U=0,J=0;(g|=0)?(t=0|ug(g),B=0|ug(g+4|0),i=0|ug(g+8|0),g=0|ug(g+12|0)):(g=1797285236,i=2036477234,B=857760878,t=1634760805),y=0|ug(e),h=0|ug(e+4|0),s=0|ug(e+8|0),E=0|ug(e+12|0),Q=0|ug(e+16|0),c=0|ug(e+20|0),o=0|ug(e+24|0),C=0|ug(e+28|0),n=0|ug(I),a=0|ug(I+4|0),r=0|ug(I+8|0),f=0,I=0|ug(I+12|0),e=t;do{l=0|$g((v=0|$g((U=0|$g((D=(v=0|$g(n^(N=y+e|0),16))+Q|0)^y,12))+N^v,8))+D^U,7),J=0|$g((p=0|$g((Y=0|$g((_=(p=0|$g(a^(H=h+B|0),16))+c|0)^h,12))+H^p,8))+_^Y,7),S=0|$g((w=0|$g((G=0|$g((b=(w=0|$g(r^(k=s+i|0),16))+o|0)^s,12))+k^w,8))+b^G,7),F=0|$g((m=0|$g((d=0|$g((t=(m=0|$g(I^(u=E+g|0),16))+C|0)^E,12))+u^m,8))+t^d,7),h=0|$g((o=(I=0|$g((e=(M=0|$g((R=0|$g(m^J+(U+N),16))+(w+b)^J,12))+(J+(U+N))|0)^R,8))+(R+(w+b))|0)^M,7),s=0|$g((C=(n=0|$g((B=(b=0|$g((M=0|$g(S+(Y+H)^v,16))+(m+t)^S,12))+(S+(Y+H))|0)^M,8))+(M+(m+t))|0)^b,7),E=0|$g((Q=(a=0|$g((i=(t=0|$g((b=0|$g(F+(G+k)^p,16))+(v+D)^F,12))+(F+(G+k))|0)^b,8))+(b+(v+D))|0)^t,7),y=0|$g((c=(r=0|$g((g=(t=0|$g((w=0|$g(d+u+l^w,16))+(p+_)^l,12))+(d+u+l)|0)^w,8))+(w+(p+_))|0)^t,7),f=f+1|0}while(10!=(0|f));return Bg(A,e),Bg(A+4|0,B),Bg(A+8|0,i),Bg(A+12|0,g),Bg(A+16|0,n),Bg(A+20|0,a),Bg(A+24|0,r),Bg(A+28|0,I),0}function d(A,I,e,g){A|=0,I|=0,e|=0,g|=0;var i=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0;o=wi,C=wi=wi+63&-64,wi=wi+704|0;A:do{if(!(0==(0|e)&0==(0|g))){if(s=0|fi[A+72>>2],Q=0|fi[A+72+4>>2],n=0|Ue(0|s,0|Q,3),c=0|Se(0|e,0|g,3),E=vi,r=0|Ue(0|e,0|g,61),a=vi,Q=0|Ig(0|s,0|Q,0|c,0|E),s=vi,fi[A+72>>2]=Q,fi[A+72+4>>2]=s,i=0|fi[A+64>>2],t=0|fi[A+64+4>>2],s>>>0<E>>>0|(0|s)==(0|E)&Q>>>0<c>>>0&&(i=0|Ig(0|i,0|t,1,0),t=vi,fi[A+64>>2]=i,fi[A+64+4>>2]=t),a=0|Ig(0|i,0|t,0|r,0|a),fi[A+64>>2]=a,fi[A+64+4>>2]=vi,a=0|Ag(128,0,127&n|0,0),(i=vi)>>>0>g>>>0|(0|i)==(0|g)&a>>>0>e>>>0)for(i=0,t=0;;)if(E=0|yi[I+i>>0],s=0|Ig(0|i,0|t,127&n|0,0),yi[A+80+s>>0]=E,i=0|Ig(0|i,0|t,1,0),!((t=vi)>>>0<g>>>0|(0|t)==(0|g)&i>>>0<e>>>0))break A;if(!(0==(0|a)&0==(0|i))){t=0,r=0;do{E=0|yi[I+t>>0],s=0|Ig(0|t,0|r,127&n|0,0),yi[A+80+s>>0]=E,t=0|Ig(0|t,0|r,1,0),r=vi}while(r>>>0<i>>>0|(0|r)==(0|i)&t>>>0<a>>>0)}if(B(A,A+80|0,C,C+640|0),i=0|Ag(0|e,0|g,0|a,0|i),(t=vi)>>>0>0|0==(0|t)&i>>>0>127){r=I+a|0;do{B(A,r,C,C+640|0),r=r+128|0,i=0|Ig(0|i,0|t,-128,-1),t=vi}while(t>>>0>0|0==(0|t)&i>>>0>127);a=r}else a=I+a|0;if(!(0==(0|(i&=127))&!0)){t=0,r=0;do{yi[A+80+t>>0]=0|yi[a+t>>0],t=0|Ig(0|t,0|r,1,0),r=vi}while(r>>>0<0|0==(0|r)&t>>>0<i>>>0)}YI(C,704)}}while(0);wi=o}function D(A,I,e,g){A|=0,e|=0,g|=0;var i=0,B=0;for(i=wi,B=wi=wi+63&-64,wi=wi+2272|0,BA(B+2016|0,I|=0),BA(B+1760|0,g),we(B+480|0,e),ue(B+320|0,e),Qe(B,B+320|0),jA(B+320|0,B,B+480|0),Qe(B+160|0,B+320|0),we(B+480+160|0,B+160|0),jA(B+320|0,B,B+480+160|0),Qe(B+160|0,B+320|0),we(B+480+320|0,B+160|0),jA(B+320|0,B,B+480+320|0),Qe(B+160|0,B+320|0),we(B+480+480|0,B+160|0),jA(B+320|0,B,B+480+480|0),Qe(B+160|0,B+320|0),we(B+480+640|0,B+160|0),jA(B+320|0,B,B+480+640|0),Qe(B+160|0,B+320|0),we(B+480+800|0,B+160|0),jA(B+320|0,B,B+480+800|0),Qe(B+160|0,B+320|0),we(B+480+960|0,B+160|0),jA(B+320|0,B,B+480+960|0),Qe(B+160|0,B+320|0),we(B+480+1120|0,B+160|0),Tg(A),I=255;!(0|yi[B+2016+I>>0]||0|yi[B+1760+I>>0]);){if(e=I+-1|0,!((0|I)>0)){I=e;break}I=e}if((0|I)>-1)for(;nI(B+320|0,A),(e=0|yi[B+2016+I>>0])<<24>>24<=0?e<<24>>24<0&&(Qe(B+160|0,B+320|0),qA(B+320|0,B+160|0,B+480+(160*(((e<<24>>24)/-2|0)<<24>>24)|0)|0)):(Qe(B+160|0,B+320|0),jA(B+320|0,B+160|0,B+480+(160*((255&e)>>>1&255)|0)|0)),(e=0|yi[B+1760+I>>0])<<24>>24<=0?e<<24>>24<0&&(Qe(B+160|0,B+320|0),WA(B+320|0,B+160|0,1064+(120*(((e<<24>>24)/-2|0)<<24>>24)|0)|0)):(Qe(B+160|0,B+320|0),zA(B+320|0,B+160|0,1064+(120*((255&e)>>>1&255)|0)|0)),Xe(A,B+320|0),(0|I)>0;)I=I+-1|0;wi=i}function v(A,I,e,g,i,B,t,r){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0;var a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0;if(h=wi,s=wi=wi+63&-64,wi=wi+16|0,fi[s>>2]=0,Ng(r),g){n=0,o=0,C=0,a=0;A:for(;;){for(;Q=0|yi[e+a>>0],255==(0|(c=4&r?0|xA(Q):0|XA(Q)));){if(!i){c=18;break A}if(!(0|wg(i,Q))){c=19;break A}if((a=a+1|0)>>>0>=g>>>0){c=17;break A}}if(o=c+(o<<6)|0,(c=n+6|0)>>>0>7){if(n=n+-2|0,C>>>0>=I>>>0){c=13;break}yi[A+C>>0]=o>>>n,C=C+1|0}else n=c;if((a=a+1|0)>>>0>=g>>>0){c=16;break}}13==(0|c)?(fi[s>>2]=a,fi[8202]=34,a=-1):16==(0|c)?(fi[s>>2]=a,a=0):17==(0|c)?(fi[s>>2]=a,a=0):18==(0|c)?(fi[s>>2]=a,a=0):19==(0|c)&&(fi[s>>2]=a,a=0),n>>>0>4?(a=-1,C=0):c=21}else a=0,C=0,o=0,n=0,c=21;do{if(21==(0|c))if((1<<n)-1&o)a=-1,C=0;else if(a|2&r||(a=0|DA(e,g,s,i,n>>>1)),a)C=0;else if(0!=(0|i)?(E=0|fi[s>>2])>>>0<g>>>0:0){for(a=E;;){if(!(0|wg(i,0|yi[e+a>>0]))){c=30;break}if((a=a+1|0)>>>0>=g>>>0){c=29;break}}if(29==(0|c)){fi[s>>2]=a,a=0;break}if(30==(0|c)){fi[s>>2]=a,a=0;break}}else a=0}while(0);return n=0|fi[s>>2],t?fi[t>>2]=e+n:(0|n)!=(0|g)&&(fi[8202]=22,a=-1),0|B&&(fi[B>>2]=C),wi=h,0|a}function b(A,I,e){I|=0,e|=0;var g=0,i=0,B=0,t=0,r=0,a=0;switch(a=wi,r=wi=wi+63&-64,wi=wi+16|0,B=0|fi[20+(A|=0)>>2],t=0|fi[A+4>>2],fi[A+20>>2]=0,fi[A+4>>2]=0,0|e){case 2:0|NA(I,33697,9)?I=-32:(I=I+9|0,i=4);break;case 1:0|NA(I,33707,8)?I=-32:(I=I+8|0,i=4);break;default:I=-26}do{if(4==(0|i))if(0==(0|NA(I,33716,3))?0!=(0|(g=0|LA(I+3|0,r+4|0))):0)if(19==(0|fi[r+4>>2]))if(0|NA(g,33720,3))I=-32;else{if(!(I=0|LA(g+3|0,r+4|0))){I=-32;break}if(fi[A+44>>2]=fi[r+4>>2],0|NA(I,33724,3))I=-32;else{if(!(I=0|LA(I+3|0,r+4|0))){I=-32;break}if(fi[A+40>>2]=fi[r+4>>2],0|NA(I,33728,3))I=-32;else{if(!(I=0|LA(I+3|0,r+4|0))){I=-32;break}if(i=0|fi[r+4>>2],fi[A+48>>2]=i,fi[A+52>>2]=i,i=36==(0|yi[I>>0]),I=i?I+1|0:I,i){if(fi[r+4>>2]=B,i=0|fi[A+16>>2],0|v(i,B,I,0|TA(I),0,r+4|0,r,3)){I=-32;break}if(fi[A+20>>2]=fi[r+4>>2],I=0|fi[r>>2],B=36==(0|yi[I>>0]),I=B?I+1|0:I,B){if(fi[r+4>>2]=t,B=0|fi[A>>2],0|v(B,t,I,0|TA(I),0,r+4|0,r,3)){I=-32;break}fi[A+4>>2]=fi[r+4>>2],e=0|fi[r>>2],(I=0|O(A))||(I=0==(0|yi[e>>0])?0:-32)}else I=-32}else I=-32}}}else I=-26;else I=-32}while(0);return wi=a,0|I}function k(A,I,e){A|=0,I|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0,u=0,d=0,D=0,v=0,b=0,k=0,G=0,F=0,m=0,M=0,H=0;for(a=0|ug(e|=0),r=0|ug(e+4|0),t=0|ug(e+8|0),B=0|ug(e+12|0),y=0|ug(e+16|0),h=0|ug(e+20|0),s=0|ug(e+24|0),E=0|ug(e+28|0),i=0|ug(I),g=0|ug(I+4|0),n=0|ug(I+8|0),e=0|ug(I+12|0),I=n,n=20,C=2036477234,o=857760878,c=1634760805,Q=1797285236;b=(0|$g(h+c|0,7))^B,d=(0|$g(b+c|0,9))^I,w=(0|$g(d+b|0,13))^h,F=(0|$g(w+d|0,18))^c,u=(0|$g(o+a|0,7))^e,p=(0|$g(u+o|0,9))^s,H=(0|$g(p+u|0,13))^a,v=(0|$g(H+p|0,18))^o,_=(0|$g(C+i|0,7))^E,M=(0|$g(_+C|0,9))^r,G=(0|$g(M+_|0,13))^i,l=(0|$g(G+M|0,18))^C,m=(0|$g(Q+y|0,7))^t,k=(0|$g(m+Q|0,9))^g,D=(0|$g(k+m|0,13))^y,f=(0|$g(D+k|0,18))^Q,a=(0|$g(m+F|0,7))^H,r=(0|$g(a+F|0,9))^M,t=(0|$g(r+a|0,13))^m,c=(0|$g(t+r|0,18))^F,i=(0|$g(v+b|0,7))^G,g=(0|$g(i+v|0,9))^k,B=(0|$g(g+i|0,13))^b,o=(0|$g(B+g|0,18))^v,y=(0|$g(l+u|0,7))^D,I=(0|$g(y+l|0,9))^d,e=(0|$g(I+y|0,13))^u,C=(0|$g(e+I|0,18))^l,h=(0|$g(f+_|0,7))^w,s=(0|$g(h+f|0,9))^p,E=(0|$g(s+h|0,13))^_,Q=(0|$g(E+s|0,18))^f,!((0|n)<=2);)n=n+-2|0;Bg(A,c),Bg(A+4|0,o),Bg(A+8|0,C),Bg(A+12|0,Q),Bg(A+16|0,i),Bg(A+20|0,g),Bg(A+24|0,I),Bg(A+28|0,e)}function G(A,I,e,g){I|=0,e|=0,g|=0;var i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0;if(B=0|fi[56+(A|=0)>>2],i=0|fi[A+56+4>>2],0==(0|B)&0==(0|i))C=6;else{if(r=0|Ag(16,0,0|B,0|i),n=vi,a=n>>>0>g>>>0|(0|n)==(0|g)&r>>>0>e>>>0?e:r,n=n>>>0>g>>>0|(0|n)==(0|g)&r>>>0>e>>>0?g:n,!(0==(0|a)&0==(0|n))){r=0,t=0;do{o=0|yi[I+r>>0],B=0|Ig(0|B,0|i,0|r,0|t),yi[A+64+B>>0]=o,r=0|Ig(0|r,0|t,1,0),t=vi,B=0|fi[A+56>>2],i=0|fi[A+56+4>>2]}while(t>>>0<n>>>0|(0|t)==(0|n)&r>>>0<a>>>0)}o=0|Ig(0|B,0|i,0|a,0|n),r=vi,fi[A+56>>2]=o,fi[A+56+4>>2]=r,r>>>0<0|0==(0|r)&o>>>0<16||(e=0|Ag(0|e,0|g,0|a,0|n),g=vi,y(A,A+64|0,16,0),fi[A+56>>2]=0,fi[A+56+4>>2]=0,I=I+a|0,C=6)}if(6==(0|C)&&(i=-16&e,g>>>0>0|0==(0|g)&e>>>0>15?(e=0|Ag(0|e,0|g,0|i,0|g),o=vi,y(A,I,i,g),I=I+i|0,i=o):i=g,!(0==(0|e)&0==(0|i)))){g=0,B=0|fi[A+56>>2],t=0|fi[A+56+4>>2],r=0;do{C=0|yi[I+g>>0],o=0|Ig(0|B,0|t,0|g,0|r),yi[A+64+o>>0]=C,g=0|Ig(0|g,0|r,1,0),r=vi,B=0|fi[A+56>>2],t=0|fi[A+56+4>>2]}while(r>>>0<i>>>0|(0|r)==(0|i)&g>>>0<e>>>0);o=0|Ig(0|B,0|t,0|e,0|i),fi[A+56>>2]=o,fi[A+56+4>>2]=vi}}function F(A,I,e){e|=0;var g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+400|0,0==(0|(A|=0))|0==(0|(I|=0))||(II(i,0,0,64),Bg(i+384|0,0|fi[I+48>>2]),rg(i,i+384|0,4,0),Bg(i+384|0,0|fi[I+4>>2]),rg(i,i+384|0,4,0),Bg(i+384|0,0|fi[I+44>>2]),rg(i,i+384|0,4,0),Bg(i+384|0,0|fi[I+40>>2]),rg(i,i+384|0,4,0),Bg(i+384|0,19),rg(i,i+384|0,4,0),Bg(i+384|0,e),rg(i,i+384|0,4,0),Bg(i+384|0,0|fi[I+12>>2]),rg(i,i+384|0,4,0),(0|(e=0|fi[I+8>>2])?(rg(i,e,0|fi[I+12>>2],0),1&fi[I+56>>2]|0):0)&&(YI(0|fi[I+8>>2],0|fi[I+12>>2]),fi[I+12>>2]=0),Bg(i+384|0,0|fi[I+20>>2]),rg(i,i+384|0,4,0),0|(e=0|fi[I+16>>2])&&rg(i,e,0|fi[I+20>>2],0),Bg(i+384|0,0|fi[I+28>>2]),rg(i,i+384|0,4,0),(0|(e=0|fi[I+24>>2])?(rg(i,e,0|fi[I+28>>2],0),2&fi[I+56>>2]|0):0)&&(YI(0|fi[I+24>>2],0|fi[I+28>>2]),fi[I+28>>2]=0),Bg(i+384|0,0|fi[I+36>>2]),rg(i,i+384|0,4,0),0|(e=0|fi[I+32>>2])&&rg(i,e,0|fi[I+36>>2],0),ye(i,A,64)),wi=g}function m(A,I,e,g){A|=0,I|=0,e|=0,g|=0;var i=0,B=0,t=0,r=0,a=0;if(r=wi,a=wi=wi+63&-64,wi=wi+528|0,fi[a+384>>2]=0,Bg(a+384|0,I),I>>>0<65)(0|II(a,0,0,I))>=0&&(rg(a,a+384|0,4,0),rg(a,e,g,0),ye(a,A,I));else A:do{if((0|II(a,0,0,64))>=0?(rg(a,a+384|0,4,0),rg(a,e,g,0),(0|ye(a,a+456|0,64))>=0):0){B=a+456|0,t=(i=A)+32|0;do{yi[i>>0]=0|yi[B>>0],i=i+1|0,B=B+1|0}while((0|i)<(0|t));B=a+456|0,t=64+(i=a+392|0)|0;do{yi[i>>0]=0|yi[B>>0],i=i+1|0,B=B+1|0}while((0|i)<(0|t));if((I+-32|0)>>>0>64){g=I+-32|0,e=A+32|0;do{if((0|aI(a+456|0,64,a+392|0,64,0,0,0))<0)break A;B=a+456|0,t=(i=e)+32|0;do{yi[i>>0]=0|yi[B>>0],i=i+1|0,B=B+1|0}while((0|i)<(0|t));g=g+-32|0,e=e+32|0,B=a+456|0,t=64+(i=a+392|0)|0;do{yi[i>>0]=0|yi[B>>0],i=i+1|0,B=B+1|0}while((0|i)<(0|t))}while(g>>>0>64)}else g=I+-32|0,e=A+32|0;(0|aI(a+456|0,g,a+392|0,64,0,0,0))>=0&&T(0|e,a+456|0,0|g)}}while(0);YI(a,384),wi=r}function M(A,I){A|=0,I|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,o=0,c=0,Q=0;A:do{if(0|A){do{if(2==(0|fi[A+36>>2])){if(0==(0|(e=0|fi[I>>2]))?(0|_i[I+8>>0])<=1:0){g=6;break}Q=0,c=0|fi[A+4>>2]}else g=6}while(0);if(6==(0|g)&&(z(A,I,c=0|fi[A+4>>2]),Q=1,e=0|fi[I>>2]),i=0|yi[I+8>>0],e=0==(0|e)&i<<24>>24==0?2:0,g=0|fi[A+24>>2],a=0|bi(g,0|fi[I+4>>2]),o=0|fi[A+20>>2],i=e+a+(0|bi(o,255&i))|0,e>>>0<o>>>0)for(o=i,i=(0==(0|(i>>>0)%(g>>>0))?g+-1|0:-1)+i|0;;){if(a=1==(0|(o>>>0)%(g>>>0))?o+-1|0:i,g=Q?c+(e<<3)|0:(0|fi[4+(0|fi[A>>2])>>2])+(a<<10)|0,B=0|fi[g>>2],g=0|ne(0|fi[g+4>>2],0,0|fi[A+28>>2],0),i=vi,((r=0==(0|fi[I>>2]))?0==(0|yi[I+8>>0]):0)&&(g=0|fi[I+4>>2],i=0),fi[I+12>>2]=e,B=0|aA(A,I,B,1&(0==(0|i)?(0|g)==(0|fi[I+4>>2]):0)),t=0|fi[4+(0|fi[A>>2])>>2],g=0|he(0|fi[A+24>>2],0,0|g,0|i),i=t+(o<<10)|0,r?C(t+(a<<10)|0,t+(g<<10)+(B<<10)|0,i):n(t+(a<<10)|0,t+(g<<10)+(B<<10)|0,i),(e=e+1|0)>>>0>=(0|fi[A+20>>2])>>>0)break A;o=o+1|0,i=a+1|0,g=0|fi[A+24>>2]}}}while(0)}function H(A,I,e,g,i,B,t,r){A|=0,I|=0,i|=0,B|=0,t|=0,r|=0;var a=0,n=0,C=0,o=0;if(C=wi,o=wi=wi+63&-64,wi=wi+112|0,!(0==(0|(e|=0))&0==(0|(g|=0)))){a=32+(n=o+16|0)|0;do{yi[n>>0]=0|yi[r>>0],n=n+1|0,r=r+1|0}while((0|n)<(0|a));for(r=_i[i+4>>0]|_i[i+4+1>>0]<<8|_i[i+4+2>>0]<<16|_i[i+4+3>>0]<<24,fi[o>>2]=_i[i>>0]|_i[i+1>>0]<<8|_i[i+2>>0]<<16|_i[i+3>>0]<<24,fi[o+4>>2]=r,r=8;yi[o+r>>0]=B,B=0|Ue(0|B,0|t,8),16!=(0|(r=r+1|0));)t=vi;if(g>>>0>0|0==(0|g)&e>>>0>63)for(r=A,B=e;;){Ug(o+48|0,o,o+16|0),A=0;do{yi[r+A>>0]=yi[o+48+A>>0]^yi[I+A>>0],A=A+1|0}while(64!=(0|A));for(A=1,t=8;e=o+t|0,A=(0|_i[e>>0])+A|0,yi[e>>0]=A,16!=(0|(t=t+1|0));)A>>>=8;if(t=0|Ig(0|B,0|g,-64,-1),g=vi,A=r+64|0,I=I+64|0,!(g>>>0>0|0==(0|g)&t>>>0>63))break;r=A,B=t}else t=e;if(0==(0|t)&0==(0|g)?0:(Ug(o+48|0,o,o+16|0),0|t)){g=0;do{yi[A+g>>0]=yi[o+48+g>>0]^yi[I+g>>0],g=g+1|0}while((0|g)!=(0|t))}YI(o+48|0,64),YI(o+16|0,32)}wi=C}function Y(A,I){A|=0;var e=0,g=0;e=wi,g=wi=wi+63&-64,wi=wi+160|0,c(g+120|0,I|=0),c(g+80|0,g+120|0),c(g+80|0,g+80|0),a(g+80|0,I,g+80|0),a(g+120|0,g+120|0,g+80|0),c(g+40|0,g+120|0),a(g+80|0,g+80|0,g+40|0),c(g+40|0,g+80|0),I=1;do{c(g+40|0,g+40|0),I=I+1|0}while(5!=(0|I));a(g+80|0,g+40|0,g+80|0),c(g+40|0,g+80|0),I=1;do{c(g+40|0,g+40|0),I=I+1|0}while(10!=(0|I));a(g+40|0,g+40|0,g+80|0),c(g,g+40|0),I=1;do{c(g,g),I=I+1|0}while(20!=(0|I));a(g+40|0,g,g+40|0),c(g+40|0,g+40|0),I=1;do{c(g+40|0,g+40|0),I=I+1|0}while(10!=(0|I));a(g+80|0,g+40|0,g+80|0),c(g+40|0,g+80|0),I=1;do{c(g+40|0,g+40|0),I=I+1|0}while(50!=(0|I));a(g+40|0,g+40|0,g+80|0),c(g,g+40|0),I=1;do{c(g,g),I=I+1|0}while(100!=(0|I));a(g+40|0,g,g+40|0),c(g+40|0,g+40|0),I=1;do{c(g+40|0,g+40|0),I=I+1|0}while(50!=(0|I));a(g+80|0,g+40|0,g+80|0),c(g+80|0,g+80|0),I=1;do{c(g+80|0,g+80|0),I=I+1|0}while(5!=(0|I));a(A,g+80|0,g+120|0),wi=e}function S(A,I,e,g,i,B,t){A|=0,I|=0,e|=0,g|=0,i|=0;var r=0,a=0,n=0,C=0;a=wi,n=wi=wi+63&-64,wi=wi+352|0,k(n+256|0,B|=0,t|=0),(A>>>0>e>>>0?0<i>>>0|0==(0|i)&(A-e|0)>>>0<g>>>0:0)?r=5:(e>>>0>A>>>0?0<i>>>0|0==(0|i)&(e-A|0)>>>0<g>>>0:0)&&(r=5),5==(0|r)&&(GI(0|A,0|e,0|g),e=A),r=32+(t=n+288|0)|0;do{yi[t>>0]=0,t=t+1|0}while((0|t)<(0|r));return t=i>>>0>0|0==(0|i)&g>>>0>32?32:g,r=i>>>0>0|0==(0|i)&g>>>0>32?0:i,0==(0|t)&0==(0|r)||T(n+288+32|0,0|e,1+(C=0|Ag(-2,-1,0|(~i>>>0>4294967295|-1==(0|~i)&~g>>>0>4294967263?~g:-33),0|(~i>>>0>4294967295|-1==(0|~i)&~g>>>0>4294967263?~i:-1)))|0),C=0|Ig(0|t,0|r,32,0),ze(n+288|0,n+288|0,C,vi,B+16|0,n+256|0),Mg(n,n+288|0),0==(0|t)&0==(0|r)||T(0|A,n+288+32|0,1+(C=0|Ag(-2,-1,0|(~i>>>0>4294967295|-1==(0|~i)&~g>>>0>4294967263?~g:-33),0|(~i>>>0>4294967295|-1==(0|~i)&~g>>>0>4294967263?~i:-1)))|0),YI(n+288|0,64),i>>>0>0|0==(0|i)&g>>>0>32&&qe(A+t|0,e+t|0,C=0|Ag(0|g,0|i,0|t,0|r),vi,B+16|0,n+256|0),YI(n+256|0,32),eg(n,A,g,i),mg(n,I),YI(n,256),wi=a,0}function R(A,I){I|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0;if(g=0|fi[56+(A|=0)>>2],e=0|fi[A+56+4>>2],!(0==(0|g)&0==(0|e))){for(i=1;yi[A+64+g>>0]=i,g=0|Ig(0|g,0|e,1,0),(e=vi)>>>0<0|0==(0|e)&g>>>0<16;)i=0;yi[A+80>>0]=1,y(A,A+64|0,16,0)}g=0|fi[A+24>>2],a=(((n=(((B=(5*((t=((a=((i=(0|fi[A+28>>2])+(g>>>26)|0)>>>26)+(0|fi[A+32>>2])|0)>>>26)+(0|fi[A+36>>2])|0)>>>26)|0)+(0|fi[A+20>>2])|0)>>>26)+(67108863&g)+((5+(67108863&B)|0)>>>26)|0)>>>26)+(67108863&i)|0)>>>26)+a&67108863&((r=(-67108864|t)+((((n+(67108863&i)|0)>>>26)+(67108863&a)|0)>>>26)|0)>>>31)-1|r>>31&67108863&a,B=0|Ig(B+5&67108863&(r>>>31)-1|r>>31&67108863&B|(g=(B>>>26)+(67108863&g)+((5+(67108863&B)|0)>>>26)&67108863&(r>>>31)-1|r>>31&(B>>>26)+(67108863&g))<<26|0,0,0|fi[A+40>>2],0),e=vi,e=0|Ig(0|(g=0|Ig(g>>>6|(n+i&67108863&(r>>>31)-1|r>>31&67108863&i)<<20|0,0,0|fi[A+44>>2],0)),0|vi,0|e,0),g=vi,g=0|Ig(0|(i=0|Ig((n+i&67108863&(r>>>31)-1|r>>31&67108863&i)>>>12|a<<14|0,0,0|fi[A+48>>2],0)),0|vi,0|g,0),i=vi,i=0|Ig(0|(t=0|Ig(a>>>18|((r>>>31)-1&r|r>>31&t)<<8|0,0,0|fi[A+52>>2],0)),0|vi,0|i,0),Bg(I,B),Bg(I+4|0,e),Bg(I+8|0,g),Bg(I+12|0,i),YI(A,88)}function N(A,I){A|=0;var e=0,g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+128|0,c(i+80|0,I|=0),c(i+40|0,i+80|0),c(i+40|0,i+40|0),a(i+40|0,I,i+40|0),a(i+80|0,i+80|0,i+40|0),c(i+80|0,i+80|0),a(i+80|0,i+40|0,i+80|0),c(i+40|0,i+80|0),e=1;do{c(i+40|0,i+40|0),e=e+1|0}while(5!=(0|e));a(i+80|0,i+40|0,i+80|0),c(i+40|0,i+80|0),e=1;do{c(i+40|0,i+40|0),e=e+1|0}while(10!=(0|e));a(i+40|0,i+40|0,i+80|0),c(i,i+40|0),e=1;do{c(i,i),e=e+1|0}while(20!=(0|e));a(i+40|0,i,i+40|0),c(i+40|0,i+40|0),e=1;do{c(i+40|0,i+40|0),e=e+1|0}while(10!=(0|e));a(i+80|0,i+40|0,i+80|0),c(i+40|0,i+80|0),e=1;do{c(i+40|0,i+40|0),e=e+1|0}while(50!=(0|e));a(i+40|0,i+40|0,i+80|0),c(i,i+40|0),e=1;do{c(i,i),e=e+1|0}while(100!=(0|e));a(i+40|0,i,i+40|0),c(i+40|0,i+40|0),e=1;do{c(i+40|0,i+40|0),e=e+1|0}while(50!=(0|e));a(i+80|0,i+40|0,i+80|0),c(i+80|0,i+80|0),c(i+80|0,i+80|0),a(A,i+80|0,I),wi=g}function U(A,I,e,g,i){A|=0,I|=0,e|=0,g|=0;var B=0,t=0,r=0,a=0,n=0,C=0;Ng(i|=0),t=(0|bi((g>>>0)/3|0,-3))+g|0,B=((g>>>0)/3|0)<<2;do{if(t){if(2&i){B=(2|B)+(t>>>1)|0;break}B=B+4|0;break}}while(0);if(B>>>0>=I>>>0&&hi(),4&i)if(0|g){r=0,n=0,t=0,i=0;do{for(i=0|_i[e+n>>0]|i<<8,C=r+8|0,a=t;r=C+-6|0,t=a+1|0,yi[A+a>>0]=0|OI(i>>>r&63),r>>>0>5;)C=r,a=t;n=n+1|0}while((0|n)!=(0|g));r&&(yi[A+t>>0]=0|OI(i<<12-C&63),t=a+2|0)}else t=0;else if(0|g){a=0,i=0,t=0,r=0;do{for(i=0|_i[e+a>>0]|i<<8,C=t,n=r+8|0;r=n+-6|0,t=C+1|0,yi[A+C>>0]=0|Ae(i>>>r&63),r>>>0>5;)C=t,n=r;a=a+1|0}while((0|a)!=(0|g));r&&(yi[A+t>>0]=0|Ae(i<<12-n&63),t=C+2|0)}else t=0;return B>>>0<t>>>0&&Mi(34645,34664,230,34680),B>>>0>t>>>0?wA(A+t|0,61,B-t|0):B=t,g=B+1|0,wA(A+B|0,0,(g>>>0<I>>>0?I:g)-B|0),0|A}function J(A,I){A|=0;var e=0,g=0,i=0;for(g=wi,i=wi=wi+63&-64,wi=wi+1760|0,we(i+480|0,I|=0),ue(i+320|0,I),Qe(i,i+320|0),jA(i+320|0,i,i+480|0),Qe(i+160|0,i+320|0),we(i+480+160|0,i+160|0),jA(i+320|0,i,i+480+160|0),Qe(i+160|0,i+320|0),we(i+480+320|0,i+160|0),jA(i+320|0,i,i+480+320|0),Qe(i+160|0,i+320|0),we(i+480+480|0,i+160|0),jA(i+320|0,i,i+480+480|0),Qe(i+160|0,i+320|0),we(i+480+640|0,i+160|0),jA(i+320|0,i,i+480+640|0),Qe(i+160|0,i+320|0),we(i+480+800|0,i+160|0),jA(i+320|0,i,i+480+800|0),Qe(i+160|0,i+320|0),we(i+480+960|0,i+160|0),jA(i+320|0,i,i+480+960|0),Qe(i+160|0,i+320|0),we(i+480+1120|0,i+160|0),bg(A),I=252;ue(i+320|0,A),(e=0|yi[32988+I>>0])<<24>>24<=0?e<<24>>24<0&&(Qe(i+160|0,i+320|0),qA(i+320|0,i+160|0,i+480+(160*(((e<<24>>24)/-2|0)<<24>>24)|0)|0)):(Qe(i+160|0,i+320|0),jA(i+320|0,i+160|0,i+480+(160*((255&e)>>>1&255)|0)|0)),Qe(A,i+320|0),(0|I)>0;)I=I+-1|0;wi=g}function P(A,I,e){A|=0,I|=0,e|=0;var g=0,i=0,B=0;i=wi,B=wi=wi+63&-64,wi=wi+288|0,g=0;do{yi[A+g>>0]=0|yi[I+g>>0],g=g+1|0}while(32!=(0|g));for(yi[A>>0]=-8&yi[A>>0],yi[A+31>>0]=63&yi[A+31>>0]|64,f(B+240|0,e),$e(B+200|0),fg(B+160|0),KA(B+120|0,B+240|0),$e(B+80|0),g=0,I=254;e=g,g=(0|_i[A+(I>>>3)>>0])>>>(7&I)&1,e^=g,x(B+200|0,B+120|0,e),x(B+160|0,B+80|0,e),hA(B+40|0,B+120|0,B+80|0),hA(B,B+200|0,B+160|0),yA(B+200|0,B+200|0,B+160|0),yA(B+160|0,B+120|0,B+80|0),a(B+80|0,B+40|0,B+200|0),a(B+160|0,B+160|0,B),c(B+40|0,B),c(B,B+200|0),yA(B+120|0,B+80|0,B+160|0),hA(B+160|0,B+80|0,B+160|0),a(B+200|0,B,B+40|0),hA(B,B,B+40|0),c(B+160|0,B+160|0),_(B+80|0,B),c(B+120|0,B+120|0),yA(B+40|0,B+40|0,B+80|0),a(B+80|0,B+240|0,B+160|0),a(B+160|0,B,B+40|0),!((0|I)<=0);)I=I+-1|0;return x(B+200|0,B+120|0,g),x(B+160|0,B+80|0,g),Y(B+160|0,B+160|0),a(B+200|0,B+200|0,B+160|0),q(A,B+200|0),wi=i,0}function L(A,I,e){A|=0,I|=0;var i=0,B=0,t=0,r=0,a=0;if(a=wi,r=wi=wi+63&-64,wi=wi+64|0,(e|=0)<<24>>24?(255&e)<=64:0){if(0|jg(0|fi[A+80>>2],0|fi[A+80+4>>2]))i=-1;else{i=0|fi[A+352>>2];do{if(i>>>0>128){if(QI(A,128,0),g(A,A+96|0),i=(0|fi[A+352>>2])-128|0,fi[A+352>>2]=i,i>>>0<129){T(A+96|0,A+224|0,0|i),B=A+96|0,t=0|fi[A+352>>2];break}Mi(33273,33305,304,33350)}else B=A+96|0,t=i}while(0);QI(A,t,0),ig(A),wA(A+96+(i=0|fi[A+352>>2])|0,0,256-i|0),g(A,B),WI(r,0|fi[A>>2],0|fi[A+4>>2]),WI(r+8|0,0|fi[A+8>>2],0|fi[A+8+4>>2]),WI(r+16|0,0|fi[A+16>>2],0|fi[A+16+4>>2]),WI(r+24|0,0|fi[A+24>>2],0|fi[A+24+4>>2]),WI(r+32|0,0|fi[A+32>>2],0|fi[A+32+4>>2]),WI(r+40|0,0|fi[A+40>>2],0|fi[A+40+4>>2]),WI(r+48|0,0|fi[A+48>>2],0|fi[A+48+4>>2]),WI(r+56|0,0|fi[A+56>>2],0|fi[A+56+4>>2]),T(0|I,0|r,255&e|0),YI(A,64),YI(B,256),i=0}return wi=a,0|i}return hi(),0}function x(A,I,e){I|=0,e|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0,l=0;l=0|fi[(A|=0)>>2],p=0|fi[A+4>>2],f=0|fi[A+8>>2],h=0|fi[A+12>>2],E=0|fi[A+16>>2],c=0|fi[A+20>>2],C=0|fi[A+24>>2],a=0|fi[A+28>>2],t=0|fi[A+32>>2],i=0|fi[A+36>>2],w=0|fi[I>>2],_=0|fi[I+4>>2],y=0|fi[I+8>>2],s=0|fi[I+12>>2],Q=0|fi[I+16>>2],o=0|fi[I+20>>2],n=0|fi[I+24>>2],r=0|fi[I+28>>2],B=0|fi[I+32>>2],g=0|fi[I+36>>2],fi[A>>2]=(w^l)&0-e^l,fi[A+4>>2]=(_^p)&0-e^p,fi[A+8>>2]=(y^f)&0-e^f,fi[A+12>>2]=(s^h)&0-e^h,fi[A+16>>2]=(Q^E)&0-e^E,fi[A+20>>2]=(o^c)&0-e^c,fi[A+24>>2]=(n^C)&0-e^C,fi[A+28>>2]=(r^a)&0-e^a,fi[A+32>>2]=(B^t)&0-e^t,fi[A+36>>2]=(g^i)&0-e^i,fi[I>>2]=(w^l)&0-e^w,fi[I+4>>2]=(_^p)&0-e^_,fi[I+8>>2]=(y^f)&0-e^y,fi[I+12>>2]=(s^h)&0-e^s,fi[I+16>>2]=(Q^E)&0-e^Q,fi[I+20>>2]=(o^c)&0-e^o,fi[I+24>>2]=(n^C)&0-e^n,fi[I+28>>2]=(r^a)&0-e^r,fi[I+32>>2]=(B^t)&0-e^B,fi[I+36>>2]=(g^i)&0-e^g}function X(A,I,e,g,i,B,t){A|=0,I|=0,e|=0,g|=0,i|=0;var r=0,a=0,n=0;return n=wi,a=wi=wi+63&-64,wi=wi+96|0,k(a,B|=0,t|=0),Sg(a+32|0,B+16|0,a),0|We(e,I,g,i,a+32|0)?(YI(a,32),e=-1):A?((I>>>0>=A>>>0?0<i>>>0|0==(0|i)&(I-A|0)>>>0<g>>>0:0)?r=8:(A>>>0>=I>>>0?0<i>>>0|0==(0|i)&(A-I|0)>>>0<g>>>0:0)&&(r=8),8==(0|r)&&(GI(0|A,0|I,0|g),I=A),0==(0|(e=i>>>0>0|0==(0|i)&g>>>0>32?32:g))&0==(0|(t=i>>>0>0|0==(0|i)&g>>>0>32?0:i))?ze(a+32|0,a+32|0,32,0,B+16|0,a):(T(a+32+32|0,0|I,1+(r=0|Ag(-2,-1,0|(~i>>>0>4294967295|-1==(0|~i)&~g>>>0>4294967263?~g:-33),0|(~i>>>0>4294967295|-1==(0|~i)&~g>>>0>4294967263?~i:-1)))|0),ze(a+32|0,a+32|0,0|Ig(0|e,0|t,32,0),vi,B+16|0,a),T(0|A,a+32+32|0,r+1|0)),i>>>0>0|0==(0|i)&g>>>0>32&&qe(A+e|0,I+e|0,0|Ag(0|g,0|i,0|e,0|t),vi,B+16|0,a),YI(a,32),e=0):e=0,wi=n,0|e}function K(A,I,e,g,i){A|=0,g|=0,i|=0;var B=0,t=0,r=0,a=0,n=0,C=0,o=0;if(C=wi,o=wi=wi+63&-64,wi=wi+112|0,!(0==(0|(I|=0))&0==(0|(e|=0)))){B=32+(t=o+16|0)|0;do{yi[t>>0]=0|yi[i>>0],t=t+1|0,i=i+1|0}while((0|t)<(0|B));if(t=_i[g+4>>0]|_i[g+4+1>>0]<<8|_i[g+4+2>>0]<<16|_i[g+4+3>>0]<<24,fi[o>>2]=_i[g>>0]|_i[g+1>>0]<<8|_i[g+2>>0]<<16|_i[g+3>>0]<<24,fi[o+4>>2]=t,fi[o+8>>2]=0,fi[o+8+4>>2]=0,e>>>0>0|0==(0|e)&I>>>0>63){do{for(Ug(A,o,o+16|0),i=1,B=8;t=o+B|0,i=(0|_i[t>>0])+i|0,yi[t>>0]=i,16!=(0|(B=B+1|0));)i>>>=8;I=0|Ig(0|I,0|e,-64,-1),e=vi,A=A+64|0}while(e>>>0>0|0==(0|e)&I>>>0>63);0==(0|I)&0==(0|e)||(a=A,n=I,r=7)}else a=A,n=I,r=7;if(7==(0|r)?(Ug(o+48|0,o,o+16|0),0|n):0){i=0;do{yi[a+i>>0]=0|yi[o+48+i>>0],i=i+1|0}while((0|i)!=(0|n))}YI(o+48|0,64),YI(o+16|0,32)}wi=C}function T(A,I,e){A|=0,I|=0;var g=0,i=0,B=0;if((0|(e|=0))>=8192)return 0|Ri(0|A,0|I,0|e);if(B=0|A,i=A+e|0,(3&A)==(3&I)){for(;3&A;){if(!e)return 0|B;yi[A>>0]=0|yi[I>>0],A=A+1|0,I=I+1|0,e=e-1|0}for(g=(e=-4&i|0)-64|0;(0|A)<=(0|g);)fi[A>>2]=fi[I>>2],fi[A+4>>2]=fi[I+4>>2],fi[A+8>>2]=fi[I+8>>2],fi[A+12>>2]=fi[I+12>>2],fi[A+16>>2]=fi[I+16>>2],fi[A+20>>2]=fi[I+20>>2],fi[A+24>>2]=fi[I+24>>2],fi[A+28>>2]=fi[I+28>>2],fi[A+32>>2]=fi[I+32>>2],fi[A+36>>2]=fi[I+36>>2],fi[A+40>>2]=fi[I+40>>2],fi[A+44>>2]=fi[I+44>>2],fi[A+48>>2]=fi[I+48>>2],fi[A+52>>2]=fi[I+52>>2],fi[A+56>>2]=fi[I+56>>2],fi[A+60>>2]=fi[I+60>>2],A=A+64|0,I=I+64|0;for(;(0|A)<(0|e);)fi[A>>2]=fi[I>>2],A=A+4|0,I=I+4|0}else for(e=i-4|0;(0|A)<(0|e);)yi[A>>0]=0|yi[I>>0],yi[A+1>>0]=0|yi[I+1>>0],yi[A+2>>0]=0|yi[I+2>>0],yi[A+3>>0]=0|yi[I+3>>0],A=A+4|0,I=I+4|0;for(;(0|A)<(0|i);)yi[A>>0]=0|yi[I>>0],A=A+1|0,I=I+1|0;return 0|B}function V(A){var I=0,e=0,g=0,i=0,B=0;e=wi,g=wi=wi+63&-64,wi=wi+48|0,i=A|=0,B=(I=g)+32|0;do{yi[I>>0]=0|yi[i>>0],I=I+1|0,i=i+1|0}while((0|I)<(0|B));i=_i[A+36>>0]|_i[A+36+1>>0]<<8|_i[A+36+2>>0]<<16|_i[A+36+3>>0]<<24,I=_i[A+36+4>>0]|_i[A+36+4+1>>0]<<8|_i[A+36+4+2>>0]<<16|_i[A+36+4+3>>0]<<24,yi[g+32>>0]=i,yi[g+32+1>>0]=i>>8,yi[g+32+2>>0]=i>>16,yi[g+32+3>>0]=i>>24,yi[g+32+4>>0]=I,yi[g+32+4+1>>0]=I>>8,yi[g+32+4+2>>0]=I>>16,yi[g+32+4+3>>0]=I>>24,ng(g,g,A+32|0,A),i=g,B=(I=A)+32|0;do{yi[I>>0]=0|yi[i>>0],I=I+1|0,i=i+1|0}while((0|I)<(0|B));i=_i[g+32>>0]|_i[g+32+1>>0]<<8|_i[g+32+2>>0]<<16|_i[g+32+3>>0]<<24,B=_i[g+32+4>>0]|_i[g+32+4+1>>0]<<8|_i[g+32+4+2>>0]<<16|_i[g+32+4+3>>0]<<24,yi[A+36>>0]=i,yi[A+36+1>>0]=i>>8,yi[A+36+2>>0]=i>>16,yi[A+36+3>>0]=i>>24,yi[A+36+4>>0]=B,yi[A+36+4+1>>0]=B>>8,yi[A+36+4+2>>0]=B>>16,yi[A+36+4+3>>0]=B>>24,Ye(A),wi=e}function q(A,I){A|=0;var e=0,g=0,i=0;e=wi,i=wi=wi+63&-64,wi=wi+48|0,j(i,I|=0),I=0|fi[i>>2],yi[A>>0]=I,yi[A+1>>0]=I>>>8,yi[A+2>>0]=I>>>16,g=0|fi[i+4>>2],yi[A+3>>0]=g<<2|I>>>24,yi[A+4>>0]=g>>>6,yi[A+5>>0]=g>>>14,I=0|fi[i+8>>2],yi[A+6>>0]=I<<3|g>>>22,yi[A+7>>0]=I>>>5,yi[A+8>>0]=I>>>13,g=0|fi[i+12>>2],yi[A+9>>0]=g<<5|I>>>21,yi[A+10>>0]=g>>>3,yi[A+11>>0]=g>>>11,I=0|fi[i+16>>2],yi[A+12>>0]=I<<6|g>>>19,yi[A+13>>0]=I>>>2,yi[A+14>>0]=I>>>10,yi[A+15>>0]=I>>>18,I=0|fi[i+20>>2],yi[A+16>>0]=I,yi[A+17>>0]=I>>>8,yi[A+18>>0]=I>>>16,g=0|fi[i+24>>2],yi[A+19>>0]=g<<1|I>>>24,yi[A+20>>0]=g>>>7,yi[A+21>>0]=g>>>15,I=0|fi[i+28>>2],yi[A+22>>0]=I<<3|g>>>23,yi[A+23>>0]=I>>>5,yi[A+24>>0]=I>>>13,g=0|fi[i+32>>2],yi[A+25>>0]=g<<4|I>>>21,yi[A+26>>0]=g>>>4,yi[A+27>>0]=g>>>12,I=0|fi[i+36>>2],yi[A+28>>0]=I<<6|g>>>20,yi[A+29>>0]=I>>>2,yi[A+30>>0]=I>>>10,yi[A+31>>0]=I>>>18,wi=e}function j(A,I){A|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0;Q=0|fi[(I|=0)>>2],o=0|fi[I+4>>2],C=0|fi[I+8>>2],n=0|fi[I+12>>2],r=0|fi[I+16>>2],t=0|fi[I+20>>2],B=0|fi[I+24>>2],g=0|fi[I+28>>2],e=0|fi[I+32>>2],i=(((a=(((c=(19*((((((((((((16777216+(19*(I=0|fi[I+36>>2])|0)|0)>>>25)+Q>>26)+o>>25)+C>>26)+n>>25)+r>>26)+t>>25)+B>>26)+g>>25)+e>>26)+I>>25)|0)+Q>>26)+o>>25)+C>>26)+n>>25)+r>>26)+t>>25)+B>>26,fi[A>>2]=(19*((((((((((((16777216+(19*I|0)|0)>>>25)+Q>>26)+o>>25)+C>>26)+n>>25)+r>>26)+t>>25)+B>>26)+g>>25)+e>>26)+I>>25)|0)+Q-(c<<26),fi[A+4>>2]=c+o-(c+o>>25<<25),fi[A+8>>2]=(c+o>>25)+C-((c+o>>25)+C>>26<<26),fi[A+12>>2]=((c+o>>25)+C>>26)+n-(a<<25),fi[A+16>>2]=a+r-(a+r>>26<<26),fi[A+20>>2]=(a+r>>26)+t-((a+r>>26)+t>>25<<25),fi[A+24>>2]=((a+r>>26)+t>>25)+B-(i<<26),fi[A+28>>2]=i+g-(i+g>>25<<25),fi[A+32>>2]=(i+g>>25)+e-((i+g>>25)+e>>26<<26),fi[A+36>>2]=((i+g>>25)+e>>26)+I&33554431}function Z(A,I){A|=0,I|=0;var e=0,g=0,i=0,B=0,t=0;g=wi,i=wi=wi+63&-64,wi=wi+464|0,e=0;do{t=0|yi[I+e>>0],yi[i+400+(B=e<<1)>>0]=15&t,yi[i+400+(1|B)>>0]=(255&t)>>>4,e=e+1|0}while(32!=(0|e));e=0,I=0;do{e=134217728+((B=(0|_i[(t=i+400+I|0)>>0])+e|0)<<24)>>28,yi[t>>0]=B-(e<<4),I=I+1|0}while(63!=(0|I));yi[i+400+63>>0]=(0|_i[i+400+63>>0])+e,bg(A),e=1;do{vg(i,(0|e)/2|0,0|yi[i+400+e>>0]),zA(i+240|0,A,i),Qe(A,i+240|0),e=e+2|0}while((0|e)<64);ue(i+240|0,A),Xe(i+120|0,i+240|0),nI(i+240|0,i+120|0),Xe(i+120|0,i+240|0),nI(i+240|0,i+120|0),Xe(i+120|0,i+240|0),nI(i+240|0,i+120|0),Qe(A,i+240|0),e=0;do{vg(i,(0|e)/2|0,0|yi[i+400+e>>0]),zA(i+240|0,A,i),Qe(A,i+240|0),e=e+2|0}while((0|e)<64);wi=g}function W(A,I,e,g){A|=0,I|=0,e|=0,g|=0;var i=0,B=0,r=0,a=0,n=0,C=0,o=0;o=wi,C=wi=wi+63&-64,wi=wi+64|0,B=52+(i=C+8|0)|0;do{fi[i>>2]=0,i=i+4|0}while((0|i)<(0|B));i=0|TA(A),fi[C+36>>2]=i,fi[C+20>>2]=i,fi[C+4>>2]=i,B=0|t(i),fi[C+32>>2]=B,r=0|t(i),fi[C+16>>2]=r,a=0|t(i),fi[C>>2]=a;do{if(0==(0|r)|0==(0|a)|0==(0|B))Q(B),Q(r),Q(a),i=-22;else{if(!(n=0|t(i))){Q(B),Q(r),Q(a),i=-22;break}if(0|(i=0|b(C,A,g))){Q(0|fi[C+32>>2]),Q(0|fi[C+16>>2]),Q(0|fi[C>>2]),Q(n);break}g=0|eA(0|fi[C+40>>2],0|fi[C+44>>2],0|fi[C+52>>2],I,e,0|fi[C+16>>2],0|fi[C+20>>2],n,0|fi[C+4>>2],0,0,g),Q(0|fi[C+32>>2]),Q(0|fi[C+16>>2]),i=(0==(0|g)?0==(0|iI(n,0|fi[C>>2],0|fi[C+4>>2])):0)?0:-35,Q(n),Q(0|fi[C>>2])}}while(0);return wi=o,0|i}function z(A,I,e){A|=0,I|=0,e|=0;var g=0,i=0,B=0,t=0,r=0;if(i=wi,B=wi=wi+63&-64,wi=wi+4096|0,ei(B+3072|0),ei(B+2048|0),0!=(0|A)&0!=(0|I)?(fi[B+2048>>2]=fi[I>>2],fi[B+2048+4>>2]=0,fi[B+2048+8>>2]=fi[I+4>>2],fi[B+2048+8+4>>2]=0,fi[B+2048+16>>2]=_i[I+8>>0],fi[B+2048+16+4>>2]=0,fi[B+2048+24>>2]=fi[A+16>>2],fi[B+2048+24+4>>2]=0,fi[B+2048+32>>2]=fi[A+8>>2],fi[B+2048+32+4>>2]=0,fi[B+2048+40>>2]=fi[A+36>>2],fi[B+2048+40+4>>2]=0,0|fi[A+20>>2]):0){I=0;do{(g=127&I)||(t=0|Ig(0|fi[B+2048+48>>2],0|fi[B+2048+48+4>>2],1,0),fi[B+2048+48>>2]=t,fi[B+2048+48+4>>2]=vi,ei(B),ei(B+1024|0),n(B+3072|0,B+2048|0,B),n(B+3072|0,B,B+1024|0)),r=0|fi[B+1024+(g<<3)+4>>2],fi[(t=e+(I<<3)|0)>>2]=fi[B+1024+(g<<3)>>2],fi[t+4>>2]=r,I=I+1|0}while(I>>>0<(0|fi[A+20>>2])>>>0)}wi=i}function O(A){A|=0;var I=0,e=0;do{if(A)if(0|fi[A>>2])if((0|fi[A+4>>2])>>>0>=16){if(0==(0|fi[A+8>>2])?0|fi[A+12>>2]:0){I=-18;break}if(I=0|fi[A+20>>2],0!=(0|fi[A+16>>2])|0==(0|I))if(I>>>0>=8){if(0==(0|fi[A+24>>2])?0|fi[A+28>>2]:0){I=-20;break}if(0==(0|fi[A+32>>2])?0|fi[A+36>>2]:0){I=-21;break}if((I=0|fi[A+44>>2])>>>0>=8)if(I>>>0<=2097152)if(e=0|fi[A+48>>2],I>>>0>=e<<3>>>0)if(0|fi[A+40>>2])if(e){if(!(e>>>0>16777215))return 0|(0==(0|(A=0|fi[A+52>>2]))?-28:A>>>0>16777215?-29:0);I=-17}else I=-16;else I=-12;else I=-14;else I=-15;else I=-14}else I=-6;else I=-19}else I=-2;else I=-1;else I=-25}while(0);return 0|I}function $(A,I,e,g,i){A|=0,e|=0,g|=0,i|=0;var B=0,t=0,r=0;t=wi,r=wi=wi+63&-64,wi=wi+192|0,((I|=0)-1&255)>63&&hi(),e||hi(),yi[r+128>>0]=I,yi[r+128+1>>0]=32,yi[r+128+2>>0]=1,yi[r+128+3>>0]=1,Dg(r+128+4|0),WI(r+128+8|0,0,0),B=16+(I=r+128+16|0)|0;do{yi[I>>0]=0,I=I+1|0}while((0|I)<(0|B));if(g)de(r+128|0,g);else{B=16+(I=r+128+32|0)|0;do{yi[I>>0]=0,I=I+1|0}while((0|I)<(0|B))}if(i)le(r+128|0,i);else{B=16+(I=r+128+48|0)|0;do{yi[I>>0]=0,I=I+1|0}while((0|I)<(0|B))}bI(A,r+128|0),B=96+(I=r+32|0)|0;do{yi[I>>0]=0,I=I+1|0}while((0|I)<(0|B));B=(I=r)+32|0;do{yi[I>>0]=0|yi[e>>0],I=I+1|0,e=e+1|0}while((0|I)<(0|B));rA(A,r,128,0),YI(r,128),wi=t}function AA(A,I,e,g,i,B,t,r,a,n,C){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0;var o=0;o=wi,wi=wi+352|0,ag(o+280|0,64,0,n|=0,C|=0),Mg(o,o+280|0),YI(o+280|0,64),eg(o,t,r,a),eg(o,35288,15&(I=0|Ag(0,0,0|r,0|a)),0),eg(o,e,g,i),eg(o,35288,15&(I=0|Ag(0,0,0|g,0|i)),0),WI(o+272|0,r,a),eg(o,o+272|0,8,0),WI(o+272|0,g,i),eg(o,o+272|0,8,0),mg(o,o+256|0),YI(o,256),I=0|zg(o+256|0,B),YI(o+256|0,16);do{if(A){if(I){wA(0|A,0,0|g),I=-1;break}He(A,e,g,i,n,1,C),I=0;break}}while(0);return wi=o,0|I}function IA(A){var I=0,e=0,g=0,i=0;if((A|=0)>>>0>=4294967168)return fi[8202]=12,0|(i=0);if(i=A>>>0<11?16:A+11&-8,!(g=0|t(i+76|0)))return 0|(i=0);do{if(63&g){if(e=((g+63&-64)-8-(g+-8)|0)>>>0>15?(g+63&-64)-8|0:56+(g+63&-64)|0,A=e-(g+-8)|0,3&(I=0|fi[g+-4>>2])){fi[e+4>>2]=(-8&I)-A|1&fi[e+4>>2]|2,fi[e+((-8&I)-A)+4>>2]=1|fi[e+((-8&I)-A)+4>>2],fi[g+-4>>2]=A|1&fi[g+-4>>2]|2,fi[e+4>>2]=1|fi[e+4>>2],E(g+-8|0,A),A=e;break}fi[e>>2]=(0|fi[g+-8>>2])+A,fi[e+4>>2]=(-8&I)-A,A=e;break}A=g+-8|0,e=g+-8|0}while(0);return A=A+4|0,(3&(I=0|fi[A>>2])|0?(-8&I)>>>0>(i+16|0)>>>0:0)&&(g=e+i|0,fi[A>>2]=i|1&I|2,fi[g+4>>2]=(-8&I)-i|3,fi[g+((-8&I)-i)+4>>2]=1|fi[g+((-8&I)-i)+4>>2],E(g,(-8&I)-i|0)),0|(i=e+8|0)}function eA(A,I,e,g,i,B,r,a,n,C,o,c){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,r|=0,a|=0,C|=0,o|=0,c|=0;var E=0,s=0,h=0;h=wi,s=wi=wi+63&-64,wi=wi+64|0,E=0|t(n|=0);do{if(E){if(fi[s>>2]=E,fi[s+4>>2]=n,fi[s+8>>2]=g,fi[s+12>>2]=i,fi[s+16>>2]=B,fi[s+20>>2]=r,fi[s+24>>2]=0,fi[s+24+4>>2]=0,fi[s+24+8>>2]=0,fi[s+24+12>>2]=0,fi[s+40>>2]=A,fi[s+44>>2]=I,fi[s+48>>2]=e,fi[s+52>>2]=e,fi[s+56>>2]=4,0|(A=0|cA(s,c))){YI(E,n),Q(E);break}if(0|a&&T(0|a,0|E,0|n),0!=(0|C)&0!=(0|o)?0|l(C,o,s,c):0){YI(E,n),YI(C,o),Q(E),A=-31;break}YI(E,n),Q(E),A=0}else A=-22}while(0);return wi=h,0|A}function gA(A,I){var e=0,g=0,i=0;return i=wi,e=wi=wi+63&-64,wi=wi+240|0,f(40+(A|=0)|0,I|=0),$e(A+80|0),c(e+200|0,A+40|0),a(e+160|0,e+200|0,944),hA(e+200|0,e+200|0,A+80|0),yA(e+160|0,e+160|0,A+80|0),c(e+120|0,e+160|0),a(e+120|0,e+120|0,e+160|0),c(A,e+120|0),a(A,A,e+160|0),a(A,A,e+200|0),N(A,A),a(A,A,e+120|0),a(A,A,e+200|0),c(e+80|0,A),a(e+80|0,e+80|0,e+160|0),hA(e+40|0,e+80|0,e+200|0),0|ve(e+40|0)?g=4:(yA(e,e+80|0,e+200|0),0|ve(e)?(a(A,A,984),g=4):A=-1),4==(0|g)&&((0|(g=0|Re(A)))==((0|_i[I+31>>0])>>>7|0)&&RA(A,A),a(A+120|0,A,A+40|0),A=0),wi=i,0|A}function iA(A,I,e){I|=0,e|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0,c=0,Q=0,E=0,s=0,h=0,y=0,f=0,_=0,p=0,w=0;w=0|fi[(A|=0)>>2],_=0|fi[A+4>>2],y=0|fi[A+8>>2],s=0|fi[A+12>>2],Q=0|fi[A+16>>2],o=0|fi[A+20>>2],n=0|fi[A+24>>2],r=0|fi[A+28>>2],B=0|fi[A+32>>2],g=0|fi[A+36>>2],p=(fi[I+4>>2]^_)&0-e,f=(fi[I+8>>2]^y)&0-e,h=(fi[I+12>>2]^s)&0-e,E=(fi[I+16>>2]^Q)&0-e,c=(fi[I+20>>2]^o)&0-e,C=(fi[I+24>>2]^n)&0-e,a=(fi[I+28>>2]^r)&0-e,t=(fi[I+32>>2]^B)&0-e,i=(fi[I+36>>2]^g)&0-e,fi[A>>2]=(fi[I>>2]^w)&0-e^w,fi[A+4>>2]=p^_,fi[A+8>>2]=f^y,fi[A+12>>2]=h^s,fi[A+16>>2]=E^Q,fi[A+20>>2]=c^o,fi[A+24>>2]=C^n,fi[A+28>>2]=a^r,fi[A+32>>2]=t^B,fi[A+36>>2]=i^g}function BA(A,I){A|=0,I|=0;var e=0,g=0,i=0,B=0,t=0;e=0;do{yi[A+e>>0]=(0|_i[I+(e>>3)>>0])>>>(7&e)&1,e=e+1|0}while(256!=(0|e));B=0;do{t=A+B|0;A:do{if(0|yi[t>>0]){i=1;do{if((0|(e=i+B|0))>=256)break A;I=0|yi[A+e>>0];I:do{if(I<<24>>24){if(I=I<<24>>24<<i,((g=0|yi[t>>0])+I|0)<16){yi[t>>0]=g+I,yi[A+e>>0]=0;break}if((g-I|0)<-15)break A;for(yi[t>>0]=g-I;I=A+e|0,0|yi[I>>0];)if(yi[I>>0]=0,(0|(e=e+1|0))>=256)break I;yi[I>>0]=1}}while(0);i=i+1|0}while((0|i)<7)}}while(0);B=B+1|0}while(256!=(0|B))}function tA(A,I,e,g,i,B,t,r,a,n,C,o){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,o|=0,n=wi,wi=wi+336|0,ag(n+264|0,64,0,C,o),Mg(n,n+264|0),YI(n+264|0,64),eg(n,t,r,a),t=0|Ag(0,0,0|r,0|a),eg(n,35288,15&t,0),He(A,g,i,B,C,1,o),eg(n,A,i,B),t=0|Ag(0,0,0|i,0|B),eg(n,35288,15&t,0),WI(n+256|0,r,a),eg(n,n+256|0,8,0),WI(n+256|0,i,B),eg(n,n+256|0,8,0),mg(n,I),YI(n,256),0|e&&(fi[e>>2]=16,fi[e+4>>2]=0),wi=n,0}function rA(A,I,e,i){A|=0,I|=0,e|=0,i|=0;var B=0,t=0,r=0,a=0;A:do{if(!(0==(0|e)&0==(0|i))){for(B=0|fi[A+352>>2],a=i;r=256-B|0,i=A+96+B|0,a>>>0>0|0==(0|a)&e>>>0>r>>>0;){T(0|i,0|I,0|r),fi[A+352>>2]=(0|fi[A+352>>2])+r,QI(A,128,0),g(A,A+96|0),B=A+224|0,t=128+(i=A+96|0)|0;do{yi[i>>0]=0|yi[B>>0],i=i+1|0,B=B+1|0}while((0|i)<(0|t));if(B=(0|fi[A+352>>2])-128|0,fi[A+352>>2]=B,e=0|Ag(0|e,0|a,0|r,0),i=vi,0==(0|e)&0==(0|i))break A;I=I+r|0,a=i}T(0|i,0|I,0|e),a=0|Ig(0|fi[A+352>>2],0,0|e,0|a),fi[A+352>>2]=a}}while(0)}function aA(A,I,e,g){A|=0,e|=0,g|=0;var i=0,B=0,t=0,r=0;r=0==(0|fi[(I|=0)>>2]),B=0|fi[I+12>>2];do{if(r){if(!((i=0|yi[I+8>>0])<<24>>24)){i=B+-1|0;break}if(i=0|bi(0|fi[A+20>>2],255&i),g){i=B+-1+i|0;break}i=i+((0==(0|B))<<31>>31)|0;break}if(i=(0|fi[A+24>>2])-(0|fi[A+20>>2])|0,g){i=B+-1+i|0;break}i=i+((0==(0|B))<<31>>31)|0;break}while(0);return he(0|e,0,0|e,0),he(0|i,0,0|vi,0),B=0|Ag(i+-1|0,0,0|vi,0),e=vi,(r?0:(t=0|yi[I+8>>0])<<24>>24!=3)?(i=0|bi(0|fi[A+20>>2],1+(255&t)|0),g=0):(i=0,g=0),r=0|Ig(0|B,0|e,0|i,0|g),0|(A=0|ne(0|r,0|vi,0|fi[A+24>>2],0))}function nA(A,I,e,g,i,B,t,r,a,n,C){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0;var o=0;o=wi,wi=wi+352|0,Rg(o+280|0,n|=0,C|=0),Mg(o,o+280|0),YI(o+280|0,64),eg(o,t,r,a),WI(o+272|0,r,a),eg(o,o+272|0,8,0),eg(o,e,g,i),WI(o+272|0,g,i),eg(o,o+272|0,8,0),mg(o,o+256|0),YI(o,256),I=0|zg(o+256|0,B),YI(o+256|0,16);do{if(A){if(I){wA(0|A,0,0|g),I=-1;break}Oe(A,e,g,i,n,C),I=0;break}}while(0);return wi=o,0|I}function CA(A,I,e,g,B,t,a){A|=0,I|=0,e|=0,g|=0,B|=0,t|=0;var n=0,C=0;n=wi,C=wi=wi+63&-64,wi=wi+560|0,gg(C,a|=0),KI(C+496|0,t,32,0),d(C,C+496+32|0,32,0),d(C,e,g,B),ee(C,C+432|0),GI(A+32|0,t+32|0,32),r(C+432|0),Z(C+208|0,C+432|0),fI(A,C+208|0),gg(C,a),d(C,A,64,0),d(C,e,g,B),ee(C,C+368|0),r(C+368|0),pg(C+496|0),i(A+32|0,C+368|0,C+496|0,C+432|0),YI(C+496|0,64),YI(C+432|0,64),0|I&&(fi[I>>2]=64,fi[I+4>>2]=0),wi=n}function oA(A,I,e,g,i){I|=0,e|=0,g|=0,i|=0;var B=0,t=0,r=0,a=0;if(a=wi,r=wi=wi+63&-64,wi=wi+64|0,t=0|TA(A|=0),e>>>0>0|0==(0|e)&I>>>0>4294967295|t>>>0>127)fi[8202]=22,e=-1;else{B=(e=r)+60|0;do{fi[e>>2]=0,e=e+4|0}while((0|e)<(0|B));(B=0|Ne(t))?(fi[r+16>>2]=B,fi[r+8>>2]=B,fi[r>>2]=B,fi[r+20>>2]=t,fi[r+12>>2]=t,fi[r+4>>2]=t,fi[r+24>>2]=0,fi[r+24+4>>2]=0,fi[r+24+8>>2]=0,fi[r+24+12>>2]=0,0|b(r,A,i)?(fi[8202]=22,e=-1):e=(0|fi[r+40>>2])==(0|I)?(0|fi[r+44>>2])!=(g>>>10|0)&1:1,Q(B)):e=-1}return wi=a,0|e}function cA(A,I){I|=0;var e=0,g=0,i=0,B=0,t=0;if(i=wi,g=wi=wi+63&-64,wi=wi+48|0,!(e=0|O(A|=0)))if((I+-1|0)>>>0<=1){if(B=0|fi[A+44>>2],e=0|fi[A+48>>2],B=((B>>>0<e<<3>>>0?e<<3:B)>>>0)/(e<<2>>>0)|0,t=0|bi(B,e<<2),fi[g>>2]=0,fi[g+8>>2]=fi[A+40>>2],fi[g+12>>2]=-1,fi[g+16>>2]=t,fi[g+20>>2]=B,fi[g+24>>2]=B<<2,fi[g+28>>2]=e,fi[g+32>>2]=fi[A+52>>2],fi[g+36>>2]=I,!(e=0|PA(g,A))){if(0|fi[g+8>>2]){e=0;do{lA(g,e),e=e+1|0}while(e>>>0<(0|fi[g+8>>2])>>>0)}uA(A,g),e=0}}else e=-26;return wi=i,0|e}function QA(A,I,e,g,i,B){I|=0,e|=0,g|=0,i|=0,B|=0;var t=0,a=0;return a=wi,t=wi=wi+63&-64,wi=wi+592|0,((((0!=(0|DI(32+(A|=0)|0))?0==(0|tI(A)):0)?0!=(0|re(i)):0)?0==(0|tI(i)):0)?0==(0|gA(t+328|0,i)):0)?(gg(t,B),d(t,A,32,0),d(t,i,32,0),d(t,I,e,g),ee(t,t+520|0),r(t+520|0),D(t+208|0,t+520|0,t+328|0,A+32|0),fI(t+488|0,t+208|0),B=0|Wg(t+488|0,A),A=0|((t+488|0)==(0|A)?-1:B)|iI(A,t+488|0,32)):A=-1,wi=a,0|A}function EA(A,I){A|=0,I|=0;var e=0,g=0;A:do{if(255&I){if(3&A)do{if((g=0|yi[A>>0])<<24>>24==0?1:g<<24>>24==(255&I)<<24>>24)break A;A=A+1|0}while(0!=(3&A|0));g=0|bi(255&I,16843009),e=0|fi[A>>2];I:do{if(!((-2139062144&e^-2139062144)&e+-16843009))do{if((-2139062144&(e^=g)^-2139062144)&e+-16843009|0)break I;e=0|fi[(A=A+4|0)>>2]}while(!((-2139062144&e^-2139062144)&e+-16843009|0))}while(0);for(;(g=0|yi[A>>0])<<24>>24!=0&&g<<24>>24!=(255&I)<<24>>24;)A=A+1|0}else A=A+(0|TA(A))|0}while(0);return 0|A}function sA(A,I){I|=0;var e=0,g=0,i=0;i=wi,wi=wi+192|0,XI(A|=0),g=127+(e=i+64+1|0)|0;do{yi[e>>0]=54,e=e+1|0}while((0|e)<(0|g));yi[i+64>>0]=54^yi[I>>0],e=1;do{yi[(g=i+64+e|0)>>0]=yi[g>>0]^yi[I+e>>0],e=e+1|0}while(32!=(0|e));d(A,i+64|0,128,0),XI(A+208|0),g=127+(e=i+64+1|0)|0;do{yi[e>>0]=92,e=e+1|0}while((0|e)<(0|g));yi[i+64>>0]=92^yi[I>>0],e=1;do{yi[(g=i+64+e|0)>>0]=yi[g>>0]^yi[I+e>>0],e=e+1|0}while(32!=(0|e));d(A+208|0,i+64|0,128,0),YI(i+64|0,128),YI(i,64),wi=i}function hA(A,I,e){A|=0,e|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0;o=(0|fi[4+(I|=0)>>2])-(0|fi[e+4>>2])|0,C=(0|fi[I+8>>2])-(0|fi[e+8>>2])|0,n=(0|fi[I+12>>2])-(0|fi[e+12>>2])|0,a=(0|fi[I+16>>2])-(0|fi[e+16>>2])|0,r=(0|fi[I+20>>2])-(0|fi[e+20>>2])|0,t=(0|fi[I+24>>2])-(0|fi[e+24>>2])|0,B=(0|fi[I+28>>2])-(0|fi[e+28>>2])|0,i=(0|fi[I+32>>2])-(0|fi[e+32>>2])|0,g=(0|fi[I+36>>2])-(0|fi[e+36>>2])|0,fi[A>>2]=(0|fi[I>>2])-(0|fi[e>>2]),fi[A+4>>2]=o,fi[A+8>>2]=C,fi[A+12>>2]=n,fi[A+16>>2]=a,fi[A+20>>2]=r,fi[A+24>>2]=t,fi[A+28>>2]=B,fi[A+32>>2]=i,fi[A+36>>2]=g}function yA(A,I,e){A|=0,I|=0;var g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0,o=0;o=(0|fi[4+(e|=0)>>2])+(0|fi[I+4>>2])|0,C=(0|fi[e+8>>2])+(0|fi[I+8>>2])|0,n=(0|fi[e+12>>2])+(0|fi[I+12>>2])|0,a=(0|fi[e+16>>2])+(0|fi[I+16>>2])|0,r=(0|fi[e+20>>2])+(0|fi[I+20>>2])|0,t=(0|fi[e+24>>2])+(0|fi[I+24>>2])|0,B=(0|fi[e+28>>2])+(0|fi[I+28>>2])|0,i=(0|fi[e+32>>2])+(0|fi[I+32>>2])|0,g=(0|fi[e+36>>2])+(0|fi[I+36>>2])|0,fi[A>>2]=(0|fi[e>>2])+(0|fi[I>>2]),fi[A+4>>2]=o,fi[A+8>>2]=C,fi[A+12>>2]=n,fi[A+16>>2]=a,fi[A+20>>2]=r,fi[A+24>>2]=t,fi[A+28>>2]=B,fi[A+32>>2]=i,fi[A+36>>2]=g}function fA(A,I,e,g,i,B){A|=0,I|=0,e|=0,g|=0,B|=0;var t=0,r=0,a=0;return r=wi,t=wi=wi+63&-64,wi=wi+32|0,a=_i[4+(i|=0)>>0]|_i[i+4+1>>0]<<8|_i[i+4+2>>0]<<16|_i[i+4+3>>0]<<24,fi[t>>2]=_i[i>>0]|_i[i+1>>0]<<8|_i[i+2>>0]<<16|_i[i+3>>0]<<24,fi[t+4>>2]=a,fi[t+8>>2]=0,fi[t+8+4>>2]=0,WI(t+16|0,e,g),i=t+16+8|0,yi[i>>0]=0,yi[i+1>>0]=0,yi[i+2>>0]=0,yi[i+3>>0]=0,i=t+16+8+4|0,yi[i>>0]=0,yi[i+1>>0]=0,yi[i+2>>0]=0,yi[i+3>>0]=0,(I+-16|0)>>>0>48?(fi[8202]=22,A=-1):A=0|te(A,I,B,t+16|0,t),wi=r,0|A}function _A(A,I,e,g){A|=0,e|=0,g|=0;var i=0,B=0,t=0;if(B=wi,t=wi=wi+63&-64,wi=wi+192|0,((I|=0)-1&255)>63&&hi(),!((g+-1&255)>63|0==(0|e))){yi[t+128>>0]=I,yi[t+128+1>>0]=g,yi[t+128+2>>0]=1,yi[t+128+3>>0]=1,Dg(t+128+4|0),WI(t+128+8|0,0,0),i=48+(I=t+128+16|0)|0;do{yi[I>>0]=0,I=I+1|0}while((0|I)<(0|i));return bI(A,t+128|0),wA(t+(255&g)|0,0,0|(g<<24>>24<0?0:128-(255&g)|0)),T(0|t,0|e,255&g|0),rA(A,t,128,0),YI(t,128),void(wi=B)}hi()}function pA(A,I,e,g,i,B,t,r,a,n,C,o){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,o|=0,n=wi,wi=wi+336|0,Rg(n+264|0,C,o),Mg(n,n+264|0),YI(n+264|0,64),eg(n,t,r,a),WI(n+256|0,r,a),eg(n,n+256|0,8,0),Oe(A,g,i,B,C,o),eg(n,A,i,B),WI(n+256|0,i,B),eg(n,n+256|0,8,0),mg(n,I),YI(n,256),0|e&&(fi[e>>2]=16,fi[e+4>>2]=0),wi=n,0}function wA(A,I,e){I|=0;var g=0,i=0;if(g=(A|=0)+(e|=0)|0,I&=255,(0|e)>=67){for(;3&A;)yi[A>>0]=I,A=A+1|0;for(i=I|I<<8|I<<16|I<<24;(0|A)<=((-4&g)-64|0);)fi[A>>2]=i,fi[A+4>>2]=i,fi[A+8>>2]=i,fi[A+12>>2]=i,fi[A+16>>2]=i,fi[A+20>>2]=i,fi[A+24>>2]=i,fi[A+28>>2]=i,fi[A+32>>2]=i,fi[A+36>>2]=i,fi[A+40>>2]=i,fi[A+44>>2]=i,fi[A+48>>2]=i,fi[A+52>>2]=i,fi[A+56>>2]=i,fi[A+60>>2]=i,A=A+64|0;for(;(0|A)<(-4&g|0);)fi[A>>2]=i,A=A+4|0}for(;(0|A)<(0|g);)yi[A>>0]=I,A=A+1|0;return g-e|0}function lA(A,I){I|=0;var e=0,g=0,i=0,B=0;if(i=wi,B=wi=wi+63&-64,wi=wi+32|0,0|(A|=0)?0|(e=0|fi[A+28>>2]):0){fi[B>>2]=I,g=0,I=e;do{if(yi[B+8>>0]=g,I){e=0;do{fi[B+4>>2]=e,fi[B+12>>2]=0,fi[B+16>>2]=fi[B>>2],fi[B+16+4>>2]=fi[B+4>>2],fi[B+16+8>>2]=fi[B+8>>2],fi[B+16+12>>2]=fi[B+12>>2],M(A,B+16|0),e=e+1|0,I=0|fi[A+28>>2]}while(e>>>0<I>>>0)}else I=0;g=g+1|0}while(4!=(0|g))}wi=i}function uA(A,I){var e=0,g=0,i=0,B=0;if(g=wi,i=wi=wi+63&-64,wi=wi+2048|0,0!=(0|(A|=0))&0!=(0|(I|=0))){if(Og(i,(0|fi[4+(0|fi[I>>2])>>2])+(fi[I+24>>2]<<10)-1024|0),(0|fi[I+28>>2])>>>0>1){e=1;do{B=(B=0|fi[I+24>>2])-1+(0|bi(B,e))|0,RI(i,(0|fi[4+(0|fi[I>>2])>>2])+(B<<10)|0),e=e+1|0}while(e>>>0<(0|fi[I+28>>2])>>>0)}Ce(i+1024|0,i),m(0|fi[A>>2],0|fi[A+4>>2],i+1024|0,1024),YI(i,1024),YI(i+1024|0,1024),Te(I,0|fi[A+56>>2])}wi=g}function dA(A,I,e,g,i,B,t,r,a,n,C,o){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,o|=0,n=wi,wi=wi+48|0,fi[n>>2]=0,u(n+16|0,C,o,0),o=_i[C+16+4>>0]|_i[C+16+4+1>>0]<<8|_i[C+16+4+2>>0]<<16|_i[C+16+4+3>>0]<<24,fi[n+4>>2]=_i[C+16>>0]|_i[C+16+1>>0]<<8|_i[C+16+2>>0]<<16|_i[C+16+3>>0]<<24,fi[n+4+4>>2]=o,tA(A,I,e,g,i,B,t,r,a,0,n,n+16|0),YI(n+16|0,32),wi=n,0}function DA(A,I,e,g,i){A|=0,I|=0,e|=0,g|=0,i|=0;var B=0,t=0;A:do{if(i){B=0|fi[e>>2];I:for(;;){if(B>>>0>=I>>>0){i=34;break}for(;(t=0|yi[A+B>>0])<<24>>24!=61;){if(!g){i=22;break I}if(!(0|wg(g,t<<24>>24))){i=22;break I}if(B=B+1|0,fi[e>>2]=B,B>>>0>=I>>>0){i=34;break I}}if(i=i+-1|0,B=B+1|0,fi[e>>2]=B,!i){i=0;break A}}fi[8202]=i,i=-1}else i=0}while(0);return 0|i}function vA(A,I,e,g,i,B,t,r,a,n){e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,wA(0|(A|=0),0,0|(I|=0));do{if(!(e>>>0>0|0==(0|e)&I>>>0>4294967295)){if(e>>>0<0|0==(0|e)&I>>>0<16){fi[8202]=22,A=-1;break}if((a|B)>>>0>0|0==(a|B|0)&(r|i)>>>0>4294967295|n>>>0>2147483648){fi[8202]=27,A=-1;break}if(a>>>0<0|0==(0|a)&r>>>0<3|n>>>0<8192){fi[8202]=22,A=-1;break}A=(0!=(0|xe(r,n>>>10,g,i,t,A,I)))<<31>>31;break}fi[8202]=27,A=-1}while(0);return 0|A}function bA(A,I,e,g,i,B,t,r,a,n,C){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,I=wi,wi=wi+48|0,fi[I>>2]=0,u(I+16|0,n,C,0),C=_i[n+16+4>>0]|_i[n+16+4+1>>0]<<8|_i[n+16+4+2>>0]<<16|_i[n+16+4+3>>0]<<24,fi[I+4>>2]=_i[n+16>>0]|_i[n+16+1>>0]<<8|_i[n+16+2>>0]<<16|_i[n+16+3>>0]<<24,fi[I+4+4>>2]=C,n=0|AA(A,0,e,g,i,B,t,r,a,I,I+16|0),YI(I+16|0,32),wi=I,0|n}function kA(A,I,e){A|=0,I|=0;var g=0,i=0,B=0;g=wi,B=wi=wi+63&-64,wi=wi+128|0,e=((e|=0)<<24>>24)-((e<<24>>24&0-(255&(i=0|lg(e))))<<1)&255,Lg(A),Je(A,I,0|Zg(e,1)),Je(A,I+120|0,0|Zg(e,2)),Je(A,I+240|0,0|Zg(e,3)),Je(A,I+360|0,0|Zg(e,4)),Je(A,I+480|0,0|Zg(e,5)),Je(A,I+600|0,0|Zg(e,6)),Je(A,I+720|0,0|Zg(e,7)),Je(A,I+840|0,0|Zg(e,8)),KA(B,A+40|0),KA(B+40|0,A),RA(B+80|0,A+80|0),Je(A,B,i),wi=g}function GA(A,I,e,g,i,B,t,r,a,n){e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,wA(0|(A|=0),0,0|(I|=0));do{if(!(e>>>0>0|0==(0|e)&I>>>0>4294967295)){if(e>>>0<0|0==(0|e)&I>>>0<16){fi[8202]=22,A=-1;break}if((a|B)>>>0>0|0==(a|B|0)&(r|i)>>>0>4294967295|n>>>0>2147483648){fi[8202]=27,A=-1;break}if(0==(0|r)&0==(0|a)|n>>>0<8192){fi[8202]=22,A=-1;break}A=(0!=(0|Le(r,n>>>10,g,i,t,A,I)))<<31>>31;break}fi[8202]=27,A=-1}while(0);return 0|A}function FA(A,I,e,g,i,B,t){I|=0,e|=0,g|=0,i|=0,B|=0,t|=0;var r=0,a=0,n=0,C=0;C=wi,a=wi=wi+63&-64,wi=wi+16|0,n=128+(r=A|=0)|0;do{yi[r>>0]=0,r=r+1|0}while((0|r)<(0|n));do{if(!((B|g)>>>0>0|0==(B|g|0)&(i|e)>>>0>4294967295|t>>>0>2147483648)){if(B>>>0<0|0==(0|B)&i>>>0<3|t>>>0<8192){fi[8202]=22,A=-1;break}pe(a,16),A=(0!=(0|je(i,t>>>10,I,e,a,A)))<<31>>31;break}fi[8202]=27,A=-1}while(0);return wi=C,0|A}function mA(A,I,e,g,i,B,t){I|=0,e|=0,g|=0,i|=0,B|=0,t|=0;var r=0,a=0,n=0,C=0;C=wi,a=wi=wi+63&-64,wi=wi+16|0,n=128+(r=A|=0)|0;do{yi[r>>0]=0,r=r+1|0}while((0|r)<(0|n));do{if(!((B|g)>>>0>0|0==(B|g|0)&(i|e)>>>0>4294967295|t>>>0>2147483648)){if(0==(0|i)&0==(0|B)|t>>>0<8192){fi[8202]=22,A=-1;break}pe(a,16),A=(0!=(0|Ve(i,t>>>10,I,e,a,A)))<<31>>31;break}fi[8202]=27,A=-1}while(0);return wi=C,0|A}function MA(A,I){I|=0,fi[(A|=0)>>2]=67108863&(0|ug(I)),fi[A+4>>2]=(0|ug(I+3|0))>>>2&67108611,fi[A+8>>2]=(0|ug(I+6|0))>>>4&67092735,fi[A+12>>2]=(0|ug(I+9|0))>>>6&66076671,fi[A+16>>2]=(0|ug(I+12|0))>>>8&1048575,fi[A+20>>2]=0,fi[A+20+4>>2]=0,fi[A+20+8>>2]=0,fi[A+20+12>>2]=0,fi[A+20+16>>2]=0,fi[A+40>>2]=0|ug(I+16|0),fi[A+44>>2]=0|ug(I+20|0),fi[A+48>>2]=0|ug(I+24|0),fi[A+52>>2]=0|ug(I+28|0),fi[A+56>>2]=0,fi[A+56+4>>2]=0,yi[A+80>>0]=0}function HA(A,I){A|=0,I|=0;var e=0,g=0,i=0;i=wi,g=wi=wi+63&-64,wi=wi+16|0;do{if(((0!=(0|A)?0!=(0|I):0)?1024==(0|(I<<10>>>0)/(I>>>0)):0)?(e=0|t(12),fi[A>>2]=e,0!=(0|e)):0){if(fi[e+4>>2]=0,fi[e>>2]=0,e=0|Me(g,I<<10),fi[8202]=e,0|e){fi[g>>2]=0,e=-22;break}(e=0|fi[g>>2])?(fi[fi[A>>2]>>2]=e,fi[4+(0|fi[A>>2])>>2]=e,fi[8+(0|fi[A>>2])>>2]=I<<10,e=0):e=-22}else e=-22}while(0);return wi=i,0|e}function YA(A,I,e,g,i,B,t){A|=0,e|=0,g|=0,t|=0;var r=0,a=0;r=wi,a=wi=wi+63&-64,wi=wi+384|0,0==(0|(I|=0))&(0!=(0|(i|=0))|0!=(0|(B|=0)))&&hi(),A||hi(),(g+-1&255)>63&&hi(),0!=(0|e)|t<<24>>24!=0^1||hi(),(255&t)>64&&hi(),t<<24>>24?_A(a,g,e,t):OA(a,g),rA(a,I,i,B),L(a,A,g),wi=r}function SA(A,I,e,g,i,B){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0;var t=0,r=0,a=0;do{if(i>>>0<0|0==(0|i)&g>>>0<64||(t=0|Ig(0|g,0|i,-64,-1),(r=vi)>>>0>0|0==(0|r)&t>>>0>4294967231))a=8;else{if(0|Ze(e,e+64|0,t,r,B)){wA(0|A,0,0|t),a=8;break}0|I&&(fi[I>>2]=t,fi[I+4>>2]=r),GI(0|A,e+64|0,0|t),A=0}}while(0);return 8==(0|a)&&(I?(fi[I>>2]=0,fi[I+4>>2]=0,A=-1):A=-1),0|A}function RA(A,I){A|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0;C=0-(0|fi[4+(I|=0)>>2])|0,n=0-(0|fi[I+8>>2])|0,a=0-(0|fi[I+12>>2])|0,r=0-(0|fi[I+16>>2])|0,t=0-(0|fi[I+20>>2])|0,B=0-(0|fi[I+24>>2])|0,i=0-(0|fi[I+28>>2])|0,g=0-(0|fi[I+32>>2])|0,e=0-(0|fi[I+36>>2])|0,fi[A>>2]=0-(0|fi[I>>2]),fi[A+4>>2]=C,fi[A+8>>2]=n,fi[A+12>>2]=a,fi[A+16>>2]=r,fi[A+20>>2]=t,fi[A+24>>2]=B,fi[A+28>>2]=i,fi[A+32>>2]=g,fi[A+36>>2]=e}function NA(A,I,e){A|=0,I|=0;var g=0,i=0,B=0,t=0,r=0,a=0;if(e|=0){r=0|yi[A>>0],g=0|yi[I>>0];A:do{if(r<<24>>24){a=A,t=e,i=g,B=r,e=255&g,A=255&r;do{if(t=t+-1|0,!(B<<24>>24==i<<24>>24&0!=(0|t)&i<<24>>24!=0))break A;I=I+1|0,A=255&(B=0|yi[(a=a+1|0)>>0]),e=255&(i=0|yi[I>>0])}while(B<<24>>24!=0)}else e=255&g,A=255&r}while(0);A=A-e|0}else A=0;return 0|A}function UA(A,I){A|=0;var e=0,g=0,i=0;if(g=wi,i=wi=wi+63&-64,wi=wi+1024|0,0|fi[28+(I|=0)>>2]){e=0;do{Bg(A+64|0,0),Bg(A+68|0,e),m(i,1024,A,72),ie((0|fi[4+(0|fi[I>>2])>>2])+((0|bi(0|fi[I+24>>2],e))<<10)|0,i),Bg(A+64|0,1),m(i,1024,A,72),ie((0|fi[4+(0|fi[I>>2])>>2])+(1+(0|bi(0|fi[I+24>>2],e))<<10)|0,i),e=e+1|0}while(e>>>0<(0|fi[I+28>>2])>>>0)}YI(i,1024),wi=g}function JA(A,I,e,g,i,B){I|=0,i|=0,B|=0;var t=0,r=0;return t=wi,r=wi=wi+63&-64,wi=wi+16|0,GI(64+(A|=0)|0,0|(e|=0),0|(g|=0)),Ke(A,r,A+64|0,g,i,B),64==(0|fi[r>>2])&0==(0|fi[r+4>>2])?0|I?(A=0|Ig(0|g,0|i,64,0),fi[I>>2]=A,fi[I+4>>2]=vi,A=0):A=0:(0|I&&(fi[I>>2]=0,fi[I+4>>2]=0),wA(0|A,0,0|(r=0|Ig(0|g,0|i,64,0))),A=-1),wi=t,0|A}function PA(A,I){A|=0,I|=0;var e=0,g=0,i=0;i=wi,g=wi=wi+63&-64,wi=wi+80|0;do{if(0==(0|A)|0==(0|I))e=-25;else{if(e=0|t(fi[A+20>>2]<<3),fi[A+4>>2]=e,e){if(e=0|HA(A,0|fi[A+16>>2])){Te(A,0|fi[I+56>>2]);break}F(g,I,0|fi[A+36>>2]),YI(g+64|0,8),UA(g,A),YI(g,72),e=0;break}e=-22}}while(0);return wi=i,0|e}function LA(A,I){I|=0;var e=0,g=0,i=0,B=0,t=0;t=0|yi[(A|=0)>>0];A:do{if((t+-48&255)<=9){for(i=0,B=A,g=t;;){if(e=(g<<24>>24)-48|0,g=10*i|0,!(i>>>0<429496730&(e>>>0>~g>>>0^1))){e=0;break A}if(i=(e>>>0>~g>>>0?0:e)+g|0,e=B+1|0,((g=0|yi[e>>0])-48&255)>9)break;B=e}((0|e)!=(0|A)?(0|B)==(0|A)|t<<24>>24!=48:0)?fi[I>>2]=i:e=0}else e=0}while(0);return 0|e}function xA(A){return((0-((0-(95^(A|=0))|0)>>>8&63^63|(0-(45^A)|0)>>>8&62^62|((A+65439|0)>>>8^255)&A+185&((122-A|0)>>>8&255^255)|((A+-65|0)>>>8^255)&A+-65&((90-A|0)>>>8&255^255)|((A+65488|0)>>>8^255)&A+4&((57-A|0)>>>8&255^255))|0)>>>8&255^255)&(0-(65^A)|0)>>>8|(0-(95^A)|0)>>>8&63^63|(0-(45^A)|0)>>>8&62^62|((A+65439|0)>>>8^255)&A+185&((122-A|0)>>>8&255^255)|((A+-65|0)>>>8^255)&A+-65&((90-A|0)>>>8&255^255)|((A+65488|0)>>>8^255)&A+4&((57-A|0)>>>8&255^255)|0}function XA(A){return((0-((0-(47^(A|=0))|0)>>>8&63^63|(0-(43^A)|0)>>>8&62^62|((A+65439|0)>>>8^255)&A+185&((122-A|0)>>>8&255^255)|((A+-65|0)>>>8^255)&A+-65&((90-A|0)>>>8&255^255)|((A+65488|0)>>>8^255)&A+4&((57-A|0)>>>8&255^255))|0)>>>8&255^255)&(0-(65^A)|0)>>>8|(0-(47^A)|0)>>>8&63^63|(0-(43^A)|0)>>>8&62^62|((A+65439|0)>>>8^255)&A+185&((122-A|0)>>>8&255^255)|((A+-65|0)>>>8^255)&A+-65&((90-A|0)>>>8&255^255)|((A+65488|0)>>>8^255)&A+4&((57-A|0)>>>8&255^255)|0}function KA(A,I){A|=0;var e=0,g=0,i=0,B=0,t=0,r=0,a=0,n=0,C=0;C=0|fi[4+(I|=0)>>2],n=0|fi[I+8>>2],a=0|fi[I+12>>2],r=0|fi[I+16>>2],t=0|fi[I+20>>2],B=0|fi[I+24>>2],i=0|fi[I+28>>2],g=0|fi[I+32>>2],e=0|fi[I+36>>2],fi[A>>2]=fi[I>>2],fi[A+4>>2]=C,fi[A+8>>2]=n,fi[A+12>>2]=a,fi[A+16>>2]=r,fi[A+20>>2]=t,fi[A+24>>2]=B,fi[A+28>>2]=i,fi[A+32>>2]=g,fi[A+36>>2]=e}function TA(A){A|=0;var I=0,e=0,g=0;A:do{if(3&A)for(I=A,e=A;;){if(!(0|yi[I>>0])){I=e;break A}if(I=I+1|0,!(3&(e=I))){g=4;break}}else I=A,g=4}while(0);if(4==(0|g)){for(;!((-2139062144&(e=0|fi[I>>2])^-2139062144)&e+-16843009);)I=I+4|0;if((255&e)<<24>>24)do{I=I+1|0}while(0!=(0|yi[I>>0]))}return I-A|0}function VA(A,I){I|=0;var e=0,g=0;if((127&(e=0|Ue(0|fi[72+(A|=0)>>2],0|fi[A+72+4>>2],3)))>>>0<112)112-(127&e)|0&&T(A+80+(127&e)|0,33569,112-(127&e)|0);else{128-(127&e)|0&&T(A+80+(127&e)|0,33569,128-(127&e)|0),B(A,A+80|0,I,I+640|0),g=112+(e=A+80|0)|0;do{fi[e>>2]=0,e=e+4|0}while((0|e)<(0|g))}TI(A+192|0,A+64|0,16),B(A,A+80|0,I,I+640|0)}function qA(A,I,e){e|=0;var g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+48|0,yA(A|=0,40+(I|=0)|0,I),hA(A+40|0,I+40|0,I),a(A+80|0,A,e+40|0),a(A+40|0,A+40|0,e),a(A+120|0,e+120|0,I+120|0),a(A,I+80|0,e+80|0),yA(i,A,A),hA(A,A+80|0,A+40|0),yA(A+40|0,A+80|0,A+40|0),hA(A+80|0,i,A+120|0),yA(A+120|0,i,A+120|0),wi=g}function jA(A,I,e){e|=0;var g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+48|0,yA(A|=0,40+(I|=0)|0,I),hA(A+40|0,I+40|0,I),a(A+80|0,A,e),a(A+40|0,A+40|0,e+40|0),a(A+120|0,e+120|0,I+120|0),a(A,I+80|0,e+80|0),yA(i,A,A),hA(A,A+80|0,A+40|0),yA(A+40|0,A+80|0,A+40|0),yA(A+80|0,i,A+120|0),hA(A+120|0,i,A+120|0),wi=g}function ZA(A){var I=0,e=0,g=0,i=0,B=0,t=0,r=0;return B=0|_i[7+(A|=0)>>0],t=0|Se(0|_i[A+6>>0],0,8),r=vi,i=0|Se(0|_i[A+5>>0],0,16),r|=vi,g=0|Se(0|_i[A+4>>0],0,24),r=r|vi|0|_i[A+3>>0],e=0|Se(0|_i[A+2>>0],0,40),r|=vi,I=0|Se(0|_i[A+1>>0],0,48),r|=vi,A=0|Se(0|_i[A>>0],0,56),vi|=r,t|B|i|g|e|I|A|0}function WA(A,I,e){e|=0;var g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+48|0,yA(A|=0,40+(I|=0)|0,I),hA(A+40|0,I+40|0,I),a(A+80|0,A,e+40|0),a(A+40|0,A+40|0,e),a(A+120|0,e+80|0,I+120|0),yA(i,I+80|0,I+80|0),hA(A,A+80|0,A+40|0),yA(A+40|0,A+80|0,A+40|0),hA(A+80|0,i,A+120|0),yA(A+120|0,i,A+120|0),wi=g}function zA(A,I,e){e|=0;var g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+48|0,yA(A|=0,40+(I|=0)|0,I),hA(A+40|0,I+40|0,I),a(A+80|0,A,e),a(A+40|0,A+40|0,e+40|0),a(A+120|0,e+80|0,I+120|0),yA(i,I+80|0,I+80|0),hA(A,A+80|0,A+40|0),yA(A+40|0,A+80|0,A+40|0),yA(A+80|0,i,A+120|0),hA(A+120|0,i,A+120|0),wi=g}function OA(A,I){A|=0;var e=0,g=0,i=0;if(g=wi,i=wi=wi+63&-64,wi=wi+64|0,!(((I|=0)-1&255)>63)){yi[i>>0]=I,yi[i+1>>0]=0,yi[i+2>>0]=1,yi[i+3>>0]=1,Dg(i+4|0),WI(i+8|0,0,0),e=48+(I=i+16|0)|0;do{yi[I>>0]=0,I=I+1|0}while((0|I)<(0|e));return bI(A,i),void(wi=g)}hi()}function $A(A,I){I|=0,fi[(A|=0)>>2]=1634760805,fi[A+4>>2]=857760878,fi[A+8>>2]=2036477234,fi[A+12>>2]=1797285236,fi[A+16>>2]=0|ug(I),fi[A+20>>2]=0|ug(I+4|0),fi[A+24>>2]=0|ug(I+8|0),fi[A+28>>2]=0|ug(I+12|0),fi[A+32>>2]=0|ug(I+16|0),fi[A+36>>2]=0|ug(I+20|0),fi[A+40>>2]=0|ug(I+24|0),fi[A+44>>2]=0|ug(I+28|0)}function AI(A,I,e,g,i){I|=0,e|=0,g|=0,i|=0;var B=0,t=0;if(B=wi,t=wi=wi+63&-64,wi=wi+384|0,(A|=0)||hi(),(e+-1&255)>63&&hi(),I)return $(t,e,I,g,i),rA(t,0,0,0),L(t,A,e),void(wi=B);hi()}function II(A,I,e,g){A|=0,I|=0,e|=0,g|=0;do{if(!(e>>>0>64|(g+-1|0)>>>0>63)){if(g>>>0>=256&&Mi(33384,33404,53,33504),e>>>0>=256&&Mi(33484,33404,54,33504),0==(0|I)|0==(0|e)){OA(A,255&g),A=0;break}_A(A,255&g,I,255&e),A=0;break}A=-1}while(0);return 0|A}function eI(A,I,e){A|=0,I|=0,e|=0;var g=0,i=0;if(g=wi,i=wi=wi+63&-64,wi=wi+16|0,fi[i+8>>2]=A,fi[i+4>>2]=I,fi[i>>2]=0,(0|e)>0){A=0;do{fi[i>>2]=255&(yi[(0|fi[i+4>>2])+A>>0]^yi[(0|fi[i+8>>2])+A>>0])|fi[i>>2],A=A+1|0}while((0|A)!=(0|e))}return wi=g,((511+(0|fi[i>>2])|0)>>>8&1)-1|0}function gI(A,I){A|=0,I|=0;var e=0,g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+208|0,e=0;do{yi[A+e>>0]=0|yi[I+e>>0],e=e+1|0}while(32!=(0|e));return yi[A>>0]=-8&yi[A>>0],yi[A+31>>0]=63&yi[A+31>>0]|64,Z(i+40|0,A),jI(i,i+40+40|0,i+40+80|0),q(A,i),wi=g,0}function iI(A,I,e){A|=0,I|=0,e|=0;var g=0,i=0;if(g=wi,i=wi=wi+63&-64,wi=wi+16|0,fi[i+4>>2]=A,fi[i>>2]=I,yi[i+8>>0]=0,0|e){A=0;do{yi[i+8>>0]=yi[i+8>>0]|yi[(0|fi[i>>2])+A>>0]^yi[(0|fi[i+4>>2])+A>>0],A=A+1|0}while((0|A)!=(0|e))}return wi=g,((511+(0|_i[i+8>>0])|0)>>>8&1)-1|0}function BI(A,I,e){I|=0,e|=0;var g=0;yi[7+(A|=0)>>0]=I,g=0|Ue(0|I,0|e,8),yi[A+6>>0]=g,g=0|Ue(0|I,0|e,16),yi[A+5>>0]=g,g=0|Ue(0|I,0|e,24),yi[A+4>>0]=g,yi[A+3>>0]=e,g=0|Ue(0|I,0|e,40),yi[A+2>>0]=g,g=0|Ue(0|I,0|e,48),yi[A+1>>0]=g,e=0|Ue(0|I,0|e,56),yi[A>>0]=e}function tI(A){var I=0,e=0,g=0,i=0,B=0,t=0;for(i=0|yi[(A|=0)>>0],e=0;;){I=0,g=0,B=0|yi[16+(e<<5)>>0],t=i;do{g=255&(B^t)|255&g,t=0|yi[A+(I=I+1|0)>>0],B=0|yi[16+(e<<5)+I>>0]}while(31!=(0|I));if(e=e+1|0,!(255&(127&t^B)|g)){I=1;break}if(e>>>0>=7){I=0;break}}return 0|I}function rI(A,I,e,g,i,B,t,r){A|=0,I|=0,i|=0,B|=0,t|=0,r|=0;var a=0,n=0;a=wi,n=wi=wi+63&-64,wi=wi+80|0,0==(0|(e|=0))&0==(0|(g|=0))||(Bg(n+64|0,B),Bg(n+64+4|0,t),$A(n,r),UI(n,i,n+64|0),h(n,I,A,e,g),YI(n,64)),wi=a}function aI(A,I,e,g,i,B,t){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0;var r=0;do{if((I+-1|0)>>>0>63|t>>>0>64)r=-1;else{if(I>>>0>=256&&Mi(33384,33404,19,33457),t>>>0<256){YA(A,e,B,255&I,g,i,255&t),r=0;break}Mi(33484,33404,20,33457)}}while(0);return 0|r}function nI(A,I){var e=0,g=0;e=wi,g=wi=wi+63&-64,wi=wi+48|0,c(A|=0,I|=0),c(A+80|0,I+40|0),o(A+120|0,I+80|0),yA(A+40|0,I,I+40|0),c(g,A+40|0),yA(A+40|0,A+80|0,A),hA(A+80|0,A+80|0,A),hA(A,g,A+40|0),hA(A+120|0,A+120|0,A+80|0),wi=e}function CI(A,I,e){A|=0,I|=0,e|=0;var g=0,i=0;if(i=wi,g=wi=wi+63&-64,wi=wi+16|0,yi[g>>0]=0,0|P(A,I,e))I=-1;else{I=0;do{yi[g>>0]=yi[g>>0]|yi[A+I>>0],I=I+1|0}while(32!=(0|I));I=0-((511+(0|_i[g>>0])|0)>>>8&1)|0}return wi=i,0|I}function oI(A,I,e){A|=0,I|=0;var g=0,i=0,B=0,t=0;B=wi,t=wi=wi+63&-64,wi=wi+64|0,KI(t,e|=0,32,0),g=t,i=(e=I)+32|0;do{yi[e>>0]=0|yi[g>>0],e=e+1|0,g=g+1|0}while((0|e)<(0|i));return YI(t,64),t=0|Fg(A,I),wi=B,0|t}function cI(A,I,e,g,i,B,t){A|=0,I|=0,i|=0,B|=0,t|=0;var r=0,a=0;r=wi,a=wi=wi+63&-64,wi=wi+80|0,0==(0|(e|=0))&0==(0|(g|=0))||(Bg(a+64|0,B),$A(a,t),ZI(a,i,a+64|0),h(a,I,A,e,g),YI(a,64)),wi=r}function QI(A,I,e){I|=0,e|=0;var g=0,i=0;g=0|Ig(0|fi[64+(A|=0)>>2],0|fi[A+64+4>>2],0|I,0|e),i=vi,fi[A+64>>2]=g,fi[A+64+4>>2]=i,e=0|Ig(1&(i>>>0<e>>>0|(0|i)==(0|e)&g>>>0<I>>>0)|0,0,0|fi[A+72>>2],0|fi[A+72+4>>2]),fi[A+72>>2]=e,fi[A+72+4>>2]=vi}function EI(A,I){A|=0,I|=0;var e=0,g=0,i=0,B=0;for(i=wi,B=wi=wi+63&-64,wi=wi+16|0,g=10;e=g+-1|0,yi[B+e>>0]=48|(I>>>0)%10,I>>>0>9&0!=(0|e);)g=e,I=(I>>>0)/10|0;T(0|A,B+e|0,0|(g=11-g|0)),yi[A+g>>0]=0,wi=i}function sI(A,I,e){A|=0;var g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+160|0,KI(I|=0,e|=0,32,0),yi[I>>0]=-8&yi[I>>0],yi[I+31>>0]=63&yi[I+31>>0]|64,Z(i,I),fI(A,i),GI(0|I,0|e,32),GI(I+32|0,0|A,32),wi=g}function hI(A,I,e,g){A|=0,I|=0,e|=0,g|=0;A:do{if(g>>>0>0|0==(0|g)&e>>>0>4294967295)fi[8202]=27,A=-1;else{switch(0|xg(A,I,e)){case 0:A=0;break A;case-35:fi[8202]=22}A=-1}}while(0);return 0|A}function yI(A,I,e,g,i){A|=0,g|=0,i|=0;var B=0,t=0;B=wi,t=wi=wi+63&-64,wi=wi+64|0,0==(0|(I|=0))&0==(0|(e|=0))||($A(t,i),ZI(t,g,0),wA(0|A,0,0|I),h(t,A,A,I,e),YI(t,64)),wi=B}function fI(A,I){A|=0;var e=0,g=0;e=wi,g=wi=wi+63&-64,wi=wi+128|0,Y(g+80|0,80+(I|=0)|0),a(g+40|0,I,g+80|0),a(g,I+40|0,g+80|0),q(A,g),I=(0|Re(g+40|0))<<7,yi[A+31>>0]=(0|_i[A+31>>0])^I,wi=e}function _I(A,I,e,g){A|=0,I|=0,e|=0,g|=0;A:do{if(g>>>0>0|0==(0|g)&e>>>0>4294967295)fi[8202]=27,A=-1;else{switch(0|Kg(A,I,e)){case 0:A=0;break A;case-35:fi[8202]=22}A=-1}}while(0);return 0|A}function pI(A){var I=0,e=0;return e=15+(A|=0)&-16|0,I=0|fi[pi>>2],A=I+e|0,(0|e)>0&(0|A)<(0|I)|(0|A)<0?(mi(),Hi(12),-1):(fi[pi>>2]=A,((0|A)>(0|Fi())?0==(0|Gi()):0)?(fi[pi>>2]=I,Hi(12),-1):0|I)}function wI(A,I,e,g,i){A|=0,g|=0,i|=0;var B=0,t=0;B=wi,t=wi=wi+63&-64,wi=wi+64|0,0==(0|(I|=0))&0==(0|(e|=0))||($A(t,i),UI(t,g,0),wA(0|A,0,0|I),h(t,A,A,I,e),YI(t,64)),wi=B}function lI(A,I,e,g,i,B,t,r){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0;var a=0;return a=wi,wi=wi+32|0,0|_g(a,t|=0,r|=0)?A=-1:(A=0|Ge(A,I,e,g,i,B,a),YI(a,32)),wi=a,0|A}function uI(A,I,e,g,i,B,t,r){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0;var a=0;return a=wi,wi=wi+32|0,0|_g(a,t|=0,r|=0)?A=-1:(me(A,I,e,g,i,B,a),YI(a,32),A=0),wi=a,0|A}function dI(A,I){A|=0,I|=0;var e=0,g=0,i=0;if(g=wi,i=wi=wi+63&-64,wi=wi+16|0,yi[i>>0]=0,0|I){e=0;do{yi[i>>0]=yi[i>>0]|yi[A+e>>0],e=e+1|0}while((0|e)!=(0|I))}return wi=g,(511+(0|_i[i>>0])|0)>>>8&1|0}function DI(A){A|=0;var I=0,e=0,g=0,i=0,B=0;for(e=32,I=1,g=0;e=e+-1|0,i=0|yi[A+e>>0],B=0|yi[33241+e>>0],I&=255,g=((255&i)-(255&B)|0)>>>8&I|255&g,e;)I&=(65535+(255&(B^i))|0)>>>8;return 0!=(0|g)|0}function vI(A,I){var e=0,g=0,i=0;return e=0|bi(65535&(I|=0),65535&(A|=0)),i=(e>>>16)+(0|bi(65535&I,A>>>16))|0,g=0|bi(I>>>16,65535&A),0|(vi=(i>>>16)+(0|bi(I>>>16,A>>>16))+(((65535&i)+g|0)>>>16)|0,i+g<<16|65535&e|0)}function bI(A,I){I|=0;var e=0,g=0,i=0,B=0;ce(A|=0),e=0;do{B=0|oe(I+(e<<3)|0),i=fi[4+(g=A+(e<<3)|0)>>2]^vi,fi[g>>2]=fi[g>>2]^B,fi[g+4>>2]=i,e=e+1|0}while(8!=(0|e))}function kI(A,I,e){A|=0,I|=0,e|=0;var g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+384|0,sg(i,0,0,24),og(i,I,32,0),og(i,e,32,0),dg(i,A,24),wi=g}function GI(A,I,e){var g=0;if((0|(I|=0))<(0|(A|=0))&(0|A)<(I+(e|=0)|0)){for(g=A,I=I+e|0,A=A+e|0;(0|e)>0;)I=I-1|0,e=e-1|0,yi[(A=A-1|0)>>0]=0|yi[I>>0];A=g}else T(A,I,e);return 0|A}function FI(A,I,e,g,i){A|=0;var B=0;return B=wi,wi=wi+32|0,xI(B,I|=0,e|=0,g|=0,i|=0),i=0|Wg(A,B),i=0|((0|B)==(0|A)?-1:i)|iI(B,A,32),wi=B,0|i}function mI(A,I,e){A|=0;var g=0,i=0;return i=wi,g=wi=wi+63&-64,wi=wi+32|0,0|CI(g,e|=0,I|=0)?A=-1:(k(A,35304,g),A=0),wi=i,0|A}function MI(A,I,e,g,i,B,t){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,0|(A=g>>>0<0|0==(0|g)&e>>>0<16?-1:0|lI(A,I+16|0,I,g=0|Ig(0|e,0|g,-16,-1),vi,i,B,t))}function HI(A){var I=0,e=0,g=0,i=0;return e=0|_i[(A|=0)>>0],g=0|Se(0|_i[A+1>>0],0,8),i=vi,I=0|Se(0|_i[A+2>>0],0,16),i|=vi,A=0|Se(0|_i[A+3>>0],0,24),vi|=i,g|e|I|A|0}function YI(A,I){A|=0,I|=0;var e=0,g=0;if(e=wi,g=wi=wi+63&-64,wi=wi+16|0,fi[g>>2]=A,0|I){A=0;do{yi[(0|fi[g>>2])+A>>0]=0,A=A+1|0}while((0|A)!=(0|I))}wi=e}function SI(A,I,e,g,i){A|=0;var B=0,t=0;return B=wi,t=wi=wi+63&-64,wi=wi+16|0,LI(t,I|=0,e|=0,g|=0,i|=0),i=0|zg(A,t),wi=B,0|i}function RI(A,I){A|=0,I|=0;var e=0,g=0,i=0,B=0;e=0;do{B=I+(e<<3)|0,i=fi[4+(g=A+(e<<3)|0)>>2]^fi[B+4>>2],fi[g>>2]=fi[g>>2]^fi[B>>2],fi[g+4>>2]=i,e=e+1|0}while(128!=(0|e))}function NI(A){var I=0;return(0|(I=0|yi[ui+(255&(A|=0))>>0]))<8?0|I:(0|(I=0|yi[ui+(A>>8&255)>>0]))<8?I+8|0:(0|(I=0|yi[ui+(A>>16&255)>>0]))<8?I+16|0:24+(0|yi[ui+(A>>>24)>>0])|0}function UI(A,I,e){A|=0,I|=0,(e|=0)?(fi[A+48>>2]=0|ug(e),e=0|ug(e+4|0)):(fi[A+48>>2]=0,e=0),fi[A+52>>2]=e,fi[A+56>>2]=0|ug(I),fi[A+60>>2]=0|ug(I+4|0)}function JI(A,I,e,g){var i=0,B=0;return B=0|Ig(0|(e|=0),0|(g|=0),0|(A|=0),0|(I|=0)),i=vi,g=0|Se(0|A,0|I,1),g=0|he(-2&g|0,1&vi|0,0|e,0),0|(g=0|Ig(0|B,0|i,0|g,0|vi))}function PI(A,I){I|=0;var e=0,g=0;g=wi,wi=wi+64|0,$I(A|=0,g),A=g,e=I+32|0;do{yi[I>>0]=0|yi[A>>0],I=I+1|0,A=A+1|0}while((0|I)<(0|e));wi=g}function LI(A,I,e,g,i){A|=0,I|=0,e|=0,g|=0;var B=0,t=0;B=wi,t=wi=wi+63&-64,wi=wi+96|0,MA(t,i|=0),G(t,I,e,g),R(t,A),wi=B}function xI(A,I,e,g,i){A|=0,I|=0,e|=0,g|=0;var B=0;B=wi,wi=wi+416|0,Pg(B,i|=0),cg(B,I,e,g),PI(B,A),wi=B}function XI(A){var I=0,e=0;fi[64+(A|=0)>>2]=0,fi[A+64+4>>2]=0,fi[A+64+8>>2]=0,fi[A+64+12>>2]=0,I=240,e=A+64|0;do{fi[A>>2]=fi[I>>2],A=A+4|0,I=I+4|0}while((0|A)<(0|e))}function KI(A,I,e,g){A|=0,I|=0,e|=0,g|=0;var i=0,B=0;i=wi,B=wi=wi+63&-64,wi=wi+208|0,XI(B),d(B,I,e,g),ee(B,A),wi=i}function TI(A,I,e){A|=0,I|=0;var g=0,i=0;if((e|=0)>>>3|0){g=0;do{BI(A+(g<<3)|0,0|fi[(i=I+(g<<3)|0)>>2],0|fi[i+4>>2]),g=g+1|0}while((0|g)!=(e>>>3|0))}}function VI(A,I,e){I|=0,e|=0;var g=0,i=0;return g=wi,i=wi=wi+63&-64,wi=wi+64|0,ee(A|=0,i),e=0|QA(I,i,64,0,e,1),wi=g,0|e}function qI(A,I,e,g){I|=0,e|=0,g|=0;var i=0,B=0;i=wi,B=wi=wi+63&-64,wi=wi+64|0,ee(A|=0,B),CA(I,e,B,64,0,g,1),wi=i}function jI(A,I,e){A|=0;var g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+80|0,yA(i+40|0,e|=0,I|=0),hA(i,e,I),Y(i,i),a(A,i+40|0,i),wi=g}function ZI(A,I,e){A|=0,I|=0,e=(e|=0)?0|ug(e):0,fi[A+48>>2]=e,fi[A+52>>2]=0|ug(I),fi[A+56>>2]=0|ug(I+4|0),fi[A+60>>2]=0|ug(I+8|0)}function WI(A,I,e){I|=0,e|=0,yi[(A|=0)>>0]=I,yi[A+1>>0]=I>>8,yi[A+2>>0]=I>>16,yi[A+3>>0]=I>>24,yi[A+4>>0]=e,yi[A+4+1>>0]=e>>8,yi[A+4+2>>0]=e>>16,yi[A+4+3>>0]=e>>24}function zI(A,I,e,g,i,B,t){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,g>>>0>0|0==(0|g)&e>>>0>4294967279?(hi(),0):0|uI(A+16|0,A,I,e,g,i,B,t)}function OI(A){return(0-(62^(A|=0))|0)>>>8&45^45|(A+65510|0)>>>8&255&A+65|(0-(63^A)|0)>>>8&95^95|(A+65484|0)>>>8&A+71&((A+65510|0)>>>8&255^255)|(A+65474|0)>>>8&A+252&((A+65484|0)>>>8&255^255)|0}function $I(A,I){I|=0;var e=0;e=wi,wi=wi+64|0,ee(A|=0,e),d(A+208|0,e,64,0),ee(A+208|0,I),YI(e,64),wi=e}function Ae(A){return(0-(62^(A|=0))|0)>>>8&43^43|(A+65510|0)>>>8&255&A+65|(0-(63^A)|0)>>>8&47^47|(A+65484|0)>>>8&A+71&((A+65510|0)>>>8&255^255)|(A+65474|0)>>>8&A+252&((A+65484|0)>>>8&255^255)|0}function Ie(A,I){A|=0,0|(I|=0)&&(0|(I=0|fi[A>>2])&&YI(0|fi[I+4>>2],fi[A+16>>2]<<10),0|(I=0|fi[A+4>>2])&&YI(I,fi[A+20>>2]<<3))}function ee(A,I){I|=0;var e=0,g=0;e=wi,g=wi=wi+63&-64,wi=wi+704|0,VA(A|=0,g),TI(I,A,64),YI(g,704),YI(A,208),wi=e}function ge(A,I){A|=0,I|=0;var e=0,g=0,i=0;e=0;do{i=0|ZA(I+(e<<3)|0),fi[(g=A+(e<<3)|0)>>2]=i,fi[g+4>>2]=vi,e=e+1|0}while(16!=(0|e))}function ie(A,I){A|=0,I|=0;var e=0,g=0,i=0;e=0;do{i=0|oe(I+(e<<3)|0),fi[(g=A+(e<<3)|0)>>2]=i,fi[g+4>>2]=vi,e=e+1|0}while(128!=(0|e))}function Be(A,I){A|=0,I|=0;var e=0,g=0;e=wi,g=wi=wi+63&-64,wi=wi+32|0,pe(g,32),sI(A,I,g),YI(g,32),wi=e}function te(A,I,e,g,i){return A|=0,I|=0,e|=0,g|=0,i|=0,(I+-1|0)>>>0>63?A=-1:(AI(A,e,255&I,g,i),A=0),0|A}function re(A){var I=0,e=0;I=127&yi[31+(A|=0)>>0]^127,e=30;do{I|=~yi[A+e>>0],e=e+-1|0}while(0!=(0|e));return(236-(0|_i[A>>0])&511+(255&I))>>>8&1^1|0}function ae(A){A|=0;var I=0,e=0,g=0;for(e=0,I=1;g=A+e|0,I=(0|_i[g>>0])+I|0,yi[g>>0]=I,4!=(0|(e=e+1|0));)I>>>=8}function ne(A,I,e,g){var i=0;return i=wi,wi=wi+16|0,p(A|=0,I|=0,e|=0,g|=0,0|i),wi=i,0|(vi=0|fi[i+4>>2],0|fi[i>>2])}function Ce(A,I){A|=0,I|=0;var e=0,g=0;e=0;do{WI(A+(e<<3)|0,0|fi[(g=I+(e<<3)|0)>>2],0|fi[g+4>>2]),e=e+1|0}while(128!=(0|e))}function oe(A){return A|=0,vi=_i[A+4>>0]|_i[A+4+1>>0]<<8|_i[A+4+2>>0]<<16|_i[A+4+3>>0]<<24,_i[A>>0]|_i[A+1>>0]<<8|_i[A+2>>0]<<16|_i[A+3>>0]<<24|0}function ce(A){var I=0,e=0,g=0;e=240,g=64+(I=A|=0)|0;do{fi[I>>2]=fi[e>>2],I=I+4|0,e=e+4|0}while((0|I)<(0|g));wA(A+64|0,0,293)}function Qe(A,I){a(A|=0,I|=0,I+120|0),a(A+40|0,I+40|0,I+80|0),a(A+80|0,I+80|0,I+120|0),a(A+120|0,I,I+40|0)}function Ee(A,I,e){var g=0,i=0;return g=0|Ue(0|(A|=0),0|(I|=0),0|(e|=0)),i=vi,e=0|Se(0|A,0|I,64-e|0),vi|=i,e|g|0}function se(A,I,e){var g=0,i=0;return g=0|Se(0|(A|=0),0|(I|=0),0|(e|=0)),i=vi,e=0|Ue(0|A,0|I,64-e|0),vi|=i,e|g|0}function he(A,I,e,g){I|=0,g|=0;var i=0,B=0;return i=0|vI(A|=0,e|=0),B=vi,0|(vi=(0|bi(I,e))+(0|bi(g,A))+B|0&B,0|i)}function ye(A,I,e){return A|=0,I|=0,(e|=0)>>>0<256?0|L(A,I,255&e):(Mi(33384,33404,103,33536),0)}function fe(A,I,e){A|=0,e|=0;var g=0;return I=0|Se(255&(I|=0)|0,0,8),g=vi,e=0|Se(255&e|0,0,16),vi|=g,I|255&A|e|0}function _e(A){var I=0,e=0;return I=wi,e=wi=wi+63&-64,wi=wi+160|0,J(e,A|=0),A=0|ve(e),wi=I,0|A}function pe(A,I){A|=0;var e=0;if(0|(I|=0)){e=0;do{yi[A+e>>0]=0|Bi(),e=e+1|0}while((0|e)!=(0|I))}}function we(A,I){yA(A|=0,40+(I|=0)|0,I),hA(A+40|0,I+40|0,I),KA(A+80|0,I+80|0),a(A+120|0,I+120|0,1024)}function le(A,I){I|=0;var e=0;A=16+(e=48+(A|=0)|0)|0;do{yi[e>>0]=0|yi[I>>0],e=e+1|0,I=I+1|0}while((0|e)<(0|A))}function ue(A,I){A|=0;var e=0,g=0;e=wi,g=wi=wi+63&-64,wi=wi+128|0,tg(g,I|=0),nI(A,g),wi=e}function de(A,I){I|=0;var e=0;A=16+(e=32+(A|=0)|0)|0;do{yi[e>>0]=0|yi[I>>0],e=e+1|0,I=I+1|0}while((0|e)<(0|A))}function De(){var A=0;(0|(A=0|Ni(30)))>0?fi[8681]=A:A=0|fi[8681],A>>>0<16?hi():pe(35336,16)}function ve(A){var I=0,e=0;return I=wi,e=wi=wi+63&-64,wi=wi+32|0,q(e,A|=0),A=0|dI(e,32),wi=I,0|A}function be(A,I,e){return A|=0,I|=0,(0|(e|=0))<32?(vi=I>>e,A>>>e|(I&(1<<e)-1)<<32-e):(vi=(0|I)<0?-1:0,I>>e-32|0)}function ke(A,I){A|=0,I|=0;var e=0,g=0;e=0;do{yi[(g=A+e|0)>>0]=yi[g>>0]^yi[I+e>>0],e=e+1|0}while(8!=(0|e))}function Ge(A,I,e,g,i,B,t){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,0|X(A,I,e,g,i,B,t)}function Fe(){var A=0,I=0;A=wi,I=wi=wi+63&-64,wi=wi+16|0,Gg(I),0|fi[I>>2]&&Gg(I),wi=A}function me(A,I,e,g,i,B,t){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,S(A,I,e,g,i,B,t),0}function Me(A,I){A|=0;var e=0;return((I|=0)>>>0<=4294967168?0!=(0|(e=0|IA(I))):0)?(fi[A>>2]=e,A=0):A=12,0|A}function He(A,I,e,g,i,B,t){cI(A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0)}function Ye(A){yi[32+(A|=0)>>0]=0,yi[A+32+1>>0]=0,yi[A+32+2>>0]=0,yi[A+32+3>>0]=0,yi[A+32>>0]=1}function Se(A,I,e){return A|=0,I|=0,(0|(e|=0))<32?(vi=I<<e|(A&(1<<e)-1<<32-e)>>>32-e,A<<e):(vi=A<<e-32,0)}function Re(A){var I=0,e=0;return e=wi,I=wi=wi+63&-64,wi=wi+32|0,q(I,A|=0),wi=e,1&yi[I>>0]|0}function Ne(A){var I=0;return(I=0|t(A|=0))&&3&fi[I+-4>>2]?(wA(0|I,0,0|A),0|I):0|I}function Ue(A,I,e){return A|=0,I|=0,(0|(e|=0))<32?(vi=I>>>e,A>>>e|(I&(1<<e)-1)<<32-e):(vi=0,I>>>e-32|0)}function Je(A,I,e){iA(A|=0,I|=0,255&(e|=0)),iA(A+40|0,I+40|0,255&e),iA(A+80|0,I+80|0,255&e)}function Pe(A,I,e,g,i,B,t){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,0|aI(A,I,e,g,i,B,t)}function Le(A,I,e,g,i,B,t){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,0|eA(A,I,1,e,g,i,16,B,t,0,0,2)}function xe(A,I,e,g,i,B,t){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,0|eA(A,I,1,e,g,i,16,B,t,0,0,1)}function Xe(A,I){a(A|=0,I|=0,I+120|0),a(A+40|0,I+40|0,I+80|0),a(A+80|0,I+80|0,I+120|0)}function Ke(A,I,e,g,i,B){CA(A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,0)}function Te(A,I){Ie(A|=0,4&(I|=0)),Q(0|fi[A+4>>2]),fi[A+4>>2]=0,kg(0|fi[A>>2]),fi[A>>2]=0}function Ve(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,0|eA(A,I,1,e,g,i,16,0,32,B,128,2)}function qe(A,I,e,g,i,B){H(A|=0,I|=0,e|=0,g|=0,i|=0,1,0,B|=0)}function je(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,0|eA(A,I,1,e,g,i,16,0,32,B,128,1)}function Ze(A,I,e,g,i){return A|=0,I|=0,e|=0,g|=0,i|=0,0|QA(A,I,e,g,i,0)}function We(A,I,e,g,i){return A|=0,I|=0,e|=0,g|=0,i|=0,0|SI(A,I,e,g,i)}function ze(A,I,e,g,i,B){H(A|=0,I|=0,e|=0,g|=0,i|=0,0,0,B|=0)}function Oe(A,I,e,g,i,B){rI(A|=0,I|=0,e|=0,g|=0,i|=0,1,0,B|=0)}function $e(A){var I=0;fi[(A|=0)>>2]=1,I=36+(A=A+4|0)|0;do{fi[A>>2]=0,A=A+4|0}while((0|A)<(0|I))}function Ag(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,g=I-g-(e>>>0>A>>>0|0)>>>0,0|(vi=g,A-e>>>0|0)}function Ig(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,0|(vi=I+g+(A+e>>>0>>>0<A>>>0|0)>>>0,A+e>>>0|0)}function eg(A,I,e,g){hg(A|=0,I|=0,e|=0,g|=0)}function gg(A,I){I|=0,XI(A|=0),0|I&&d(A,33786,34,0)}function ig(A){0|yi[356+(A|=0)>>0]&&qg(A),fi[A+80>>2]=-1,fi[A+80+4>>2]=-1}function Bg(A,I){I|=0,yi[(A|=0)>>0]=I,yi[A+1>>0]=I>>8,yi[A+2>>0]=I>>16,yi[A+3>>0]=I>>24}function tg(A,I){KA(A|=0,I|=0),KA(A+40|0,I+40|0),KA(A+80|0,I+80|0)}function rg(A,I,e,g){rA(A|=0,I|=0,e|=0,g|=0)}function ag(A,I,e,g,i){yI(A|=0,I|=0,e|=0,g|=0,i|=0)}function ng(A,I,e,g){cI(A|=0,I|=0,40,0,e|=0,0,g|=0)}function Cg(A,I){return A|=0,I|=0,pe(I,32),0|Fg(A,I)}function og(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,rg(A,I,e,g),0}function cg(A,I,e,g){yg(A|=0,I|=0,e|=0,g|=0)}function Qg(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,0|oA(A,I,e,g,2)}function Eg(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,0|oA(A,I,e,g,1)}function sg(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,0|II(A,I,e,g)}function hg(A,I,e,g){G(A|=0,I|=0,e|=0,g|=0)}function yg(A,I,e,g){d(A|=0,I|=0,e|=0,g|=0)}function fg(A){var I=0;I=40+(A|=0)|0;do{fi[A>>2]=0,A=A+4|0}while((0|A)<(0|I))}function _g(A,I,e){return A|=0,I|=0,e|=0,0|mI(A,I,e)}function pg(A){yi[(A|=0)>>0]=-8&yi[A>>0],yi[A+31>>0]=63&yi[A+31>>0]|64}function wg(A,I){return A|=0,I|=0,A=0|EA(A,I),0|((0|yi[A>>0])==(255&I)<<24>>24?A:0)}function lg(A){return A|=0,255&(A=0|Ue(A<<24>>24|0,((A<<24>>24|0)<0)<<31>>31|0,63))|0}function ug(A){return A|=0,_i[A>>0]|_i[A+1>>0]<<8|_i[A+2>>0]<<16|_i[A+3>>0]<<24|0}function dg(A,I,e){return A|=0,I|=0,e|=0,0|ye(A,I,e)}function Dg(A){yi[(A|=0)>>0]=0,yi[A+1>>0]=0,yi[A+2>>0]=0,yi[A+3>>0]=0}function vg(A,I,e){kA(A|=0,2024+(960*(I|=0)|0)|0,e|=0)}function bg(A){fg(A|=0),$e(A+40|0),$e(A+80|0),fg(A+120|0)}function kg(A){var I=0;(0|(A|=0)?0|(I=0|fi[A>>2]):0)&&Q(I),Q(A)}function Gg(A){fi[(A|=0)>>2]=0,fi[A+4>>2]=0,fi[A+8>>2]=0,fi[A+12>>2]=0}function Fg(A,I){return A|=0,I|=0,0|gI(A,I)}function mg(A,I){Xg(A|=0,I|=0)}function Mg(A,I){Vg(A|=0,I|=0)}function Hg(A,I,e){return A|=0,I|=0,e|=0,0|CI(A,I,e)}function Yg(A,I){return A|=0,I|=0,0|Cg(A,I)}function Sg(A,I,e){K(A|=0,32,0,I|=0,e|=0)}function Rg(A,I,e){wI(A|=0,64,0,I|=0,e|=0)}function Ng(A){1!=(-7&(A|=0)|0)&&hi()}function Ug(A,I,e){w(A|=0,I|=0,e|=0)}function Jg(A,I){return A|=0,I|=0,0|Fg(A,I)}function Pg(A,I){sA(A|=0,I|=0)}function Lg(A){$e(A|=0),$e(A+40|0),fg(A+80|0)}function xg(A,I,e){return A|=0,I|=0,e|=0,0|W(A,I,e,2)}function Xg(A,I){R(A|=0,I|=0)}function Kg(A,I,e){return A|=0,I|=0,e|=0,0|W(A,I,e,1)}function Tg(A){fg(A|=0),$e(A+40|0),$e(A+80|0)}function Vg(A,I){MA(A|=0,I|=0)}function qg(A){fi[88+(A|=0)>>2]=-1,fi[A+88+4>>2]=-1}function jg(A,I){return A|=0,I|=0,1&(0!=(0|A)|0!=(0|I))|0}function Zg(A,I){return A|=0,((255&((I|=0)^A))-1|0)>>>31&255|0}function Wg(A,I){return A|=0,I|=0,0|eI(A,I,32)}function zg(A,I){return A|=0,I|=0,0|eI(A,I,16)}function Og(A,I){T(0|(A|=0),0|(I|=0),1024)}function $g(A,I){return A|=0,I|=0,A>>>(32-I|0)|A<<I|0}function Ai(A){XI(A|=0)}function Ii(){Fe()}function ei(A){wA(0|(A|=0),0,1024)}function gi(A){pe(A|=0,32)}function ii(){Si(1)}function Bi(){return 0|Si(0)}function ti(){return 3}function ri(){return 2}function ai(){return-1}function ni(){return 1}function Ci(){return 8}function oi(){return 24}function ci(){return 16}function Qi(){return 64}function Ei(){return 32}function si(){return 0}function hi(){Yi()}var yi=new A.Int8Array(e),fi=(new A.Int16Array(e),new A.Int32Array(e)),_i=new A.Uint8Array(e),pi=(new A.Uint16Array(e),new A.Uint32Array(e),new A.Float32Array(e),new A.Float64Array(e),0|I.DYNAMICTOP_PTR),wi=(I.tempDoublePtr,I.ABORT,0|I.STACKTOP),li=0|I.STACK_MAX,ui=0|I.cttz_i8,di=0,Di=0,vi=(A.NaN,A.Infinity,0),bi=(A.Math.floor,A.Math.abs,A.Math.sqrt,A.Math.pow,A.Math.cos,A.Math.sin,A.Math.tan,A.Math.acos,A.Math.asin,A.Math.atan,A.Math.atan2,A.Math.exp,A.Math.log,A.Math.ceil,A.Math.imul),ki=(A.Math.min,A.Math.max,A.Math.clz32),Gi=(I.abort,I.assert,I.enlargeMemory),Fi=I.getTotalMemory,mi=I.abortOnCannotGrowMemory,Mi=I.___assert_fail,Hi=I.___setErrNo,Yi=I._abort,Si=I._emscripten_asm_const_i,Ri=I._emscripten_memcpy_big,Ni=I._sysconf;return{___muldi3:he,___uremdi3:ne,_bitshift64Ashr:be,_bitshift64Lshr:Ue,_bitshift64Shl:Se,_crypto_aead_chacha20poly1305_abytes:ci,_crypto_aead_chacha20poly1305_decrypt:function(A,I,e,g,i,B,t,r,a,n,C){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,A=B>>>0>0|0==(0|B)&i>>>0>15?0|nA(A,0,g,e=0|Ig(0|i,0|B,-16,-1),vi,g+i+-16|0,t,r,a,n,C):-1,0|I&&(n=0==(0|A),B=0|Ig(0|i,0|B,-16,-1),fi[I>>2]=n?B:0,fi[I+4>>2]=n?vi:0),0|A},_crypto_aead_chacha20poly1305_decrypt_detached:nA,_crypto_aead_chacha20poly1305_encrypt:function(A,I,e,g,i,B,t,r,a,n,C){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,i>>>0>0|0==(0|i)&g>>>0>4294967279&&hi(),pA(A,A+g|0,0,e,g,i,B,t,r,0,n,C),0|I&&(n=0|Ig(0|g,0|i,16,0),fi[I>>2]=n,fi[I+4>>2]=vi),0},_crypto_aead_chacha20poly1305_encrypt_detached:pA,_crypto_aead_chacha20poly1305_ietf_abytes:ci,_crypto_aead_chacha20poly1305_ietf_decrypt:function(A,I,e,g,i,B,t,r,a,n,C){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,A=B>>>0>0|0==(0|B)&i>>>0>15?0|AA(A,0,g,e=0|Ig(0|i,0|B,-16,-1),vi,g+i+-16|0,t,r,a,n,C):-1,0|I&&(n=0==(0|A),B=0|Ig(0|i,0|B,-16,-1),fi[I>>2]=n?B:0,fi[I+4>>2]=n?vi:0),0|A},_crypto_aead_chacha20poly1305_ietf_decrypt_detached:AA,_crypto_aead_chacha20poly1305_ietf_encrypt:function(A,I,e,g,i,B,t,r,a,n,C){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,i>>>0>0|0==(0|i)&g>>>0>4294967279&&hi(),tA(A,A+g|0,0,e,g,i,B,t,r,0,n,C),0|I&&(n=0|Ig(0|g,0|i,16,0),fi[I>>2]=n,fi[I+4>>2]=vi),0},_crypto_aead_chacha20poly1305_ietf_encrypt_detached:tA,_crypto_aead_chacha20poly1305_ietf_keybytes:Ei,_crypto_aead_chacha20poly1305_ietf_keygen:gi,_crypto_aead_chacha20poly1305_ietf_npubbytes:function(){return 12},_crypto_aead_chacha20poly1305_ietf_nsecbytes:si,_crypto_aead_chacha20poly1305_keybytes:Ei,_crypto_aead_chacha20poly1305_keygen:gi,_crypto_aead_chacha20poly1305_npubbytes:Ci,_crypto_aead_chacha20poly1305_nsecbytes:si,_crypto_aead_xchacha20poly1305_ietf_abytes:ci,_crypto_aead_xchacha20poly1305_ietf_decrypt:function(A,I,e,g,i,B,t,r,a,n,C){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,A=B>>>0>0|0==(0|B)&i>>>0>15?0|bA(A,0,g,e=0|Ig(0|i,0|B,-16,-1),vi,g+i+-16|0,t,r,a,n,C):-1,0|I&&(n=0==(0|A),B=0|Ig(0|i,0|B,-16,-1),fi[I>>2]=n?B:0,fi[I+4>>2]=n?vi:0),0|A},_crypto_aead_xchacha20poly1305_ietf_decrypt_detached:bA,_crypto_aead_xchacha20poly1305_ietf_encrypt:function(A,I,e,g,i,B,t,r,a,n,C){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,C|=0,i>>>0>4294967295|-1==(0|i)&g>>>0>4294967279&&hi(),dA(A,A+g|0,0,e,g,i,B,t,r,0,n,C),0|I&&(n=0|Ig(0|g,0|i,16,0),fi[I>>2]=n,fi[I+4>>2]=vi),0},_crypto_aead_xchacha20poly1305_ietf_encrypt_detached:dA,_crypto_aead_xchacha20poly1305_ietf_keybytes:Ei,_crypto_aead_xchacha20poly1305_ietf_keygen:gi,_crypto_aead_xchacha20poly1305_ietf_npubbytes:oi,_crypto_aead_xchacha20poly1305_ietf_nsecbytes:si,_crypto_auth:function(A,I,e,g,i){return A|=0,I|=0,e|=0,g|=0,i|=0,xI(A,I,e,g,i),0},_crypto_auth_bytes:Ei,_crypto_auth_keybytes:Ei,_crypto_auth_keygen:gi,_crypto_auth_verify:function(A,I,e,g,i){return A|=0,I|=0,e|=0,g|=0,i|=0,0|FI(A,I,e,g,i)},_crypto_box_beforenm:_g,_crypto_box_beforenmbytes:Ei,_crypto_box_detached:uI,_crypto_box_detached_afternm:me,_crypto_box_easy:zI,_crypto_box_easy_afternm:function(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,g>>>0>0|0==(0|g)&e>>>0>4294967279?(hi(),0):(me(A+16|0,A,I,e,g,i,B),0)},_crypto_box_keypair:Yg,_crypto_box_macbytes:ci,_crypto_box_noncebytes:oi,_crypto_box_open_detached:lI,_crypto_box_open_detached_afternm:Ge,_crypto_box_open_easy:MI,_crypto_box_open_easy_afternm:function(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,0|(A=g>>>0<0|0==(0|g)&e>>>0<16?-1:0|Ge(A,I+16|0,I,g=0|Ig(0|e,0|g,-16,-1),vi,i,B))},_crypto_box_publickeybytes:Ei,_crypto_box_seal:function(A,I,e,g,i){A|=0,I|=0,e|=0,g|=0,i|=0;var B=0,t=0,r=0,a=0;if(a=wi,wi=wi+96|0,0|Yg(a+32|0,a))A=-1;else{t=a+32|0,r=(B=A)+32|0;do{yi[B>>0]=0|yi[t>>0],B=B+1|0,t=t+1|0}while((0|B)<(0|r));kI(a+64|0,a+32|0,i),A=0|zI(A+32|0,I,e,g,a+64|0,i,a),YI(a,32),YI(a+32|0,32),YI(a+64|0,24)}return wi=a,0|A},_crypto_box_seal_open:function(A,I,e,g,i,B){A|=0,I|=0,i|=0,B|=0;var t=0,r=0;return r=wi,t=wi=wi+63&-64,wi=wi+32|0,(g|=0)>>>0<0|0==(0|g)&(e|=0)>>>0<48?A=-1:(e=0|Ig(0|e,0|g,-32,-1),g=vi,kI(t,I,i),A=0|MI(A,I+32|0,e,g,t,I,B)),wi=r,0|A},_crypto_box_sealbytes:function(){return 48},_crypto_box_secretkeybytes:Ei,_crypto_box_seed_keypair:function(A,I,e){return A|=0,I|=0,e|=0,0|oI(A,I,e)},_crypto_box_seedbytes:Ei,_crypto_core_hchacha20:u,_crypto_core_hchacha20_constbytes:ci,_crypto_core_hchacha20_inputbytes:ci,_crypto_core_hchacha20_keybytes:Ei,_crypto_core_hchacha20_outputbytes:Ei,_crypto_generichash:Pe,_crypto_generichash_bytes:Ei,_crypto_generichash_bytes_max:Qi,_crypto_generichash_bytes_min:ci,_crypto_generichash_final:dg,_crypto_generichash_init:sg,_crypto_generichash_keybytes:Ei,_crypto_generichash_keybytes_max:Qi,_crypto_generichash_keybytes_min:ci,_crypto_generichash_keygen:gi,_crypto_generichash_statebytes:function(){return 384},_crypto_generichash_update:og,_crypto_hash:function(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,KI(A,I,e,g),0},_crypto_hash_bytes:Qi,_crypto_kdf_bytes_max:Qi,_crypto_kdf_bytes_min:ci,_crypto_kdf_contextbytes:Ci,_crypto_kdf_derive_from_key:function(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,0|fA(A,I,e,g,i,B)},_crypto_kdf_keybytes:Ei,_crypto_kdf_keygen:gi,_crypto_kx_client_session_keys:function(A,I,e,g,i){I|=0,e|=0,g|=0,i|=0;var B=0,t=0,r=0;if(r=wi,t=wi=wi+63&-64,wi=wi+480|0,B=0==(0|(A|=0))?I:A,I=0==(0|I)?B:I,B||hi(),0|Hg(t+448|0,g,i))A=-1;else{sg(t,0,0,64),og(t,t+448|0,32,0),YI(t+448|0,32),og(t,e,32,0),og(t,i,32,0),dg(t,t+384|0,64),YI(t,384),A=0;do{yi[B+A>>0]=0|yi[t+384+A>>0],yi[I+A>>0]=0|yi[t+384+(A+32)>>0],A=A+1|0}while(32!=(0|A));YI(t+384|0,64),A=0}return wi=r,0|A},_crypto_kx_keypair:function(A,I){return A|=0,I|=0,pe(I,32),0|Jg(A,I)},_crypto_kx_publickeybytes:Ei,_crypto_kx_secretkeybytes:Ei,_crypto_kx_seed_keypair:function(A,I,e){return A|=0,I|=0,e|=0,Pe(I,32,e,32,0,0,0),0|Jg(A,I)},_crypto_kx_seedbytes:Ei,_crypto_kx_server_session_keys:function(A,I,e,g,i){I|=0,e|=0,g|=0,i|=0;var B=0,t=0,r=0;if(r=wi,t=wi=wi+63&-64,wi=wi+480|0,B=0==(0|(A|=0))?I:A,I=0==(0|I)?B:I,B||hi(),0|Hg(t+448|0,g,i))A=-1;else{sg(t,0,0,64),og(t,t+448|0,32,0),YI(t+448|0,32),og(t,i,32,0),og(t,e,32,0),dg(t,t+384|0,64),YI(t,384),A=0;do{yi[I+A>>0]=0|yi[t+384+A>>0],yi[B+A>>0]=0|yi[t+384+(A+32)>>0],A=A+1|0}while(32!=(0|A));YI(t+384|0,64),A=0}return wi=r,0|A},_crypto_kx_sessionkeybytes:Ei,_crypto_pwhash:function(A,I,e,g,i,B,t,r,a,n,C){switch(A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0,0|(C|=0)){case 1:A=0|vA(A,I,e,g,i,B,t,r,a,n);break;case 2:A=0|GA(A,I,e,g,i,B,t,r,a,n);break;default:fi[8202]=22,A=-1}return 0|A},_crypto_pwhash_alg_argon2i13:ni,_crypto_pwhash_alg_argon2id13:ri,_crypto_pwhash_alg_default:ri,_crypto_pwhash_bytes_max:ai,_crypto_pwhash_bytes_min:ci,_crypto_pwhash_memlimit_interactive:function(){return 67108864},_crypto_pwhash_memlimit_max:function(){return-2147483648},_crypto_pwhash_memlimit_min:function(){return 8192},_crypto_pwhash_memlimit_moderate:function(){return 268435456},_crypto_pwhash_memlimit_sensitive:function(){return 1073741824},_crypto_pwhash_opslimit_interactive:ri,_crypto_pwhash_opslimit_max:ai,_crypto_pwhash_opslimit_min:ni,_crypto_pwhash_opslimit_moderate:ti,_crypto_pwhash_opslimit_sensitive:function(){return 4},_crypto_pwhash_passwd_max:ai,_crypto_pwhash_passwd_min:si,_crypto_pwhash_primitive:function(){return 33778},_crypto_pwhash_saltbytes:ci,_crypto_pwhash_str:function(A,I,e,g,i,B,t){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0,0|mA(A,I,e,g,i,B,t)},_crypto_pwhash_str_alg:function(A,I,e,g,i,B,t,r){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0;var a=0;switch(0|(r|=0)){case 1:a=0|FA(A,I,e,g,i,B,t);break;case 2:a=0|mA(A,I,e,g,i,B,t);break;default:hi()}return 0|a},_crypto_pwhash_str_needs_rehash:function(A,I,e,g){A|=0,I|=0,e|=0,g|=0;do{if(0|NA(A,33757,10)){if(0|NA(A,33768,9)){fi[8202]=22,A=-1;break}A=0|Eg(A,I,e,g);break}A=0|Qg(A,I,e,g)}while(0);return 0|A},_crypto_pwhash_str_verify:function(A,I,e,g){A|=0,I|=0,e|=0,g|=0;do{if(0|NA(A,33757,10)){if(0|NA(A,33768,9)){fi[8202]=22,A=-1;break}A=0|_I(A,I,e,g);break}A=0|hI(A,I,e,g)}while(0);return 0|A},_crypto_pwhash_strbytes:function(){return 128},_crypto_pwhash_strprefix:function(){return 33757},_crypto_scalarmult:Hg,_crypto_scalarmult_base:Jg,_crypto_scalarmult_bytes:Ei,_crypto_scalarmult_scalarbytes:Ei,_crypto_secretbox_detached:S,_crypto_secretbox_easy:function(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,g>>>0>0|0==(0|g)&e>>>0>4294967279?(hi(),0):(S(A+16|0,A,I,e,g,i,B),0)},_crypto_secretbox_keybytes:Ei,_crypto_secretbox_keygen:gi,_crypto_secretbox_macbytes:ci,_crypto_secretbox_noncebytes:oi,_crypto_secretbox_open_detached:X,_crypto_secretbox_open_easy:function(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,0|(A=g>>>0<0|0==(0|g)&e>>>0<16?-1:0|X(A,I+16|0,I,g=0|Ig(0|e,0|g,-16,-1),vi,i,B))},_crypto_secretstream_xchacha20poly1305_abytes:function(){return 17},_crypto_secretstream_xchacha20poly1305_headerbytes:oi,_crypto_secretstream_xchacha20poly1305_init_pull:function(A,I,e){var g=0;return u(A|=0,I|=0,e|=0,0),Ye(A),g=_i[I+16>>0]|_i[I+16+1>>0]<<8|_i[I+16+2>>0]<<16|_i[I+16+3>>0]<<24,e=_i[I+16+4>>0]|_i[I+16+4+1>>0]<<8|_i[I+16+4+2>>0]<<16|_i[I+16+4+3>>0]<<24,yi[A+36>>0]=g,yi[A+36+1>>0]=g>>8,yi[A+36+2>>0]=g>>16,yi[A+36+3>>0]=g>>24,yi[A+36+4>>0]=e,yi[A+36+4+1>>0]=e>>8,yi[A+36+4+2>>0]=e>>16,yi[A+36+4+3>>0]=e>>24,yi[A+44>>0]=0,yi[A+44+1>>0]=0,yi[A+44+2>>0]=0,yi[A+44+3>>0]=0,yi[A+44+4>>0]=0,yi[A+44+4+1>>0]=0,yi[A+44+4+2>>0]=0,yi[A+44+4+3>>0]=0,0},_crypto_secretstream_xchacha20poly1305_init_push:function(A,I,e){A|=0,e|=0;var g=0;return pe(I|=0,24),u(A,I,e,0),Ye(A),g=_i[I+16>>0]|_i[I+16+1>>0]<<8|_i[I+16+2>>0]<<16|_i[I+16+3>>0]<<24,e=_i[I+16+4>>0]|_i[I+16+4+1>>0]<<8|_i[I+16+4+2>>0]<<16|_i[I+16+4+3>>0]<<24,yi[A+36>>0]=g,yi[A+36+1>>0]=g>>8,yi[A+36+2>>0]=g>>16,yi[A+36+3>>0]=g>>24,yi[A+36+4>>0]=e,yi[A+36+4+1>>0]=e>>8,yi[A+36+4+2>>0]=e>>16,yi[A+36+4+3>>0]=e>>24,yi[A+44>>0]=0,yi[A+44+1>>0]=0,yi[A+44+2>>0]=0,yi[A+44+3>>0]=0,yi[A+44+4>>0]=0,yi[A+44+4+1>>0]=0,yi[A+44+4+2>>0]=0,yi[A+44+4+3>>0]=0,0},_crypto_secretstream_xchacha20poly1305_keybytes:Ei,_crypto_secretstream_xchacha20poly1305_keygen:gi,_crypto_secretstream_xchacha20poly1305_messagebytes_max:ai,_crypto_secretstream_xchacha20poly1305_pull:function(A,I,e,g,i,B,t,r,a,n){A|=0,I|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0;var C=0,o=0,c=0,Q=0,E=0;E=wi,Q=wi=wi+63&-64,wi=wi+352|0,0|(e|=0)&&(fi[e>>2]=0,fi[e+4>>2]=0),0|g&&(yi[g>>0]=-1);do{if(t>>>0<0|0==(0|t)&B>>>0<17)r=-1;else{o=0|Ig(0|B,0|t,-17,-1),(c=vi)>>>0>0|0==(0|c)&o>>>0>4294967295&&hi(),ag(Q+280|0,64,0,A+32|0,A),Mg(Q,Q+280|0),YI(Q+280|0,64),eg(Q,r,a,n),eg(Q,35320,15&(r=0|Ag(0,0,0|a,0|n)),0),C=63+(r=Q+280+1|0)|0;do{yi[r>>0]=0,r=r+1|0}while((0|r)<(0|C));if(yi[Q+280>>0]=0|yi[i>>0],He(Q+280|0,Q+280|0,64,0,A+32|0,1,A),r=0|yi[Q+280>>0],yi[Q+280>>0]=0|yi[i>>0],eg(Q,Q+280|0,64,0),eg(Q,i+1|0,o,c),C=0|Ig(0|B,0|t,15,0),eg(Q,35320,15&C,0),WI(Q+272|0,a,n),eg(Q,Q+272|0,8,0),n=0|Ig(0|B,0|t,47,0),WI(Q+272|0,n,vi),eg(Q,Q+272|0,8,0),mg(Q,Q+256|0),YI(Q,256),0|iI(Q+256|0,i+1+o|0,16)){YI(Q+256|0,16),r=-1;break}He(I,i+1|0,o,c,A+32|0,2,A),ke(A+36|0,Q+256|0),ae(A+32|0),(0==(2&r)?!(0|dI(A+32|0,4)):0)||V(A),0|e&&(fi[e>>2]=o,fi[e+4>>2]=c),0|g?(yi[g>>0]=r,r=0):r=0}}while(0);return wi=E,0|r},_crypto_secretstream_xchacha20poly1305_push:function(A,I,e,g,i,B,t,r,a,n){A|=0,I|=0,g|=0,i|=0,B|=0,t|=0,r|=0,a|=0,n|=0;var C=0,o=0,c=0;o=wi,c=wi=wi+63&-64,wi=wi+336|0,0|(e|=0)&&(fi[e>>2]=0,fi[e+4>>2]=0),B>>>0>0|0==(0|B)&i>>>0>4294967295&&hi(),ag(c+264|0,64,0,A+32|0,A),Mg(c,c+264|0),YI(c+264|0,64),eg(c,t,r,a),eg(c,35320,15&(t=0|Ag(0,0,0|r,0|a)),0),C=63+(t=c+264+1|0)|0;do{yi[t>>0]=0,t=t+1|0}while((0|t)<(0|C));return yi[c+264>>0]=n,He(c+264|0,c+264|0,64,0,A+32|0,1,A),eg(c,c+264|0,64,0),yi[I>>0]=0|yi[c+264>>0],He(I+1|0,g,i,B,A+32|0,2,A),eg(c,I+1|0,i,B),eg(c,35320,15&i,0),WI(c+256|0,r,a),eg(c,c+256|0,8,0),a=0|Ig(0|i,0|B,64,0),WI(c+256|0,a,vi),eg(c,c+256|0,8,0),mg(c,I+1+i|0),YI(c,256),ke(A+36|0,I+1+i|0),ae(A+32|0),(0==(2&n)?!(0|dI(A+32|0,4)):0)||V(A),0|e&&(c=0|Ig(0|i,0|B,17,0),fi[e>>2]=c,fi[e+4>>2]=vi),wi=o,0},_crypto_secretstream_xchacha20poly1305_rekey:V,_crypto_secretstream_xchacha20poly1305_statebytes:function(){return 52},_crypto_secretstream_xchacha20poly1305_tag_final:ti,_crypto_secretstream_xchacha20poly1305_tag_message:si,_crypto_secretstream_xchacha20poly1305_tag_push:ni,_crypto_secretstream_xchacha20poly1305_tag_rekey:ri,_crypto_shorthash:function(A,I,e,g,i){return A|=0,I|=0,e|=0,g|=0,i|=0,s(A,I,e,g,i),0},_crypto_shorthash_bytes:Ci,_crypto_shorthash_keybytes:ci,_crypto_shorthash_keygen:function(A){pe(A|=0,16)},_crypto_sign:function(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,0|JA(A,I,e,g,i,B)},_crypto_sign_bytes:Qi,_crypto_sign_detached:function(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,Ke(A,I,e,g,i,B),0},_crypto_sign_ed25519_pk_to_curve25519:function(A,I){A|=0;var e=0,g=0;return g=wi,e=wi=wi+63&-64,wi=wi+240|0,((0==(0|tI(I|=0))?0==(0|gA(e+80|0,I)):0)?0!=(0|_e(e+80|0)):0)?($e(e),hA(e,e,e+80+40|0),Y(e,e),$e(e+40|0),yA(e+40|0,e+40|0,e+80+40|0),a(e+40|0,e+40|0,e),q(A,e+40|0),A=0):A=-1,wi=g,0|A},_crypto_sign_ed25519_sk_to_curve25519:function(A,I){A|=0;var e=0,g=0,i=0;g=wi,i=wi=wi+63&-64,wi=wi+64|0,KI(i,I|=0,32,0),yi[i>>0]=-8&yi[i>>0],yi[i+31>>0]=63&yi[i+31>>0]|64,I=i,e=A+32|0;do{yi[A>>0]=0|yi[I>>0],A=A+1|0,I=I+1|0}while((0|A)<(0|e));return YI(i,64),wi=g,0},_crypto_sign_final_create:function(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,qI(A,I,e,g),0},_crypto_sign_final_verify:function(A,I,e){return A|=0,I|=0,e|=0,0|VI(A,I,e)},_crypto_sign_init:function(A){return A|=0,Ai(A),0},_crypto_sign_keypair:function(A,I){return A|=0,I|=0,Be(A,I),0},_crypto_sign_open:function(A,I,e,g,i,B){return A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,0|SA(A,I,e,g,i,B)},_crypto_sign_publickeybytes:Ei,_crypto_sign_secretkeybytes:Qi,_crypto_sign_seed_keypair:function(A,I,e){return A|=0,I|=0,e|=0,sI(A,I,e),0},_crypto_sign_seedbytes:Ei,_crypto_sign_statebytes:function(){return 208},_crypto_sign_update:function(A,I,e,g){return A|=0,I|=0,e|=0,g|=0,yg(A,I,e,g),0},_crypto_sign_verify_detached:function(A,I,e,g,i){return A|=0,I|=0,e|=0,g|=0,i|=0,0|Ze(A,I,e,g,i)},_crypto_stream_keygen:gi,_emscripten_get_global_libc:function(){return 35224},_free:Q,_i64Add:Ig,_i64Subtract:Ag,_malloc:t,_memcpy:T,_memmove:GI,_memset:wA,_randombytes:function(A,I,e){A|=0,(e|=0)>>>0<1|1==(0|e)&(I|=0)>>>0<0?pe(A,I):Mi(34587,34607,204,34633)},_randombytes_buf:pe,_randombytes_buf_deterministic:function(A,I,e){ag(A|=0,I|=0,0,34575,e|=0)},_randombytes_close:si,_randombytes_random:Bi,_randombytes_seedbytes:Ei,_randombytes_stir:ii,_randombytes_uniform:function(A){var I=0;if((A|=0)>>>0<2)A=0;else{do{I=0|Bi()}while(I>>>0<(((0-A|0)>>>0)%(A>>>0)|0)>>>0);A=(I>>>0)%(A>>>0)|0}return 0|A},_sbrk:pI,_sodium_base642bin:v,_sodium_base64_encoded_len:function(A,I){A|=0;var e=0;return Ng(I|=0),e=(0|bi((A>>>0)/3|0,-3))+A|0,(((A>>>0)/3|0)<<2|1)+(4-(3-e&0-(I>>>1&1))&0-(1&(e>>>1|e)))|0},_sodium_bin2base64:U,_sodium_bin2hex:function(A,I,e,g){A|=0,e|=0;var i=0,B=0;if((g|=0)>>>0<2147483647&g<<1>>>0<(I|=0)>>>0||hi(),g)for(i=0,I=0;;){if(B=0|_i[e+i>>0],yi[A+I>>0]=87+(B>>>4)+((65526+(B>>>4)|0)>>>8&217),yi[A+(1|I)>>0]=(22272+((15&B)<<8)+(65526+(15&B)&55552)|0)>>>8,(0|(I=i+1|0))==(0|g)){I=g<<1;break}i=I,I<<=1}else I=0;return yi[A+I>>0]=0,0|A},_sodium_hex2bin:function(A,I,e,g,i,B,t){A|=0,I|=0,e|=0,g|=0,i|=0,B|=0,t|=0;var r=0,a=0,n=0,C=0,o=0,c=0,Q=0;A:do{if(g){a=0,C=0,n=0,c=0;I:for(;;){for(;r=0|_i[e+n>>0],!(255&((o=(65526+(201+(223&r)&255)^65520+(201+(223&r)&255))>>>8)|(65526+(48^r)|0)>>>8)|0);){if(!(0!=(0|i)&a<<24>>24==0)){r=0;break I}if(!(0|wg(i,r))){a=C,r=0;break A}if(!((n=n+1|0)>>>0<g>>>0)){a=C,r=0;break A}a=0}if(C>>>0>=I>>>0){Q=9;break}if(r=201+(223&r)&255&o|(65526+(48^r)|0)>>>8&(48^r),a<<24>>24?(yi[A+C>>0]=r|255&c,C=C+1|0,r=c):r=r<<4&255,a=~a,!((n=n+1|0)>>>0<g>>>0)){r=0;break}c=r}9==(0|Q)&&(fi[8202]=34,r=-1),a<<24>>24?(fi[8202]=22,a=C,n=n+-1|0,r=-1):a=C}else a=0,n=0,r=0}while(0);return a=0==(0|r)?a:0,t?fi[t>>2]=e+n:(0|n)!=(0|g)&&(fi[8202]=22,r=-1),0|B&&(fi[B>>2]=a),0|r},_sodium_init:function(){var A=0;return 0|fi[8680]?A=1:(Ii(),ii(),De(),fi[8680]=1,A=0),0|A},_sodium_library_minimal:ni,_sodium_library_version_major:function(){return 10},_sodium_library_version_minor:si,_sodium_pad:function(A,I,e,g,i){A|=0,I|=0,e|=0,i|=0;var B=0,t=0,r=0,a=0;if(a=wi,r=wi=wi+63&-64,wi=wi+16|0,g|=0)if(B=g+-1&g?(e>>>0)%(g>>>0)|0:g+-1&e,(t=g+-1-B|0)>>>0>=~e>>>0&&hi(),(t+e|0)>>>0<i>>>0){0|A&&(fi[A>>2]=t+e+1),yi[r>>0]=0,B=0;do{i=(65535+(B^t)|0)>>>8,yi[(A=I+(t+e)+(0-B)|0)>>0]=yi[r>>0]&yi[A>>0]&255|128&i,yi[r>>0]=0|_i[r>>0]|i,B=B+1|0}while((0|B)!=(0|g));B=0}else B=-1;else B=-1;return wi=a,0|B},_sodium_unpad:function(A,I,e,g){A|=0,I|=0,e|=0,g|=0;var i=0,B=0,t=0,r=0,a=0,n=0,C=0;if(n=wi,a=wi=wi+63&-64,wi=wi+16|0,fi[a>>2]=0,(g+-1|0)>>>0<e>>>0){for(t=0,i=0,r=0;i&=255,B=0|_i[I+(e+-1)+(0-t)>>0],C=(511+(0|fi[a>>2])&i+511&511+(128^B))>>>8,fi[a>>2]=1+(1^(-2|C))&t|fi[a>>2],t=t+1|0,r=1&C|255&r,(0|t)!=(0|g);)i|=B;fi[A>>2]=e+-1-(0|fi[a>>2]),i=r+-1|0}else i=-1;return wi=n,0|i},_sodium_version_string:function(){return 34698},establishStackSpace:function(A,I){wi=A|=0,li=I|=0},getTempRet0:function(){return 0|vi},runPostSets:function(){},setTempRet0:function(A){vi=A|=0},setThrew:function(A,I){A|=0,I|=0,di||(di=A,Di=I)},stackAlloc:function(A){var I=0;return I=wi,wi=wi+(A|=0)|0,wi=wi+15&-16,0|I},stackRestore:function(A){wi=A|=0},stackSave:function(){return 0|wi}}}(J.asmGlobalArg,J.asmLibraryArg,eA),XA=(J.___muldi3=xA.___muldi3,J.___uremdi3=xA.___uremdi3,J._bitshift64Ashr=xA._bitshift64Ashr,J._bitshift64Lshr=xA._bitshift64Lshr,J._bitshift64Shl=xA._bitshift64Shl,J._crypto_aead_chacha20poly1305_abytes=xA._crypto_aead_chacha20poly1305_abytes,J._crypto_aead_chacha20poly1305_decrypt=xA._crypto_aead_chacha20poly1305_decrypt,J._crypto_aead_chacha20poly1305_decrypt_detached=xA._crypto_aead_chacha20poly1305_decrypt_detached,J._crypto_aead_chacha20poly1305_encrypt=xA._crypto_aead_chacha20poly1305_encrypt,J._crypto_aead_chacha20poly1305_encrypt_detached=xA._crypto_aead_chacha20poly1305_encrypt_detached,J._crypto_aead_chacha20poly1305_ietf_abytes=xA._crypto_aead_chacha20poly1305_ietf_abytes,J._crypto_aead_chacha20poly1305_ietf_decrypt=xA._crypto_aead_chacha20poly1305_ietf_decrypt,J._crypto_aead_chacha20poly1305_ietf_decrypt_detached=xA._crypto_aead_chacha20poly1305_ietf_decrypt_detached,J._crypto_aead_chacha20poly1305_ietf_encrypt=xA._crypto_aead_chacha20poly1305_ietf_encrypt,J._crypto_aead_chacha20poly1305_ietf_encrypt_detached=xA._crypto_aead_chacha20poly1305_ietf_encrypt_detached,J._crypto_aead_chacha20poly1305_ietf_keybytes=xA._crypto_aead_chacha20poly1305_ietf_keybytes,J._crypto_aead_chacha20poly1305_ietf_keygen=xA._crypto_aead_chacha20poly1305_ietf_keygen,J._crypto_aead_chacha20poly1305_ietf_npubbytes=xA._crypto_aead_chacha20poly1305_ietf_npubbytes,J._crypto_aead_chacha20poly1305_ietf_nsecbytes=xA._crypto_aead_chacha20poly1305_ietf_nsecbytes,J._crypto_aead_chacha20poly1305_keybytes=xA._crypto_aead_chacha20poly1305_keybytes,J._crypto_aead_chacha20poly1305_keygen=xA._crypto_aead_chacha20poly1305_keygen,J._crypto_aead_chacha20poly1305_npubbytes=xA._crypto_aead_chacha20poly1305_npubbytes,J._crypto_aead_chacha20poly1305_nsecbytes=xA._crypto_aead_chacha20poly1305_nsecbytes,J._crypto_aead_xchacha20poly1305_ietf_abytes=xA._crypto_aead_xchacha20poly1305_ietf_abytes,J._crypto_aead_xchacha20poly1305_ietf_decrypt=xA._crypto_aead_xchacha20poly1305_ietf_decrypt,J._crypto_aead_xchacha20poly1305_ietf_decrypt_detached=xA._crypto_aead_xchacha20poly1305_ietf_decrypt_detached,J._crypto_aead_xchacha20poly1305_ietf_encrypt=xA._crypto_aead_xchacha20poly1305_ietf_encrypt,J._crypto_aead_xchacha20poly1305_ietf_encrypt_detached=xA._crypto_aead_xchacha20poly1305_ietf_encrypt_detached,J._crypto_aead_xchacha20poly1305_ietf_keybytes=xA._crypto_aead_xchacha20poly1305_ietf_keybytes,J._crypto_aead_xchacha20poly1305_ietf_keygen=xA._crypto_aead_xchacha20poly1305_ietf_keygen,J._crypto_aead_xchacha20poly1305_ietf_npubbytes=xA._crypto_aead_xchacha20poly1305_ietf_npubbytes,J._crypto_aead_xchacha20poly1305_ietf_nsecbytes=xA._crypto_aead_xchacha20poly1305_ietf_nsecbytes,J._crypto_auth=xA._crypto_auth,J._crypto_auth_bytes=xA._crypto_auth_bytes,J._crypto_auth_keybytes=xA._crypto_auth_keybytes,J._crypto_auth_keygen=xA._crypto_auth_keygen,J._crypto_auth_verify=xA._crypto_auth_verify,J._crypto_box_beforenm=xA._crypto_box_beforenm,J._crypto_box_beforenmbytes=xA._crypto_box_beforenmbytes,J._crypto_box_detached=xA._crypto_box_detached,J._crypto_box_detached_afternm=xA._crypto_box_detached_afternm,J._crypto_box_easy=xA._crypto_box_easy,J._crypto_box_easy_afternm=xA._crypto_box_easy_afternm,J._crypto_box_keypair=xA._crypto_box_keypair,J._crypto_box_macbytes=xA._crypto_box_macbytes,J._crypto_box_noncebytes=xA._crypto_box_noncebytes,J._crypto_box_open_detached=xA._crypto_box_open_detached,J._crypto_box_open_detached_afternm=xA._crypto_box_open_detached_afternm,J._crypto_box_open_easy=xA._crypto_box_open_easy,J._crypto_box_open_easy_afternm=xA._crypto_box_open_easy_afternm,J._crypto_box_publickeybytes=xA._crypto_box_publickeybytes,J._crypto_box_seal=xA._crypto_box_seal,J._crypto_box_seal_open=xA._crypto_box_seal_open,J._crypto_box_sealbytes=xA._crypto_box_sealbytes,J._crypto_box_secretkeybytes=xA._crypto_box_secretkeybytes,J._crypto_box_seed_keypair=xA._crypto_box_seed_keypair,J._crypto_box_seedbytes=xA._crypto_box_seedbytes,J._crypto_core_hchacha20=xA._crypto_core_hchacha20,J._crypto_core_hchacha20_constbytes=xA._crypto_core_hchacha20_constbytes,J._crypto_core_hchacha20_inputbytes=xA._crypto_core_hchacha20_inputbytes,J._crypto_core_hchacha20_keybytes=xA._crypto_core_hchacha20_keybytes,J._crypto_core_hchacha20_outputbytes=xA._crypto_core_hchacha20_outputbytes,J._crypto_generichash=xA._crypto_generichash,J._crypto_generichash_bytes=xA._crypto_generichash_bytes,J._crypto_generichash_bytes_max=xA._crypto_generichash_bytes_max,J._crypto_generichash_bytes_min=xA._crypto_generichash_bytes_min,J._crypto_generichash_final=xA._crypto_generichash_final,J._crypto_generichash_init=xA._crypto_generichash_init,J._crypto_generichash_keybytes=xA._crypto_generichash_keybytes,J._crypto_generichash_keybytes_max=xA._crypto_generichash_keybytes_max,J._crypto_generichash_keybytes_min=xA._crypto_generichash_keybytes_min,J._crypto_generichash_keygen=xA._crypto_generichash_keygen,J._crypto_generichash_statebytes=xA._crypto_generichash_statebytes,J._crypto_generichash_update=xA._crypto_generichash_update,J._crypto_hash=xA._crypto_hash,J._crypto_hash_bytes=xA._crypto_hash_bytes,J._crypto_kdf_bytes_max=xA._crypto_kdf_bytes_max,J._crypto_kdf_bytes_min=xA._crypto_kdf_bytes_min,J._crypto_kdf_contextbytes=xA._crypto_kdf_contextbytes,J._crypto_kdf_derive_from_key=xA._crypto_kdf_derive_from_key,J._crypto_kdf_keybytes=xA._crypto_kdf_keybytes,J._crypto_kdf_keygen=xA._crypto_kdf_keygen,J._crypto_kx_client_session_keys=xA._crypto_kx_client_session_keys,J._crypto_kx_keypair=xA._crypto_kx_keypair,J._crypto_kx_publickeybytes=xA._crypto_kx_publickeybytes,J._crypto_kx_secretkeybytes=xA._crypto_kx_secretkeybytes,J._crypto_kx_seed_keypair=xA._crypto_kx_seed_keypair,J._crypto_kx_seedbytes=xA._crypto_kx_seedbytes,J._crypto_kx_server_session_keys=xA._crypto_kx_server_session_keys,J._crypto_kx_sessionkeybytes=xA._crypto_kx_sessionkeybytes,J._crypto_pwhash=xA._crypto_pwhash,J._crypto_pwhash_alg_argon2i13=xA._crypto_pwhash_alg_argon2i13,J._crypto_pwhash_alg_argon2id13=xA._crypto_pwhash_alg_argon2id13,J._crypto_pwhash_alg_default=xA._crypto_pwhash_alg_default,J._crypto_pwhash_bytes_max=xA._crypto_pwhash_bytes_max,J._crypto_pwhash_bytes_min=xA._crypto_pwhash_bytes_min,J._crypto_pwhash_memlimit_interactive=xA._crypto_pwhash_memlimit_interactive,J._crypto_pwhash_memlimit_max=xA._crypto_pwhash_memlimit_max,J._crypto_pwhash_memlimit_min=xA._crypto_pwhash_memlimit_min,J._crypto_pwhash_memlimit_moderate=xA._crypto_pwhash_memlimit_moderate,J._crypto_pwhash_memlimit_sensitive=xA._crypto_pwhash_memlimit_sensitive,J._crypto_pwhash_opslimit_interactive=xA._crypto_pwhash_opslimit_interactive,J._crypto_pwhash_opslimit_max=xA._crypto_pwhash_opslimit_max,J._crypto_pwhash_opslimit_min=xA._crypto_pwhash_opslimit_min,J._crypto_pwhash_opslimit_moderate=xA._crypto_pwhash_opslimit_moderate,J._crypto_pwhash_opslimit_sensitive=xA._crypto_pwhash_opslimit_sensitive,J._crypto_pwhash_passwd_max=xA._crypto_pwhash_passwd_max,J._crypto_pwhash_passwd_min=xA._crypto_pwhash_passwd_min,J._crypto_pwhash_primitive=xA._crypto_pwhash_primitive,J._crypto_pwhash_saltbytes=xA._crypto_pwhash_saltbytes,J._crypto_pwhash_str=xA._crypto_pwhash_str,J._crypto_pwhash_str_alg=xA._crypto_pwhash_str_alg,J._crypto_pwhash_str_needs_rehash=xA._crypto_pwhash_str_needs_rehash,J._crypto_pwhash_str_verify=xA._crypto_pwhash_str_verify,J._crypto_pwhash_strbytes=xA._crypto_pwhash_strbytes,J._crypto_pwhash_strprefix=xA._crypto_pwhash_strprefix,J._crypto_scalarmult=xA._crypto_scalarmult,J._crypto_scalarmult_base=xA._crypto_scalarmult_base,J._crypto_scalarmult_bytes=xA._crypto_scalarmult_bytes,J._crypto_scalarmult_scalarbytes=xA._crypto_scalarmult_scalarbytes,J._crypto_secretbox_detached=xA._crypto_secretbox_detached,J._crypto_secretbox_easy=xA._crypto_secretbox_easy,J._crypto_secretbox_keybytes=xA._crypto_secretbox_keybytes,J._crypto_secretbox_keygen=xA._crypto_secretbox_keygen,J._crypto_secretbox_macbytes=xA._crypto_secretbox_macbytes,J._crypto_secretbox_noncebytes=xA._crypto_secretbox_noncebytes,J._crypto_secretbox_open_detached=xA._crypto_secretbox_open_detached,J._crypto_secretbox_open_easy=xA._crypto_secretbox_open_easy,J._crypto_secretstream_xchacha20poly1305_abytes=xA._crypto_secretstream_xchacha20poly1305_abytes,J._crypto_secretstream_xchacha20poly1305_headerbytes=xA._crypto_secretstream_xchacha20poly1305_headerbytes,J._crypto_secretstream_xchacha20poly1305_init_pull=xA._crypto_secretstream_xchacha20poly1305_init_pull,J._crypto_secretstream_xchacha20poly1305_init_push=xA._crypto_secretstream_xchacha20poly1305_init_push,J._crypto_secretstream_xchacha20poly1305_keybytes=xA._crypto_secretstream_xchacha20poly1305_keybytes,J._crypto_secretstream_xchacha20poly1305_keygen=xA._crypto_secretstream_xchacha20poly1305_keygen,J._crypto_secretstream_xchacha20poly1305_messagebytes_max=xA._crypto_secretstream_xchacha20poly1305_messagebytes_max,J._crypto_secretstream_xchacha20poly1305_pull=xA._crypto_secretstream_xchacha20poly1305_pull,J._crypto_secretstream_xchacha20poly1305_push=xA._crypto_secretstream_xchacha20poly1305_push,J._crypto_secretstream_xchacha20poly1305_rekey=xA._crypto_secretstream_xchacha20poly1305_rekey,J._crypto_secretstream_xchacha20poly1305_statebytes=xA._crypto_secretstream_xchacha20poly1305_statebytes,J._crypto_secretstream_xchacha20poly1305_tag_final=xA._crypto_secretstream_xchacha20poly1305_tag_final,J._crypto_secretstream_xchacha20poly1305_tag_message=xA._crypto_secretstream_xchacha20poly1305_tag_message,J._crypto_secretstream_xchacha20poly1305_tag_push=xA._crypto_secretstream_xchacha20poly1305_tag_push,J._crypto_secretstream_xchacha20poly1305_tag_rekey=xA._crypto_secretstream_xchacha20poly1305_tag_rekey,J._crypto_shorthash=xA._crypto_shorthash,J._crypto_shorthash_bytes=xA._crypto_shorthash_bytes,J._crypto_shorthash_keybytes=xA._crypto_shorthash_keybytes,J._crypto_shorthash_keygen=xA._crypto_shorthash_keygen,J._crypto_sign=xA._crypto_sign,J._crypto_sign_bytes=xA._crypto_sign_bytes,J._crypto_sign_detached=xA._crypto_sign_detached,J._crypto_sign_ed25519_pk_to_curve25519=xA._crypto_sign_ed25519_pk_to_curve25519,J._crypto_sign_ed25519_sk_to_curve25519=xA._crypto_sign_ed25519_sk_to_curve25519,J._crypto_sign_final_create=xA._crypto_sign_final_create,J._crypto_sign_final_verify=xA._crypto_sign_final_verify,J._crypto_sign_init=xA._crypto_sign_init,J._crypto_sign_keypair=xA._crypto_sign_keypair,J._crypto_sign_open=xA._crypto_sign_open,J._crypto_sign_publickeybytes=xA._crypto_sign_publickeybytes,J._crypto_sign_secretkeybytes=xA._crypto_sign_secretkeybytes,J._crypto_sign_seed_keypair=xA._crypto_sign_seed_keypair,J._crypto_sign_seedbytes=xA._crypto_sign_seedbytes,J._crypto_sign_statebytes=xA._crypto_sign_statebytes,J._crypto_sign_update=xA._crypto_sign_update,J._crypto_sign_verify_detached=xA._crypto_sign_verify_detached,J._crypto_stream_keygen=xA._crypto_stream_keygen,J._emscripten_get_global_libc=xA._emscripten_get_global_libc,J._free=xA._free),KA=(J._i64Add=xA._i64Add,J._i64Subtract=xA._i64Subtract,J._malloc=xA._malloc);if(J._memcpy=xA._memcpy,J._memmove=xA._memmove,J._memset=xA._memset,J._randombytes=xA._randombytes,J._randombytes_buf=xA._randombytes_buf,J._randombytes_buf_deterministic=xA._randombytes_buf_deterministic,J._randombytes_close=xA._randombytes_close,J._randombytes_random=xA._randombytes_random,J._randombytes_seedbytes=xA._randombytes_seedbytes,J._randombytes_stir=xA._randombytes_stir,J._randombytes_uniform=xA._randombytes_uniform,J._sbrk=xA._sbrk,J._sodium_base642bin=xA._sodium_base642bin,J._sodium_base64_encoded_len=xA._sodium_base64_encoded_len,J._sodium_bin2base64=xA._sodium_bin2base64,J._sodium_bin2hex=xA._sodium_bin2hex,J._sodium_hex2bin=xA._sodium_hex2bin,J._sodium_init=xA._sodium_init,J._sodium_library_minimal=xA._sodium_library_minimal,J._sodium_library_version_major=xA._sodium_library_version_major,J._sodium_library_version_minor=xA._sodium_library_version_minor,J._sodium_pad=xA._sodium_pad,J._sodium_unpad=xA._sodium_unpad,J._sodium_version_string=xA._sodium_version_string,J.establishStackSpace=xA.establishStackSpace,J.getTempRet0=xA.getTempRet0,J.runPostSets=xA.runPostSets,J.setTempRet0=xA.setTempRet0,J.setThrew=xA.setThrew,J.stackAlloc=xA.stackAlloc,J.stackRestore=xA.stackRestore,J.stackSave=xA.stackSave,j.stackAlloc=J.stackAlloc,j.stackSave=J.stackSave,j.stackRestore=J.stackRestore,j.establishStackSpace=J.establishStackSpace,j.setTempRet0=J.setTempRet0,j.getTempRet0=J.getTempRet0,J.asm=xA,YA)if("function"==typeof J.locateFile?YA=J.locateFile(YA):J.memoryInitializerPrefixURL&&(YA=J.memoryInitializerPrefixURL+YA),K||T){var TA=J.readBinary(YA);iA.set(TA,j.GLOBAL_BASE)}else{k();var VA=function(A){A.byteLength&&(A=new Uint8Array(A)),iA.set(A,j.GLOBAL_BASE),J.memoryInitializerRequest&&delete J.memoryInitializerRequest.response,G()};function qA(){J.readAsync(YA,VA,function(){throw"could not load memory initializer "+YA})}var jA=Y(YA);if(jA)VA(jA.buffer);else if(J.memoryInitializerRequest){function ZA(){var A=J.memoryInitializerRequest,I=A.response;if(200!==A.status&&0!==A.status){var e=Y(J.memoryInitializerRequestURL);if(!e)return void qA();I=e.buffer}VA(I)}J.memoryInitializerRequest.response?setTimeout(ZA,0):J.memoryInitializerRequest.addEventListener("load",ZA)}else qA()}S.prototype=new Error,S.prototype.constructor=S;var WA,zA=null,OA=!1;HA=function A(){J.calledRun||R(),J.calledRun||(HA=A)},J.callMain=J.callMain=function(A){function I(){for(var A=0;A<3;A++)g.push(0)}A=A||[],p();var e=A.length+1,g=[t(m(J.thisProgram),"i8",0)];I();for(var i=0;i<e-1;i+=1)g.push(t(m(A[i]),"i8",0)),I();g.push(0),g=t(g,"i32",0);try{N(J._main(e,g,0),!0)}catch(A){if(A instanceof S)return;if("SimulateInfiniteLoop"==A)return void(J.noExitRuntime=!0);var B=A;A&&"object"==typeof A&&A.stack&&(B=[A,A.stack]),J.printErr("exception thrown: "+B),J.quit(1,A)}finally{OA=!0}},J.run=J.run=R,J.exit=J.exit=N;var $A=[];if(J.abort=J.abort=U,J.preInit)for("function"==typeof J.preInit&&(J.preInit=[J.preInit]);J.preInit.length>0;)J.preInit.pop()();var AI=!0;J.noInitialRun&&(AI=!1),J.noExitRuntime=!0,R()}),"object"==typeof process&&process.removeAllListeners("uncaughtException"),I}"function"==typeof define&&define.amd?define(["exports"],I):"object"==typeof exports&&"string"!=typeof exports.nodeName?I(exports):A.libsodium=I(A.libsodium_mod||(A.commonJsStrict={}))}(this),function(A){function I(A,I){"use strict";function e(A){if("function"==typeof TextEncoder)return new TextEncoder("utf-8").encode(A);A=unescape(encodeURIComponent(A));for(var I=new Uint8Array(A.length),e=0;e<A.length;e++)I[e]=A.charCodeAt(e);return I}function g(A){if("function"==typeof TextDecoder)return new TextDecoder("utf-8",{fatal:!0}).decode(A);var I=Math.ceil(A.length/8192);if(I<=1)try{return decodeURIComponent(escape(String.fromCharCode.apply(null,A)))}catch(A){throw new TypeError("The encoded data was not valid.")}for(var e="",i=0,B=0;B<I;B++){var t=Array.prototype.slice.call(A,8192*B+i,8192*(B+1)+i);if(0!=t.length){var r,a=t.length,n=0;do{var C=t[--a];C>=240?(n=4,r=!0):C>=224?(n=3,r=!0):C>=192?(n=2,r=!0):C<128&&(n=1,r=!0)}while(!r);for(var o=n-(t.length-a),c=0;c<o;c++)i--,t.pop();e+=g(t)}}return e}function i(A){A=_(null,A,"input");for(var I,e,g,i="",B=0;B<A.length;B++)g=87+(e=15&A[B])+(e-10>>8&-39)<<8|87+(I=A[B]>>>4)+(I-10>>8&-39),i+=String.fromCharCode(255&g)+String.fromCharCode(g>>>8);return i}function B(A){if(void 0==A)return dI.URLSAFE_NO_PADDING;if(A!==dI.ORIGINAL&&A!==dI.ORIGINAL_NO_PADDING&&A!==dI.URLSAFE&&A!=dI.URLSAFE_NO_PADDING)throw new Error("unsupported base64 variant");return A}function t(A,I){I=B(I),A=_(i,A,"input");var e,i=[],t=0|Math.floor(A.length/3),r=A.length-3*t,a=4*t+(0!==r?0==(2&I)?4:2+(r>>>1):0),n=new o(a+1),C=c(A);return i.push(C),i.push(n.address),0===wI._sodium_bin2base64(n.address,n.length,C,A.length,I)&&h(i,"conversion failed"),n.length=a,e=g(n.to_Uint8Array()),s(i),e}function r(){return["uint8array","text","hex","base64"]}function a(A,I){var e=I||lI;if(!n(e))throw new Error(e+" output format is not available");if(A instanceof o){if("uint8array"===e)return A.to_Uint8Array();if("text"===e)return g(A.to_Uint8Array());if("hex"===e)return i(A.to_Uint8Array());if("base64"===e)return t(A.to_Uint8Array(),dI.URLSAFE_NO_PADDING);throw new Error('What is output format "'+e+'"?')}if("object"==typeof A){for(var B=Object.keys(A),r={},C=0;C<B.length;C++)r[B[C]]=a(A[B[C]],e);return r}if("string"==typeof A)return A;throw new TypeError("Cannot format output")}function n(A){for(var I=r(),e=0;e<I.length;e++)if(I[e]===A)return!0;return!1}function C(A){if(A){if("string"!=typeof A)throw new TypeError("When defined, the output format must be a string");if(!n(A))throw new Error(A+" is not a supported output format")}}function o(A){this.length=A,this.address=Q(A)}function c(A){var I=Q(A.length);return wI.HEAPU8.set(A,I),I}function Q(A){var I=wI._malloc(A);if(0===I)throw{message:"_malloc() failed",length:A};return I}function E(A){wI._free(A)}function s(A){if(A)for(var I=0;I<A.length;I++)E(A[I])}function h(A,I){throw s(A),new Error(I)}function y(A,I){throw s(A),new TypeError(I)}function f(A,I,e){void 0==I&&y(A,e+" cannot be null or undefined")}function _(A,I,g){return f(A,I,g),I instanceof Uint8Array?I:"string"==typeof I?e(I):void y(A,"unsupported input type for "+g)}function p(A,I,e,g,i,B){var t=[];C(B);var r=null;void 0!=A&&(r=c(A=_(t,A,"secret_nonce")),A.length,t.push(r));var n=c(I=_(t,I,"ciphertext")),Q=I.length;t.push(n);var E=null,f=0;void 0!=e&&(E=c(e=_(t,e,"additional_data")),f=e.length,t.push(E)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_chacha20poly1305_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_chacha20poly1305_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(Q-wI._crypto_aead_chacha20poly1305_abytes()|0),D=d.address;if(t.push(D),0===wI._crypto_aead_chacha20poly1305_decrypt(D,null,r,n,Q,0,E,f,0,p,l)){var v=a(d,B);return s(t),v}h(t,"invalid usage")}function w(A,I,e,g,i,B,t){var r=[];C(t);var n=null;void 0!=A&&(n=c(A=_(r,A,"secret_nonce")),A.length,r.push(n));var Q=c(I=_(r,I,"ciphertext")),E=I.length;r.push(Q),e=_(r,e,"mac");var f,p=0|wI._crypto_box_macbytes();e.length!==p&&y(r,"invalid mac length"),f=c(e),r.push(f);var w=null,l=0;void 0!=g&&(w=c(g=_(r,g,"additional_data")),l=g.length,r.push(w)),i=_(r,i,"public_nonce");var u,d=0|wI._crypto_aead_chacha20poly1305_npubbytes();i.length!==d&&y(r,"invalid public_nonce length"),u=c(i),r.push(u),B=_(r,B,"key");var D,v=0|wI._crypto_aead_chacha20poly1305_keybytes();B.length!==v&&y(r,"invalid key length"),D=c(B),r.push(D);var b=new o(0|E),k=b.address;if(r.push(k),0===wI._crypto_aead_chacha20poly1305_decrypt_detached(k,n,Q,E,0,f,w,l,0,u,D)){var G=a(b,t);return s(r),G}h(r,"invalid usage")}function l(A,I,e,g,i,B){var t=[];C(B);var r=c(A=_(t,A,"message")),n=A.length;t.push(r);var Q=null,E=0;void 0!=I&&(Q=c(I=_(t,I,"additional_data")),E=I.length,t.push(Q));var f=null;void 0!=e&&(f=c(e=_(t,e,"secret_nonce")),e.length,t.push(f)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_chacha20poly1305_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_chacha20poly1305_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(n+wI._crypto_aead_chacha20poly1305_abytes()|0),D=d.address;if(t.push(D),0===wI._crypto_aead_chacha20poly1305_encrypt(D,null,r,n,0,Q,E,0,f,p,l)){var v=a(d,B);return s(t),v}h(t,"invalid usage")}function u(A,I,e,g,i,B){var t=[];C(B);var r=c(A=_(t,A,"message")),n=A.length;t.push(r);var Q=null,E=0;void 0!=I&&(Q=c(I=_(t,I,"additional_data")),E=I.length,t.push(Q));var f=null;void 0!=e&&(f=c(e=_(t,e,"secret_nonce")),e.length,t.push(f)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_chacha20poly1305_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_chacha20poly1305_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(0|n),D=d.address;t.push(D);var v=new o(0|wI._crypto_aead_chacha20poly1305_abytes()),b=v.address;if(t.push(b),0===wI._crypto_aead_chacha20poly1305_encrypt_detached(D,b,null,r,n,0,Q,E,0,f,p,l)){var k=a({ciphertext:d,mac:v},B);return s(t),k}h(t,"invalid usage")}function d(A,I,e,g,i,B){var t=[];C(B);var r=null;void 0!=A&&(r=c(A=_(t,A,"secret_nonce")),A.length,t.push(r));var n=c(I=_(t,I,"ciphertext")),Q=I.length;t.push(n);var E=null,f=0;void 0!=e&&(E=c(e=_(t,e,"additional_data")),f=e.length,t.push(E)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_chacha20poly1305_ietf_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_chacha20poly1305_ietf_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(Q-wI._crypto_aead_chacha20poly1305_ietf_abytes()|0),D=d.address;if(t.push(D),0===wI._crypto_aead_chacha20poly1305_ietf_decrypt(D,null,r,n,Q,0,E,f,0,p,l)){var v=a(d,B);return s(t),v}h(t,"invalid usage")}function D(A,I,e,g,i,B,t){var r=[];C(t);var n=null;void 0!=A&&(n=c(A=_(r,A,"secret_nonce")),A.length,r.push(n));var Q=c(I=_(r,I,"ciphertext")),E=I.length;r.push(Q),e=_(r,e,"mac");var f,p=0|wI._crypto_box_macbytes();e.length!==p&&y(r,"invalid mac length"),f=c(e),r.push(f);var w=null,l=0;void 0!=g&&(w=c(g=_(r,g,"additional_data")),l=g.length,r.push(w)),i=_(r,i,"public_nonce");var u,d=0|wI._crypto_aead_chacha20poly1305_ietf_npubbytes();i.length!==d&&y(r,"invalid public_nonce length"),u=c(i),r.push(u),B=_(r,B,"key");var D,v=0|wI._crypto_aead_chacha20poly1305_ietf_keybytes();B.length!==v&&y(r,"invalid key length"),D=c(B),r.push(D);var b=new o(0|E),k=b.address;if(r.push(k),0===wI._crypto_aead_chacha20poly1305_ietf_decrypt_detached(k,n,Q,E,0,f,w,l,0,u,D)){var G=a(b,t);return s(r),G}h(r,"invalid usage")}function v(A,I,e,g,i,B){var t=[];C(B);var r=c(A=_(t,A,"message")),n=A.length;t.push(r);var Q=null,E=0;void 0!=I&&(Q=c(I=_(t,I,"additional_data")),E=I.length,t.push(Q));var f=null;void 0!=e&&(f=c(e=_(t,e,"secret_nonce")),e.length,t.push(f)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_chacha20poly1305_ietf_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_chacha20poly1305_ietf_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(n+wI._crypto_aead_chacha20poly1305_ietf_abytes()|0),D=d.address;if(t.push(D),0===wI._crypto_aead_chacha20poly1305_ietf_encrypt(D,null,r,n,0,Q,E,0,f,p,l)){var v=a(d,B);return s(t),v}h(t,"invalid usage")}function b(A,I,e,g,i,B){var t=[];C(B);var r=c(A=_(t,A,"message")),n=A.length;t.push(r);var Q=null,E=0;void 0!=I&&(Q=c(I=_(t,I,"additional_data")),E=I.length,t.push(Q));var f=null;void 0!=e&&(f=c(e=_(t,e,"secret_nonce")),e.length,t.push(f)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_chacha20poly1305_ietf_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_chacha20poly1305_ietf_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(0|n),D=d.address;t.push(D);var v=new o(0|wI._crypto_aead_chacha20poly1305_ietf_abytes()),b=v.address;if(t.push(b),0===wI._crypto_aead_chacha20poly1305_ietf_encrypt_detached(D,b,null,r,n,0,Q,E,0,f,p,l)){var k=a({ciphertext:d,mac:v},B);return s(t),k}h(t,"invalid usage")}function k(A){var I=[];C(A);var e=new o(0|wI._crypto_aead_chacha20poly1305_ietf_keybytes()),g=e.address;I.push(g),wI._crypto_aead_chacha20poly1305_ietf_keygen(g);var i=a(e,A);return s(I),i}function G(A){var I=[];C(A);var e=new o(0|wI._crypto_aead_chacha20poly1305_keybytes()),g=e.address;I.push(g),wI._crypto_aead_chacha20poly1305_keygen(g);var i=a(e,A);return s(I),i}function F(A,I,e,g,i,B){var t=[];C(B);var r=null;void 0!=A&&(r=c(A=_(t,A,"secret_nonce")),A.length,t.push(r));var n=c(I=_(t,I,"ciphertext")),Q=I.length;t.push(n);var E=null,f=0;void 0!=e&&(E=c(e=_(t,e,"additional_data")),f=e.length,t.push(E)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_xchacha20poly1305_ietf_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_xchacha20poly1305_ietf_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(Q-wI._crypto_aead_xchacha20poly1305_ietf_abytes()|0),D=d.address;if(t.push(D),0===wI._crypto_aead_xchacha20poly1305_ietf_decrypt(D,null,r,n,Q,0,E,f,0,p,l)){var v=a(d,B);return s(t),v}h(t,"invalid usage")}function m(A,I,e,g,i,B,t){var r=[];C(t);var n=null;void 0!=A&&(n=c(A=_(r,A,"secret_nonce")),A.length,r.push(n));var Q=c(I=_(r,I,"ciphertext")),E=I.length;r.push(Q),e=_(r,e,"mac");var f,p=0|wI._crypto_box_macbytes();e.length!==p&&y(r,"invalid mac length"),f=c(e),r.push(f);var w=null,l=0;void 0!=g&&(w=c(g=_(r,g,"additional_data")),l=g.length,r.push(w)),i=_(r,i,"public_nonce");var u,d=0|wI._crypto_aead_xchacha20poly1305_ietf_npubbytes();i.length!==d&&y(r,"invalid public_nonce length"),u=c(i),r.push(u),B=_(r,B,"key");var D,v=0|wI._crypto_aead_xchacha20poly1305_ietf_keybytes();B.length!==v&&y(r,"invalid key length"),D=c(B),r.push(D);var b=new o(0|E),k=b.address;if(r.push(k),0===wI._crypto_aead_xchacha20poly1305_ietf_decrypt_detached(k,n,Q,E,0,f,w,l,0,u,D)){var G=a(b,t);return s(r),G}h(r,"invalid usage")}function M(A,I,e,g,i,B){var t=[];C(B);var r=c(A=_(t,A,"message")),n=A.length;t.push(r);var Q=null,E=0;void 0!=I&&(Q=c(I=_(t,I,"additional_data")),E=I.length,t.push(Q));var f=null;void 0!=e&&(f=c(e=_(t,e,"secret_nonce")),e.length,t.push(f)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_xchacha20poly1305_ietf_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_xchacha20poly1305_ietf_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(n+wI._crypto_aead_xchacha20poly1305_ietf_abytes()|0),D=d.address;if(t.push(D),0===wI._crypto_aead_xchacha20poly1305_ietf_encrypt(D,null,r,n,0,Q,E,0,f,p,l)){var v=a(d,B);return s(t),v}h(t,"invalid usage")}function H(A,I,e,g,i,B){var t=[];C(B);var r=c(A=_(t,A,"message")),n=A.length;t.push(r);var Q=null,E=0;void 0!=I&&(Q=c(I=_(t,I,"additional_data")),E=I.length,t.push(Q));var f=null;void 0!=e&&(f=c(e=_(t,e,"secret_nonce")),e.length,t.push(f)),g=_(t,g,"public_nonce");var p,w=0|wI._crypto_aead_xchacha20poly1305_ietf_npubbytes();g.length!==w&&y(t,"invalid public_nonce length"),p=c(g),t.push(p),i=_(t,i,"key");var l,u=0|wI._crypto_aead_xchacha20poly1305_ietf_keybytes();i.length!==u&&y(t,"invalid key length"),l=c(i),t.push(l);var d=new o(0|n),D=d.address;t.push(D);var v=new o(0|wI._crypto_aead_xchacha20poly1305_ietf_abytes()),b=v.address;if(t.push(b),0===wI._crypto_aead_xchacha20poly1305_ietf_encrypt_detached(D,b,null,r,n,0,Q,E,0,f,p,l)){var k=a({ciphertext:d,mac:v},B);return s(t),k}h(t,"invalid usage")}function Y(A){var I=[];C(A);var e=new o(0|wI._crypto_aead_xchacha20poly1305_ietf_keybytes()),g=e.address;I.push(g),wI._crypto_aead_xchacha20poly1305_ietf_keygen(g);var i=a(e,A);return s(I),i}function S(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"key");var t,r=0|wI._crypto_auth_keybytes();I.length!==r&&y(g,"invalid key length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_auth_bytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_auth(Q,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function R(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"key");var t,r=0|wI._crypto_auth_hmacsha256_keybytes();I.length!==r&&y(g,"invalid key length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_auth_hmacsha256_bytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_auth_hmacsha256(Q,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function N(A){var I=[];C(A);var e=new o(0|wI._crypto_auth_hmacsha256_keybytes()),g=e.address;I.push(g),wI._crypto_auth_hmacsha256_keygen(g);var i=a(e,A);return s(I),i}function U(A,I,e){var g=[];A=_(g,A,"tag");var i,B=0|wI._crypto_auth_hmacsha256_bytes();A.length!==B&&y(g,"invalid tag length"),i=c(A),g.push(i);var t=c(I=_(g,I,"message")),r=I.length;g.push(t),e=_(g,e,"key");var a,n=0|wI._crypto_auth_hmacsha256_keybytes();e.length!==n&&y(g,"invalid key length"),a=c(e),g.push(a);var C=0==(0|wI._crypto_auth_hmacsha256_verify(i,t,r,0,a));return s(g),C}function J(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"key");var t,r=0|wI._crypto_auth_hmacsha512_keybytes();I.length!==r&&y(g,"invalid key length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_auth_hmacsha512_bytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_auth_hmacsha512(Q,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function P(A){var I=[];C(A);var e=new o(0|wI._crypto_auth_hmacsha512_keybytes()),g=e.address;I.push(g),wI._crypto_auth_hmacsha512_keygen(g);var i=a(e,A);return s(I),i}function L(A,I,e){var g=[];A=_(g,A,"tag");var i,B=0|wI._crypto_auth_hmacsha512_bytes();A.length!==B&&y(g,"invalid tag length"),i=c(A),g.push(i);var t=c(I=_(g,I,"message")),r=I.length;g.push(t),e=_(g,e,"key");var a,n=0|wI._crypto_auth_hmacsha512_keybytes();e.length!==n&&y(g,"invalid key length"),a=c(e),g.push(a);var C=0==(0|wI._crypto_auth_hmacsha512_verify(i,t,r,0,a));return s(g),C}function x(A){var I=[];C(A);var e=new o(0|wI._crypto_auth_keybytes()),g=e.address;I.push(g),wI._crypto_auth_keygen(g);var i=a(e,A);return s(I),i}function X(A,I,e){var g=[];A=_(g,A,"tag");var i,B=0|wI._crypto_auth_bytes();A.length!==B&&y(g,"invalid tag length"),i=c(A),g.push(i);var t=c(I=_(g,I,"message")),r=I.length;g.push(t),e=_(g,e,"key");var a,n=0|wI._crypto_auth_keybytes();e.length!==n&&y(g,"invalid key length"),a=c(e),g.push(a);var C=0==(0|wI._crypto_auth_verify(i,t,r,0,a));return s(g),C}function K(A,I,e){var g=[];C(e),A=_(g,A,"publicKey");var i,B=0|wI._crypto_box_publickeybytes();A.length!==B&&y(g,"invalid publicKey length"),i=c(A),g.push(i),I=_(g,I,"privateKey");var t,r=0|wI._crypto_box_secretkeybytes();I.length!==r&&y(g,"invalid privateKey length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_box_beforenmbytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_box_beforenm(Q,i,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function T(A,I,e,g,i){var B=[];C(i);var t=c(A=_(B,A,"message")),r=A.length;B.push(t),I=_(B,I,"nonce");var n,Q=0|wI._crypto_box_noncebytes();I.length!==Q&&y(B,"invalid nonce length"),n=c(I),B.push(n),e=_(B,e,"publicKey");var E,f=0|wI._crypto_box_publickeybytes();e.length!==f&&y(B,"invalid publicKey length"),E=c(e),B.push(E),g=_(B,g,"privateKey");var p,w=0|wI._crypto_box_secretkeybytes();g.length!==w&&y(B,"invalid privateKey length"),p=c(g),B.push(p);var l=new o(0|r),u=l.address;B.push(u);var d=new o(0|wI._crypto_box_macbytes()),D=d.address;if(B.push(D),0==(0|wI._crypto_box_detached(u,D,t,r,0,n,E,p))){var v=a({ciphertext:l,mac:d},i);return s(B),v}h(B,"invalid usage")}function V(A,I,e,g,i){var B=[];C(i);var t=c(A=_(B,A,"message")),r=A.length;B.push(t),I=_(B,I,"nonce");var n,Q=0|wI._crypto_box_noncebytes();I.length!==Q&&y(B,"invalid nonce length"),n=c(I),B.push(n),e=_(B,e,"publicKey");var E,f=0|wI._crypto_box_publickeybytes();e.length!==f&&y(B,"invalid publicKey length"),E=c(e),B.push(E),g=_(B,g,"privateKey");var p,w=0|wI._crypto_box_secretkeybytes();g.length!==w&&y(B,"invalid privateKey length"),p=c(g),B.push(p);var l=new o(r+wI._crypto_box_macbytes()|0),u=l.address;if(B.push(u),0==(0|wI._crypto_box_easy(u,t,r,0,n,E,p))){var d=a(l,i);return s(B),d}h(B,"invalid usage")}function q(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"message")),t=A.length;i.push(B),I=_(i,I,"nonce");var r,n=0|wI._crypto_box_noncebytes();I.length!==n&&y(i,"invalid nonce length"),r=c(I),i.push(r),e=_(i,e,"sharedKey");var Q,E=0|wI._crypto_box_beforenmbytes();e.length!==E&&y(i,"invalid sharedKey length"),Q=c(e),i.push(Q);var f=new o(t+wI._crypto_box_macbytes()|0),p=f.address;if(i.push(p),0==(0|wI._crypto_box_easy_afternm(p,B,t,0,r,Q))){var w=a(f,g);return s(i),w}h(i,"invalid usage")}function j(A){var I=[];C(A);var e=new o(0|wI._crypto_box_publickeybytes()),g=e.address;I.push(g);var i=new o(0|wI._crypto_box_secretkeybytes()),B=i.address;if(I.push(B),0==(0|wI._crypto_box_keypair(g,B))){var t={publicKey:a(e,A),privateKey:a(i,A),keyType:"x25519"};return s(I),t}h(I,"internal error")}function Z(A,I,e,g,i,B){var t=[];C(B);var r=c(A=_(t,A,"ciphertext")),n=A.length;t.push(r),I=_(t,I,"mac");var Q,E=0|wI._crypto_box_macbytes();I.length!==E&&y(t,"invalid mac length"),Q=c(I),t.push(Q),e=_(t,e,"nonce");var f,p=0|wI._crypto_box_noncebytes();e.length!==p&&y(t,"invalid nonce length"),f=c(e),t.push(f),g=_(t,g,"publicKey");var w,l=0|wI._crypto_box_publickeybytes();g.length!==l&&y(t,"invalid publicKey length"),w=c(g),t.push(w),i=_(t,i,"privateKey");var u,d=0|wI._crypto_box_secretkeybytes();i.length!==d&&y(t,"invalid privateKey length"),u=c(i),t.push(u);var D=new o(0|n),v=D.address;if(t.push(v),0==(0|wI._crypto_box_open_detached(v,r,Q,n,0,f,w,u))){var b=a(D,B);return s(t),b}h(t,"incorrect key pair for the given ciphertext")}function W(A,I,e,g,i){var B=[];C(i);var t=c(A=_(B,A,"ciphertext")),r=A.length;B.push(t),I=_(B,I,"nonce");var n,Q=0|wI._crypto_box_noncebytes();I.length!==Q&&y(B,"invalid nonce length"),n=c(I),B.push(n),e=_(B,e,"publicKey");var E,f=0|wI._crypto_box_publickeybytes();e.length!==f&&y(B,"invalid publicKey length"),E=c(e),B.push(E),g=_(B,g,"privateKey");var p,w=0|wI._crypto_box_secretkeybytes();g.length!==w&&y(B,"invalid privateKey length"),p=c(g),B.push(p);var l=new o(r-wI._crypto_box_macbytes()|0),u=l.address;if(B.push(u),0==(0|wI._crypto_box_open_easy(u,t,r,0,n,E,p))){var d=a(l,i);return s(B),d}h(B,"incorrect key pair for the given ciphertext")}function z(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"ciphertext")),t=A.length;i.push(B),I=_(i,I,"nonce");var r,n=0|wI._crypto_box_noncebytes();I.length!==n&&y(i,"invalid nonce length"),r=c(I),i.push(r),e=_(i,e,"sharedKey");var Q,E=0|wI._crypto_box_beforenmbytes();e.length!==E&&y(i,"invalid sharedKey length"),Q=c(e),i.push(Q);var f=new o(t-wI._crypto_box_macbytes()|0),p=f.address;if(i.push(p),0==(0|wI._crypto_box_open_easy_afternm(p,B,t,0,r,Q))){var w=a(f,g);return s(i),w}h(i,"incorrect secret key for the given ciphertext")}function O(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"publicKey");var t,r=0|wI._crypto_box_publickeybytes();I.length!==r&&y(g,"invalid publicKey length"),t=c(I),g.push(t);var n=new o(B+wI._crypto_box_sealbytes()|0),Q=n.address;if(g.push(Q),0==(0|wI._crypto_box_seal(Q,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function $(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"ciphertext")),t=A.length;i.push(B),I=_(i,I,"publicKey");var r,n=0|wI._crypto_box_publickeybytes();I.length!==n&&y(i,"invalid publicKey length"),r=c(I),i.push(r),e=_(i,e,"privateKey");var Q,E=0|wI._crypto_box_secretkeybytes();e.length!==E&&y(i,"invalid privateKey length"),Q=c(e),i.push(Q);var f=new o(t-wI._crypto_box_sealbytes()|0),p=f.address;if(i.push(p),0==(0|wI._crypto_box_seal_open(p,B,t,0,r,Q))){var w=a(f,g);return s(i),w}h(i,"incorrect key pair for the given ciphertext")}function AA(A,I){var e=[];C(I),A=_(e,A,"seed");var g,i=0|wI._crypto_box_seedbytes();A.length!==i&&y(e,"invalid seed length"),g=c(A),e.push(g);var B=new o(0|wI._crypto_box_publickeybytes()),t=B.address;e.push(t);var r=new o(0|wI._crypto_box_secretkeybytes()),n=r.address;if(e.push(n),0==(0|wI._crypto_box_seed_keypair(t,n,g))){var Q={publicKey:a(B,I),privateKey:a(r,I),keyType:"x25519"};return s(e),Q}h(e,"invalid usage")}function IA(A,I,e,g){var i=[];C(g),f(i,A,"hash_length"),("number"!=typeof A||(0|A)!==A||A<0)&&y(i,"hash_length must be an unsigned integer");var B=c(I=_(i,I,"message")),t=I.length;i.push(B);var r=null,n=0;void 0!=e&&(r=c(e=_(i,e,"key")),n=e.length,i.push(r));var Q=new o(A|=0),E=Q.address;if(i.push(E),0==(0|wI._crypto_generichash(E,A,B,t,0,r,n))){var p=a(Q,g);return s(i),p}h(i,"invalid usage")}function eA(A,I,e){var g=[];C(e),f(g,A,"state_address"),f(g,I,"hash_length"),("number"!=typeof I||(0|I)!==I||I<0)&&y(g,"hash_length must be an unsigned integer");var i=new o(I|=0),B=i.address;if(g.push(B),0==(0|wI._crypto_generichash_final(A,B,I))){var t=(wI._free(A),a(i,e));return s(g),t}h(g,"invalid usage")}function gA(A,I,e){var g=[];C(e);var i=null,B=0;void 0!=A&&(i=c(A=_(g,A,"key")),B=A.length,g.push(i)),f(g,I,"hash_length"),("number"!=typeof I||(0|I)!==I||I<0)&&y(g,"hash_length must be an unsigned integer");var t=new o(357).address;if(0==(0|wI._crypto_generichash_init(t,i,B,I))){var r=t;return s(g),r}h(g,"invalid usage")}function iA(A){var I=[];C(A);var e=new o(0|wI._crypto_generichash_keybytes()),g=e.address;I.push(g),wI._crypto_generichash_keygen(g);var i=a(e,A);return s(I),i}function BA(A,I,e){var g=[];C(e),f(g,A,"state_address");var i=c(I=_(g,I,"message_chunk")),B=I.length;g.push(i),0!=(0|wI._crypto_generichash_update(A,i,B))&&h(g,"invalid usage"),s(g)}function tA(A,I){var e=[];C(I);var g=c(A=_(e,A,"message")),i=A.length;e.push(g);var B=new o(0|wI._crypto_hash_bytes()),t=B.address;if(e.push(t),0==(0|wI._crypto_hash(t,g,i,0))){var r=a(B,I);return s(e),r}h(e,"invalid usage")}function rA(A,I){var e=[];C(I);var g=c(A=_(e,A,"message")),i=A.length;e.push(g);var B=new o(0|wI._crypto_hash_sha256_bytes()),t=B.address;if(e.push(t),0==(0|wI._crypto_hash_sha256(t,g,i,0))){var r=a(B,I);return s(e),r}h(e,"invalid usage")}function aA(A,I){var e=[];C(I);var g=c(A=_(e,A,"message")),i=A.length;e.push(g);var B=new o(0|wI._crypto_hash_sha512_bytes()),t=B.address;if(e.push(t),0==(0|wI._crypto_hash_sha512(t,g,i,0))){var r=a(B,I);return s(e),r}h(e,"invalid usage")}function nA(A,I,g,i,B){var t=[];C(B),f(t,A,"subkey_len"),("number"!=typeof A||(0|A)!==A||A<0)&&y(t,"subkey_len must be an unsigned integer"),f(t,I,"subkey_id"),("number"!=typeof I||(0|I)!==I||I<0)&&y(t,"subkey_id must be an unsigned integer");var r=c(g=e(g+"\0"));g.length,t.push(r),i=_(t,i,"key");var n,Q=0|wI._crypto_kdf_keybytes();i.length!==Q&&y(t,"invalid key length"),n=c(i),t.push(n);var E=new o(0|A),h=E.address;t.push(h),wI._crypto_kdf_derive_from_key(h,A,I,0,r,n);var p=a(E,B);return s(t),p}function CA(A){var I=[];C(A);var e=new o(0|wI._crypto_kdf_keybytes()),g=e.address;I.push(g),wI._crypto_kdf_keygen(g);var i=a(e,A);return s(I),i}function oA(A,I,e,g){var i=[];C(g),A=_(i,A,"clientPublicKey");var B,t=0|wI._crypto_kx_publickeybytes();A.length!==t&&y(i,"invalid clientPublicKey length"),B=c(A),i.push(B),I=_(i,I,"clientSecretKey");var r,n=0|wI._crypto_kx_secretkeybytes();I.length!==n&&y(i,"invalid clientSecretKey length"),r=c(I),i.push(r),e=_(i,e,"serverPublicKey");var Q,E=0|wI._crypto_kx_publickeybytes();e.length!==E&&y(i,"invalid serverPublicKey length"),Q=c(e),i.push(Q);var f=new o(0|wI._crypto_kx_sessionkeybytes()),p=f.address;i.push(p);var w=new o(0|wI._crypto_kx_sessionkeybytes()),l=w.address;if(i.push(l),0==(0|wI._crypto_kx_client_session_keys(p,l,B,r,Q))){var u=a({sharedRx:f,sharedTx:w},g);return s(i),u}h(i,"invalid usage")}function cA(A){var I=[];C(A);var e=new o(0|wI._crypto_kx_publickeybytes()),g=e.address;I.push(g);var i=new o(0|wI._crypto_kx_secretkeybytes()),B=i.address;if(I.push(B),0==(0|wI._crypto_kx_keypair(g,B))){var t={publicKey:a(e,A),privateKey:a(i,A),keyType:"x25519"};return s(I),t}h(I,"internal error")}function QA(A,I){var e=[];C(I),A=_(e,A,"seed");var g,i=0|wI._crypto_kx_seedbytes();A.length!==i&&y(e,"invalid seed length"),g=c(A),e.push(g);var B=new o(0|wI._crypto_kx_publickeybytes()),t=B.address;e.push(t);var r=new o(0|wI._crypto_kx_secretkeybytes()),n=r.address;if(e.push(n),0==(0|wI._crypto_kx_seed_keypair(t,n,g))){var Q={publicKey:a(B,I),privateKey:a(r,I),keyType:"x25519"};return s(e),Q}h(e,"internal error")}function EA(A,I,e,g){var i=[];C(g),A=_(i,A,"serverPublicKey");var B,t=0|wI._crypto_kx_publickeybytes();A.length!==t&&y(i,"invalid serverPublicKey length"),B=c(A),i.push(B),I=_(i,I,"serverSecretKey");var r,n=0|wI._crypto_kx_secretkeybytes();I.length!==n&&y(i,"invalid serverSecretKey length"),r=c(I),i.push(r),e=_(i,e,"clientPublicKey");var Q,E=0|wI._crypto_kx_publickeybytes();e.length!==E&&y(i,"invalid clientPublicKey length"),Q=c(e),i.push(Q);var f=new o(0|wI._crypto_kx_sessionkeybytes()),p=f.address;i.push(p);var w=new o(0|wI._crypto_kx_sessionkeybytes()),l=w.address;if(i.push(l),0==(0|wI._crypto_kx_server_session_keys(p,l,B,r,Q))){var u=a({sharedRx:f,sharedTx:w},g);return s(i),u}h(i,"invalid usage")}function sA(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"key");var t,r=0|wI._crypto_onetimeauth_keybytes();I.length!==r&&y(g,"invalid key length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_onetimeauth_bytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_onetimeauth(Q,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function hA(A,I){var e=[];C(I),f(e,A,"state_address");var g=new o(0|wI._crypto_onetimeauth_bytes()),i=g.address;if(e.push(i),0==(0|wI._crypto_onetimeauth_final(A,i))){var B=(wI._free(A),a(g,I));return s(e),B}h(e,"invalid usage")}function yA(A,I){var e=[];C(I);var g=null;void 0!=A&&(g=c(A=_(e,A,"key")),A.length,e.push(g));var i=new o(144).address;if(0==(0|wI._crypto_onetimeauth_init(i,g))){var B=i;return s(e),B}h(e,"invalid usage")}function fA(A){var I=[];C(A);var e=new o(0|wI._crypto_onetimeauth_keybytes()),g=e.address;I.push(g),wI._crypto_onetimeauth_keygen(g);var i=a(e,A);return s(I),i}function _A(A,I,e){var g=[];C(e),f(g,A,"state_address");var i=c(I=_(g,I,"message_chunk")),B=I.length;g.push(i),0!=(0|wI._crypto_onetimeauth_update(A,i,B))&&h(g,"invalid usage"),s(g)}function pA(A,I,e){var g=[];A=_(g,A,"hash");var i,B=0|wI._crypto_onetimeauth_bytes();A.length!==B&&y(g,"invalid hash length"),i=c(A),g.push(i);var t=c(I=_(g,I,"message")),r=I.length;g.push(t),e=_(g,e,"key");var a,n=0|wI._crypto_onetimeauth_keybytes();e.length!==n&&y(g,"invalid key length"),a=c(e),g.push(a);var C=0==(0|wI._crypto_onetimeauth_verify(i,t,r,0,a));return s(g),C}function wA(A,I,e,g,i,B,t){var r=[];C(t),f(r,A,"keyLength"),("number"!=typeof A||(0|A)!==A||A<0)&&y(r,"keyLength must be an unsigned integer");var n=c(I=_(r,I,"password")),Q=I.length;r.push(n),e=_(r,e,"salt");var E,p=0|wI._crypto_pwhash_saltbytes();e.length!==p&&y(r,"invalid salt length"),E=c(e),r.push(E),f(r,g,"opsLimit"),("number"!=typeof g||(0|g)!==g||g<0)&&y(r,"opsLimit must be an unsigned integer"),f(r,i,"memLimit"),("number"!=typeof i||(0|i)!==i||i<0)&&y(r,"memLimit must be an unsigned integer"),f(r,B,"algorithm"),("number"!=typeof B||(0|B)!==B||B<0)&&y(r,"algorithm must be an unsigned integer");var w=new o(0|A),l=w.address;if(r.push(l),0==(0|wI._crypto_pwhash(l,A,0,n,Q,0,E,g,0,i,B))){var u=a(w,t);return s(r),u}h(r,"invalid usage")}function lA(A,I,e,g,i,B){var t=[];C(B),f(t,A,"keyLength"),("number"!=typeof A||(0|A)!==A||A<0)&&y(t,"keyLength must be an unsigned integer");var r=c(I=_(t,I,"password")),n=I.length;t.push(r),e=_(t,e,"salt");var Q,E=0|wI._crypto_pwhash_scryptsalsa208sha256_saltbytes();e.length!==E&&y(t,"invalid salt length"),Q=c(e),t.push(Q),f(t,g,"opsLimit"),("number"!=typeof g||(0|g)!==g||g<0)&&y(t,"opsLimit must be an unsigned integer"),f(t,i,"memLimit"),("number"!=typeof i||(0|i)!==i||i<0)&&y(t,"memLimit must be an unsigned integer");var p=new o(0|A),w=p.address;if(t.push(w),0==(0|wI._crypto_pwhash_scryptsalsa208sha256(w,A,0,r,n,0,Q,g,0,i))){var l=a(p,B);return s(t),l}h(t,"invalid usage")}function uA(A,I,e,g,i,B,t){var r=[];C(t);var n=c(A=_(r,A,"password")),Q=A.length;r.push(n);var E=c(I=_(r,I,"salt")),p=I.length;r.push(E),f(r,e,"opsLimit"),("number"!=typeof e||(0|e)!==e||e<0)&&y(r,"opsLimit must be an unsigned integer"),f(r,g,"r"),("number"!=typeof g||(0|g)!==g||g<0)&&y(r,"r must be an unsigned integer"),f(r,i,"p"),("number"!=typeof i||(0|i)!==i||i<0)&&y(r,"p must be an unsigned integer"),f(r,B,"keyLength"),("number"!=typeof B||(0|B)!==B||B<0)&&y(r,"keyLength must be an unsigned integer");var w=new o(0|B),l=w.address;if(r.push(l),0==(0|wI._crypto_pwhash_scryptsalsa208sha256_ll(n,Q,E,p,e,0,g,i,l,B))){var u=a(w,t);return s(r),u}h(r,"invalid usage")}function dA(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"password")),t=A.length;i.push(B),f(i,I,"opsLimit"),("number"!=typeof I||(0|I)!==I||I<0)&&y(i,"opsLimit must be an unsigned integer"),f(i,e,"memLimit"),("number"!=typeof e||(0|e)!==e||e<0)&&y(i,"memLimit must be an unsigned integer");var r=new o(0|wI._crypto_pwhash_scryptsalsa208sha256_strbytes()).address;if(i.push(r),0==(0|wI._crypto_pwhash_scryptsalsa208sha256_str(r,B,t,0,I,0,e))){var a=wI.Pointer_stringify(r);return s(i),a}h(i,"invalid usage")}function DA(A,I,g){var i=[];C(g);var B=c(A=e(A+"\0"));A.length,i.push(B);var t=c(I=_(i,I,"password")),r=I.length;i.push(t);var a=0==(0|wI._crypto_pwhash_scryptsalsa208sha256_str_verify(B,t,r,0));return s(i),a}function vA(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"password")),t=A.length;i.push(B),f(i,I,"opsLimit"),("number"!=typeof I||(0|I)!==I||I<0)&&y(i,"opsLimit must be an unsigned integer"),f(i,e,"memLimit"),("number"!=typeof e||(0|e)!==e||e<0)&&y(i,"memLimit must be an unsigned integer");var r=new o(0|wI._crypto_pwhash_strbytes()).address;if(i.push(r),0==(0|wI._crypto_pwhash_str(r,B,t,0,I,0,e))){var a=wI.Pointer_stringify(r);return s(i),a}h(i,"invalid usage")}function bA(A,I,g){var i=[];C(g);var B=c(A=e(A+"\0"));A.length,i.push(B);var t=c(I=_(i,I,"password")),r=I.length;i.push(t);var a=0==(0|wI._crypto_pwhash_str_verify(B,t,r,0));return s(i),a}function kA(A,I,e){var g=[];C(e),A=_(g,A,"privateKey");var i,B=0|wI._crypto_scalarmult_scalarbytes();A.length!==B&&y(g,"invalid privateKey length"),i=c(A),g.push(i),I=_(g,I,"publicKey");var t,r=0|wI._crypto_scalarmult_scalarbytes();I.length!==r&&y(g,"invalid publicKey length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_scalarmult_bytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_scalarmult(Q,i,t))){var E=a(n,e);return s(g),E}h(g,"weak public key")}function GA(A,I){var e=[];C(I),A=_(e,A,"privateKey");var g,i=0|wI._crypto_scalarmult_scalarbytes();A.length!==i&&y(e,"invalid privateKey length"),g=c(A),e.push(g);var B=new o(0|wI._crypto_scalarmult_scalarbytes()),t=B.address;if(e.push(t),0==(0|wI._crypto_scalarmult_base(t,g))){var r=a(B,I);return s(e),r}h(e,"insecure scalar")}function FA(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"message")),t=A.length;i.push(B),I=_(i,I,"nonce");var r,n=0|wI._crypto_secretbox_noncebytes();I.length!==n&&y(i,"invalid nonce length"),r=c(I),i.push(r),e=_(i,e,"key");var Q,E=0|wI._crypto_secretbox_keybytes();e.length!==E&&y(i,"invalid key length"),Q=c(e),i.push(Q);var f=new o(0|t),p=f.address;i.push(p);var w=new o(0|wI._crypto_secretbox_macbytes()),l=w.address;if(i.push(l),0==(0|wI._crypto_secretbox_detached(p,l,B,t,0,r,Q))){var u=a({mac:w,cipher:f},g);return s(i),u}h(i,"invalid usage")}function mA(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"message")),t=A.length;i.push(B),I=_(i,I,"nonce");var r,n=0|wI._crypto_secretbox_noncebytes();I.length!==n&&y(i,"invalid nonce length"),r=c(I),i.push(r),e=_(i,e,"key");var Q,E=0|wI._crypto_secretbox_keybytes();e.length!==E&&y(i,"invalid key length"),Q=c(e),i.push(Q);var f=new o(t+wI._crypto_secretbox_macbytes()|0),p=f.address;if(i.push(p),0==(0|wI._crypto_secretbox_easy(p,B,t,0,r,Q))){var w=a(f,g);return s(i),w}h(i,"invalid usage")}function MA(A){var I=[];C(A);var e=new o(0|wI._crypto_secretbox_keybytes()),g=e.address;I.push(g),wI._crypto_secretbox_keygen(g);var i=a(e,A);return s(I),i}function HA(A,I,e,g,i){var B=[];C(i);var t=c(A=_(B,A,"ciphertext")),r=A.length;B.push(t),I=_(B,I,"mac");var n,Q=0|wI._crypto_secretbox_macbytes();I.length!==Q&&y(B,"invalid mac length"),n=c(I),B.push(n),e=_(B,e,"nonce");var E,f=0|wI._crypto_secretbox_noncebytes();e.length!==f&&y(B,"invalid nonce length"),E=c(e),B.push(E),g=_(B,g,"key");var p,w=0|wI._crypto_secretbox_keybytes();g.length!==w&&y(B,"invalid key length"),p=c(g),B.push(p);var l=new o(0|r),u=l.address;if(B.push(u),0==(0|wI._crypto_secretbox_open_detached(u,t,n,r,0,E,p))){var d=a(l,i);return s(B),d}h(B,"wrong secret key for the given ciphertext")}function YA(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"ciphertext")),t=A.length;i.push(B),I=_(i,I,"nonce");var r,n=0|wI._crypto_secretbox_noncebytes();I.length!==n&&y(i,"invalid nonce length"),r=c(I),i.push(r),e=_(i,e,"key");var Q,E=0|wI._crypto_secretbox_keybytes();e.length!==E&&y(i,"invalid key length"),Q=c(e),i.push(Q);var f=new o(t-wI._crypto_secretbox_macbytes()|0),p=f.address;if(i.push(p),0==(0|wI._crypto_secretbox_open_easy(p,B,t,0,r,Q))){var w=a(f,g);return s(i),w}h(i,"wrong secret key for the given ciphertext")}function SA(A,I,e){var g=[];C(e),A=_(g,A,"header");var i,B=0|wI._crypto_secretstream_xchacha20poly1305_headerbytes();A.length!==B&&y(g,"invalid header length"),i=c(A),g.push(i),I=_(g,I,"key");var t,r=0|wI._crypto_secretstream_xchacha20poly1305_keybytes();I.length!==r&&y(g,"invalid key length"),t=c(I),g.push(t);var a=new o(52).address;if(0==(0|wI._crypto_secretstream_xchacha20poly1305_init_pull(a,i,t))){var n=a;return s(g),n}h(g,"invalid usage")}function RA(A,I){var e=[];C(I),A=_(e,A,"key");var g,i=0|wI._crypto_secretstream_xchacha20poly1305_keybytes();A.length!==i&&y(e,"invalid key length"),g=c(A),e.push(g);var B=new o(52).address,t=new o(0|wI._crypto_secretstream_xchacha20poly1305_headerbytes()),r=t.address;if(e.push(r),0==(0|wI._crypto_secretstream_xchacha20poly1305_init_push(B,r,g))){var n={state:B,header:a(t,I)};return s(e),n}h(e,"invalid usage")}function NA(A){var I=[];C(A);var e=new o(0|wI._crypto_secretstream_xchacha20poly1305_keybytes()),g=e.address;I.push(g),wI._crypto_secretstream_xchacha20poly1305_keygen(g);var i=a(e,A);return s(I),i}function UA(A,I,e,g){var i=[];C(g),f(i,A,"state_address");var B=c(I=_(i,I,"cipher")),t=I.length;i.push(B);var r=null,n=0;void 0!=e&&(e=_(i,e,"ad"),r=c(e),n=e.length,i.push(r));var E=new o(t-wI._crypto_secretstream_xchacha20poly1305_abytes()|0),h=E.address;i.push(h);var y=(y=function(){var I=Q(1);return i.push(I),0===wI._crypto_secretstream_xchacha20poly1305_pull(A,h,0,I,B,t,0,r,n)&&{tag:wI.HEAPU8[I],message:E}}())&&{message:a(y.message,g),tag:y.tag};return s(i),y}function JA(A,I,e,g,i){var B=[];C(i),f(B,A,"state_address");var t=c(I=_(B,I,"message_chunk")),r=I.length;B.push(t);var n=null,Q=0;void 0!=e&&(n=c(e=_(B,e,"ad")),Q=e.length,B.push(n)),f(B,g,"tag"),("number"!=typeof g||(0|g)!==g||g<0)&&y(B,"tag must be an unsigned integer");var E=new o(r+wI._crypto_secretstream_xchacha20poly1305_abytes()|0),p=E.address;if(B.push(p),0==(0|wI._crypto_secretstream_xchacha20poly1305_push(A,p,0,t,r,0,n,Q,0,g))){var w=a(E,i);return s(B),w}h(B,"invalid usage")}function PA(A,I){var e=[];return C(I),f(e,A,"state_address"),wI._crypto_secretstream_xchacha20poly1305_rekey(A),s(e),!0}function LA(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"key");var t,r=0|wI._crypto_shorthash_keybytes();I.length!==r&&y(g,"invalid key length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_shorthash_bytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_shorthash(Q,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function xA(A){var I=[];C(A);var e=new o(0|wI._crypto_shorthash_keybytes()),g=e.address;I.push(g),wI._crypto_shorthash_keygen(g);var i=a(e,A);return s(I),i}function XA(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"key");var t,r=0|wI._crypto_shorthash_siphashx24_keybytes();I.length!==r&&y(g,"invalid key length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_shorthash_siphashx24_bytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_shorthash_siphashx24(Q,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function KA(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"privateKey");var t,r=0|wI._crypto_sign_secretkeybytes();I.length!==r&&y(g,"invalid privateKey length"),t=c(I),g.push(t);var n=new o(A.length+wI._crypto_sign_bytes()|0),Q=n.address;if(g.push(Q),0==(0|wI._crypto_sign(Q,null,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function TA(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"message")),B=A.length;g.push(i),I=_(g,I,"privateKey");var t,r=0|wI._crypto_sign_secretkeybytes();I.length!==r&&y(g,"invalid privateKey length"),t=c(I),g.push(t);var n=new o(0|wI._crypto_sign_bytes()),Q=n.address;if(g.push(Q),0==(0|wI._crypto_sign_detached(Q,null,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"invalid usage")}function VA(A,I){var e=[];C(I),A=_(e,A,"edPk");var g,i=0|wI._crypto_sign_publickeybytes();A.length!==i&&y(e,"invalid edPk length"),g=c(A),e.push(g);var B=new o(0|wI._crypto_scalarmult_scalarbytes()),t=B.address;if(e.push(t),0==(0|wI._crypto_sign_ed25519_pk_to_curve25519(t,g))){var r=a(B,I);return s(e),r}h(e,"invalid key")}function qA(A,I){var e=[];C(I),A=_(e,A,"edSk");var g,i=0|wI._crypto_sign_secretkeybytes();A.length!==i&&y(e,"invalid edSk length"),g=c(A),e.push(g);var B=new o(0|wI._crypto_scalarmult_scalarbytes()),t=B.address;if(e.push(t),0==(0|wI._crypto_sign_ed25519_sk_to_curve25519(t,g))){var r=a(B,I);return s(e),r}h(e,"invalid key")}function jA(A,I){var e=[];C(I),A=_(e,A,"privateKey");var g,i=0|wI._crypto_sign_secretkeybytes();A.length!==i&&y(e,"invalid privateKey length"),g=c(A),e.push(g);var B=new o(0|wI._crypto_sign_publickeybytes()),t=B.address;if(e.push(t),0==(0|wI._crypto_sign_ed25519_sk_to_pk(t,g))){var r=a(B,I);return s(e),r}h(e,"invalid key")}function ZA(A,I){var e=[];C(I),A=_(e,A,"privateKey");var g,i=0|wI._crypto_sign_secretkeybytes();A.length!==i&&y(e,"invalid privateKey length"),g=c(A),e.push(g);var B=new o(0|wI._crypto_sign_seedbytes()),t=B.address;if(e.push(t),0==(0|wI._crypto_sign_ed25519_sk_to_seed(t,g))){var r=a(B,I);return s(e),r}h(e,"invalid key")}function WA(A,I,e){var g=[];C(e),f(g,A,"state_address"),I=_(g,I,"privateKey");var i,B=0|wI._crypto_sign_secretkeybytes();I.length!==B&&y(g,"invalid privateKey length"),i=c(I),g.push(i);var t=new o(0|wI._crypto_sign_bytes()),r=t.address;if(g.push(r),0==(0|wI._crypto_sign_final_create(A,r,null,i))){var n=(wI._free(A),a(t,e));return s(g),n}h(g,"invalid usage")}function zA(A,I,e,g){var i=[];C(g),f(i,A,"state_address"),I=_(i,I,"signature");var B,t=0|wI._crypto_sign_bytes();I.length!==t&&y(i,"invalid signature length"),B=c(I),i.push(B),e=_(i,e,"publicKey");var r,a=0|wI._crypto_sign_publickeybytes();e.length!==a&&y(i,"invalid publicKey length"),r=c(e),i.push(r);var n=0==(0|wI._crypto_sign_final_verify(A,B,r));return s(i),n}function OA(A){var I=[];C(A);var e=new o(208).address;if(0==(0|wI._crypto_sign_init(e))){var g=e;return s(I),g}h(I,"internal error")}function $A(A){var I=[];C(A);var e=new o(0|wI._crypto_sign_publickeybytes()),g=e.address;I.push(g);var i=new o(0|wI._crypto_sign_secretkeybytes()),B=i.address;if(I.push(B),0==(0|wI._crypto_sign_keypair(g,B))){var t={publicKey:a(e,A),privateKey:a(i,A),keyType:"ed25519"};return s(I),t}h(I,"internal error")}function AI(A,I,e){var g=[];C(e);var i=c(A=_(g,A,"signedMessage")),B=A.length;g.push(i),I=_(g,I,"publicKey");var t,r=0|wI._crypto_sign_publickeybytes();I.length!==r&&y(g,"invalid publicKey length"),t=c(I),g.push(t);var n=new o(B-wI._crypto_sign_bytes()|0),Q=n.address;if(g.push(Q),0==(0|wI._crypto_sign_open(Q,null,i,B,0,t))){var E=a(n,e);return s(g),E}h(g,"incorrect signature for the given public key")}function II(A,I){var e=[];C(I),A=_(e,A,"seed");var g,i=0|wI._crypto_sign_seedbytes();A.length!==i&&y(e,"invalid seed length"),g=c(A),e.push(g);var B=new o(0|wI._crypto_sign_publickeybytes()),t=B.address;e.push(t);var r=new o(0|wI._crypto_sign_secretkeybytes()),n=r.address;if(e.push(n),0==(0|wI._crypto_sign_seed_keypair(t,n,g))){var Q={publicKey:a(B,I),privateKey:a(r,I),keyType:"ed25519"};return s(e),Q}h(e,"invalid usage")}function eI(A,I,e){var g=[];C(e),f(g,A,"state_address");var i=c(I=_(g,I,"message_chunk")),B=I.length;g.push(i),0!=(0|wI._crypto_sign_update(A,i,B))&&h(g,"invalid usage"),s(g)}function gI(A,I,e){var g=[];A=_(g,A,"signature");var i,B=0|wI._crypto_sign_bytes();A.length!==B&&y(g,"invalid signature length"),i=c(A),g.push(i);var t=c(I=_(g,I,"message")),r=I.length;g.push(t),e=_(g,e,"publicKey");var a,n=0|wI._crypto_sign_publickeybytes();e.length!==n&&y(g,"invalid publicKey length"),a=c(e),g.push(a);var C=0==(0|wI._crypto_sign_verify_detached(i,t,r,0,a));return s(g),C}function iI(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"input_message")),t=A.length;i.push(B),I=_(i,I,"nonce");var r,n=0|wI._crypto_stream_chacha20_ietf_noncebytes();I.length!==n&&y(i,"invalid nonce length"),r=c(I),i.push(r),e=_(i,e,"key");var Q,E=0|wI._crypto_stream_chacha20_ietf_keybytes();e.length!==E&&y(i,"invalid key length"),Q=c(e),i.push(Q);var f=new o(0|t),p=f.address;if(i.push(p),0===wI._crypto_stream_chacha20_ietf_xor(p,B,t,0,r,Q)){var w=a(f,g);return s(i),w}h(i,"invalid usage")}function BI(A,I,e,g,i){var B=[];C(i);var t=c(A=_(B,A,"input_message")),r=A.length;B.push(t),I=_(B,I,"nonce");var n,Q=0|wI._crypto_stream_chacha20_ietf_noncebytes();I.length!==Q&&y(B,"invalid nonce length"),n=c(I),B.push(n),f(B,e,"nonce_increment"),("number"!=typeof e||(0|e)!==e||e<0)&&y(B,"nonce_increment must be an unsigned integer"),g=_(B,g,"key");var E,p=0|wI._crypto_stream_chacha20_ietf_keybytes();g.length!==p&&y(B,"invalid key length"),E=c(g),B.push(E);var w=new o(0|r),l=w.address;if(B.push(l),0===wI._crypto_stream_chacha20_ietf_xor_ic(l,t,r,0,n,e,0,E)){var u=a(w,i);return s(B),u}h(B,"invalid usage")}function tI(A){var I=[];C(A);var e=new o(0|wI._crypto_stream_chacha20_keybytes()),g=e.address;I.push(g),wI._crypto_stream_chacha20_keygen(g);var i=a(e,A);return s(I),i}function rI(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"input_message")),t=A.length;i.push(B),I=_(i,I,"nonce");var r,n=0|wI._crypto_stream_chacha20_noncebytes();I.length!==n&&y(i,"invalid nonce length"),r=c(I),i.push(r),e=_(i,e,"key");var Q,E=0|wI._crypto_stream_chacha20_keybytes();e.length!==E&&y(i,"invalid key length"),Q=c(e),i.push(Q);var f=new o(0|t),p=f.address;if(i.push(p),0===wI._crypto_stream_chacha20_xor(p,B,t,0,r,Q)){var w=a(f,g);return s(i),w}h(i,"invalid usage")}function aI(A,I,e,g,i){var B=[];C(i);var t=c(A=_(B,A,"input_message")),r=A.length;B.push(t),I=_(B,I,"nonce");var n,Q=0|wI._crypto_stream_chacha20_noncebytes();I.length!==Q&&y(B,"invalid nonce length"),n=c(I),B.push(n),f(B,e,"nonce_increment"),("number"!=typeof e||(0|e)!==e||e<0)&&y(B,"nonce_increment must be an unsigned integer"),g=_(B,g,"key");var E,p=0|wI._crypto_stream_chacha20_keybytes();g.length!==p&&y(B,"invalid key length"),E=c(g),B.push(E);var w=new o(0|r),l=w.address;if(B.push(l),0===wI._crypto_stream_chacha20_xor_ic(l,t,r,0,n,e,0,E)){var u=a(w,i);return s(B),u}h(B,"invalid usage")}function nI(A){var I=[];C(A);var e=new o(0|wI._crypto_stream_keybytes()),g=e.address;I.push(g),wI._crypto_stream_keygen(g);var i=a(e,A);return s(I),i}function CI(A){var I=[];C(A);var e=new o(0|wI._crypto_stream_xchacha20_keybytes()),g=e.address;I.push(g),wI._crypto_stream_xchacha20_keygen(g);var i=a(e,A);return s(I),i}function oI(A,I,e,g){var i=[];C(g);var B=c(A=_(i,A,"input_message")),t=A.length;i.push(B),I=_(i,I,"nonce");var r,n=0|wI._crypto_stream_xchacha20_noncebytes();I.length!==n&&y(i,"invalid nonce length"),r=c(I),i.push(r),e=_(i,e,"key");var Q,E=0|wI._crypto_stream_xchacha20_keybytes();e.length!==E&&y(i,"invalid key length"),Q=c(e),i.push(Q);var f=new o(0|t),p=f.address;if(i.push(p),0===wI._crypto_stream_xchacha20_xor(p,B,t,0,r,Q)){var w=a(f,g);return s(i),w}h(i,"invalid usage")}function cI(A,I,e,g,i){var B=[];C(i);var t=c(A=_(B,A,"input_message")),r=A.length;B.push(t),I=_(B,I,"nonce");var n,Q=0|wI._crypto_stream_xchacha20_noncebytes();I.length!==Q&&y(B,"invalid nonce length"),n=c(I),B.push(n),f(B,e,"nonce_increment"),("number"!=typeof e||(0|e)!==e||e<0)&&y(B,"nonce_increment must be an unsigned integer"),g=_(B,g,"key");var E,p=0|wI._crypto_stream_xchacha20_keybytes();g.length!==p&&y(B,"invalid key length"),E=c(g),B.push(E);var w=new o(0|r),l=w.address;if(B.push(l),0===wI._crypto_stream_xchacha20_xor_ic(l,t,r,0,n,e,0,E)){var u=a(w,i);return s(B),u}h(B,"invalid usage")}function QI(A,I){var e=[];C(I),f(e,A,"length"),("number"!=typeof A||(0|A)!==A||A<0)&&y(e,"length must be an unsigned integer");var g=new o(0|A),i=g.address;e.push(i),wI._randombytes_buf(i,A);var B=a(g,I);return s(e),B}function EI(A,I,e){var g=[];C(e),f(g,A,"length"),("number"!=typeof A||(0|A)!==A||A<0)&&y(g,"length must be an unsigned integer"),I=_(g,I,"seed");var i,B=0|wI._randombytes_seedbytes();I.length!==B&&y(g,"invalid seed length"),i=c(I),g.push(i);var t=new o(0|A),r=t.address;g.push(r),wI._randombytes_buf_deterministic(r,A,0,I);var n=a(t,e);return s(g),n}function sI(A){C(A),wI._randombytes_close()}function hI(A){C(A);var I=wI._randombytes_random()>>>0;return s([]),I}function yI(A,I){var e=[];C(I);for(var g=wI._malloc(24),i=0;i<6;i++)wI.setValue(g+4*i,wI.Runtime.addFunction(A[["implementation_name","random","stir","uniform","buf","close"][i]]),"i32");0!=(0|wI._randombytes_set_implementation(g))&&h(e,"unsupported implementation"),s(e)}function fI(A){C(A),wI._randombytes_stir()}function _I(A,I){var e=[];C(I),f(e,A,"upper_bound"),("number"!=typeof A||(0|A)!==A||A<0)&&y(e,"upper_bound must be an unsigned integer");var g=wI._randombytes_uniform(A)>>>0;return s(e),g}function pI(){var A=wI._sodium_version_string(),I=wI.Pointer_stringify(A);return s([]),I}var wI,lI="uint8array",uI=I.ready.then(function(){if(0!==(wI=I)._sodium_init())throw new Error("libsodium was not correctly initialized.");for(var e=["crypto_aead_chacha20poly1305_decrypt","crypto_aead_chacha20poly1305_decrypt_detached","crypto_aead_chacha20poly1305_encrypt","crypto_aead_chacha20poly1305_encrypt_detached","crypto_aead_chacha20poly1305_ietf_decrypt","crypto_aead_chacha20poly1305_ietf_decrypt_detached","crypto_aead_chacha20poly1305_ietf_encrypt","crypto_aead_chacha20poly1305_ietf_encrypt_detached","crypto_aead_chacha20poly1305_ietf_keygen","crypto_aead_chacha20poly1305_keygen","crypto_aead_xchacha20poly1305_ietf_decrypt","crypto_aead_xchacha20poly1305_ietf_decrypt_detached","crypto_aead_xchacha20poly1305_ietf_encrypt","crypto_aead_xchacha20poly1305_ietf_encrypt_detached","crypto_aead_xchacha20poly1305_ietf_keygen","crypto_auth","crypto_auth_hmacsha256","crypto_auth_hmacsha256_keygen","crypto_auth_hmacsha256_verify","crypto_auth_hmacsha512","crypto_auth_hmacsha512_keygen","crypto_auth_hmacsha512_verify","crypto_auth_keygen","crypto_auth_verify","crypto_box_beforenm","crypto_box_detached","crypto_box_easy","crypto_box_easy_afternm","crypto_box_keypair","crypto_box_open_detached","crypto_box_open_easy","crypto_box_open_easy_afternm","crypto_box_seal","crypto_box_seal_open","crypto_box_seed_keypair","crypto_generichash","crypto_generichash_final","crypto_generichash_init","crypto_generichash_keygen","crypto_generichash_update","crypto_hash","crypto_hash_sha256","crypto_hash_sha512","crypto_kdf_derive_from_key","crypto_kdf_keygen","crypto_kx_client_session_keys","crypto_kx_keypair","crypto_kx_seed_keypair","crypto_kx_server_session_keys","crypto_onetimeauth","crypto_onetimeauth_final","crypto_onetimeauth_init","crypto_onetimeauth_keygen","crypto_onetimeauth_update","crypto_onetimeauth_verify","crypto_pwhash","crypto_pwhash_scryptsalsa208sha256","crypto_pwhash_scryptsalsa208sha256_ll","crypto_pwhash_scryptsalsa208sha256_str","crypto_pwhash_scryptsalsa208sha256_str_verify","crypto_pwhash_str","crypto_pwhash_str_verify","crypto_scalarmult","crypto_scalarmult_base","crypto_secretbox_detached","crypto_secretbox_easy","crypto_secretbox_keygen","crypto_secretbox_open_detached","crypto_secretbox_open_easy","crypto_secretstream_xchacha20poly1305_init_pull","crypto_secretstream_xchacha20poly1305_init_push","crypto_secretstream_xchacha20poly1305_keygen","crypto_secretstream_xchacha20poly1305_pull","crypto_secretstream_xchacha20poly1305_push","crypto_secretstream_xchacha20poly1305_rekey","crypto_shorthash","crypto_shorthash_keygen","crypto_shorthash_siphashx24","crypto_sign","crypto_sign_detached","crypto_sign_ed25519_pk_to_curve25519","crypto_sign_ed25519_sk_to_curve25519","crypto_sign_ed25519_sk_to_pk","crypto_sign_ed25519_sk_to_seed","crypto_sign_final_create","crypto_sign_final_verify","crypto_sign_init","crypto_sign_keypair","crypto_sign_open","crypto_sign_seed_keypair","crypto_sign_update","crypto_sign_verify_detached","crypto_stream_chacha20_ietf_xor","crypto_stream_chacha20_ietf_xor_ic","crypto_stream_chacha20_keygen","crypto_stream_chacha20_xor","crypto_stream_chacha20_xor_ic","crypto_stream_keygen","crypto_stream_xchacha20_keygen","crypto_stream_xchacha20_xor","crypto_stream_xchacha20_xor_ic","randombytes_buf","randombytes_buf_deterministic","randombytes_close","randombytes_random","randombytes_set_implementation","randombytes_stir","randombytes_uniform","sodium_version_string"],g=[p,w,l,u,d,D,v,b,k,G,F,m,M,H,Y,S,R,N,U,J,P,L,x,X,K,T,V,q,j,Z,W,z,O,$,AA,IA,eA,gA,iA,BA,tA,rA,aA,nA,CA,oA,cA,QA,EA,sA,hA,yA,fA,_A,pA,wA,lA,uA,dA,DA,vA,bA,kA,GA,FA,mA,MA,HA,YA,SA,RA,NA,UA,JA,PA,LA,xA,XA,KA,TA,VA,qA,jA,ZA,WA,zA,OA,$A,AI,II,eI,gI,iI,BI,tI,rI,aI,nI,CI,oI,cI,QI,EI,sI,hI,yI,fI,_I,pI],i=0;i<g.length;i++)"function"==typeof wI["_"+e[i]]&&(A[e[i]]=g[i]);for(var B=["SODIUM_LIBRARY_VERSION_MAJOR","SODIUM_LIBRARY_VERSION_MINOR","crypto_aead_chacha20poly1305_ABYTES","crypto_aead_chacha20poly1305_KEYBYTES","crypto_aead_chacha20poly1305_MESSAGEBYTES_MAX","crypto_aead_chacha20poly1305_NPUBBYTES","crypto_aead_chacha20poly1305_NSECBYTES","crypto_aead_chacha20poly1305_ietf_ABYTES","crypto_aead_chacha20poly1305_ietf_KEYBYTES","crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX","crypto_aead_chacha20poly1305_ietf_NPUBBYTES","crypto_aead_chacha20poly1305_ietf_NSECBYTES","crypto_aead_xchacha20poly1305_ietf_ABYTES","crypto_aead_xchacha20poly1305_ietf_KEYBYTES","crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX","crypto_aead_xchacha20poly1305_ietf_NPUBBYTES","crypto_aead_xchacha20poly1305_ietf_NSECBYTES","crypto_auth_BYTES","crypto_auth_KEYBYTES","crypto_auth_hmacsha256_BYTES","crypto_auth_hmacsha256_KEYBYTES","crypto_auth_hmacsha512_BYTES","crypto_auth_hmacsha512_KEYBYTES","crypto_box_BEFORENMBYTES","crypto_box_MACBYTES","crypto_box_MESSAGEBYTES_MAX","crypto_box_NONCEBYTES","crypto_box_PUBLICKEYBYTES","crypto_box_SEALBYTES","crypto_box_SECRETKEYBYTES","crypto_box_SEEDBYTES","crypto_core_hchacha20_CONSTBYTES","crypto_core_hchacha20_INPUTBYTES","crypto_core_hchacha20_KEYBYTES","crypto_core_hchacha20_OUTPUTBYTES","crypto_generichash_BYTES","crypto_generichash_BYTES_MAX","crypto_generichash_BYTES_MIN","crypto_generichash_KEYBYTES","crypto_generichash_KEYBYTES_MAX","crypto_generichash_KEYBYTES_MIN","crypto_hash_BYTES","crypto_hash_sha256_BYTES","crypto_hash_sha512_BYTES","crypto_kdf_BYTES_MAX","crypto_kdf_BYTES_MIN","crypto_kdf_CONTEXTBYTES","crypto_kdf_KEYBYTES","crypto_kx_PUBLICKEYBYTES","crypto_kx_SECRETKEYBYTES","crypto_kx_SEEDBYTES","crypto_kx_SESSIONKEYBYTES","crypto_onetimeauth_BYTES","crypto_onetimeauth_KEYBYTES","crypto_pwhash_ALG_ARGON2I13","crypto_pwhash_ALG_ARGON2ID13","crypto_pwhash_ALG_DEFAULT","crypto_pwhash_BYTES_MAX","crypto_pwhash_BYTES_MIN","crypto_pwhash_MEMLIMIT_INTERACTIVE","crypto_pwhash_MEMLIMIT_MAX","crypto_pwhash_MEMLIMIT_MIN","crypto_pwhash_MEMLIMIT_MODERATE","crypto_pwhash_MEMLIMIT_SENSITIVE","crypto_pwhash_OPSLIMIT_INTERACTIVE","crypto_pwhash_OPSLIMIT_MAX","crypto_pwhash_OPSLIMIT_MIN","crypto_pwhash_OPSLIMIT_MODERATE","crypto_pwhash_OPSLIMIT_SENSITIVE","crypto_pwhash_PASSWD_MAX","crypto_pwhash_PASSWD_MIN","crypto_pwhash_SALTBYTES","crypto_pwhash_STRBYTES","crypto_pwhash_STR_VERIFY","crypto_pwhash_scryptsalsa208sha256_BYTES_MAX","crypto_pwhash_scryptsalsa208sha256_BYTES_MIN","crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE","crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX","crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN","crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE","crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE","crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX","crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN","crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE","crypto_pwhash_scryptsalsa208sha256_SALTBYTES","crypto_pwhash_scryptsalsa208sha256_STRBYTES","crypto_pwhash_scryptsalsa208sha256_STR_VERIFY","crypto_scalarmult_BYTES","crypto_scalarmult_SCALARBYTES","crypto_secretbox_KEYBYTES","crypto_secretbox_MACBYTES","crypto_secretbox_MESSAGEBYTES_MAX","crypto_secretbox_NONCEBYTES","crypto_secretstream_xchacha20poly1305_ABYTES","crypto_secretstream_xchacha20poly1305_HEADERBYTES","crypto_secretstream_xchacha20poly1305_KEYBYTES","crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX","crypto_secretstream_xchacha20poly1305_MESSAGESBYTES_MAX","crypto_secretstream_xchacha20poly1305_NPUBBYTES","crypto_secretstream_xchacha20poly1305_TAG_FINAL","crypto_secretstream_xchacha20poly1305_TAG_MESSAGE","crypto_secretstream_xchacha20poly1305_TAG_PUSH","crypto_secretstream_xchacha20poly1305_TAG_REKEY","crypto_shorthash_BYTES","crypto_shorthash_KEYBYTES","crypto_shorthash_siphashx24_BYTES","crypto_shorthash_siphashx24_KEYBYTES","crypto_sign_BYTES","crypto_sign_MESSAGEBYTES_MAX","crypto_sign_PUBLICKEYBYTES","crypto_sign_SECRETKEYBYTES","crypto_sign_SEEDBYTES","crypto_stream_KEYBYTES","crypto_stream_MESSAGEBYTES_MAX","crypto_stream_NONCEBYTES","crypto_stream_chacha20_KEYBYTES","crypto_stream_chacha20_NONCEBYTES","crypto_stream_chacha20_ietf_KEYBYTES","crypto_stream_chacha20_ietf_MESSAGEBYTES_MAX","crypto_stream_chacha20_ietf_NONCEBYTES","crypto_stream_xchacha20_KEYBYTES","crypto_stream_xchacha20_MESSAGEBYTES_MAX","crypto_stream_xchacha20_NONCEBYTES","randombytes_SEEDBYTES"],i=0;i<B.length;i++)"function"==typeof(r=wI["_"+B[i].toLowerCase()])&&(A[B[i]]=r());for(var t=["SODIUM_VERSION_STRING","crypto_pwhash_STRPREFIX","crypto_pwhash_scryptsalsa208sha256_STRPREFIX"],i=0;i<t.length;i++){var r=wI["_"+t[i].toLowerCase()];"function"==typeof r&&(A[t[i]]=wI.Pointer_stringify(r()))}}),dI={ORIGINAL:1,ORIGINAL_NO_PADDING:3,URLSAFE:5,URLSAFE_NO_PADDING:7};return o.prototype.to_Uint8Array=function(){var A=new Uint8Array(this.length);return A.set(wI.HEAPU8.subarray(this.address,this.address+this.length)),A},A.add=function(A,I){if(!(A instanceof Uint8Array&&I instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can added");var e=A.length,g=0,i=0;if(I.length!=A.length)throw new TypeError("Arguments must have the same length");for(i=0;i<e;i++)g>>=8,g+=A[i]+I[e],A[i]=255&g},A.base64_variants=dI,A.compare=function(A,I){if(!(A instanceof Uint8Array&&I instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be compared");if(A.length!==I.length)throw new TypeError("Only instances of identical length can be compared");for(var e=0,g=1,i=A.length;i-- >0;)e|=I[i]-A[i]>>8&g,g&=(I[i]^A[i])-1>>8;return e+e+g-1},A.from_base64=function(A,I){I=B(I);var e,g=[],i=new o(3*(A=_(g,A,"input")).length/4),t=c(A),r=Q(4),a=Q(4);return g.push(t),g.push(i.address),g.push(i.result_bin_len_p),g.push(i.b64_end_p),0!==wI._sodium_base642bin(i.address,i.length,t,A.length,0,r,a,I)&&h(g,"invalid input"),wI.getValue(a,"i32")-t!==A.length&&h(g,"incomplete input"),i.length=wI.getValue(r,"i32"),e=i.to_Uint8Array(),s(g),e},A.from_hex=function(A){var I,e=[],g=new o((A=_(e,A,"input")).length/2),i=c(A),B=Q(4);return e.push(i),e.push(g.address),e.push(g.hex_end_p),0!==wI._sodium_hex2bin(g.address,g.length,i,A.length,0,0,B)&&h(e,"invalid input"),wI.getValue(B,"i32")-i!==A.length&&h(e,"incomplete input"),I=g.to_Uint8Array(),s(e),I},A.from_string=e,A.increment=function(A){if(!(A instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be incremented");for(var I=256,e=0,g=A.length;e<g;e++)I>>=8,I+=A[e],A[e]=255&I},A.is_zero=function(A){if(!(A instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be checked");for(var I=0,e=0,g=A.length;e<g;e++)I|=A[e];return 0===I},A.libsodium=I,A.memcmp=function(A,I){if(!(A instanceof Uint8Array&&I instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be compared");if(A.length!==I.length)throw new TypeError("Only instances of identical length can be compared");for(var e=0,g=0,i=A.length;g<i;g++)e|=A[g]^I[g];return 0===e},A.memzero=function(A){if(!(A instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be wiped");for(var I=0,e=A.length;I<e;I++)A[I]=0},A.output_formats=r,A.pad=function(A,I){if(!(A instanceof Uint8Array))throw new TypeError("buffer must be a Uint8Array");if((I|=0)<=0)throw new Error("block size must be > 0");var e,g=[],i=Q(4),B=1,t=0,r=0|A.length,a=new o(r+I);g.push(i),g.push(a.address);for(var n=a.address,C=a.address+r+I;n<C;n++)wI.HEAPU8[n]=A[t],t+=B=1&~((65535&((r-=B)>>>48|r>>>32|r>>>16|r))-1>>16);return 0!==wI._sodium_pad(i,a.address,A.length,I,a.length)&&h(g,"internal error"),a.length=wI.getValue(i,"i32"),e=a.to_Uint8Array(),s(g),e},A.unpad=function(A,I){if(!(A instanceof Uint8Array))throw new TypeError("buffer must be a Uint8Array");if((I|=0)<=0)throw new Error("block size must be > 0");var e=[],g=c(A),i=Q(4);return e.push(g),e.push(i),0!==wI._sodium_unpad(i,g,A.length,I)&&h(e,"unsupported/invalid padding"),A=new Uint8Array(A),A=A.subarray(0,wI.getValue(i,"i32")),s(e),A},A.ready=uI,A.symbols=function(){return Object.keys(A).sort()},A.to_base64=t,A.to_hex=i,A.to_string=g,A}var e="object"==typeof A.sodium&&"function"==typeof A.sodium.onload?A.sodium.onload:null;"function"==typeof define&&define.amd?define(["exports","libsodium"],I):"object"==typeof exports&&"string"!=typeof exports.nodeName?I(exports,require("libsodium")):A.sodium=I(A.commonJsStrict={},A.libsodium),e&&A.sodium.ready.then(function(){e(A.sodium)})}(this);

/**
 * The exposed API from jiff-client.js (The client side library of JIFF).
 * Wraps the jiff API. Internal members can be accessed with jiff.&lt;member-name&gt;.
 * @namespace jiff
 * @version 1.0
 */
(function (exports, node) {
  var crypto_, io_, sodium_;
  if (node) {
    io_ = require('socket.io-client');
    sodium_ = require('libsodium-wrappers');

    crypto_ = require('crypto');
    crypto_.__randomBytesWrapper = crypto_.randomBytes;
  } else { // Browser: sodium (and other dependencies) should be available in global scope from including sodium.js
    io_ = window.io;
    sodium_ = window.sodium;

    crypto_ = window.crypto || window.msCrypto;
    crypto_.__randomBytesWrapper = function (bytesNeeded) {
      var randomBytes = new Uint8Array(bytesNeeded);
      crypto_.getRandomValues(randomBytes);
      return randomBytes;
    };
  }

  /**
   * Provides the needed dependencies in case where they are not global variable (e.g. using AMD define)
   * @memberof jiff
   * @function dependencies
   * @param {object} dependencies - contains any of these two attributes: "io", "sodium"
   *                                unprovided dependencies will be expected to exist as global variables
   *                                in the browser, or are fetched using require() in node.
   */
  exports.dependencies = function (dependencies) {
    io_ = dependencies['io'] != null ? dependencies['io'] : io_;
    sodium_ = dependencies['sodium'] != null ? dependencies['sodium'] : sodium_;
  };

  /**
   * The default mod to be used in a jiff instance if a custom mod was not provided.
   */
  var gZp = 15485867;

  /** Return the maximum of two numbers */
  function max(x, y) {
    return x > y ? x : y;
  }

  /**
   * Check that an integer is prime. Used to safely set the modulus Zp.
   * @memberof jiff.utils
   * @param {number} p - the prime number candidate.
   * @returns {boolean} true if p is prime, false otherwise.
   */
  function is_prime(p) {
    // AKS Primality Test

    if (p === 2) {
      return true;
    } else if (p === 3) {
      return true;
    } else if (p % 2 === 0) {
      return false;
    } else if (p % 3 === 0) {
      return false;
    }

    var i = 5;
    var n = 2;
    while (i * i <= p) {
      if (p % i === 0) {
        return false;
      }
      i += n;
      n = 6 - n;
    }

    return true;
  }

  /** Doubly linked list with add and remove functions and pointers to head and tail **/
  var linked_list = function () {
    // attributes: list.head and list.tail
    // functions: list.add(object) (returns pointer), list.remove(pointer)
    // list.head/list.tail/any element contains:
    //    next: pointer to next,
    //    previous: pointer to previous,
    //    object: stored object.
    var list = {head: null, tail: null};
    list.add = function (obj) {
      var node = { object: obj, next: null, previous: null };
      if (list.head == null) {
        list.head = node;
        list.tail = node;
      } else {
        list.tail.next = node;
        node.previous = list.tail;
        list.tail = node;
      }
      return node;
    };
    list.remove = function (ptr) {
      var prev = ptr.previous;
      var next = ptr.next;

      if (prev == null && list.head !== ptr) {
        return;
      } else if (next == null && list.tail !== ptr) {
        return;
      }

      if (prev == null) { // ptr is head (or both head and tail)
        list.head = next;
        if (list.head != null) {
          list.head.previous = null;
        } else {
          list.tail = null;
        }
      } else if (next == null) { // ptr is tail (and not head)
        list.tail = prev;
        prev.next = null;
      } else { // ptr is inside
        prev.next = next;
        next.previous = prev;
      }
    };
    return list;
  };

  /**
   * Encrypts and signs the given message.
   * @memberof jiff.utils
   * @param {number/string} message - the message to encrypt.
   * @param {Uint8Array} encryption_public_key - ascii-armored public key to encrypt with.
   * @param {Uint8Array} signing_private_key - the private key of the encrypting party to sign with.
   * @returns {object} the signed cipher, includes two properties: 'cipher' and 'nonce'.
   */
  function encrypt_and_sign(jiff, message, encryption_public_key, signing_private_key) {
    var nonce = sodium_.randombytes_buf(sodium_.crypto_box_NONCEBYTES);
    var cipher = sodium_.crypto_box_easy(message, nonce, encryption_public_key, signing_private_key);

    var result = { nonce: '[' + nonce.toString() + ']', cipher: '[' + cipher.toString() + ']' };
    return result;
  }

  /**
   * Decrypts and checks the signature of the given cipher text.
   * @memberof jiff.utils
   * @param {object} cipher_text - the cipher text to decrypt, includes two properties: 'cipher' and 'nonce'.
   * @param {Uint8Array} decryption_secret_key - the secret key to decrypt with.
   * @param {Uint8Array} signing_public_key - ascii-armored public key to verify against signature.
   * @returns {number/string} the decrypted message if the signature was correct, the decrypted message type should
   *                          the type of operation, such that the returned value has the appropriate type and does
   *                          not need any type modifications.
   * @throws error if signature or nonce was forged/incorrect.
   */
  function decrypt_and_sign(jiff, cipher_text, decryption_secret_key, signing_public_key) {
    var nonce = new Uint8Array(JSON.parse(cipher_text.nonce));
    cipher_text = new Uint8Array(JSON.parse(cipher_text.cipher));

    try {
      return sodium_.crypto_box_open_easy(cipher_text, nonce, signing_public_key, decryption_secret_key, 'text');
    } catch (_) {
      throw new Error('Bad signature or Bad nonce: Cipher: ' + cipher_text + '.  DecSKey: ' + decryption_secret_key + '.  SignPKey: ' + signing_public_key);
    }
  }

  /**
   * Create an array of secret shares and associated deferred.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {number} count - number of secret shares.
   * @param {Array} holders - the parties that hold all the corresponding shares (must be sorted).
   * @param {number} threshold - the min number of parties needed to reconstruct the secret.
   * @param {number} Zp - the mod under which this share was created.
   * @return {object} the secret share object containing the give value.
   *
   */
  function many_secret_shares(jiff, count, holders, threshold, Zp) {
    var deferreds = [];
    var shares = [];
    for (var i = 0; i < count; i++) {
      var deferred = new jiff.helpers.Deferred;
      shares.push(jiff.secret_share(jiff, false, deferred.promise, undefined, holders, threshold, Zp));
      deferreds.push(deferred);
    }

    return { shares: shares, deferreds: deferreds };
  }

  /**
   * Resolve the array of deferreds with the values of the given shares when ready, matched by index.
   * @param {Deferred[]} deferreds - the deferred to resolve.
   * @param {SecretShare[]} shares - the shares to resolve with.
   */
  function resolve_many_secrets(deferreds, shares) {
    for (var i = 0; i < deferreds.length; i++) {
      shares[i].wThen(deferreds[i].resolve);
    }
  }

  /**
   * A high level combinator for iteration of bit arrays.
   * It executes a round of (func) starting from index 0 to the length.
   * Every round is blocked until the previous one finishes and the promise produced by it
   * is resolved.
   * The final value is used to resolve deferred.
   */
  function bit_combinator(deferred, start, length, initial, func, promisify, valufy) {
    if (promisify == null) {
      promisify = function (share) {
        return { then: share.wThen };
      }
    }

    if (valufy == null) {
      valufy = function (share) {
        return share.value;
      }
    }

    var next = start <= length ? 1 : -1;
    var __bit_combinator = function (start, val) {
      if (start === length) {
        // done
        deferred.resolve(valufy(val));
        return;
      }

      // execute func once
      val = func(start, val);

      // when done, do next iteration
      promisify(val).then(function () {
        __bit_combinator(start + next, val);
      });
    };

    // start combinator
    if (initial == null) {
      __bit_combinator(start, initial);
    } else {
      promisify(initial).then(function () {
        __bit_combinator(start, initial);
      });
    }
  }

  /**
   * Share given secret to the participating parties.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {number} secret - the secret to share.
   * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
   * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
   * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
   * @param {number} [Zp=jiff.Zp] - the mod (if null then the default Zp for the instance is used).
   * @param {string|number} [share_id=auto_gen()] - the tag used to tag the messages sent by this share operation, this tag is used
   *                                   so that parties distinguish messages belonging to this share operation from other
   *                                   share operations between the same parties (when the order of execution is not
   *                                   deterministic). An automatic id is generated by increasing a local counter, default
   *                                   ids suffice when all parties execute all sharing operations with the same senders
   *                                   and receivers in the same order.
   * @returns {object} a map where the key is the sender party id
   *          and the value is the share object that wraps
   *          what was sent from that party (the internal value maybe deferred).
   *          if the party that calls this function is not a receiver then the map
   *          will be empty.
   */
  function jiff_share(jiff, secret, threshold, receivers_list, senders_list, Zp, share_id) {
    var i, p_id;

    // defaults
    if (Zp == null) {
      Zp = jiff.Zp;
    }
    if (receivers_list == null) {
      receivers_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        receivers_list.push(i);
      }
    }
    if (senders_list == null) {
      senders_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        senders_list.push(i);
      }
    }
    if (threshold == null) {
      threshold = receivers_list.length;
    }
    if (threshold < 0) {
      threshold = 2;
    }
    if (threshold > receivers_list.length) {
      threshold = receivers_list.length;
    }

    // if party is uninvolved in the share, do nothing
    if (receivers_list.indexOf(jiff.id) === -1 && senders_list.indexOf(jiff.id) === -1) {
      return {};
    }

    // compute operation id
    if (share_id == null) {
      share_id = jiff.counters.gen_op_id2('share', receivers_list, senders_list);
    }

    // stage sending of shares
    if (senders_list.indexOf(jiff.id) > -1) {
      // Call hook
      secret = jiff.execute_array_hooks('beforeShare', [jiff, secret, threshold, receivers_list, senders_list, Zp], 1);

      // compute shares
      var shares = jiff.hooks.computeShares(jiff, secret, receivers_list, threshold, Zp);

      // Call hook
      shares = jiff.execute_array_hooks('afterComputeShare', [jiff, shares, threshold, receivers_list, senders_list, Zp], 1);

      // send shares
      for (i = 0; i < receivers_list.length; i++) {
        p_id = receivers_list[i];
        if (p_id === jiff.id) {
          continue;
        }

        // send encrypted and signed shares_id[p_id] to party p_id
        var msg = { party_id: p_id, share: shares[p_id], op_id: share_id };
        msg = jiff.execute_array_hooks('beforeOperation', [jiff, 'share', msg], 2);

        msg['share'] = jiff.hooks.encryptSign(jiff, msg['share'].toString(10), jiff.keymap[msg['party_id']], jiff.secret_key);
        jiff.socket.safe_emit('share', JSON.stringify(msg));
      }
    }

    // stage receiving of shares
    var result = {};
    if (receivers_list.indexOf(jiff.id) > -1) {
      // setup a map of deferred for every received share
      if (jiff.deferreds[share_id] == null) {
        jiff.deferreds[share_id] = {};
      }

      var _remaining = senders_list.length;
      for (i = 0; i < senders_list.length; i++) {
        p_id = senders_list[i];
        if (p_id === jiff.id) { // Keep party's own share
          var my_share = jiff.execute_array_hooks('receiveShare', [jiff, p_id, shares[p_id]], 2);
          result[p_id] = jiff.secret_share(jiff, true, null, my_share, receivers_list, threshold, Zp);
          _remaining--;
          continue;
        }

        // check if a deferred is set up (maybe the message was previously received)
        if (jiff.deferreds[share_id][p_id] == null) { // not ready, setup a deferred
          jiff.deferreds[share_id][p_id] = new jiff.helpers.Deferred;
        }

        var promise = jiff.deferreds[share_id][p_id].promise;
        // destroy deferred when done
        (function (promise, p_id) { // p_id is modified in a for loop, must do this to avoid scoping issues.
          promise.then(function () {
            delete jiff.deferreds[share_id][p_id];
            _remaining--;
            if (_remaining === 0) {
              delete jiff.deferreds[share_id];
            }
          });
        })(promise, p_id);

        // receive share_i[id] from party p_id
        result[p_id] = jiff.secret_share(jiff, false, promise, undefined, receivers_list, threshold, Zp);
      }
    }

    return result;
  }

  /**
   * Default way of computing shares (can be overridden using hooks).
   * Compute the shares of the secret (as many shares as parties) using Shamir secret sharing
   * @memberof jiff.sharing_schemes
   * @method shamir_share
   * @param {jiff-instance} jiff - the jiff instance
   * @param {number} secret - the secret to share.
   * @param {Array} parties_list - array of party ids to share with.
   * @param {number} threshold - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
   * @param {number} Zp - the mod.
   * @returns {object} a map between party number and its share, this means that (party number, share) is a
   *          point from the polynomial.
   *
   */
  function jiff_compute_shares(jiff, secret, parties_list, threshold, Zp) {
    var shares = {}; // Keeps the shares
    var i;

    // Each player's random polynomial f must have
    // degree threshold - 1, so that threshold many points are needed
    // to interpolate/reconstruct.
    var t = threshold - 1;
    var polynomial = Array(t + 1); // stores the coefficients

    // Each players's random polynomial f must be constructed
    // such that f(0) = secret
    polynomial[0] = secret;

    // Compute the random polynomial f's coefficients
    for (i = 1; i <= t; i++) {
      polynomial[i] = jiff.helpers.random(Zp);
    }

    // Compute each players share such that share[i] = f(i)
    for (i = 0; i < parties_list.length; i++) {
      var p_id = parties_list[i];
      shares[p_id] = polynomial[0];
      var power = jiff.helpers.get_party_number(p_id);

      for (var j = 1; j < polynomial.length; j++) {
        var tmp = jiff.helpers.mod((polynomial[j] * power), Zp);
        shares[p_id] = jiff.helpers.mod((shares[p_id] + tmp), Zp);
        power = jiff.helpers.mod(power * jiff.helpers.get_party_number(p_id), Zp);
      }
    }

    return shares;
  }

  /**
   * Store the received share and resolves the corresponding
   * deferred if needed.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {object} json_msg - the parsed json message as received.
   *
   */
  function receive_share(jiff, json_msg) {
    // Decrypt share
    json_msg['share'] = jiff.hooks.decryptSign(jiff, json_msg['share'], jiff.secret_key, jiff.keymap[json_msg['party_id']]);
    json_msg = jiff.execute_array_hooks('afterOperation', [jiff, 'share', json_msg], 2);

    var sender_id = json_msg['party_id'];
    var op_id = json_msg['op_id'];
    var share = json_msg['share'];

    // Call hook
    share = jiff.execute_array_hooks('receiveShare', [jiff, sender_id, share], 2);

    // check if a deferred is set up (maybe the share was received early)
    if (jiff.deferreds[op_id] == null) {
      jiff.deferreds[op_id] = {};
    }
    if (jiff.deferreds[op_id][sender_id] == null) {
      // Share is received before deferred was setup, store it.
      jiff.deferreds[op_id][sender_id] = new jiff.helpers.Deferred;
    }

    // Deferred is already setup, resolve it.
    jiff.deferreds[op_id][sender_id].resolve(share);
  }

  /**
   * Open up the given share to the participating parties.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {SecretShare} share - the share of the secret to open that belongs to this party.
   * @param {Array<number|string>} [parties=all_parties] - an array with party ids of receiving parties.
   * @param {string|number} [op_id=auto_gen()] - the operation id to be used to tag outgoing messages.
   * @returns {promise} a (JQuery) promise to the open value of the secret, null if the calling party is not a receiving party.
   * @throws error if share does not belong to the passed jiff instance.
   *
   */
  function jiff_open(jiff, share, parties, op_id) {
    var i;

    if (!(share.jiff === jiff)) {
      throw 'share does not belong to given instance';
    }

    // Default values
    if (parties == null || parties === []) {
      parties = [];
      for (i = 1; i <= jiff.party_count; i++) {
        parties.push(i);
      }
    }

    // If not a receiver nor holder, do nothing
    if (share.holders.indexOf(jiff.id) === -1 && parties.indexOf(jiff.id) === -1) {
      return null;
    }

    // Compute operation ids (one for each party that will receive a result
    if (op_id == null) {
      op_id = jiff.counters.gen_op_id2('open', parties, share.holders);
    }

    // Party is a holder
    if (share.holders.indexOf(jiff.id) > -1) {
      // Call hook
      share = jiff.execute_array_hooks('beforeOpen', [jiff, share, parties], 1);

      // refresh/reshare, so that the original share remains secret, instead
      // a new share is sent/open without changing the actual value.
      share = share.refresh(op_id + ':refresh');

      // The given share has been computed, broadcast it to all parties
      jiff.counters.pending_opens++;
      share.wThen(function () {
        jiff_broadcast(jiff, share, parties, op_id);
        jiff.counters.pending_opens--;
      }, share.error);
    }

    // Party is a receiver
    if (parties.indexOf(jiff.id) > -1) {
      var final_deferred = new jiff.helpers.Deferred; // will be resolved when the final value is reconstructed
      var final_promise = final_deferred.promise;

      if (jiff.deferreds[op_id] == null) {
        jiff.deferreds[op_id] = {};
      }

      jiff.deferreds[op_id].deferred = final_deferred;
      jiff.deferreds[op_id].threshold = share.threshold;
      jiff.deferreds[op_id].total = share.holders.length;
      if (jiff.deferreds[op_id].shares != null && jiff.deferreds[op_id].shares.length >= share.threshold) {
        final_deferred.resolve();
      }

      return final_promise.then(function () {
        var shares = jiff.deferreds[op_id].shares;

        if (shares.length === jiff.deferreds[op_id].total) {
          delete jiff.deferreds[op_id];
        } else {
          jiff.deferreds[op_id].deferred = 'CLEAN';
        }

        var recons_secret = jiff.hooks.reconstructShare(jiff, shares);
        recons_secret = jiff.execute_array_hooks('afterReconstructShare', [jiff, recons_secret], 1);
        return recons_secret;
      });
    }

    return null;
  }

  /**
   * Share the given share to all the parties in the jiff instance.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {SecretShare} share - the share.
   * @param {Array} parties - the parties to broadcast the share to.
   * @param {number|string} op_id - a unique operation id, used to tag outgoing messages.
   *
   */
  function jiff_broadcast(jiff, share, parties, op_id) {
    for (var index = 0; index < parties.length; index++) {
      var i = parties[index]; // Party id
      if (i === jiff.id) {
        receive_open(jiff, { party_id: i, share: share.value, op_id: op_id, Zp: share.Zp });
        continue;
      }

      // encrypt, sign and send
      var msg = {party_id: i, share: share.value, op_id: op_id, Zp: share.Zp};
      msg = jiff.execute_array_hooks('beforeOperation', [jiff, 'open', msg], 2);

      msg['share'] = jiff.hooks.encryptSign(jiff, msg['share'].toString(), jiff.keymap[msg['party_id']], jiff.secret_key);
      jiff.socket.safe_emit('open', JSON.stringify(msg));
    }
  }

  /**
   * Resolves the deferred corresponding to operation_id and sender_id.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {object} json_msg - the json message as received with the open event.
   *
   */
  function receive_open(jiff, json_msg) {
    // Decrypt share
    if (json_msg['party_id'] !== jiff.id) {
      json_msg['share'] = jiff.hooks.decryptSign(jiff, json_msg['share'], jiff.secret_key, jiff.keymap[json_msg['party_id']]);
      json_msg = jiff.execute_array_hooks('afterOperation', [jiff, 'open', json_msg], 2);
    }

    var sender_id = json_msg['party_id'];
    var op_id = json_msg['op_id'];
    var share = json_msg['share'];
    var Zp = json_msg['Zp'];

    // call hook
    share = jiff.execute_array_hooks('receiveOpen', [jiff, sender_id, share, Zp], 2);

    // Ensure deferred is setup
    if (jiff.deferreds[op_id] == null) {
      jiff.deferreds[op_id] = {};
    }
    if (jiff.deferreds[op_id].shares == null) {
      jiff.deferreds[op_id].shares = [];
    }

    // Accumulate received shares
    jiff.deferreds[op_id].shares.push({value: share, sender_id: sender_id, Zp: Zp});

    // Resolve when ready
    if (jiff.deferreds[op_id].shares.length === jiff.deferreds[op_id].threshold) {
      jiff.deferreds[op_id].deferred.resolve();
    }

    // Clean up if done
    if (jiff.deferreds[op_id] != null && jiff.deferreds[op_id].deferred === 'CLEAN' && jiff.deferreds[op_id].shares.length === jiff.deferreds[op_id].total) {
      delete jiff.deferreds[op_id];
    }
  }

  /**
   * Uses Lagrange polynomials to interpolate the polynomial
   * described by the given shares (points).
   * @memberof jiff.sharing_schemes
   * @method shamir_reconstruct
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {Array} shares - an array of objects representing shares to reconstruct, every object has 3 attributes: value, sender_id, Zp.
   * @returns {number} the value of the polynomial at x=0 (the secret value).
   *
   */
  function jiff_lagrange(jiff, shares) {
    var lagrange_coeff = []; // will contain shares.length many elements.

    // Compute the Langrange coefficients at 0.
    for (var i = 0; i < shares.length; i++) {
      var pi = jiff.helpers.get_party_number(shares[i].sender_id);
      lagrange_coeff[pi] = 1;

      for (var j = 0; j < shares.length; j++) {
        var pj = jiff.helpers.get_party_number(shares[j].sender_id);
        if (pj !== pi) {
          var inv = jiff.helpers.extended_gcd(pi - pj, shares[i].Zp)[0];
          lagrange_coeff[pi] = jiff.helpers.mod(lagrange_coeff[pi] * (0 - pj), shares[i].Zp) * inv;
          lagrange_coeff[pi] = jiff.helpers.mod(lagrange_coeff[pi], shares[i].Zp);
        }
      }
    }

    // Reconstruct the secret via Lagrange interpolation
    var recons_secret = 0;
    for (var p = 0; p < shares.length; p++) {
      var party = jiff.helpers.get_party_number(shares[p].sender_id);
      var tmp = jiff.helpers.mod((shares[p].value * lagrange_coeff[party]), shares[p].Zp);
      recons_secret = jiff.helpers.mod((recons_secret + tmp), shares[p].Zp);
    }

    return recons_secret;
  }

  /**
   * Requests secret(s) from the server (crypto provider) of type matching the given label.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {string} label - the type of secret(s) being requested from crypto_provider (e.g. triplet, bit, etc)
   * @param {Array} [receivers_list=all_parties] - array of party ids that want to receive the secret(s), by default, this includes all parties.
   * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret(s).
   * @param {number} [Zp=jiff_instance.Zp] - the mod, defaults to the Zp of the instance.
   * @param {string} [op_id=auto_Gen()] - an id which is used to identify the secret requested, so that every party
   *                              gets a share from the same secret for every matching instruction. An automatic id
   *                              is generated by increasing a local counter per label, default ids suffice when all
   *                              parties execute all instructions in the same order.
   * @param {object} [params={}] - any additional parameters specific to the label, these are defined by the label handler at the server side.
   *                               some of these parameters may be optional, while others may be required.
   * @returns {promise} a promise to the secret(s) provided by the server/crypto provider, the promise returns an object with the given format:
   *                               { values: <any values returned by the server side>, shares: <array of secret share objects matching shares returned by server by index>}
   */
  function from_crypto_provider(jiff, label, receivers_list, threshold, Zp, op_id, params) {
    // defaults
    if (Zp == null) {
      Zp = jiff.Zp;
    }
    if (receivers_list == null) {
      receivers_list = [];
      for (var i = 1; i <= jiff.party_count; i++) {
        receivers_list.push(i);
      }
    }
    if (threshold == null) {
      threshold = receivers_list.length;
    }
    if (op_id == null) {
      op_id = jiff.counters.gen_op_id('crypto_provider:' + label, receivers_list);
    }
    if (params == null) {
      params = {};
    }

    // Send a request to the server
    var msg = { label: label, op_id: op_id, receivers: receivers_list, threshold: threshold, Zp: Zp, params: params };
    msg = jiff.execute_array_hooks('beforeOperation', [jiff, 'crypto_provider', msg], 2);
    msg = JSON.stringify(msg);

    // Setup deferred to handle receiving the result later.
    jiff.deferreds[op_id] = new jiff.helpers.Deferred;
    var result = jiff.deferreds[op_id].promise;

    // send a request to the server.
    jiff.socket.safe_emit('crypto_provider', msg);
    return result;
  }

  /**
   * Parse server response and resolve associated promise.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {object} json_msg - the parsed json message as received by the crypto_provider event, contains 'values' and 'shares' attributes.
   *
   */
  function receive_crypto_provider(jiff, json_msg) {
    // Hook
    json_msg = jiff.execute_array_hooks('afterOperation', [jiff, 'crypto_provider', json_msg], 2);

    var op_id = json_msg['op_id'];
    if (jiff.deferreds[op_id] == null) {
      return;
    }

    // parse msg
    var receivers_list = json_msg['receivers'];
    var threshold = json_msg['threshold'];
    var Zp = json_msg['Zp'];

    // construct secret share objects
    var result = {};
    if (json_msg['values'] != null) {
      result.values = json_msg['values'];
    }
    if (json_msg['shares'] != null) {
      result.shares = [];
      for (var i = 0; i < json_msg['shares'].length; i++) {
        result.shares.push(jiff.secret_share(jiff, true, null, json_msg['shares'][i], receivers_list, threshold, Zp));
      }
    }

    // resolve deferred
    jiff.deferreds[op_id].resolve(result);
    delete jiff.deferreds[op_id];
  }

  /**
   * Can be used to generate shares of a random number, or shares of zero.
   * For a random number, every party generates a local random number and secret share it,
   * then every party sums its share, resulting in a single share of an unknown random number for every party.
   * The same approach is followed for zero, but instead, all the parties know that the total number is zero, but they
   * do not know the value of any resulting share (except their own).
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {number} n - the number to share.
   * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
   * @param {Array} [receivers_list=all_parties] - array of party ids to receive the result, by default, this includes all parties.
   * @param {Array} [compute_list=all_parties] - array of party ids to perform the protocol, by default, this includes all parties.
   * @param {number} [Zp=jiff.Zp] - the mod.
   * @param {object} [params={}] - an object containing extra parameters passed by the user.
   *                                 Expects:
   *                               - op_id: the base id to use for operation during the execution of this protocol, defaults to auto generated.
   *                               - compute_threshold: the threshold to use during computation: defaults to compute_list.length
   * @return {Object} contains 'share' (this party's share of the result) and 'promise'.
   */
  function jiff_share_all_number(jiff, n, threshold, receivers_list, compute_list, Zp, params) {
    var isSender = compute_list.indexOf(jiff.id) > -1;
    var isReceiver = receivers_list.indexOf(jiff.id) > -1;

    if (!isSender && !isReceiver) {
      return {};
    }

    if (params.compute_threshold == null) {
      params.compute_threshold = Math.min(threshold, compute_list.length);
    }

    var result, promise;
    if (isSender) {
      var shares = jiff.internal_share(n, params.compute_threshold, compute_list, compute_list, Zp, params.op_id + ':share');
      result = shares[compute_list[0]];
      for (var i = 1; i < compute_list.length; i++) {
        result = result.isadd(shares[compute_list[i]]);
      }
      promise = result.promise;
    }

    result = jiff.protocols.reshare(result, threshold, receivers_list, compute_list, Zp, params.op_id + ':reshare');
    if (receivers_list.indexOf(jiff.id) > -1) {
      promise = result.promise;
    }

    return {share: result, promise: promise};
  }

  /**
   * Share an array of values. Each sender may have an array of different length. This is handled by the lengths parameter.
   * This function will reveal the lengths of the shared array.
   * If parties would like to keep the lengths of their arrays secret, they should agree on some "max" length apriori (either under MPC
   * or as part of the logistics of the computation), all their arrays should be padded to that length by using appropriate default/identity
   * values.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {Array} array - the array to be shared.
   * @param {null|number|object} lengths - the lengths of the arrays to be shared, has the following options:
   *                                       1. null: lengths are unknown, each sender will publicly reveal the lengths of its own array.
   *                                       2. number: all arrays are of this length
   *                                       3. object: { <sender_party_id>: length }: must specify the length of the array for each sender.
   * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
   * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
   * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
   * @param {number} [Zp=jiff.Zp] - the mod.
   * @param {string|number} [share_id=auto_gen()] - the base tag used to tag the messages sent by this share operation, every element of the array
   *                                   will get a unique id based on the concatenation of base_share_id and the index of the element.
   *                                   This tag is used so that parties distinguish messages belonging to this share operation from
   *                                   other share operations between the same parties (when the order of execution is not
   *                                   deterministic). An automatic id is generated by increasing a local counter, default
   *                                   ids suffice when all parties execute all sharing operations with the same senders
   *                                   and receivers in the same order.
   * @return {promise} if the calling party is a receiver then a promise to the shared arrays is returned, the promise will provide an object
   *                    formatted as follows: { <party_id>: [ <1st_share>, <2nd_share>, ..., <(lengths[party_id])th_share> ] }
   *                    where the party_ids are those of the senders.
   *                    if the calling party is not a receiver, then null is returned.
   */
  function jiff_share_array(jiff, array, lengths, threshold, receivers_list, senders_list, Zp, share_id) {
    var i;

    // Check format of lengths
    if (lengths != null && typeof(lengths) !== 'number' && typeof(lengths) !== 'object') {
      throw new Error('share_array: unrecognized lengths');
    }

    // Default values
    if (receivers_list == null) {
      receivers_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        receivers_list.push(i);
      }
    }
    if (senders_list == null) {
      senders_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        senders_list.push(i);
      }
    }

    var isReceiving = receivers_list.indexOf(jiff.id) > -1;
    if (senders_list.indexOf(jiff.id) === -1 && !isReceiving) {
      return null;
    } // This party is neither a sender nor a receiver, do nothing!

    // compute operation id
    if (share_id == null) {
      share_id = jiff.counters.gen_op_id2('share_array', receivers_list, senders_list);
    }

    // wrap around result of share_array
    var share_array_deferred = new jiff.helpers.Deferred;
    var share_array_promise = share_array_deferred.promise;

    // figure out lengths by having each party emit their length publicly
    if (lengths == null) {
      lengths = {};
      var total = 0;
      if (senders_list.indexOf(jiff.id) > -1) {
        lengths[jiff.id] = array.length;

        // send the length of this party's array to all receivers
        jiff.emit(share_id + 'length', receivers_list, array.length.toString(10));
      }

      jiff.listen(share_id + 'length', function (sender, message) {
        lengths[sender] = parseInt(message, 10);
        total++;
        if (total === senders_list.length) {
          jiff.remove_listener(share_id + 'length');
          share_array_deferred.resolve(lengths);
        }
      });
    } else if (typeof(lengths) === 'number') {
      // All arrays are of the same length
      var l = lengths;
      lengths = {};
      for (i = 0; i < senders_list.length; i++) {
        lengths[senders_list[i]] = l;
      }

      share_array_deferred.resolve(lengths);
    } else {
      // Lengths of the different arrays are all provided
      for (i = 0; i < senders_list.length; i++) {
        if (lengths[senders_list[i]] == null) {
          throw new Error('share_array: missing length');
        }
      }

      share_array_deferred.resolve(lengths);
    }

    // lengths are now set, start sharing
    share_array_promise = share_array_promise.then(function (lengths) {
      // compute the number of sharing rounds
      var max = 0;
      for (i = 0; i < senders_list.length; i++) {
        var l = lengths[senders_list[i]];
        max = l > max ? l : max;
      }

      // Store results here
      var results = {};
      if (isReceiving) {
        for (i = 0; i < senders_list.length; i++) {
          results[senders_list[i]] = [];
        }
      }

      // share every round
      for (var r = 0; r < max; r++) {
        var round_senders = [];
        for (i = 0; i < senders_list.length; i++) {
          if (lengths[senders_list[i]] > r) {
            round_senders.push(senders_list[i]);
          }
        }

        var value = (senders_list.indexOf(jiff.id) > -1) && (r < array.length) ? array[r] : null;
        var round_results = jiff.share(value, threshold, receivers_list, round_senders, Zp, share_id + 'round:' + r);

        for (var sender_id in round_results) {
          if (round_results.hasOwnProperty(sender_id)) {
            results[sender_id].push(round_results[sender_id]);
          }
        }
      }

      return results;
    });

    return isReceiving ? share_array_promise : null;
  }

  /**
   * Share an array of values. Each sender may have an array of different length. This is handled by the lengths parameter.
   * This function will reveal the lengths of the shared array.
   * If parties would like to keep the lengths of their arrays secret, they should agree on some "max" length apriori (either under MPC
   * or as part of the logistics of the computation), all their arrays should be padded to that length by using appropriate default/identity
   * values.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {Array} array - the array to be shared.
   * @param {null|number|object} lengths - the lengths of the arrays to be shared. For this to work successfully, the
   *                                       same exact value must be used in the calling code for each party. Any missing
   *                                       lengths for a row will be automatically publicly revealed by this function.
   *                                       Must have the following format:
   *                                       1. null: lengths are unknown, each sender will publicly reveal the lengths of its own array.
   *                                       2. { rows: <number>, cols: <number>, 0: <number>, 1: <number>, ...}: all parties have arrays
   *                                          with the given number of rows and cols. In case of jagged 2D arrays, different rows
   *                                          can have a different number of cols specified by using <row_index>: <col_size>.
   *                                          rows is mandatory, cols and any other number matching a specific row are optional.
   *                                       3. { <sender_party_id>: <length_object> }: must specify the lengths for each party by using
   *                                          an object with the same format as 2. Must include every party.
   * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
   * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
   * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
   * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
   * @param {string|number} [share_id=auto_gen()] - the base tag used to tag the messages sent by this share operation, every element of the array
   *                                   will get a unique id based on the concatenation of base_share_id and the index of the element.
   *                                   This tag is used so that parties distinguish messages belonging to this share operation from
   *                                   other share operations between the same parties (when the order of execution is not
   *                                   deterministic). An automatic id is generated by increasing a local counter, default
   *                                   ids suffice when all parties execute all sharing operations with the same senders
   *                                   and receivers in the same order.
   * @returns {promise} if the calling party is a receiver then a promise to the shared arrays is returned, the promise will provide an object
   *                    formatted as follows: { <party_id>: [ [ <1st_row_shares> ], [<2nd_row_share> ], ..., [ <(lengths[party_id])th_row_shares> ] ] }
   *                    where the party_ids are those of the senders.
   *                    if the calling party is not a receiver, then null is returned.
   */
  function jiff_share_2D_array(jiff, array, lengths, threshold, receivers_list, senders_list, Zp, share_id) {
    var i;

    // Check format of lengths
    if (lengths != null && typeof(lengths) !== 'object') {
      throw new Error('share_array: unrecognized lengths');
    }

    // Default values
    if (receivers_list == null) {
      receivers_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        receivers_list.push(i);
      }
    }
    if (senders_list == null) {
      senders_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        senders_list.push(i);
      }
    }

    var isReceiving = receivers_list.indexOf(jiff.id) > -1;
    if (senders_list.indexOf(jiff.id) === -1 && !isReceiving) {
      // This party is neither a sender nor a receiver, do nothing!
      return null;
    }

    // compute operation id
    if (share_id == null) {
      share_id = jiff.counters.gen_op_id2('share_2D_array', receivers_list, senders_list);
    }

    // wrap around result of share_array
    var lengths_deferred = new jiff.helpers.Deferred;
    var lengths_promise = lengths_deferred.promise;

    // figure out lengths by having each party emit their length publicly
    if (lengths == null) {
      lengths = {};
      var total = 0;
      if (senders_list.indexOf(jiff.id) > -1) {
        lengths[jiff.id] = array.length;

        // send the length of this party's array to all receivers
        jiff.emit(share_id + 'length', receivers_list, array.length.toString(10));
      }

      jiff.listen(share_id + 'length', function (sender, message) {
        lengths[sender] = { rows: parseInt(message, 10) };
        total++;
        if (total === senders_list.length) {
          jiff.remove_listener(share_id + 'length');
          lengths_deferred.resolve(lengths);
        }
      });
    } else if (typeof(lengths.rows) === 'number') {
      // All arrays are of the same length
      var l = lengths;
      lengths = {};
      for (i = 0; i < senders_list.length; i++) {
        lengths[senders_list[i]] = l;
      }

      lengths_deferred.resolve(lengths);
    } else {
      // Lengths of the different arrays are all provided
      for (i = 0; i < senders_list.length; i++) {
        if (lengths[senders_list[i]] == null || lengths[senders_list[i]].rows == null) {
          throw new Error('share_2D_array: missing rows length');
        }
      }

      lengths_deferred.resolve(lengths);
    }

    // Final results
    var share_array_deferred = new jiff.helpers.Deferred;
    var share_array_promise = share_array_deferred.promise;

    // lengths are now set, start sharing
    lengths_promise.then(function (lengths) {
      // compute the number of sharing rounds
      var max = 0;
      for (i = 0; i < senders_list.length; i++) {
        var l = lengths[senders_list[i]].rows;
        max = l > max ? l : max;
      }

      // share every round
      var promises = [];
      for (var r = 0; r < max; r++) {
        var round_senders = [];
        for (i = 0; i < senders_list.length; i++) {
          if (lengths[senders_list[i]].rows > r) {
            round_senders.push(senders_list[i]);
          }
        }

        var row_lengths = {};
        var empty = false;
        for (var p = 0; p < round_senders.length; p++) {
          var pid = round_senders[p];
          row_lengths[pid] = lengths[pid].cols;
          if (lengths[pid][r] != null) {
            row_lengths[pid] = lengths[pid][r];
          }
          if (row_lengths[pid] == null) {
            empty = true;
          }
        }

        var row = r < array.length ? array[r] : [];
        row_lengths = empty ? null : row_lengths;
        var round_results = jiff.share_array(row, row_lengths, threshold, receivers_list, round_senders, Zp, share_id + 'row' + r + ':');
        promises.push(round_results);
      }

      // Wait for every promises corresponding to every row
      return Promise.all(promises).then(function (intermediate_results) {
        // Store results here
        var results = {};
        if (isReceiving) {
          for (i = 0; i < senders_list.length; i++) {
            results[senders_list[i]] = [];
          }
        }

        for (i = 0; i < intermediate_results.length; i++) {
          var round = intermediate_results[i];
          for (var sender_id in round) {
            if (round.hasOwnProperty(sender_id)) {
              results[sender_id].push(round[sender_id]);
            }
          }
        }

        share_array_deferred.resolve(results);
      });
    });

    return isReceiving ? share_array_promise : null;
  }

  /**
   * Opens a bunch of secret shares.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {SecretShare[]} shares - an array containing this party's shares of the secrets to reconstruct.
   * @param {Array} [parties=all_parties] - an array with party ids (1 to n) of receiving parties.
   * @param {string|number} [op_id=auto_gen()] - same as jiff_instance.open
   * @returns {promise} a (JQuery) promise to ALL the open values of the secret, the promise will yield
   *                    an array of values matching the corresponding given secret share by index.
   * @throws error if some shares does not belong to the passed jiff instance.
   */
  function jiff_open_array(jiff, shares, parties, op_id) {
    // Default values
    if (parties == null || parties === []) {
      parties = [];
      for (i = 1; i <= jiff.party_count; i++) {
        parties.push(i);
      }
    }

    // Compute operation ids (one for each party that will receive a result
    if (op_id == null) {
      op_id = jiff.counters.gen_op_id2('open_array', parties, shares[0].holders);
    }

    var promises = [];
    for (var i = 0; i < shares.length; i++) {
      var promise = jiff.open(shares[i], parties, op_id + ':' + i);
      if (promise != null) {
        promises.push(promise);
      }
    }

    if (promises.length === 0) {
      return null;
    }

    return Promise.all(promises);
  }

  /**
   * Called when this party receives a custom tag message from any party (including itself).
   * If a custom listener was setup to listen to the tag, the message is passed to the listener.
   * Otherwise, the message is stored until such a listener is provided.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {object} json_msg - the parsed json message as received by the custom event.
   *
   */
  function receive_custom(jiff, json_msg) {
    if (json_msg['encrypted'] === true) {
      json_msg['message'] = jiff.hooks.decryptSign(jiff, json_msg['message'], jiff.secret_key, jiff.keymap[json_msg['party_id']]);
    }

    if (json_msg['party_id'] !== jiff.id) {
      json_msg = jiff.execute_array_hooks('afterOperation', [jiff, 'custom', json_msg], 2);
    }

    var sender_id = json_msg['party_id'];
    var tag = json_msg['tag'];
    var message = json_msg['message'];

    if (jiff.listeners[tag] != null) {
      jiff.listeners[tag](sender_id, message);
    } else { // Store message until listener is provided
      var stored_messages = jiff.custom_messages_mailbox[tag];
      if (stored_messages == null) {
        stored_messages = [];
        jiff.custom_messages_mailbox[tag] = stored_messages;
      }

      stored_messages.push({sender_id: sender_id, message: message});
    }
  }

  /**
   * Secret share objects: provides API to perform operations on shares securly, wrap promises
   * and communication primitives to ensure operations are executed when shares are available (asynchronously)
   * without requiring the user to perform promise management/synchronization.
   * @namespace SecretShare
   */

  /**
   * Create a new share.
   * A share is a value wrapper with a share object, it has a unique id
   * (per computation instance), and a pointer to the instance it belongs to.
   * A share also has methods for performing operations.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {boolean} ready - whether the value of the share is ready or deferred.
   * @param {promise} promise - a promise to the value of the share.
   * @param {number} value - the value of the share (null if not ready).
   * @param {Array} holders - the parties that hold all the corresponding shares (must be sorted).
   * @param {number} threshold - the min number of parties needed to reconstruct the secret.
   * @param {number} Zp - the mod under which this share was created.
   * @return {SecretShare} the secret share object containing the give value.
   *
   */
  function secret_share(jiff, ready, promise, value, holders, threshold, Zp) {
    /**
     * Internal helpers for operations inside/on a share. This is not exposed to the external code,
     * except through the createSecretShare hook. Modify existing helpers or add more in your extensions
     * to avoid having to re-write and duplicate the code for primitives.
     */
    var share_helpers = {
      '+': function (v1, v2) {
        return v1 + v2;
      },
      '-': function (v1, v2) {
        return v1 - v2;
      },
      '*': function (v1, v2) {
        return v1 * v2;
      },
      '/': function (v1, v2) {
        return v1 / v2;
      },
      '<': function (v1, v2) {
        return v1 < v2;
      },
      '<=': function (v1, v2) {
        return v1 <= v2;
      },
      'floor': function (v) {
        return Math.floor(v);
      },
      'ceil': function (v) {
        return Math.ceil(v);
      },
      'floor/': function (v1, v2) {
        return Math.floor(v1 / v2);
      },
      'pow': function (v1, v2) {
        return Math.pow(v1, v2);
      },
      'binary': function (v) {
        return v === 1 || v === 0;
      },
      'abs': function (v) {
        return Math.abs(v);
      },
      '==': function (v1, v2) {
        return v1 === v2;
      }
    };

    var self = {};

    /**
     * @member {jiff-instance} jiff
     * @memberof SecretShare
     * @instance
     */
    self.jiff = jiff;

    /**
     * @member {boolean} ready
     * @memberof SecretShare
     * @instance
     */
    self.ready = ready;

    /**
     * @member {promise} promise
     * @memberof SecretShare
     * @instance
     */
    self.promise = promise;
    /**
     * @member {number} value
     * @memberof SecretShare
     * @instance
     */
    self.value = value;
    /**
     * @member {Array} holders
     * @memberof SecretShare
     * @instance
     */
    self.holders = holders;
    /**
     * @member {Array} threshold
     * @memberof SecretShare
     * @instance
     */
    self.threshold = threshold;
    /**
     * @member {number} Zp
     * @memberof SecretShare
     * @instance
     */
    self.Zp = Zp;

    /**
     * Gets the value of this share.
     * @method valueOf
     * @returns {number} the value (undefined if not ready yet).
     * @memberof SecretShare
     * @instance
     */
    self.valueOf = function () {
      if (ready) {
        return self.value;
      } else {
        return undefined;
      }
    };

    /**
     * Gets a string representation of this share.
     * @method toString
     * @returns {string} the id and value of the share as a string.
     * @memberof SecretShare
     * @instance
     */
    self.toString = function () {
      var val = self.ready ? self.value : '<deferred>';
      return 'share: ' + val + '. Holders: ' + JSON.stringify(self.holders) + '. Threshold: ' + self.threshold + '. Zp: ' + self.Zp.toString() + '.';
    };

    /**
     * Logs an error.
     * @method error
     * @memberof SecretShare
     * @instance
     */
    self.error = self.jiff.error.bind(null, 'secret-share');

    /**
     * Logs the value represented by this share to the console.
     * WARNING: THIS LEAKS INFORMATION AND MUST BE USED ONLY TO DEBUG ON FAKE DATA.
     * @method logLEAK
     * @memberof SecretShare
     * @instance
     * @param {string} tag - accompanying tag to display in the console.
     * @param {Array<number|string>} [parties=[holders[0]] - the parties which will display the log.
     * @return {promise} a promise to the value represented by this share after logging it, null if party is not in parties.
     */
    self.logLEAK = function (tag, parties) {
      if (parties == null) {
        parties = [self.holders[0]];
      }
      var promise = self.open(parties, tag);
      if (promise != null) {
        promise = promise.then(function (result) {
          console.log(tag, result.toString());
          return result;
        });
      }
      return promise;
    };

    /**
     * Receives the value of this share when ready.
     * @method receive_share
     * @param {number} value - the value of the share.
     * @memberof SecretShare
     * @instance
     */
    self.receive_share = function (value) {
      self.value = value;
      self.ready = true;
      self.promise = null;
    };

    /**
     * Joins the pending promises of this share and the given share.
     * @method pick_promise
     * @param {SecretShare} o - the other share object.
     * @returns {promise} the joined promise for both shares (or whichever is pending).
     * @memberof SecretShare
     * @instance
     */
    self.pick_promise = function (o) {
      if (self.ready && o.ready) {
        return null;
      }

      if (self.ready) {
        return o.promise;
      } else if (o.ready) {
        return self.promise;
      } else {
        return Promise.all([self.promise, o.promise]);
      }
    };

    /**
     * Checks if the given parameter is a constant, used to determine whether constant or secret
     * operations should be executed.
     * @param {number/object} o - the parameter to determine.
     * @return {boolean} true if o is a valid constant, false otherwise.
     */
    self.isConstant = function (o) {
      return typeof(o) === 'number';
    };

    /**
     * Reshares/refreshes the sharing of this number, used before opening to keep the share secret.
     * @method refresh
     * @param {string} [op_id=auto_gen()] - the operation id with which to tag the messages sent by this refresh, by default
     *                         an automatic operation id is generated by increasing a local counter, default operation ids
     *                         suffice when all parties execute the instructions in the same order.
     * @returns {SecretShare} a new share of the same number.
     * @memberof SecretShare
     * @instance
     */
    self.refresh = function (op_id) {
      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('refresh', self.holders);
      }

      // final result
      var final_deferred = new self.jiff.helpers.Deferred;
      var final_promise = final_deferred.promise;
      var result = self.jiff.secret_share(self.jiff, false, final_promise, undefined, self.holders, self.threshold, self.Zp);

      // refresh
      var ready_number = function (zero) {
        self.isadd(zero).wThen(final_deferred.resolve);
      };

      // get shares of zero
      var zero = self.jiff.get_preprocessing(op_id);
      if (zero == null) {
        var promise = self.jiff.from_crypto_provider('numbers', self.holders, self.threshold, self.Zp, op_id, {number: 0, count: 1});
        promise.then(function (msg) {
          ready_number(msg['shares'][0]);
        });
      } else {
        ready_number(zero);
      }

      return result;
    };

    /**
     * Shortcut for opening/revealing the value of this share. Alias for open in jiff-instance.
     * @see jiff-instance#open
     * @method open
     * @memberof SecretShare
     * @instance
     * @param {Array} [parties=all_parties] - an array with party ids (1 to n) of receiving parties.
     * @param {string|number|object} [op_id=auto_gen()] - same as jiff_instance.open
     * @returns {promise|null} a (JQuery) promise to the open value of the secret, null if the party is not specified in the parties array as a receiver.
     */
    self.open = function (parties, op_id) {
      return self.jiff.open(self, parties, op_id);
    };

    /**
     * Generic Addition.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method add
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     * @example
     * var shares = jiff_instance.share(input);
     * // this will add two secret shared values together
     * var result = shares[1].add(shares[2]);
     * // this will add 3 to the secret input from party 1
     * var constant_sum = shares[1].add(3);
     */
    self.add = function (o) {
      if (self.isConstant(o)) {
        return self.cadd(o);
      }
      return self.sadd(o);
    };


    /**
     * Generic Subtraction.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method sub
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.sub = function (o) {
      if (self.isConstant(o)) {
        return self.csub(o);
      }
      return self.ssub(o);
    };


    /**
     * Generic Multiplication.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method mult
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this multiplication (and internally, the corresponding beaver triplet).
     *                         This id must be unique, and must be passed by all parties to the same instruction.
     *                         this ensures that every party gets a share from the same triplet for every matching instruction. An automatic id
     *                         is generated by increasing a local counter, default ids suffice when all parties execute the
     *                         instructions in the same order. Only used if secret multiplication is used.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.mult = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.cmult(o);
      }
      return self.smult(o, op_id);
    };


    /**
     * Generic XOR for bits (both this and o have to be bits to work correctly).
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method xor_bit
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     *                         Only used if secret xor is used..
     * @return {SecretShare} this party's share of the result, the final result is 1 if this < o, and 0 otherwise.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.xor_bit = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.cxor_bit(o);
      }
      return self.sxor_bit(o, op_id);
    };

    /**
     * Generic OR for bits (both this and o have to be bits to work correctly).
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method or_bit
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     *                         Only used if secret or is used..
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.or_bit = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.cor_bit(o);
      }
      return self.sor_bit(o, op_id);
    };

    /**
     * Generic Greater or equal.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method gteq
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.gteq = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.cgteq(o, op_id);
      }
      return self.sgteq(o);
    };


    /**
     * Generic Greater than.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method gt
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.gt = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.cgt(o, op_id);
      }
      return self.sgt(o, op_id);
    };


    /**
     * Generic Less or equal.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method lteq
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.lteq = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.clteq(o, op_id);
      }
      return self.slteq(o, op_id);
    };


    /**
     * Generic Less than.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method lt
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.lt = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.clt(o, op_id);
      }
      return self.slt(o, op_id);
    };


    /**
     * Generic Equals.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method eq
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.eq = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.ceq(o, op_id);
      }
      return self.seq(o, op_id);
    };


    /**
     * Generic Not Equals.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method neq
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.neq = function (o, op_id) {
      if (self.isConstant(o)) {
        return self.cneq(o, op_id);
      }
      return self.sneq(o, op_id);
    };


    /**
     * Generic Integer Divison.
     * Uses either the constant or secret version of this operator depending on type of paramter.
     * @method div
     * @param {number|SecretShare} o - the other operand (can be either number or share).
     * @param {number} l - the maximum bit length of the two shares.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.div = function (o, l, op_id) {
      if (self.isConstant(o)) {
        return self.cdiv(o, l, op_id);
      }
      return self.sdiv(o, l, op_id);
    };

    /**
     * Addition with a constant.
     * @method cadd
     * @param {number} cst - the constant to add.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.cadd = function (cst) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (+)');
      }

      if (self.ready) {
        // if share is ready
        return self.jiff.secret_share(self.jiff, true, null, self.jiff.helpers.mod(share_helpers['+'](self.value, cst), self.Zp), self.holders, self.threshold, self.Zp);
      }

      var promise = self.promise.then(function () {
        return self.jiff.helpers.mod(share_helpers['+'](self.value, cst), self.Zp);
      }, self.error);
      return self.jiff.secret_share(self.jiff, false, promise, undefined, self.holders, self.threshold, self.Zp);
    };

    /**
     * Subtraction with a constant.
     * @method csub
     * @param {number} cst - the constant to subtract from this share.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.csub = function (cst) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (-)');
      }

      if (self.ready) {
        // if share is ready
        return self.jiff.secret_share(self.jiff, true, null, self.jiff.helpers.mod(share_helpers['-'](self.value, cst), self.Zp), self.holders, self.threshold, self.Zp);
      }

      var promise = self.promise.then(function () {
        return self.jiff.helpers.mod(share_helpers['-'](self.value, cst), self.Zp);
      }, self.error);
      return self.jiff.secret_share(self.jiff, false, promise, undefined, self.holders, self.threshold, self.Zp);
    };

    /**
     * Multiplication by a constant.
     * @method cmult
     * @param {number} cst - the constant to multiply to this share.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.cmult = function (cst) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (*)');
      }

      if (self.ready) {
        // if share is ready
        return self.jiff.secret_share(self.jiff, true, null, self.jiff.helpers.mod(share_helpers['*'](self.value, cst), self.Zp), self.holders, self.threshold, self.Zp);
      }

      var promise = self.promise.then(function () {
        return self.jiff.helpers.mod(share_helpers['*'](self.value, cst), self.Zp);
      }, self.error);
      return self.jiff.secret_share(self.jiff, false, promise, undefined, self.holders, self.threshold, self.Zp);
    };

    /**
     * Division by a constant factor of the number represented by the share.
     * @method cdivfac
     * @param {number} cst - the constant by which to divide the share.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.cdivfac = function (cst) {
      if (!(self.isConstant(cst))) {
        throw new Error('Parameter should be a number (cdivfac)');
      }

      var inv = self.jiff.helpers.extended_gcd(cst, self.Zp)[0];

      if (self.ready) {
        // If share is ready.
        return self.jiff.secret_share(self.jiff, true, null, self.jiff.helpers.mod(share_helpers['*'](self.value, inv), self.Zp), self.holders, self.threshold, self.Zp);
      }

      var promise = self.promise.then(function () {
        return self.jiff.helpers.mod(share_helpers['*'](self.value, inv), self.Zp);
      }, self.error);
      return self.jiff.secret_share(self.jiff, false, promise, undefined, self.holders, self.threshold, self.Zp);
    };

    /**
     * Addition of two secret shares.
     * @method sadd
     * @param {SecretShare} o - the share to add to this share.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     *
     * @example
     * // share a value with all parties, and sum the values of all shares
     * var shares = jiff_instance.share(x);
     * var sum = shares[1];
     * for (var i = 2; i <= jiff_instance.party_count; i++) {
     *  sum = sum.sadd(shares[i]);
     * }
     *
     */
    self.sadd = function (o) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (+)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (+)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (+)');
      }

      // add the two shares when ready locally
      var ready_add = function () {
        return self.jiff.helpers.mod(share_helpers['+'](self.value, o.value), self.Zp);
      };

      if (self.ready && o.ready) {
        // both shares are ready
        return self.jiff.secret_share(self.jiff, true, null, ready_add(), self.holders, max(self.threshold, o.threshold), self.Zp);
      }

      // promise to execute ready_add when both are ready
      var promise = self.pick_promise(o).then(ready_add, self.error);
      return self.jiff.secret_share(self.jiff, false, promise, undefined, self.holders, max(self.threshold, o.threshold), self.Zp);
    };

    /**
     * Subtraction of two secret shares.
     * @method ssub
     * @param {SecretShare} o - the share to subtract from this share.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.ssub = function (o) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (-)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (-)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (-)');
      }

      // add the two shares when ready locally
      var ready_sub = function () {
        return self.jiff.helpers.mod(share_helpers['-'](self.value, o.value), self.Zp);
      };

      if (self.ready && o.ready) {
        // both shares are ready
        return self.jiff.secret_share(self.jiff, true, null, ready_sub(), self.holders, max(self.threshold, o.threshold), self.Zp);
      }

      // promise to execute ready_add when both are ready
      var promise = self.pick_promise(o).then(ready_sub, self.error);
      return self.jiff.secret_share(self.jiff, false, promise, undefined, self.holders, max(self.threshold, o.threshold), self.Zp);
    };

    /**
     * Multiplication of two secret shares through Beaver Triplets.
     * @method smult
     * @param {SecretShare} o - the share to multiply with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this multiplication (and internally, the corresponding beaver triplet).
     *                         This id must be unique, and must be passed by all parties to the same instruction.
     *                         this ensures that every party gets a share from the same triplet for every matching instruction. An automatic id
     *                         is generated by increasing a local counter, default ids suffice when all parties execute the
     *                         instructions in the same order.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.smult = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (*)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (*)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (*)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('smult', self.holders);
      }

      // final result
      var final_deferred = new self.jiff.helpers.Deferred;
      var final_promise = final_deferred.promise;
      var result = self.jiff.secret_share(self.jiff, false, final_promise, undefined, self.holders, max(self.threshold, o.threshold), self.Zp);

      // called when triplet is ready
      var ready_triplet = function (triplet) {
        var a = triplet[0];
        var b = triplet[1];
        var c = triplet[2];

        // d = s - a. e = o - b.
        var d = self.isadd(a.icmult(-1));
        var e = o.isadd(b.icmult(-1));

        // Open d and e.
        // The only communication cost.
        var e_promise = self.jiff.internal_open(e, e.holders, op_id + ':open1');
        var d_promise = self.jiff.internal_open(d, d.holders, op_id + ':open2');
        Promise.all([e_promise, d_promise]).then(function (arr) {
          var e_open = arr[0];
          var d_open = arr[1];

          // result_share = d_open * e_open + d_open * b_share + e_open * a_share + c.
          var t1 = self.jiff.helpers.mod(share_helpers['*'](d_open, e_open), self.Zp);
          var t2 = b.icmult(d_open);
          var t3 = a.icmult(e_open);

          // All this happens locally.
          var final_result = t2.icadd(t1);
          final_result = final_result.isadd(t3);
          final_result = final_result.isadd(c);

          final_result.wThen(final_deferred.resolve);
        });
      };

      // Get shares of triplets.
      var triplet = self.jiff.get_preprocessing(op_id + ':triplet');
      if (triplet == null) {
        var promise = jiff.from_crypto_provider('triplet', self.holders, max(self.threshold, o.threshold), self.Zp, op_id + ':triplet');
        promise.then(function (msg) {
          ready_triplet(msg['shares']);
        });
      } else {
        ready_triplet(triplet);
      }

      return result;
    };

    /**
     * Multiplication of two secret shares through BGW protocol.
     * @method smult_bgw
     * @param {SecretShare} o - the share to multiply with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this multiplication (and internally, the corresponding beaver triplet).
     *                         This id must be unique, and must be passed by all parties to the same instruction.
     *                         this ensures that every party gets a share from the same triplet for every matching instruction. An automatic id
     *                         is generated by increasing a local counter, default ids suffice when all parties execute the
     *                         instructions in the same order.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.smult_bgw = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (bgw*)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (bgw*)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (bgw*)');
      }
      if ((self.threshold - 1) + (o.threshold - 1) > self.holders.length - 1) {
        throw new Error('threshold too high for BGW (*)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('smult_bgw', self.holders);
      }

      var new_threshold = (self.threshold - 1) + (o.threshold - 1) + 1;
      if (new_threshold > self.holders) {
        var errorMsg = 'Threshold too large for smult_bgw: ' + new_threshold;
        errorMsg += '. Shares: ' + self.toString() + ', ' + o.toString();
        throw new Error(errorMsg);
      }

      var final_deferred = new self.jiff.helpers.Deferred;
      var final_promise = final_deferred.promise;
      var result = self.jiff.secret_share(self.jiff, false, final_promise, undefined, self.holders, new_threshold, self.Zp);

      Promise.all([self.promise, o.promise]).then(
        function () {
          // Get Shares  of z
          var zi = self.jiff.helpers.mod(share_helpers['*'](self.value, o.value), self.Zp);
          final_deferred.resolve(zi);
        });

      return self.jiff.protocols.reshare(result, max(self.threshold, o.threshold), result.holders, result.holders, result.Zp, op_id + ':threshold');
    };

    /**
     * bitwise-XOR with a constant (BOTH BITS).
     * @method cxor_bit
     * @param {number} cst - the constant bit to XOR with (0 or 1).
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.cxor_bit = function (cst) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (^)');
      }
      if (!share_helpers['binary'](cst)) {
        throw new Error('parameter should be binary (^)');
      }

      return self.icadd(cst).issub(self.icmult(cst).icmult(2));
    };

    /**
     * bitwise-OR with a constant (BOTH BITS).
     * @method cor_bit
     * @param {number} cst - the constant bit to OR with (0 or 1).
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.cor_bit = function (cst) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (|)');
      }
      if (!share_helpers['binary'](cst)) {
        throw new Error('parameter should be binary (|)');
      }

      return self.icadd(cst).issub(self.icmult(cst));
    };

    /**
     * bitwise-XOR of two secret shares OF BITS.
     * @method sxor_bit
     * @param {SecretShare} o - the share to XOR with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this < o, and 0 otherwise.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.sxor_bit = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (^)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (^)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (^)');
      }
      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('sxor_bit', self.holders);
      }

      return self.isadd(o).issub(self.ismult(o, op_id + ':smult1').icmult(2));
    };

    /**
     * OR of two secret shares OF BITS.
     * @method sor_bit
     * @param {SecretShare} o - the share to OR with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this < o, and 0 otherwise.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.sor_bit = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (|)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (|)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (|)');
      }
      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('sor_bit', self.holders);
      }

      return self.isadd(o).issub(self.ismult(o, op_id + ':smult1'));
    };

    /**
     * Greater than or equal with another share.
     * @method sgteq
     * @param {SecretShare} o - the other share.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this >= o, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.sgteq = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (>=)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (>=)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (>=)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('sgteq',self.holders);
      }

      return self.islt(o, op_id).inot();
    };

    /**
     * Greater than with another share.
     * @method sgt
     * @param {SecretShare} o - the other share.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this > o, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.sgt = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (>)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (>)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (>)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('sgt', self.holders);
      }

      return o.islt(self, op_id);
    };

    /**
     * Less than or equal with another share.
     * @method slteq
     * @param {SecretShare} o - the other share.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this <= o, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.slteq = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (<=)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (<=)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (<=)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('slteq', self.holders);
      }

      return o.islt(self, op_id).inot();
    };

    /**
     * Less than with another share.
     * @method slt
     * @param {SecretShare} o - the other share.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this < o, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.slt = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (<)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (<)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (<)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('slt', self.holders);
      }

      var final_deferred = new self.jiff.helpers.Deferred;
      var final_promise = final_deferred.promise;
      var result = self.jiff.secret_share(self.jiff, false, final_promise, undefined, self.holders, max(self.threshold, o.threshold), self.Zp);

      var w = self.ilt_halfprime(op_id + ':halfprime:1');
      Promise.all([w.promise]).then(function () {
        var x = o.ilt_halfprime(op_id + ':halfprime:2');
        Promise.all([x.promise]).then(function () {
          var y = self.issub(o).ilt_halfprime(op_id + ':halfprime:3');
          Promise.all([y.promise]).then(function () {
            var xy = x.ismult(y, op_id + ':smult1');
            var answer = x.icmult(-1).icadd(1).issub(y).isadd(xy).isadd(w.ismult(x.isadd(y).issub(xy.icmult(2)), op_id + ':smult2'));
            answer.wThen(final_deferred.resolve);
          });
        });
      });

      return result;
    };

    /**
     * Greater than or equal with a constant.
     * @method cgteqn
     * @param {number} cst - the constant to compare with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this >= cst, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.cgteq = function (cst, op_id) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (>=)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('cgteq', self.holders);
      }

      return self.iclt(cst, op_id).inot();
    };

    /**
     * Greater than with a constant.
     * @method cgt
     * @param {number} cst - the constant to compare with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.default ids suffice when all parties execute the
     *                         instructions in the same order.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this > cst, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.cgt = function (cst, op_id) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (>)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('cgt', self.holders);
      }

      var final_deferred = new self.jiff.helpers.Deferred;
      var final_promise = final_deferred.promise;
      var result = self.jiff.secret_share(self.jiff, false, final_promise, undefined, self.holders, self.threshold, self.Zp);

      var w = share_helpers['<'](cst, share_helpers['/'](self.Zp, 2)) ? 1 : 0;
      var x = self.ilt_halfprime(op_id + ':halfprime:1');
      Promise.all([x.promise]).then(function () {
        var y = self.icmult(-1).icadd(cst).ilt_halfprime(op_id + ':halfprime:2');
        Promise.all([y.promise]).then(function () {
          var xy = y.ismult(x, op_id + ':smult1');
          var answer = x.icmult(-1).icadd(1).issub(y).isadd(xy).isadd(x.isadd(y).issub(xy.icmult(2)).icmult(w));
          answer.wThen(final_deferred.resolve);
        });
      });

      return result;
    };

    /**
     * Less than or equal with a constant.
     * @method clteq
     * @param {number} cst - the constant to compare with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this <= cst, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.clteq = function (cst, op_id) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (<=)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('clteq', self.holders);
      }

      return self.icgt(cst, op_id).inot();
    };

    /**
     * Less than with a constant.
     * @method clt
     * @param {number} cst - the constant to compare with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this < cst, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.clt = function (cst, op_id) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (<)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('clt', self.holders);
      }

      var final_deferred = new self.jiff.helpers.Deferred;
      var final_promise = final_deferred.promise;
      var result = self.jiff.secret_share(self.jiff, false, final_promise, undefined, self.holders, self.threshold, self.Zp);

      var w = self.ilt_halfprime(op_id + ':halfprime:1');
      Promise.all([w.promise]).then(function () {
        var x = share_helpers['<'](cst, share_helpers['/'](self.Zp, 2)) ? 1 : 0;
        var y = self.icsub(cst).ilt_halfprime(op_id + ':halfprime:2');
        Promise.all([y.promise]).then(function () {
          var xy = y.icmult(x);
          var answer = y.icmult(-1).icadd(1 - x).isadd(xy).isadd(w.ismult(y.icadd(x).issub(xy.icmult(2)), op_id + ':smult1'));
          answer.wThen(final_deferred.resolve);
        });
      });

      return result;
    };

    /**
     * Equality test with two shares.
     * @method seq
     * @param {SecretShare} o - the share to compare with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 1 if this = o, and 0 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.seq = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (==)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (==)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (==)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('seq', self.holders);
      }

      return self.issub(o).iclteq(0, op_id);
    };

    /**
     * Unequality test with two shares.
     * @method sneq
     * @param {SecretShare} o - the share to compare with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 0 if this = o, and 1 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.sneq = function (o, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (!=)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (!=)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (!=)');
      }
      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('sneq', self.holders);
      }
      return self.iseq(o, op_id).inot();
    };

    /**
     * Equality test with a constant.
     * @method ceq
     * @param {number} cst - the constant to compare with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 0 if this = o, and 1 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.ceq = function (cst, op_id) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (==)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('ceq', self.holders);
      }

      return self.icsub(cst).iclteq(0, op_id);
    };

    /**
     * Unequality test with a constant.
     * @method cneq
     * @param {number} cst - the constant to compare with.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result, the final result is 0 if this = o, and 1 otherwise.
     * @memberof SecretShare
     * @instance
     */
    self.cneq = function (cst, op_id) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (!=)');
      }
      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('cneq', self.holders);
      }
      return self.iceq(cst, op_id).inot();
    };

    /**
     * Negation of a bit.
     * This has to be a share of a BIT in order for this to work properly.
     * @method not
     * @return {SecretShare} this party's share of the result (negated bit).
     * @memberof SecretShare
     * @instance
     */
    self.not = function () {
      return self.icmult(-1).icadd(1);
    };

    /**
     * Integer divison with two shares (self / o)
     * @method sdiv
     * @param {SecretShare} o - the share to divide by.
     * @param {number} [l=log_2(self.Zp)] - the maximum bit length of the answer.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.sdiv = function (o, l, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (!=)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (!=)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (!=)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('sdiv', self.holders);
      }

      var lZp = share_helpers['ceil'](self.jiff.helpers.bLog(self.Zp, 2));
      if (l == null) {
        l = lZp;
      } else {
        l = l < lZp ? l : lZp;
      }

      // Convert to bits
      var dividend_bits = self.bit_decomposition(op_id + ':decomposition1').slice(0, l);
      var divisor_bits = o.bit_decomposition(op_id + ':decomposition2').slice(0, l);

      // Compute by long division
      var quotient_bits = self.jiff.protocols.bits.sdiv(dividend_bits, divisor_bits, op_id + ':bits.sdiv').quotient;
      var quotient = self.jiff.protocols.bits.bit_composition(quotient_bits);
      return quotient;
    };

    /**
     * Integer divison with a share and a constant (self / cst).
     * @method cdiv
     * @param {SecretShare} cst - the constant to divide by.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.cdiv = function (cst, op_id) {
      if (!(self.isConstant(cst))) {
        throw new Error('parameter should be a number (/)');
      }

      if (share_helpers['<='](cst, 0)) {
        throw new Error('divisor must be > 0 (cst/): ' + cst);
      }

      if (share_helpers['<='](self.Zp, cst)) {
        throw new Error('divisor must be < share.Zp (' + self.Zp + ') in (cst/): ' + cst);
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('cdiv', self.holders);
      }

      // Allocate share for result to which the answer will be resolved once available
      var final_deferred = new self.jiff.helpers.Deferred;
      var final_promise = final_deferred.promise;
      var result = self.jiff.secret_share(self.jiff, false, final_promise, undefined, self.holders, self.threshold, self.Zp);

      // Execute protocol when random in noise in [0, Zp) and quotient floor(noise/constant) is ready!
      var ready_quotient = function (noise, nOVERc) {
        // Use noise
        var noisyX = self.isadd(noise);
        self.jiff.internal_open(noisyX, noisyX.holders, op_id + ':open').then(function (noisyX) {
          var wrapped = self.icgt(noisyX, op_id + ':wrap_cgt'); // 1 => x + noise wrapped around Zp, 0 otherwise

          // if we did not wrap
          var noWrapDiv = share_helpers['floor/'](noisyX, cst);
          var unCorrectedQuotient = nOVERc.icmult(-1).icadd(noWrapDiv).icsub(1);
          var verify = self.issub(unCorrectedQuotient.icmult(cst));
          var isNotCorrect = verify.icgteq(cst, op_id + ':cor1');
          var noWrapAnswer = unCorrectedQuotient.isadd(isNotCorrect); // if incorrect => isNotCorrect = 1 => quotient = unCorrectedQuotient - 1

          // if we wrapped
          var wrapDiv = share_helpers['floor/'](share_helpers['+'](noisyX, self.Zp), cst);
          unCorrectedQuotient = nOVERc.icmult(-1).icadd(wrapDiv).icsub(1);
          verify = self.issub(unCorrectedQuotient.icmult(cst));
          isNotCorrect = verify.icgteq(cst, op_id + ':cor2');
          var wrapAnswer = unCorrectedQuotient.isadd(isNotCorrect); // if incorrect => isNotCorrect = 1 => quotient = unCorrectedQuotient - 1

          var answer = noWrapAnswer.isadd(wrapped.ismult(wrapAnswer.issub(noWrapAnswer), op_id + ':smult'));
          answer.wThen(final_deferred.resolve);
        });
      };

      // Preprocessing cases
      var quotient = self.jiff.get_preprocessing(op_id + ':quotient');
      if (quotient == null) { // case 1: no preprocessing with crypto provider!
        var promise = self.jiff.from_crypto_provider('quotient', self.holders, self.threshold, self.Zp, op_id + ':quotient', {constant: cst});
        promise.then(function (msg) {
          ready_quotient(msg['shares'][0], msg['shares'][1]);
        });
      } else if (quotient.ondemand === true) { // case 2: constant was not available at preprocessing time, must do it now!
        var ondemand = self.jiff.protocols.generate_random_and_quotient(threshold, self.holders, self.holders, self.Zp, {
          op_id: op_id + ':quotient',
          constant: cst,
          ondemand: true
        });
        ondemand.promise.then(function () {
          ready_quotient(ondemand.share.r, ondemand.share.q);
        });
      } else { // case 3: preprocessing is completed!
        ready_quotient(quotient.r, quotient.q);
      }

      // special case, if result is zero, sometimes we will get to -1 due to how correction happens above (.csub(1) and then compare)
      var zeroIt = self.iclt(cst, op_id + ':zero_check').inot();
      return result.ismult(zeroIt, op_id + ':zero_it');
    };

    /**
     * Remainder with two shares (self % o)
     * @method smod
     * @param {SecretShare} o - the modulus to apply
     * @param {number} [l=log_2(self.Zp)] - the maximum bit length of the answer.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     * @memberof SecretShare
     * @instance
     */
    self.smod = function (o, l, op_id) {
      if (!(o.jiff === self.jiff)) {
        throw new Error('shares do not belong to the same instance (!=)');
      }
      if (!self.jiff.helpers.Zp_equals(self, o)) {
        throw new Error('shares must belong to the same field (!=)');
      }
      if (!self.jiff.helpers.array_equals(self.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (!=)');
      }

      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('smod', self.holders);
      }

      var lZp = share_helpers['ceil'](self.jiff.helpers.bLog(self.Zp, 2));
      if (l == null) {
        l = lZp;
      } else {
        l = l < lZp ? l : lZp;
      }

      // Convert to bits
      var dividend_bits = self.bit_decomposition(op_id + ':decomposition1').slice(0, l);
      var divisor_bits = o.bit_decomposition(op_id + ':decomposition2').slice(0, l);

      // Compute by long division
      var remainder_bits = self.jiff.protocols.bits.sdiv(dividend_bits, divisor_bits, op_id + ':bits.sdiv').remainder;
      var remainder = self.jiff.protocols.bits.bit_composition(remainder_bits);
      return remainder;
    };

    /**
     * Checks whether the share is less than half the field size.
     * @method lt_halfprime
     * @memberof SecretShare
     * @instance
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} this party's share of the result.
     */
    self.lt_halfprime = function (op_id) {
      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('lt_halfprime', self.holders);
      }

      // if share is even, then self is less than half the prime, otherwise, share is greater than half the prime
      var share = self.icmult(2);

      // to check if share is even, we will use pre-shared bits as some form of a bit mask
      var bitLength = share_helpers['ceil'](self.jiff.helpers.bLog(share.Zp, 2));

      // Create result share
      var final_deferred = new self.jiff.helpers.Deferred;
      var final_promise = final_deferred.promise;
      var result = self.jiff.secret_share(self.jiff, false, final_promise, undefined, self.holders, self.threshold, self.Zp);

      // Execute protocol when randomly sampled bit-wise random number is ready
      var ready_sampling = function (bits) {
        // if 2*self is even, then self is less than half prime, otherwise self is greater or equal to half prime
        if (bits.length !== bitLength) {
          throw new Error('Preprocessed bits sequence has incorrect length, expected: ' + bitLength + ' actual: ' + bits.length);
        }

        // bit composition: r = (rl ... r1 r0)_10
        var r = self.jiff.protocols.bits.bit_composition(bits);
        // open share + noise, and utilize opened value with shared bit representation of noise to check the least significant digit of share.
        share.jiff.internal_open(r.isadd(share), share.holders, op_id + ':open').then(function (result) {
          var wrapped = self.jiff.protocols.bits.cgt(bits, result, op_id + ':bits.cgt');
          var isOdd = self.jiff.helpers.mod(result, 2);
          isOdd = bits[0].icxor_bit(isOdd);
          isOdd = isOdd.isxor_bit(wrapped, op_id + ':sxor_bit');

          var answer = isOdd.inot();
          answer.wThen(final_deferred.resolve);
        });
      };

      // generate the bits of a random number less than our prime
      var bits = self.jiff.get_preprocessing(op_id + ':sampling');
      if (bits == null) {
        var promise = self.jiff.from_crypto_provider('numbers', self.holders, self.threshold, self.Zp, op_id + ':sampling', {bitLength: bitLength, count: 1, max: self.Zp});
        promise.then(function (msg) {
          ready_sampling(msg['shares']);
        });
      } else {
        ready_sampling(bits);
      }

      return result;
    };

    /**
     * Bit Decomposition: Transform existing share to an array of bit shares.
     * @method bit_decomposition
     * @memberof SecretShare
     * @instance
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @returns {SecretShare[]} an array of secret shares of bits of length [ceil(self.Zp)], where
     *   index 0 represents the least significant bit.
     */
    self.bit_decomposition = function (op_id) {
      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('bit_decomposition', self.holders);
      }

      var bitLength = self.Zp.toString(2).length;

      // Create deferred shares to resolve to later when the computation completes
      var many_shares = many_secret_shares(jiff, bitLength, self.holders, self.threshold, self.Zp);
      var deferreds = many_shares.deferreds;
      var result = many_shares.shares;

      // Execute protocol when randomly sampled bit-wise random number is ready
      var ready_sampling = function (bits) {
        var r = self.jiff.protocols.bits.bit_composition(bits);
        // add and reveal random number to self
        self.jiff.internal_open(r.isadd(self), self.holders, op_id + ':open').then(function (result) {
          // compute bits assuming r+self < Zp
          var noWrap = self.jiff.protocols.bits.csubr(result, bits, op_id + ':bits.csubr:1');
          var didWrap = noWrap.pop();

          // compute bits assuming r+self >= Zp
          var withWrap = self.jiff.protocols.bits.csubr(share_helpers['+'](result, self.Zp), bits, op_id + ':bits.csubr:2');
          withWrap.pop(); // withWrap cannot underflow!

          // choose noWrap if first subtraction does not overflow (sign bit is zero), otherwise choose withWrap.
          for (var i = 0; i < bitLength; i++) {
            withWrap[i] = didWrap.iif_else(withWrap[i], noWrap[i], op_id + ':if_else:' + i);
          }
          resolve_many_secrets(deferreds, withWrap);
        });
      };

      // generate the bits of a random number less than our prime
      var bits = self.jiff.get_preprocessing(op_id + ':sampling');
      if (bits == null) {
        var promise = self.jiff.from_crypto_provider('numbers', self.holders, self.threshold, self.Zp, op_id + ':sampling', {bitLength: bitLength, count: 1, max: self.Zp});
        promise.then(function (msg) {
          ready_sampling(msg['shares']);
        });
      } else {
        ready_sampling(bits);
      }

      return result;
    };

    /**
     * Simulate an oblivious If-else statement with a single return value.
     * Should be called on a secret share of a bit: 0 representing false, and 1 representing true
     * If this is a share of 1, a new sharing of the element represented by the first parameter is returned,
     * otherwise, a new sharing of the second is returned.
     * @method if_else
     * @memberof SecretShare
     * @instance
     * @param {SecretShare|constant} trueVal - the value/share to return if this is a sharing of 1.
     * @param {SecretShare|constant} falseVal - the value/share to return if this is a sharing of 0.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @return {SecretShare} a new sharing of the result of the if.
     *
     * @example
     * // a and b are secret shares
     * // cmp will be a secret share of either 1 or 0, depending on whether a or b is greater
     * var cmp = a.gt(b);
     *
     * // max is set to the greater value, without revealing the value or the result of the inequality
     * var max = cmp.if_else(a, b);
     */
    self.if_else = function (trueVal, falseVal, op_id) {
      if (op_id == null) {
        op_id = self.jiff.counters.gen_op_id('if_else', self.holders);
      }

      var const1 = self.isConstant(trueVal);
      var const2 = self.isConstant(falseVal);
      if (const1 && const2) {
        return self.icmult(trueVal).isadd(self.inot().icmult(falseVal));
      } else if (const1) {
        return self.inot().ismult(falseVal.icsub(trueVal), op_id + ':smult').icadd(trueVal);
      } else if (const2) {
        return self.ismult(trueVal.icsub(falseVal), op_id + ':smult').icadd(falseVal);
      } else {
        return self.ismult(trueVal.issub(falseVal), op_id + ':smult').isadd(falseVal);
      }
    };

    // when the promise is resolved, acquire the value of the share and set ready to true
    if (!ready) {
      self.promise.then(self.receive_share, self.error);
      self.jiff.add_to_barriers(self.promise);
    }

    /**
     * Wrapper around share.promise.then
     * In case share is ready (its promise is resolved and cleared)
     * The callback is executed immediately.
     * Does not support chaining.
     * @method wThen
     * @memberof SecretShare
     * @instance
     * @param {function} onFulfilled - callback for success, called with self.value as parameter.
     * @param {function} [onRejected] - callback for errors.
     */
    self.wThen = function (onFulfilled, onRejected) {
      if (self.value != null) {
        onFulfilled(self.value);
      } else {
        if (onRejected == null) {
          onRejected = self.error;
        }
        self.promise.then(onFulfilled, onRejected);
      }
    };

    // internal variant of primitives, to use internally by other primitives
    var internals = ['cadd', 'csub', 'cmult', 'sadd', 'ssub', 'smult', 'smult_bgw',
      'cxor_bit', 'sxor_bit', 'cor_bit', 'sor_bit',
      'slt', 'slteq', 'sgt', 'sgteq', 'seq', 'sneq',
      'clt', 'clteq', 'cgt', 'cgteq', 'ceq', 'cneq',
      'sdiv', 'cdiv', 'not', 'lt_halfprime', 'if_else'];
    for (var i = 0; i < internals.length; i++) {
      var key = internals[i];
      self['i' + key] = self[key];
    }

    // return the share
    return jiff.execute_array_hooks('createSecretShare', [jiff, self, share_helpers], 1);
  }

  /**
   * The interface defined by an instance of jiff.
   * You can get an instance of jiff by calling function {@link jiff.make_jiff}.
   * You can access any of the specified members of function with &lt;jiff-instance&gt;.&lt;member-name&gt;.
   * @namespace jiff-instance
   * @version 1.0
   */

  /**
   * Create a new jiff instance.
   * @memberof jiff
   * @function make_jiff
   * @param {string} hostname - server hostname/ip and port.
   * @param {string} computation_id - the id of the computation of this instance.
   * @param {object} [options={}] - javascript object with additional options.
   *                           all parameters are optional, However, private and public key must either be both provided or neither of them provided.
     <pre>
     {
       "party_id": number,
       "party_count": number,
       "secret_key": Uint8Array to be used with libsodium-wrappers [(check Library Specs)]{@link https://download.libsodium.org/doc/public-key_cryptography/authenticated_encryption.html},
       "public_key": Uint8Array to be used with libsodium-wrappers [(check Library Specs)]{@link https://download.libsodium.org/doc/public-key_cryptography/authenticated_encryption.html},
       "public_keys": { 1: "Uint8Array PublicKey", 2: "Uint8Array PublicKey", ... },
       "Zp": default mod to use (prime number),
       "autoConnect": true/false,
       "hooks": { 'check out <a href="hooks.html">hooks documentation</a>' },
       "listeners" : A map from custom tags to listeners (of type function(sender_id, message_string)) that handle custom messages with that tag.
       "onConnect": function(jiff_instance),
       "onError": function(label, error): called when errors occured in client code or during handling requests from this client at the server side
                                          label is a string indicating where the error occured, and error is a string or an exception object.
       "safemod": boolean (whether or not to check if provided Zp is prime, may be slow for big primes, defaults to false),
       "crypto_provider": a boolean that flags whether to get beaver triplets and other preprocessing entities from the server (defaults to false),
       "socketOptions": an object, passed directly to socket.io constructor,
       "maxInitializationRetries": how many consecutive times to retry to initialize with the server if initialization fails, defaults to 2.
     }
     </pre>
   *
   * @return {jiff-instance} the jiff instance for the described computation.
   *                          The Jiff instance contains the socket, number of parties, functions
   *                          to share and perform operations, as well as synchronization flags.
   *
   * @example
   * // build a jiff instance which will connect to a server running on the local machine
   * var instance = jiff.make_jiff('http://localhost:8080', 'compuation-1', {party_count: 2});
   */
  function make_jiff(hostname, computation_id, options) {
    if (options == null) {
      options = {};
    }

    var jiff = {};

    /**
     * The server hostname, ends with a slash, includes port and protocol (http/https).
     * @member {string} hostname
     * @memberof jiff-instance
     * @instance
     */
    jiff.hostname = hostname.trim();
    if (!jiff.hostname.endsWith('/')) {
      jiff.hostname = jiff.hostname + '/';
    }

    /**
     * An array containing the names (jiff-client-[name].js) of extensions
     * applied to this instance.
     * @member {string[]} extensions
     * @memberof jiff-instance
     * @instance
     */
    jiff.extensions = ['base'];

    /**
     * Checks if the given extension is applied.
     * @method has_extension
     * @memberof jiff-instance
     * @instance
     * @param {string} name - the extension name (found in the filename at jiff-client-[name].js).
     * @return {boolean} true if the extension was applied, false otherwise.
     */
    jiff.has_extension = function (name) {
      return jiff.extensions.indexOf(name) > -1;
    };

    /**
     * Checks if a given extension can be safely applied to the instance
     * @method can_apply_extension
     * @memberof jiff-instance
     * @instance
     * @param {string} name - the extension name (found in the filename at jiff-client[name].js)
     * @return {boolean|string} true if the extension can be safely applied, otherwise returns an error message.
     */
    jiff.can_apply_extension = function (name) {
      return true;
    };

    /**
     * Safely applies the given extension, if the extension is safe, it will be applied succesfully.
     * If the extension is not safe to be applied, an exception will be thrown with an appropriate error message.
     * @method apply_extension
     * @memberof jiff-instance
     * @instance
     * @param {object} ext - the namespace of the extension acquired when the extension is imported, should contain a make_jiff function.
     * @param {object} [options={}] - optional options to be passed to the extension.
     */
    jiff.apply_extension = function (ext, options) {
      if (options == null) {
        options = {};
      }

      var name = ext.name;
      var status = jiff.can_apply_extension(name);

      if (status === true) {
        ext.make_jiff(jiff, options);

        jiff.extensions.push(name);
        jiff.extension_applied(name, options);
      } else {
        throw status;
      }
    };

    /**
     * Called when an extension was applied successfully. Override to change behavior based on future extensions.
     * @param {string} name - the name of the applied extension.
     * @param {object} [options={}] - the options passed by the user to the newly applied extension.
     */
    jiff.extension_applied = function (name, options) {};

    /**
     * The id of this party. [Do not modify]
     * @member {number} id
     * @memberof jiff-instance
     * @instance
     */
    jiff.id = options.party_id;

    /**
     * Stores the computation id. [Do not modify]
     * @member {string} computation_id
     * @memberof jiff-instance
     * @instance
     */
    jiff.computation_id = computation_id;

    /**
     * Flags whether this instance is capable of starting the computation.
     * In other words, the public keys for all parties and servers are known,
     * and the server is connected. [Do not use directly externally; use isReady() instead]
     * @member {boolean} __ready
     * @memberof jiff-instance
     * @instance
     */
    jiff.__ready = false;

    /**
     * Flags whether this instance has been initialized (the server responded successfully to the initialization message)
     * @member {boolean} __initialized
     * @memberof jiff-instance
     * @instance
     */
    jiff.__initialized = false;

    /**
     * Checks whether this instance is connected and the server signaled the start of computation.
     * @method isReady
     * @memberof jiff-instance
     * @instance
     * @return {boolean} true if the instance is ready, false otherwise.
     */
    jiff.isReady = function () {
      return jiff.__ready;
    };

    if (options.sodium !== false) {
      /**
       * A promise for when the sodium wrappers are ready. This will be undefined if options.sodium is false.
       * @method {Promise} sodium
       * @memberof jiff-instance
       * @instance
       */
      jiff.sodium_ready = sodium_.ready;
    }

    /**
     * The default Zp for this instance.
     * @memberof jiff-instance
     * @member {number} Zp
     * @instance
     */
    jiff.Zp = options.Zp == null ? gZp : options.Zp;
    if (options.Zp != null && options.safemod === true) {
      // bignumber primes are checked by the bignumber extension
      if (typeof(options.Zp) !== 'string' && options.Zp.isBigNumber !== true) {
        if (!is_prime(options.Zp)) {
          throw new Error('Zp = ' + options.Zp + ' is not prime.  Please use a prime number for the modulus or set safemod to false.');
        }
      }
    }

    // Setup sockets.
    var guard_socket = function (socket) {
      // Outgoing messages mailbox (linked list)
      socket.mailbox = linked_list();

      // Store message in the mailbox until acknowledgment is received
      socket.safe_emit = function (label, msg) {
        // add message to mailbox
        var mailbox_pointer = socket.mailbox.add({label: label, msg: msg});
        if (socket.connected) {
          // emit the message, if an acknowledgment is received, remove it from mailbox
          socket.emit(label, msg, function (status) {
            if (status) {
              socket.mailbox.remove(mailbox_pointer);
              if (socket.mailbox.head == null && socket.empty_deferred != null) {
                socket.empty_deferred.resolve();
              }

              if (label === 'free' && socket === jiff.socket) {
                jiff.execute_array_hooks('afterOperation', [jiff, 'free', msg], 2);
              }
            }
          });
        }
      };

      // Resend all pending messages
      socket.resend_mailbox = function () {
        // Create a new mailbox, since the current mailbox will be resent and
        // will contain new backups.
        var old_mailbox = socket.mailbox;
        socket.mailbox = linked_list();

        // loop over all stored messages and emit them
        var current_node = old_mailbox.head;
        while (current_node != null) {
          var label = current_node.object.label;
          var msg = current_node.object.msg;
          socket.safe_emit(label, msg);
          current_node = current_node.next;
        }
      };

      var old_disconnect = socket.disconnect;
      socket.disconnect = function () {
        jiff.execute_array_hooks('beforeOperation', [jiff, 'disconnect', {}], -1);
        old_disconnect.apply(socket, arguments);
      };

      // Safe disconnect: only after all messages were acknowledged
      socket.safe_disconnect = function (free, callback) {
        (function ready() {
          if (socket.mailbox.head == null && jiff.counters.pending_opens === 0) {
            if (free) {
              jiff.free();

              // disconnect after free has been delivered
              free = false;
              return ready();
            }

            socket.disconnect();
            if (callback != null) {
              callback();
            }
          } else {
            socket.empty_deferred = new jiff.helpers.Deferred;
            socket.empty_deferred.promise.then(ready);
          }
        }());
      };

      return socket;
    };

    // setup main socket
    var socketOptions = {
      reconnectionDelay: 25000,
      reconnectionDelayMax: 27500,
      randomizationFactor: 0.1,
      autoConnect: false
    };
    socketOptions = Object.assign({}, socketOptions, options.socketOptions);
    jiff.socket = options.__internal_socket;
    if (jiff.socket == null) {
      jiff.socket = io_(hostname, socketOptions);
    }

    if (options.__internal_socket == null) {
      guard_socket(jiff.socket);
    } else {
      jiff.socket.safe_emit = jiff.socket.emit;
      jiff.socket.resend_mailbox = function () {};

      jiff.socket.disconnect = function () {
        jiff.execute_array_hooks('beforeOperation', [jiff, 'disconnect', {}], -1);
      };
      jiff.socket.safe_disconnect = function (free, callback) {
        if (free) {
          jiff.free();
        }
        jiff.socket.disconnect();
        if (callback != null) {
          callback();
        }
      };
    }

    if (options.maxInitializationRetries == null) {
      options.maxInitializationRetries = 2;
    }

    jiff.error = function (label, error) {
      console.log(jiff.id, ':', 'Error from server:', label, '---', error);
      if (label === 'initialization') {
        jiff.socket.disconnect();

        if (jiff.initialization_counter < options.maxInitializationRetries) {
          console.log(jiff.id, ':', 'reconnecting..');
          setTimeout(jiff.connect, socketOptions.reconnectionDelay);
        }
      }
    };
    if (options.onError != null) {
      jiff.error = options.onError;
    }

    // Parse options
    if (options.public_keys != null) {
      /**
       * A map from party id to public key. Where key is the party id (number), and
       * value is the public key (Uint8Array).
       * @member {object} keymap
       * @memberof jiff-instance
       * @instance
       */
      jiff.keymap = options.public_keys;
    } else if (options.secret_key != null && options.public_key != null) {
      /**
       * The secret key of this party [(check Library Specs)]{@link https://download.libsodium.org/doc/public-key_cryptography/authenticated_encryption.html}. [Do not modify]
       * @member {Uint8Array} secret_key
       * @memberof jiff-instance
       * @instance
       */
      jiff.secret_key = options.secret_key;
      /**
       * The public key of this party [(check Library Specs)]{@link https://download.libsodium.org/doc/public-key_cryptography/authenticated_encryption.html}. [Do not modify]
       * @member {Uint8Array} public_key
       * @memberof jiff-instance
       * @instance
       */
      jiff.public_key = options.public_key;
    }

    if (jiff.keymap == null) {
      jiff.keymap = {};
    }

    /**
     * For the case when messages from some party is received before its public key is known.
     * { 'party_id': [ { 'label': 'share/open', <other attributes of the message> } ] }
     * @member {object} messagesWaitingKeys
     * @memberof jiff-instance
     * @instance
     */
    jiff.messagesWaitingKeys = {};

    if (options.party_count != null) {
      /**
       * Total party count in the computation, parties will take ids between 1 to party_count (inclusive).
       * @member {number} party_count
       * @memberof jiff-instance
       * @instance
       */
      jiff.party_count = options.party_count;
    }

    if (options.listeners == null) {
      options.listeners = {};
    }

    /**
     * A map from tags to listeners (functions that take a sender_id and a string message).
     * Stores listeners that are attached to this JIFF instance, listeners listen to custom messages sent by other parties
     * with a corresponding tag to the tag provided with the listener.
     * @member {object} listeners
     * @memberof jiff-instance
     * @instance
     */
    jiff.listeners = options.listeners;

    /**
     * Stores custom messages that are received before their listeners are set. Messages are stored in order.
     * Once a listener has been set, the corresponding messages are sent to it in order.
     * This object has this format: { 'tag' => [ { "sender_id": <sender_id>, "message": <message> }, ... ] }
     * @member {object} custom_messages_mailbox
     * @memberof jiff-instance
     * @instance
     */
    jiff.custom_messages_mailbox = {};

    /**
     * Stores all secret shares' promises belonging to a specific barrier.
     * @member {promise[][]} barriers
     * @memberOf jiff-instance
     * @instance
     */
    jiff.barriers = [];

    if (options.hooks == null) {
      options.hooks = {};
    }

    /**
     * The hooks for this instance.
     * Checkout the <a href="hooks.html">hooks documentation</a>
     * @member {object} hooks
     * @memberof jiff-instance
     * @instance
     */
    jiff.hooks = Object.assign({}, options.hooks);

    // Default hooks:
    if (jiff.hooks.computeShares == null) {
      jiff.hooks.computeShares = jiff_compute_shares;
    }
    if (jiff.hooks.reconstructShare == null) {
      jiff.hooks.reconstructShare = jiff_lagrange;
    }

    // Crypto hooks:
    if (jiff.hooks.encryptSign == null) {
      if (options.sodium !== false) {
        jiff.hooks.encryptSign = encrypt_and_sign;
      } else {
        jiff.hooks.encryptSign = function (jiff, message, encryption_public_key, signing_private_key) {
          return message;
        }
      }
    }
    if (jiff.hooks.decryptSign == null) {
      if (options.sodium !== false) {
        jiff.hooks.decryptSign = decrypt_and_sign;
      } else {
        jiff.hooks.decryptSign = function (jiff, cipher_text, decryption_secret_key, signing_public_key) {
          return cipher_text;
        }
      }
    }
    if (jiff.hooks.generateKeyPair == null) {
      if (options.sodium !== false) {
        jiff.hooks.generateKeyPair = function (jiff) {
          var key = sodium_.crypto_box_keypair(); // this party's public and secret key
          return { public_key: key.publicKey, secret_key: key.privateKey }
        };
      } else {
        jiff.hooks.generateKeyPair = function (jiff) {
          return { public_key: '', secret_key: ''};
        }
      }
    }
    if (jiff.hooks.parseKey == null) {
      if (options.sodium !== false) {
        jiff.hooks.parseKey = function (jiff, keyString) {
          return new Uint8Array(JSON.parse(keyString));
        };
      } else {
        jiff.hooks.parseKey = function (jiff, keyString) {
          return '';
        }
      }
    }
    if (jiff.hooks.dumpKey == null) {
      if (options.sodium !== false) {
        jiff.hooks.dumpKey = function (jiff, key) {
          return '[' + key.toString() + ']';
        };
      } else {
        jiff.hooks.dumpKey = function (jiff, key) {
          return '';
        }
      }
    }

    // Array hooks should have empty array by default:
    if (jiff.hooks.beforeShare == null) {
      jiff.hooks.beforeShare = [];
    }
    if (jiff.hooks.afterComputeShare == null) {
      jiff.hooks.afterComputeShare = [];
    }
    if (jiff.hooks.receiveShare == null) {
      jiff.hooks.receiveShare = [];
    }
    if (jiff.hooks.beforeOpen == null) {
      jiff.hooks.beforeOpen = [];
    }
    if (jiff.hooks.receiveOpen == null) {
      jiff.hooks.receiveOpen = [];
    }
    if (jiff.hooks.afterReconstructShare == null) {
      jiff.hooks.afterReconstructShare = [];
    }
    if (jiff.hooks.receiveTriplet == null) {
      jiff.hooks.receiveTriplet = [];
    }
    if (jiff.hooks.receiveNumbers == null) {
      jiff.hooks.receiveNumbers = [];
    }
    if (jiff.hooks.createSecretShare == null) {
      jiff.hooks.createSecretShare = [];
    }
    if (jiff.hooks.beforeOperation == null) {
      jiff.hooks.beforeOperation = [];
    }
    if (jiff.hooks.afterOperation == null) {
      jiff.hooks.afterOperation = [];
    }

    // parse content of share/open messages to be integers (instead of strings due to encryption/decryption)
    jiff.hooks.afterOperation.unshift(function (jiff, label, msg) {
      if (label === 'share' || label === 'open') {
        msg['share'] = parseInt(msg['share'], 10);
      }
      return msg;
    });

    /**
     * Execute all hooks attached to the given name in order.
     * Hooks are executed sequentially such that the first hook's return value is passed into the second and so on.
     * @method execute_array_hooks
     * @memberof jiff-instance
     * @instance
     * @param {string} hook_name - the name of the hook
     * @param {Array} params - parameters to pass to the hooks
     * @param {number} acc_index - the index in params in which the result of the hooks must be saved, if no hooks
     *                             exist for the name, then params[acc_index] is returned.
     * @return {object} returns the result of the last hook.
     */
    jiff.execute_array_hooks = function (hook_name, params, acc_index) {
      var arr = jiff.hooks[hook_name];
      arr = (arr == null ? [] : arr);

      for (var i = 0; i < arr.length; i++) {
        params[acc_index] = arr[i].apply(jiff, params);
      }
      return params[acc_index];
    };

    /**
     * Stores the parties and callbacks for every .wait_for() registered.
     * @member {Array} wait_callbacks
     * @memberof jiff-instance
     * @instance
     */
    jiff.wait_callbacks = [];

    /**
     * Wait until the public keys of these parties are known.
     * The public keys may be known before the parties connect (if provided in the options),
     * or they could be sent by the server after the parties connect.
     * Computation specified in the callback may assume that these parties are connected,
     * if they are not, the server will handle storing and relaying the needed messages
     * to them when they connect.
     * @memberof jiff-instance
     * @instance
     * @param {Array} parties - an array of party ids to wait for, must explicitly include 's1' if callback must wait for the server.
     * @param {function(jiff-instance)} callback - the function to execute when these parties are known.
     * @param {boolean} [wait_for_initialization=true] - specifies whether to wait for initialization to be complete
     *                                                   before executing the callback (even if parties are available).
     *                                                   Set this to false if you do not need the party count and this
     *                                                   party's id, or if you already have them, and you are certain
     *                                                   they will be accepted by the server on initialization.
     */
    jiff.wait_for = function (parties, callback, wait_for_initialization) {
      if (wait_for_initialization == null) {
        wait_for_initialization = true;
      }

      jiff.wait_callbacks.push({parties: parties, callback: callback, initialization: wait_for_initialization});
      jiff.execute_wait_callbacks(); // See if the callback can be executed immediately
    };

    /**
     * Executes all callbacks for which the wait condition has been satisfied.
     * Remove all executed callbacks so that they would not be executed in the future.
     * @memberof jiff-instance
     * @instance
     */
    jiff.execute_wait_callbacks = function () {
      var new_waits = [];
      for (var i = 0; i < jiff.wait_callbacks.length; i++) {
        var wait = jiff.wait_callbacks[i];
        var parties = wait.parties;
        var callback = wait.callback;
        var initialization = wait.initialization;

        // Check if the parties to wait for are now known
        var parties_satisfied = true;
        for (var j = 0; j < parties.length; j++) {
          var party_id = parties[j];
          if (jiff.keymap == null || jiff.keymap[party_id] == null) {
            parties_satisfied = false;
            break;
          }
        }

        if (initialization) {
          parties_satisfied = parties_satisfied && jiff.__initialized;
        }

        if (parties_satisfied) {
          callback(jiff);
        } else {
          new_waits.push(wait);
        }
      }

      jiff.wait_callbacks = new_waits;
    };

    /**
     * Resolves all messages that were pending because their senders primary key was previously unknown.
     * These messages are decrypted and verified and handled appropriatly before being removed from the wait queue.
     * @memberof jiff-instance
     * @instance
     */
    jiff.resolve_messages_waiting_for_keys = function () {
      for (var party_id in jiff.keymap) {
        if (!jiff.keymap.hasOwnProperty(party_id)) {
          continue;
        }

        var messageQueue = jiff.messagesWaitingKeys[party_id];
        if (messageQueue == null) {
          continue;
        }
        for (var i = 0; i < messageQueue.length; i++) {
          var msg = messageQueue[i];
          if (msg.label === 'share') {
            receive_share(jiff, msg.msg);
          } else if (msg.label === 'open') {
            receive_open(jiff, msg.msg);
          } else if (msg.label === 'custom') {
            receive_custom(jiff, msg.msg);
          } else {
            throw new Error('Error resolving pending message: unknown label ' + msg.label);
          }
        }

        jiff.messagesWaitingKeys[party_id] = null;
      }
    };

    /**
     * Total server count in the computation, servers will take ids between "s1" to "s<server_count>" (inclusive).
     * @member {number} server_count
     * @memberof jiff-instance
     * @instance
     */
    jiff.server_count = 1;

    /**
     * Counts how many times JIFF attempted to initialize with the server
     * without success consecutively.
     * @member {number} initialization_counter
     * @memberof jiff-instance
     * @instance
     *
     */
    jiff.initialization_counter = 0;

    /**
     * Connect to the server and starts listening.
     * @method connect
     * @memberof jiff-instance
     * @instance
     */
    jiff.connect = function () {
      // Ask socket to connect, which will automatically trigger a call to 'initialize()' when connection is established!
      if (options.sodium === false) {
        jiff.socket.connect();
      } else {
        jiff.sodium_ready.then(function () {
          jiff.socket.connect();
        });
      }
    };

    // responsible for building the initialization message
    jiff.build_initialization_message = function (public_key) {
      var msg = {
        computation_id: computation_id,
        party_id: jiff.id,
        party_count: jiff.party_count,
        public_key: public_key
      };
      msg = Object.assign(msg, options.initialization);

      // Initialization Hook
      return jiff.execute_array_hooks('beforeOperation', [jiff, 'initialization', msg], 2);
    };

    /**
     * Initializes this instance by sending the initialization message to the server.
     * Should only be called after connection is established.
     * Do not call this manually unless you know what you are doing, use <jiff_instance>.connect() instead!
     */
    jiff.initialize = function () {
      console.log('Connected!', jiff.id);
      jiff.initialization_counter++;

      if (jiff.secret_key == null && jiff.public_key == null) {
        var key = jiff.hooks.generateKeyPair(jiff);
        jiff.secret_key = key.secret_key;
        jiff.public_key = key.public_key;
      }

      // Initialization message
      var msg = jiff.build_initialization_message(jiff.hooks.dumpKey(jiff, jiff.public_key));

      // Emit initialization message to server
      jiff.socket.emit('initialization', JSON.stringify(msg));
    };

    // set on('connect') handler once!
    jiff.socket.on('connect', jiff.initialize);

    /**
     * Store the public keys given in the keymap
     * @param {object} keymap - map party id to public key.
     */
    jiff.store_public_keys = function (keymap) {
      var i;
      for (i in keymap) {
        if (keymap.hasOwnProperty(i) && jiff.keymap[i] == null) {
          jiff.keymap[i] = jiff.hooks.parseKey(jiff, keymap[i]);
        }
      }

      // Resolve any pending messages that were received before the sender's public key was known
      jiff.resolve_messages_waiting_for_keys();

      // Resolve any pending waits that have satisfied conditions
      jiff.execute_wait_callbacks();

      // Check if all keys have been received
      if (jiff.keymap['s1'] == null) {
        return;
      }
      for (i = 1; i <= jiff.party_count; i++) {
        if (jiff.keymap[i] == null) {
          return;
        }
      }

      // all parties are connected; execute callback
      if (jiff.__ready !== true && jiff.__initialized) {
        jiff.__ready = true;
        if (options.onConnect != null) {
          options.onConnect(jiff);
        }
      }
    };

    /**
     * Send a custom message to a subset of parties.
     * @memberof jiff-instance
     * @function emit
     * @instance
     * @param {string} tag - the tag to attach to the message.
     * @param {Array} receivers - contains the party ids to receive the message, all non-server parties if null.
     * @param {string} message - the message to send.
     * @param {boolean} [encrypt=true] - if true, messages will be encrypted.
     */
    jiff.emit = function (tag, receivers, message, encrypt) {
      if (typeof(message) !== 'string') {
        throw new Error('Emit: message must be a string');
      }

      if (receivers == null) {
        receivers = [];
        for (var i = 1; i <= jiff.party_count; i++) {
          receivers.push(i);
        }
      } else {
        receivers = receivers.slice();
      }

      // Remove own index from receivers
      var index = receivers.indexOf(jiff.id);
      if (index > -1) {
        receive_custom(jiff, { tag: tag, party_id: jiff.id, message: message, encrypted: false });
      }

      for (var p = 0; p < receivers.length; p++) {
        if (receivers[p] === jiff.id) {
          continue;
        }

        var message_to_send = { tag: tag, party_id: receivers[p], message: message, encrypted: encrypt };
        message_to_send = jiff.execute_array_hooks('beforeOperation', [jiff, 'custom', message_to_send], 2);

        if (message_to_send['encrypted'] !== false) {
          message_to_send['message'] = jiff.hooks.encryptSign(jiff, message_to_send['message'], jiff.keymap[message_to_send['party_id']], jiff.secret_key);
          message_to_send['encrypted'] = true;
        }

        jiff.socket.safe_emit('custom', JSON.stringify(message_to_send));
      }
    };

    /**
     * Registers the given function as a listener for messages with the given tag.
     * Removes any previously set listener for this tag.
     * @memberof jiff-instance
     * @function listen
     * @instance
     * @param {string} tag - the tag to listen for.
     * @param {function(party_id, string)} handler - the function that handles the received message: takes the sender id and the message as parameters.
     */
    jiff.listen = function (tag, handler) {
      jiff.listeners[tag] = handler;

      var stored_messages = jiff.custom_messages_mailbox[tag];
      if (stored_messages == null) {
        return;
      }

      for (var i = 0; i < stored_messages.length; i++) {
        var sender_id = stored_messages[i].sender_id;
        var message = stored_messages[i].message;
        handler(sender_id, message);
      }

      delete jiff.custom_messages_mailbox[tag];
    };

    /**
     * Removes the custom message listener attached to the given tag.
     * @param {string} tag - the tag of the listener to remove.
     */
    jiff.remove_listener = function (tag) {
      delete jiff.listeners[tag];
    };

    /**
     * Helper functions [DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING].
     * @type object
     * @memberof jiff-instance
     * @namespace helpers
     */
    jiff.helpers = {};

    /**
     * Polyfill for jQuery Deferred
     * From https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred
     * @memberof jiff-instance.helpers
     * @constructor Deferred
     * @instance
     * @return {Deferred} a new Deferred.
     */
    jiff.helpers.Deferred = function () {
      // Polyfill for jQuery Deferred
      // From https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred
      this.resolve = null;

      /* A method to reject the associated Promise with the value passed.
       * If the promise is already settled it does nothing.
       *
       * @param {anything} reason: The reason for the rejection of the Promise.
       * Generally its an Error object. If however a Promise is passed, then the Promise
       * itself will be the reason for rejection no matter the state of the Promise.
       */
      this.reject = null;

      /* A newly created Promise object.
       * Initially in pending state.
       */
      this.promise = new Promise(function (resolve, reject) {
        this.resolve = resolve;
        this.reject = reject;
      }.bind(this));
      Object.freeze(this);
    };

    /**
     * Correct Mod instead of javascript's remainder (%).
     * @memberof jiff-instance.helpers
     * @function mod
     * @instance
     * @param {number} x - the number.
     * @param {number} y - the mod.
     * @return {number} x mod y.
     */
    jiff.helpers.mod = function (x, y) {
      if (x < 0) {
        return (x % y) + y;
      }
      return x % y;
    };

    /**
     * Ceil of a number.
     * @memberof jiff-instance.helpers
     * @function ceil
     * @instance
     * @param {number} x - the number to ceil.
     * @return {number} ceil of x.
     */
    jiff.helpers.ceil = Math.ceil;

    /**
     * Floor of a number
     * @memberof jiff-instance.helpers
     * @function floor
     * @instance
     * @param {number} x - the number to floor.
     * @return {number} floor of x.
     */
    jiff.helpers.floor = Math.floor;

    /**
     * Fast Exponentiation Mod.
     * @memberof jiff-instance.helpers
     * @function pow_mod
     * @instance
     * @param {number} a - the base number.
     * @param {number} b - the power.
     * @param {number} n - the mod.
     * @return {number} (base^pow) mod m.
     */
    jiff.helpers.pow_mod = function (a, b, n) {
      a = jiff.helpers.mod(a, n);
      var result = 1;
      var x = a;
      while (b > 0) {
        var leastSignificantBit = jiff.helpers.mod(b, 2);
        b = Math.floor(b / 2);
        if (leastSignificantBit === 1) {
          result = result * x;
          result = jiff.helpers.mod(result, n);
        }
        x = x * x;
        x = jiff.helpers.mod(x, n);
      }
      return result;
    };

    /**
     * Extended Euclidean for finding inverses.
     * @method extended_gcd
     * @memberof jiff-instance.helpers
     * @instance
     * @param {number} a - the number to find inverse for.
     * @param {number} b - the mod.
     * @return {number[]} [inverse of a mod b, coefficient for a, coefficient for b].
     */
    jiff.helpers.extended_gcd = function (a, b) {
      if (b === 0) {
        return [1, 0, a];
      }

      var temp = jiff.helpers.extended_gcd(b, jiff.helpers.mod(a, b));
      var x = temp[0];
      var y = temp[1];
      var d = temp[2];
      return [y, x - y * Math.floor(a / b), d];
    };

    /**
     * Compute Log to a given base.
     * @method bLog
     * @memberof jiff-instance.helpers
     * @instance
     * @param {number} value - the number to find log for.
     * @param {number} [base=2] - the base (2 by default).
     * @return {number} log(value) with the given base.
     */
    jiff.helpers.bLog = function (value, base) {
      if (base == null) {
        base = 2;
      }
      return Math.log(value) / Math.log(base);
    };

    /**
     * Check that two sorted arrays are equal.
     * @method array_equals
     * @memberof jiff-instance.helpers
     * @instance
     * @param {Array} arr1 - the first array.
     * @param {Array} arr2 - the second array.
     * @return {boolean} true if arr1 is equal to arr2, false otherwise.
     */
    jiff.helpers.array_equals = function (arr1, arr2) {
      if (arr1.length !== arr2.length) {
        return false;
      }

      for (var i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) {
          return false;
        }
      }

      return true;
    };

    /**
     * Check that two Zps are equal. Used to determine if shares can be computed on or not.
     * @method Zp_equals
     * @memberof jiff-instance.helpers
     * @instance
     * @param {SecretShare} s1 - the first share.
     * @param {SecretShare} s2 - the second share.
     * @return {boolean} true both shares have the same Zp, false otherwise.
     */
    jiff.helpers.Zp_equals = function (s1, s2) {
      return s1.Zp === s2.Zp;
    };

    /**
     * Generate a random integer between 0 and max-1 [inclusive].
     * Modify this to change the source of randomness and how it is generated.
     * @method random
     * @memberof jiff-instance.helpers
     * @instance
     * @param {number} max - the maximum number.
     * @return {number} the random number.
     */
    jiff.helpers.random = function (max) {
      // Use rejection sampling to get random value within bounds
      // Generate random Uint8 values of 1 byte larger than the max parameter
      // Reject if random is larger than quotient * max (remainder would cause biased distribution), then try again
      if (max == null) {
        max = jiff.Zp;
      }
      // Values up to 2^53 should be supported, but log2(2^49) === log2(2^49+1), so we lack the precision to easily
      // determine how many bytes are required
      if (max > 562949953421312) {
        throw new RangeError('Max value should be smaller than or equal to 2^49');
      }

      var bitsNeeded = Math.ceil(jiff.helpers.bLog(max, 2));
      var bytesNeeded = Math.ceil(bitsNeeded / 8);
      var maxValue = Math.pow(256, bytesNeeded);

      // Keep trying until we find a random value within a normal distribution
      while (true) { // eslint-disable-line
        var randomBytes = crypto_.__randomBytesWrapper(bytesNeeded);
        var randomValue = 0;

        for (var i = 0; i < bytesNeeded; i++) {
          randomValue = randomValue * 256 + randomBytes[i];
        }

        // randomValue should be smaller than largest multiple of max within maxBytes
        if (randomValue < maxValue - maxValue % max) {
          return randomValue % max;
        }
      }
    };

    /**
     * Get the party number from the given party_id, the number is used to compute/open shares.
     * If party id was a number (regular party), that number is returned,
     * If party id refers to the ith server, then party_count + i is returned (i > 0).
     * @memberof jiff-instance.helpers
     * @instance
     * @param {number/string} party_id - the party id from which to compute the number.
     * @return {number} the party number (> 0).
     */
    jiff.helpers.get_party_number = function (party_id) {
      if (typeof(party_id) === 'number') {
        return party_id;
      }
      if (party_id.startsWith('s')) {
        return -1 * parseInt(party_id.substring(1), 10);
      }
      return parseInt(party_id, 10);
    };

    /**
     * Transforms the given number to an array of bits (numbers).
     * Lower indices in the returned array corresponding to less significant bits.
     * @memberof jiff-instance.helpers
     * @instance
     * @param {number} number - the number to transform to binary
     * @param {length} [length=ceil(log2(number))] - if provided, then the given array will be padded with zeros to the length.
     * @return {number[]} the array of bits.
     */
    jiff.helpers.number_to_bits = function (number, length) {
      number = number.toString(2);
      var bits = [];
      for (var i = 0; i < number.length; i++) {
        bits[i] = parseInt(number.charAt(number.length - 1 - i));
      }
      while (length != null && bits.length < length) {
        bits.push(0);
      }
      return bits;
    };

    /**
     * Transforms the given array of bits to a number.
     * @memberof jiff-instance.helpers
     * @instance
     * @param {bits} number[] - the array of bits to compose as a number, starting from least to most significant bits.
     * @param {length} [length = bits.length] - if provided, only the first 'length' bits will be used
     * @return {number} the array of bits.
     */
    jiff.helpers.bits_to_number = function (bits, length) {
      if (length == null || length > bits.length) {
        length = bits.length;
      }
      return parseInt(bits.slice(0, length).reverse().join(''), 2);
    };

    /**
     * The function used by JIFF to create a new share. This can be used by extensions to create custom shares.
     * Modifying this will modify how shares are generated in the BASE JIFF implementation.
     * A share is a value wrapper with a share object, it has a unique id
     * (per computation instance), and a pointer to the instance it belongs to.
     * A share also has methods for performing operations.
     * @memberof jiff-instance
     * @method secret_share
     * @instance
     * @param {jiff-instance} jiff - the jiff instance.
     * @param {boolean} ready - whether the value of the share is ready or deferred.
     * @param {promise} promise - a promise to the value of the share.
     * @param {number} value - the value of the share (null if not ready).
     * @param {Array} holders - the parties that hold all the corresponding shares (must be sorted).
     * @param {number} threshold - the min number of parties needed to reconstruct the secret.
     * @param {number} Zp - the mod under which this share was created.
     * @returns {SecretShare} the secret share object containing the give value.
     *
     */
    jiff.secret_share = secret_share;

    /**
     * Share a secret input.
     * @method share
     * @memberof jiff-instance
     * @instance
     * @param {number} secret - the number to share (this party's input).
     * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
     * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
     * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
     * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
     * @param {string|number} [share_id=auto_gen()] - the tag used to tag the messages sent by this share operation, this tag is used
     *                                   so that parties distinguish messages belonging to this share operation from other
     *                                   share operations between the same parties (when the order of execution is not
     *                                   deterministic). An automatic id is generated by increasing a local counter, default
     *                                   ids suffice when all parties execute all sharing operations with the same senders
     *                                   and receivers in the same order.
     * @returns {object} a map (of size equal to the number of sending parties)
     *          where the key is the party id (from 1 to n)
     *          and the value is the share object that wraps
     *          the value sent from that party (the internal value maybe deferred).
     * @example
     * // share an input value with all parties, and receive all other parties' inputs
     * var shares = jiff_instance.share(input);
     * // my party id is '1', so the first share is mine (technically my share of my input value)
     * var my_share = shares[1];
     *
     * // my share of party 2's input
     * var p2_share = shares[2];
     */
    jiff.share = function (secret, threshold, receivers_list, senders_list, Zp, share_id) {
      // type check to confirm the secret to be shared is a number
      // for fixed-point extension it should allow non-ints
      if (secret != null && (typeof(secret) !== 'number' || Math.floor(secret) !== secret || secret < 0)) {
        throw new Error('secret must be a non-negative whole number');
      }
      if (secret != null && (secret >= (Zp == null ? jiff.Zp : Zp))) {
        throw new Error('secret must fit inside Zp');
      }
      return jiff.internal_share(secret, threshold, receivers_list, senders_list, Zp, share_id);
    };

    /**
     * Same as jiff-instance.share, but used by internal JIFF primitives/protocols (bgw).
     */
    jiff.internal_share = function (secret, threshold, receivers_list, senders_list, Zp, share_id) {
      return jiff_share(jiff, secret, threshold, receivers_list, senders_list, Zp, share_id);
    };

    /**
     * Share an array of values. Each sender may have an array of different length. This is handled by the lengths parameter.
     * This function will reveal the lengths of the shared array.
     * If parties would like to keep the lengths of their arrays secret, they should agree on some "max" length apriori (either under MPC
     * or as part of the logistics of the computation), all their arrays should be padded to that length by using appropriate default/identity
     * values.
     * @method share_array
     * @memberof jiff-instance
     * @instance
     * @param {Array} array - the array to be shared.
     * @param {null|number|object} [lengths] - the lengths of the arrays to be shared, has the following options: <br>
     *                                       1. null: lengths are unknown, each sender will publicly reveal the lengths of its own array. <br>
     *                                       2. number: all arrays are of this length <br>
     *                                       3. object: { <sender_party_id>: length }: must specify the length of the array for each sender. <br>
     * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
     * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
     * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
     * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
     * @param {string|number} [share_id=auto_gen()] - the base tag used to tag the messages sent by this share operation, every element of the array
     *                                   will get a unique id based on the concatenation of base_share_id and the index of the element.
     *                                   This tag is used so that parties distinguish messages belonging to this share operation from
     *                                   other share operations between the same parties (when the order of execution is not
     *                                   deterministic). An automatic id is generated by increasing a local counter, default
     *                                   ids suffice when all parties execute all sharing operations with the same senders
     *                                   and receivers in the same order.
     * @returns {promise} if the calling party is a receiver then a promise to the shared arrays is returned, the promise will provide an object
     *                    formatted as follows: { <party_id>: [ <1st_share>, <2nd_share>, ..., <(lengths[party_id])th_share> ] }
     *                    where the party_ids are those of the senders.
     *                    if the calling party is not a receiver, then null is returned.
     */
    jiff.share_array = function (array, lengths, threshold, receivers_list, senders_list, Zp, share_id) {
      return jiff_share_array(jiff, array, lengths, threshold, receivers_list, senders_list, Zp, share_id);
    };

    /**
     * Share a 2D array of values. Each sender may have a 2D array of different length (possibily jagged). This is handled by the lengths parameter.
     * This function will reveal the lengths of the shared array.
     * If parties would like to keep the lengths of their arrays secret, they should agree on some "max" length apriori (either under MPC
     * or as part of the logistics of the computation), all their arrays should be padded to that length by using appropriate default/identity
     * values.
     * @method share_2D_array
     * @memberof jiff-instance
     * @instance
     * @param {Array[]} array - the 2D array to be shared.
     * @param {null|number|object} [lengths] - the lengths of the arrays to be shared. For this to work successfully, the
     *                                       same exact value must be used in the calling code for each party. Any missing
     *                                       lengths for a row will be automatically publicly revealed by this function.
     *                                       Must have the following format: <br>
     *                                       1. null: lengths are unknown, each sender will publicly reveal the lengths of its own array. <br>
     *                                       2. { rows: <number>, cols: <number>, 0: <number>, 1: <number>, ...}: all parties have arrays
     *                                          with the given number of rows and cols. In case of jagged 2D arrays, different rows
     *                                          can have a different number of cols specified by using <row_index>: <col_size>.
     *                                          rows is mandatory, cols and any other number matching a specific row are optional. <br>
     *                                       3. { <sender_party_id>: <length_object> }: must specify the lengths for each party by using
     *                                          an object with the same format as 2. Must include every party. <br>
     * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
     * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
     * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
     * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
     * @param {string|number} [share_id=auto_gen()] - the base tag used to tag the messages sent by this share operation, every element of the array
     *                                   will get a unique id based on the concatenation of base_share_id and the index of the element.
     *                                   This tag is used so that parties distinguish messages belonging to this share operation from
     *                                   other share operations between the same parties (when the order of execution is not
     *                                   deterministic). An automatic id is generated by increasing a local counter, default
     *                                   ids suffice when all parties execute all sharing operations with the same senders
     *                                   and receivers in the same order.
     * @returns {promise} if the calling party is a receiver then a promise to the shared arrays is returned, the promise will provide an object
     *                    formatted as follows: { <party_id>: [ [ <1st_row_shares> ], [<2nd_row_share> ], ..., [ <(lengths[party_id])th_row_shares> ] ] }
     *                    where the party_ids are those of the senders.
     *                    if the calling party is not a receiver, then null is returned.
     */
    jiff.share_2D_array = function (array, lengths, threshold, receivers_list, senders_list, Zp, share_id) {
      return jiff_share_2D_array(jiff, array, lengths, threshold, receivers_list, senders_list, Zp, share_id);
    };

    /**
     * Open a secret share to reconstruct secret.
     * @method open
     * @memberof jiff-instance
     * @instance
     * @param {SecretShare} share - this party's share of the secret to reconstruct.
     * @param {Array} [parties=all_parties] - an array with party ids (1 to n) of receiving parties.
     * @param {string|number} [op_id=auto_gen()] - the operation id to be used to tag outgoing messages.
     * @returns {promise|null} a (JQuery) promise to the open value of the secret, null if the party is not specified in the parties array as a receiver.
     * @throws error if share does not belong to the passed jiff instance.
     * @example
     * var shares = jiff_instance.share(input);
     * //multiply the inputs of party 1 and 2 together
     * var result = shares[1].mult(shares[2]);
     * // reveal the result of the multiplication to all parties
     * return jiff_instance.open(result);
     */
    jiff.open = function (share, parties, op_id) {
      return jiff.internal_open(share, parties, op_id);
    };

    /**
     * Same as jiff-instance.open, but used by internal JIFF primitives/protocols (comparisons and secret multiplication).
     */
    jiff.internal_open = function (share, parties, op_id) {
      return jiff_open(jiff, share, parties, op_id);
    };

    /**
     * Opens an array of secret shares.
     * @method open_array
     * @memberof jiff-instance
     * @instance
     * @param {SecretShare[]} shares - an array containing this party's shares of the secrets to reconstruct.
     * @param {Array} [parties=all_parties] - an array with party ids (1 to n) of receiving parties.
     * @param {string|number} [op_id=auto_gen()] - same as jiff_instance.open
     * @returns {promise} a (JQuery) promise to ALL the open values of the secret, the promise will yield
     *                    an array of values matching the corresponding given secret share by index.
     * @throws error if some shares does not belong to the passed jiff instance.
     */
    jiff.open_array = function (shares, parties, op_id) {
      return jiff_open_array(jiff, shares, parties, op_id);
    };

    /**
     * Opens a 2D array of secret shares.
     * @method open_2D_array
     * @memberof jiff-instance
     * @instance
     * @param {SecretShare[][]} shares - an array containing this party's shares of the secrets to reconstruct.
     * @param {jiff-instance} jiff - the jiff instance.
     * @param {SecretShare[]} shares - an array containing this party's shares of the secrets to reconstruct.
     * @param {Array} [parties=all_parties] - an array with party ids (1 to n) of receiving parties.
     * @param {string|number} [op_id=auto_gen()] - same as jiff_instance.open
     * @returns {promise} a (JQuery) promise to ALL the open values of the secret, the promise will yield
     *                    a 2D array of values matching the corresponding given secret share by indices.
     * @throws error if some shares does not belong to the passed jiff instance.
     */
    jiff.open_2D_array = function (shares, parties, op_id) {
      // Default values
      if (parties == null || parties === []) {
        parties = [];
        for (i = 1; i <= jiff.party_count; i++) {
          parties.push(i);
        }
      }

      // Compute operation ids (one for each party that will receive a result
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id2('open_2D_array', parties, shares[0].holders);
      }

      var promises = [];
      for (var i = 0; i < shares.length; i++) {
        var row = shares[i];

        // share
        var promise = jiff.open_array(row, parties, op_id + ':' + i);
        if (promise != null) {
          promises.push(promise);
        }
      }

      if (promises.length === 0) {
        return null;
      }

      return Promise.all(promises);
    };

    /**
     * Receive shares from the specified parties and reconstruct their secret.
     * Use this function in a party that will receive some answer/value but does not have a share of it.
     * @method receive_open
     * @memberof jiff-instance
     * @instance
     * @param {Array} senders - an array with party ids (1 to n) specifying the parties sending the shares.
     * @param {Array} [receivers=all_parties] - an array with party ids (1 to n) specifying the parties receiving the result.
     * @param {number} [threshold=senders.length] - the min number of parties needed to reconstruct the secret, defaults to all the senders.
     * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
     * @param {string|number} [op_id=auto_Gen()] - same as jiff-instance.open
     * @returns {promise} a (JQuery) promise to the open value of the secret.
     */
    jiff.receive_open = function (senders, receivers, threshold, Zp, op_id) {
      if (senders == null) {
        throw new Error('Must provide "senders" parameter in receive_open');
      }
      if (Zp == null) {
        Zp = jiff.Zp;
      }
      return jiff_open(jiff, jiff.secret_share(jiff, true, null, null, senders, (threshold == null ? senders.length : threshold), Zp), receivers, op_id);
    };

    /**
     * Requests secret(s) from the server (crypto provider) of type matching the given label.
     * @method from_crypto_provider
     * @memberof jiff-instance
     * @instance
     * @param {string} label - the type of secret(s) being requested from crypto_provider (e.g. triplet, bit, etc)
     * @param {Array} [receivers_list=all_parties] - array of party ids that want to receive the secret(s), by default, this includes all parties.
     * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret(s).
     * @param {number} [Zp=jiff_instance.Zp] - the mod, defaults to the Zp of the instance.
     * @param {string} [op_id=auto_Gen()] - an id which is used to identify the secret requested, so that every party
     *                              gets a share from the same secret for every matching instruction. An automatic id
     *                              is generated by increasing a local counter per label, default ids suffice when all
     *                              parties execute all instructions in the same order.
     * @returns {promise} a promise to the secret(s) provided by the server/crypto provider, the promise returns an object with the given format:
     *                               { values: <any values returned by the server side>, shares: <array of secret share objects matching shares returned by server by index>}
     */
    jiff.from_crypto_provider = function (label, receivers_list, threshold, Zp, op_id, params) {
      return from_crypto_provider(jiff, label, receivers_list, threshold, Zp, op_id, params);
    };

    /**
     * A collection of useful protocols to be used during computation or preprocessing: extensions are encouraged to add useful
     * common protocols here, under a sub namespace corresponding to the extension name.
     * @memberof jiff-instance
     * @namespace protocols
     */
    jiff.protocols = {};

    /**
     * share an existing share (value) under a new threshold or to a new set of parties. Should not be used to refresh a share (use share.refresh() instead).
     * @method reshare
     * @instance
     * @memberof jiff-instance.protocols
     * @param {secret_share} [share=null] - the share you would like to reshare (null if you are a receiver but not a sender).
     * @param {number} [threshold=receivers_list.length] - the new threshold, defaults to the length of receivers_list param
     * @param {Array} [receivers_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
     * @param {Array} [senders_list=all_parties] - array of party ids that posses the share and will reshare it with the receivers, by default, this includes all parties.
     * @param {number} [Zp=jiff.Zp] - the Zp of the existing share.
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this multiplication (and internally, the corresponding beaver triplet).
     *                         This id must be unique, and must be passed by all parties to the same instruction.
     *                         this ensures that every party gets a share from the same triplet for every matching instruction. An automatic id
     *                         is generated by increasing a local counter, default ids suffice when all parties execute the
     *                         instructions in the same order.
     * @return {SecretShare} this party's share of the result under the new threshold, or null if this party is not a receiver.
     */
    jiff.protocols.reshare = function (share, threshold, receivers_list, senders_list, Zp, op_id) {
      var i;

      // default values
      if (receivers_list == null) {
        receivers_list = [];
        for (i = 1; i <= jiff.party_count; i++) {
          receivers_list.push(i);
        }
      }
      if (senders_list == null) {
        senders_list = [];
        for (i = 1; i <= jiff.party_count; i++) {
          senders_list.push(i);
        }
      }

      if (threshold == null) {
        threshold = receivers_list.length;
      }
      if (Zp == null) {
        Zp = jiff.Zp;
      }

      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('reshare', senders_list);
      }

      // Check if this party is a sender or receiver
      var isSender = senders_list.indexOf(jiff.id) > -1;
      var isReceiver = receivers_list.indexOf(jiff.id) > -1;
      if (!isSender && !isReceiver) {
        return null;
      }

      // optimization, if nothing changes, keep share
      if (share != null && JSON.stringify(receivers_list) === JSON.stringify(senders_list) && threshold === share.threshold) {
        return share;
      }

      // Setup the result
      var final_deferred;
      var result = null;
      if (isReceiver) {
        final_deferred = new jiff.helpers.Deferred;
        result = jiff.secret_share(jiff, false, final_deferred.promise, undefined, receivers_list, threshold, Zp);
      }

      // This function is called when the share is ready: the value of the share has been received.
      var ready_share = function () {
        var intermediate_shares = jiff.internal_share(isSender ? share.value : null, threshold, receivers_list, senders_list, Zp, op_id);

        if (isReceiver) {
          var promises = [];
          for (var i = 0; i < senders_list.length; i++) {
            var party_id = senders_list[i];
            promises.push(intermediate_shares[party_id].promise);
          }

          // Reconstruct share under new threshold
          Promise.all(promises).then(function () {
            var reconstruct_parts = [];
            for (var i = 0; i < senders_list.length; i++) {
              var party_id = senders_list[i];
              //shamir reconstruct takes an array of objects
              //has attributes: {value: x, sender_id: y, Zp: jiff_instance.Zp}
              reconstruct_parts[i] = {value: intermediate_shares[party_id].value, sender_id: party_id, Zp: Zp};
            }
            var value = jiff.hooks.reconstructShare(jiff, reconstruct_parts);
            final_deferred.resolve(value);
          });
        }
      };

      if (isSender && !share.ready) {
        share.promise.then(ready_share);
      } else { // either a receiver or share is ready
        ready_share();
      }

      return result;
    };

    /**
     * Creates shares of an unknown random number. Every party comes up with its own random number and shares it.
     * Then every party combines all the received shares to construct one share of the random unknown number.
     * @method generate_random_number
     * @memberof jiff-instance.protocols
     * @instance
     * @param {number} threshold - the min number of parties needed to reconstruct the secret after it is computed.
     * @param {Array} receivers_list - array of party ids to receive the result.
     * @param {Array} compute_list - array of party ids to perform the protocol.
     * @param {number} Zp - the mod.
     * @param {object} params - an object containing extra parameters passed by the user.
     *                                 Expects:
     *                               - op_id: the base id to use for operation during the execution of this protocol, defaults to auto generated.
     *                               - compute_threshold: the threshold to use during computation: defaults to compute_list.length
     * @return {Object} contains 'share' (this party's share of the result) and 'promise'.
     */
    jiff.protocols.generate_random_number = function (threshold, receivers_list, compute_list, Zp, params) {
      if (params.op_id == null) {
        params.op_id = jiff.counters.gen_op_id2('generate_random_number', receivers_list, compute_list);
      }
      return jiff_share_all_number(jiff, jiff.helpers.random(Zp), threshold, receivers_list, compute_list, Zp, params);
    };

    /**
     * Creates shares of 0, such that no party knows the other parties' shares.
     * Every party secret shares 0, then every party sums all the shares they received, resulting
     * in a new share of 0 for every party.
     * @method generate_zero
     * @memberof jiff-instance.protocols
     * @instance
     * @param {number} threshold - the min number of parties needed to reconstruct the secret after it is computed.
     * @param {Array} receivers_list - array of party ids to receive the result.
     * @param {Array} compute_list - array of party ids to perform the protocol.
     * @param {number} Zp - the mod.
     * @param {object} params - an object containing extra parameters passed by the user.
     *                                 Expects:
     *                               - op_id: the base id to use for operation during the execution of this protocol, defaults to auto generated.
     *                               - compute_threshold: the threshold to use during computation: defaults to compute_list.length
     * @return {Object} contains 'share' (this party's share of the result) and 'promise'.
     */
    jiff.protocols.generate_zero = function (threshold, receivers_list, compute_list, Zp, params) {
      if (params.op_id == null) {
        params.op_id = jiff.counters.gen_op_id2('generate_random_number', receivers_list, compute_list);
      }
      return jiff_share_all_number(jiff, 0, threshold, receivers_list, compute_list, Zp, params);
    };

    /**
     * Creates shares of r and x, such that r is a uniform random number between 0 and Zp, and x is floor(r/constant)
     * where constant is provided by the extra params.
     * @method generate_random_and_quotient
     * @memberof jiff-instance.protocols
     * @instance
     * @param {number} threshold - the min number of parties needed to reconstruct the secret after it is computed.
     * @param {Array} receivers_list - array of party ids to receive the result.
     * @param {Array} compute_list - array of party ids to perform the protocol.
     * @param {number} Zp - the mod.
     * @param {object} params - an object containing extra parameters passed by the user.
     *                                 Expects:
     *                               - op_id: the base id to use for operation during the execution of this protocol, defaults to auto generated.
     *                               - compute_threshold: the threshold to use during computation: defaults to compute_list.length
     *                               - constant: the constant to divide the random number by.
     *                               - output_op_id: the set op id of the output quotient and noise.
     * @return {Object} contains 'share' (this party's share of the result) and 'promise'.
     */
    jiff.protocols.generate_random_and_quotient = function (threshold, receivers_list, compute_list, Zp, params, protocols) {
      // consistent and unique op_id for compute and receiver parties
      if (params.op_id == null) {
        params.op_id = jiff.counters.gen_op_id2('generate_random_and_quotient', receivers_list, compute_list);
      }
      if (params.compute_threshold == null) {
        params.compute_threshold = Math.floor((compute_list.length + 1) / 2); // honest majority BGW
      }

      // read only copy
      var _params = params;

      var promise = null;
      // do preprocessing for this function
      if (params.ondemand !== true) {
        var intermediate_output_op_id = params.constant != null ? params.op_id : params.output_op_id;
        params = Object.assign({}, _params);
        params.op_id = params.op_id + ':preprocessing';
        params.output_op_id = intermediate_output_op_id;
        promise = jiff.__preprocessing('__generate_random_and_quotient', 1, protocols, params.compute_threshold, compute_list, compute_list, Zp, [intermediate_output_op_id], params);
      }

      // execute the actual function
      if (_params.constant == null) {
        return {share: { ondemand: true }, promise: promise};
      }

      var constant = _params.constant;
      var op_id = _params.op_id;

      // stores the result
      var r, q;

      // for compute parties
      var promise;
      if (compute_list.indexOf(jiff.id) > -1) {
        var largest_quotient, largest_multiple;
        if (Zp.isBigNumber === true) {
          largest_quotient = Zp.div(constant).floor();
          largest_multiple = largest_quotient.times(constant);
        } else {
          largest_quotient = Math.floor(Zp / constant);
          largest_multiple = largest_quotient * constant;
        }

        // Uniform random number between 0 and Zp
        var r_bits = jiff.get_preprocessing(op_id + ':rejection1');
        var cmp = jiff.protocols.bits.cgteq(r_bits, largest_multiple, op_id + ':bits_cgteq');
        var r1 = jiff.protocols.bits.bit_composition(r_bits); // assume cmp = 1

        // assume cmp = 0
        params = Object.assign({}, _params);
        params.op_id = op_id + ':rejection2';
        params.upper_bound = largest_quotient;
        var div = jiff.protocols.bits.rejection_sampling(params.compute_threshold, compute_list, compute_list, Zp, params, protocols).share;
        div = jiff.protocols.bits.bit_composition(div);

        params = Object.assign({}, params);
        params.op_id = op_id + ':rejection3';
        params.upper_bound = constant;
        var mod = jiff.protocols.bits.rejection_sampling(params.compute_threshold, compute_list, compute_list, Zp, params, protocols).share;
        mod = jiff.protocols.bits.bit_composition(mod);
        var r2 = div.icmult(constant).isadd(mod);

        // choose either (r1, largest_quotient) or (r2, div) based on cmp result
        r = cmp.iif_else(r1, r2, op_id + ':ifelse1');
        q = cmp.iif_else(largest_quotient, div, op_id + ':ifelse2');
        promise = Promise.all([r.promise, q.promise]);
      }

      // reshare the result with the designated receivers
      r = jiff.protocols.reshare(r, threshold, receivers_list, compute_list, Zp, op_id + ':reshare1');
      q = jiff.protocols.reshare(q, threshold, receivers_list, compute_list, Zp, op_id + ':reshare2');

      // return result
      if (receivers_list.indexOf(jiff.id) > -1) {
        promise = Promise.all([r.promise, q.promise]);
      }
      return {share: {r: r, q: q}, promise: promise};
    };

    /**
     * generation of beaver triplet via MPC, uses the server for communication channels, but not for generation.
     * @method generate_beaver_bgw
     * @memberof jiff-instance.protocols
     * @instance
     * @param {number} threshold - the threshold of the triplets when stored by receivers after generation.
     * @param {Array} receivers_list - array of party ids that want to receive the triplet shares.
     * @param {Array} compute_list - array of party ids that will perform this protocol.
     * @param {number} Zp - the mod.
     * @param {object} params - an object containing extra parameters passed by the user.
     *                               Expects:
     *                               - op_id: the base id to use for operation during the execution of this protocol, defaults to auto generated.
     *                               - an optional number compute_threshold parameter, which specifies threshold used
     *                               during the protocol execution. By default, this is the length of the (compute_list+1)/2.
     * @param {object} protocols - the sub protocols to use for preprocessing.
     * @return {object} all pre-processing protocols must return an object with these keys:
     *  {
     *    'share': the share(s)/value(s) to store attached to op_id for later use by the computation (i.e. the result of preprocessing),
     *    'promise': a promise for when this protocol is fully completed (could be null if the protocol was already completed)
     *  }
     *  In this case, 'share' is an array of this party's shares of the resulting triplet, a,b,c such that a*b=c.
     */
    jiff.protocols.generate_beaver_bgw = function (threshold, receivers_list, compute_list, Zp, params, protocols) {
      if (params.compute_threshold == null) {
        params.compute_threshold = Math.floor((compute_list.length + 1) / 2); // honest majority BGW
      }
      if (params.op_id == null) {
        params.op_id = jiff.counters.gen_op_id2('generate_beaver_bgw', receivers_list, compute_list);
      }
      var op_id = params.op_id;
      var _params = params;

      var a, b, c, promises;
      if (compute_list.indexOf(jiff.id) > -1) {
        params = Object.assign({}, _params);
        params.op_id = op_id + ':share_a';
        a = protocols.generate_random_number(params.compute_threshold, compute_list, compute_list, Zp, params, protocols).share;

        params = Object.assign({}, _params);
        params.op_id = op_id + ':share_b';
        b = protocols.generate_random_number(params.compute_threshold, compute_list, compute_list, Zp, params, protocols).share;

        c = a.ismult_bgw(b, op_id + ':smult_bgw');
        promises = [a.promise, b.promise, c.promise];
      }

      a = jiff.protocols.reshare(a, threshold, receivers_list, compute_list, Zp, op_id + ':reshare_a');
      b = jiff.protocols.reshare(b, threshold, receivers_list, compute_list, Zp, op_id + ':reshare_b');
      c = jiff.protocols.reshare(c, threshold, receivers_list, compute_list, Zp, op_id + ':reshare_c');
      if (receivers_list.indexOf(jiff.id) > -1) {
        promises = [a.promise, b.promise, c.promise];
      }

      return { share: [a, b, c], promise: Promise.all(promises) };
    };

    /**
     * generates a random bit under MPC by xoring all bits sent by participating parties
     * @method generate_random_bit_bgw
     * @memberof jiff-instance.protocols
     * @instance
     * @param {number} threshold - the min number of parties needed to reconstruct the secret after it is computed.
     * @param {Array} receivers_list - array of party ids to receive the result.
     * @param {Array} compute_list - array of party ids to perform the protocol.
     * @param {number} Zp - the mod.
     * @param {object} params - an object containing extra parameters passed by the user.
     *                                 Expects:
     *                               - op_id: the base id to use for operation during the execution of this protocol, defaults to auto generated.
     *                               - compute_threshold: the threshold to use during computation: defaults to compute_list.length
     * @return {Object} contains 'share' (this party's share of the generated bit) and 'promise'.
     */
    jiff.protocols.generate_random_bit_bgw  = function (threshold, receivers_list, compute_list, Zp, params) {
      if (params.op_id == null) {
        params.op_id = jiff.counters.gen_op_id2('generate_random_bit_bgw', receivers_list, compute_list);
      }
      if (params.compute_threshold == null) {
        params.compute_threshold = Math.floor((compute_list.length + 1) / 2); // honest majority BGW
      }

      var op_id = params.op_id;

      // Generate random bit
      var random_bit, promise;
      if (compute_list.indexOf(jiff.id) > -1) {
        var bit = jiff.helpers.random(2);
        var bit_shares = jiff.internal_share(bit, params.compute_threshold, compute_list, compute_list, Zp, op_id + ':share');

        random_bit = bit_shares[compute_list[0]];
        for (var i = 1; i < compute_list.length; i++) {
          var party_id = compute_list[i];
          var obit = bit_shares[party_id];
          random_bit = random_bit.isadd(obit).issub(random_bit.ismult_bgw(obit, op_id + ':smult' + i).icmult(2));
        }

        promise = random_bit.promise;
      }

      // Reshare
      random_bit = jiff.protocols.reshare(random_bit, threshold, receivers_list, compute_list, Zp, op_id+':reshare');
      if (receivers_list.indexOf(jiff.id) > -1) {
        promise = random_bit.promise;
      }
      return { share: random_bit, promise: promise };
    };

    /**
     * generates a sequence of random bits under MPC.
     * @method generate_random_bits
     * @memberof jiff-instance.protocols
     * @instance
     * @param {number} [threshold=receivers_list.length] - the threshold of the bit when stored by receivers after generation.     * @param {number} threshold - the min number of parties needed to reconstruct the secret after it is computed.
     * @param {Array} receivers_list - array of party ids to receive the result.
     * @param {Array} compute_list - array of party ids to perform the protocol.
     * @param {number} Zp - the mod.
     * @param {object} params - an object containing extra parameters passed by the user.
     *                                 Expects:
     *                               - op_id: the base id to use for operation during the execution of this protocol, defaults to auto generated.
     *                               - count: how many random bits to generate.
     *                               - compute_threshold: the threshold to use during computation: defaults to compute_list.length
     * @param {object} protocols - the protocols to use for preprocessing.
     * @return {Object} contains 'share' (array of secret shares bits) and 'promise'.
     */
    jiff.protocols.generate_random_bits = function (threshold, receivers_list, compute_list, Zp, params, protocols) {
      if (params.count == null) {
        params.count = 1;
      }
      if (params.op_id == null) {
        params.op_id = jiff.counters.gen_op_id2('generate_random_bits', receivers_list, compute_list);
      }

      var op_id = params.op_id;
      var _params = params;

      var promises = [];
      var bits = [];
      for (var i = 0; i < params.count; i++) {
        params = Object.assign({}, _params);
        params.op_id = op_id + ':' + i;

        var bit = protocols.generate_random_bit(threshold, receivers_list, compute_list, Zp, params, protocols);

        promises.push(bit.promise);
        if (bit.share != null) {
          bits.push(bit.share);
        }
      }

      if (bits.length === 0) {
        bits = null;
      }
      return {share: bits, promise: Promise.all(promises)};
    };

    /**
     * A collection of useful protocols for manipulating bitwise shared numbers, and transforming them from and to regular numeric shares.
     * @memberof jiff-instance.protocols
     * @namespace bits
     */
    jiff.protocols.bits = {};

    /**
     * Creates a secret share of the number represented by the given array of secret shared bits.
     * Requires no communication, only local operations.
     * @method bit_composition
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - an array of the secret shares of bits, starting from least to most significant bits.
     * @returns {SecretShare} a secret share of the number represented by bits.
     */
    jiff.protocols.bits.bit_composition = function (bits) {
      var result = bits[0];
      var pow = 1;
      for (var i = 1; i < bits.length; i++) {
        pow = pow * 2;
        result = result.isadd(bits[i].icmult(pow));
      }
      return result;
    };

    /**
     * Share a number as an array of secret bits
     * This takes the same parameters as jiff-instance.share, but returns an array of secret bit shares per sending party.
     * Each bit array starts with the least significant bit at index 0, and most significant bit at index length-1.
     * @method share_bits
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {number} secret - the number to share (this party's input)
     * @param {number} [bit_length=jiff_instance.Zp] - the number of generated bits, if the secret has less bits, it will be
     *                                                 padded with zeros.
     * @param {number} [threshold=receivers_list.length] - threshold of each shared bit.
     * @param {Array} [receivers_list=all_parties] - receivers of every bits.
     * @param {Array} [senders_list=all_parties] - senders of evey bit.
     * @param {number} [Zp=jiff_instance.Zp] - the field of sharing for every bit.
     * @param {string|number} [share_id=auto_gen()] - synchronization id.
     * @returns {object} a map (of size equal to the number of parties)
     *          where the key is the party id (from 1 to n)
     *          and the value is an array of secret shared bits.
     */
    jiff.protocols.bits.share_bits = function (secret, bit_length, threshold, receivers_list, senders_list, Zp, share_id) {
      var i;
      if (Zp == null) {
        Zp = jiff.Zp;
      }
      if (receivers_list == null) {
        receivers_list = [];
        for (i = 1; i <= jiff.party_count; i++) {
          receivers_list.push(i);
        }
      }
      if (senders_list == null) {
        senders_list = [];
        for (i = 1; i <= jiff.party_count; i++) {
          senders_list.push(i);
        }
      }

      if (share_id == null) {
        share_id = jiff.counters.gen_op_id2('share_bits', receivers_list, senders_list);
      }

      if (bit_length == null) {
        bit_length = Zp.toString(2).length;
      }

      // to allow for secret=null when party is not a sender
      var local_bits = [];
      if (secret != null) {
        local_bits = jiff.helpers.number_to_bits(secret, bit_length);
      }

      var shared_bits = {};
      for (i = 0; i < senders_list.length; i++) {
        shared_bits[senders_list[i]] = [];
      }

      for (i = 0; i < bit_length; i++) {
        var round = jiff.internal_share(local_bits[i], threshold, receivers_list, senders_list, Zp, share_id + ':' + i);
        for (var si = 0; si < senders_list.length; si++) {
          var pid = senders_list[si];
          shared_bits[pid].push(round[pid]);
        }
      }

      return shared_bits;
    };

    /**
     * Opens the given array of secret shared bits.
     * This works regardless of whether the represented value fit inside the corresponding field or not.
     * @method open
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - an array of the secret shares of bits, starting from least to most significant bits.
     * @param {number[]} parties - parties to open (same as jiff_instance.open)
     * @param {string|number} [op_id=auto_gen()] - same as jiff_instance.open
     * @returns {promise} a promise to the number represented by bits.
     */
    jiff.protocols.bits.open = function (bits, parties, op_id) {
      // Default values
      if (parties == null || parties === []) {
        parties = [];
        for (var p = 1; p <= jiff.party_count; p++) {
          parties.push(p);
        }
      }

      // Compute operation ids (one for each party that will receive a result
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id2('bits.open', parties, bits[0].holders);
      }

      var opened_bits = [];
      for (var i = 0; i < bits.length; i++) {
        opened_bits[i] = jiff.internal_open(bits[i], parties, op_id + ':' + i);
      }

      return Promise.all(opened_bits).then(function (bits) {
        return jiff.helpers.bits_to_number(bits, bits.length);
      });
    };

    /**
     * Receives an opening of an array of secret bits without owning shares of the underlying value.
     * Similar to jiff.receive_open() but for bits.
     * This works regardless of whether the represented value fit inside the corresponding field or not.
     * @method receive_open
     * @memberOf jiff-instance.protocols.bits
     * @instance
     * @param {Array} senders - an array with party ids (1 to n) specifying the parties sending the shares.
     * @param {Array} [receivers=all_parties] - an array with party ids (1 to n) specifying the parties receiving the result.
     * @param {number} [count=ceil(log2(Zp))] - the number of bits being opened.
     * @param {number} [threshold=parties.length] - the min number of parties needed to reconstruct the secret, defaults to all the senders.
     * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
     * @param {string|number|object} [op_id=auto_gen()] - unique and consistent synchronization id between all parties.
     * @returns {promise} a (JQuery) promise to the open value of the secret.
     */
    jiff.protocols.bits.receive_open = function (senders, receivers, count, threshold, Zp, op_id) {
      if (senders == null) {
        throw new Error('Must provide "senders" parameter in receive_open');
      }
      // Default values
      if (receivers == null) {
        receivers = [];
        for (i = 1; i <= jiff.party_count; i++) {
          receivers.push(i);
        }
      }

      if (op_id == null) {
        op_id = jiff.counters.gen_op_id2('bits.open', receivers, senders);
      }

      if (count == null) {
        if (Zp == null) {
          Zp = jiff.Zp;
        }
        count = Zp.toString(2).length;
      }

      var opened_bits = [];
      for (var i = 0; i < count; i++) {
        opened_bits[i] = jiff.receive_open(senders, receivers, threshold, Zp, op_id + ':' + i);
      }

      return Promise.all(opened_bits).then(function (bits) {
        return jiff.helpers.bits_to_number(bits, bits.length);
      });
    };

    /**
     * Checks whether the given bitwise secret shared number and numeric constant are equal.
     * @method ceq
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - an array of secret shares of bits, starting from least to most significant bits.
     * @param {number} constant - the constant number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare|boolean} a secret share of 1 if parameters are equal, 0 otherwise. If result is known
     *                                (e.g. constant has a greater non-zero bit than bits' most significant bit), the result is
     *                                returned immediately as a boolean.
     */
    jiff.protocols.bits.ceq = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.ceq)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.ceq', bits[0].holders);
      }
      var result = jiff.protocols.bits.cneq(bits, constant, op_id);
      if (result === true || result === false) {
        return !result;
      }
      return result.inot();
    };

    /**
     * Checks whether the given bitwise secret shared number and numeric constant are not equal.
     * @method cneq
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - an array of secret shares of bits, starting from least to most significant bits.
     * @param {number} constant - the constant number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare|boolean} a secret share of 1 if parameters are not equal, 0 otherwise. If result is known
     *                                (e.g. constant has a greater non-zero bit than bits' most significant bit), the result is
     *                                returned immediately as a boolean.
     */
    jiff.protocols.bits.cneq = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.cneq)');
      }

      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.cneq', bits[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits = bits.slice();

      var constant_bits = jiff.helpers.number_to_bits(constant, bits.length);
      if (constant_bits.length > bits.length) {
        // Optimization: if constant has more bits, one of them must be 1, constant must be greater than bits.
        return true;
      }

      var deferred = new jiff.helpers.Deferred();
      var result = jiff.secret_share(jiff, false, deferred.promise, undefined, bits[0].holders, bits[0].threshold, bits[0].Zp);

      // big or of bitwise XORs
      var initial = bits[0].icxor_bit(constant_bits[0]);
      bit_combinator(deferred, 1, bits.length, initial, function (i, prev) {
        var xor = bits[i].icxor_bit(constant_bits[i]);
        xor = prev.isor_bit(xor, op_id + ':sor_bit:' + (i - 1));
        return xor;
      });

      return result;
    };

    /**
     * Checks whether given secret shared bits are greater than the given constant.
     * @method cgt
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - an array of the secret shares of bits, starting from least to most significant bits.
     * @param {number} constant - the constant number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare|boolean} a secret share of 1 if bits are greater than constant, 0 otherwise, if result is known
     *                                (e.g. constant has greater non-zero bit than bits' most significant bit), the result is
     *                                returned immediately as a boolean.
     */
    jiff.protocols.bits.cgt = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.cgt)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.cgt', bits[0].holders);
      }
      return jiff.protocols.bits.cgteq(bits, constant+1, op_id);
    };

    /**
     * Checks whether given secret shared bits are greater or equal to the given constant.
     * @method cgteq
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - an array of the secret shares of bits, starting from least to most significant bits.
     * @param {number} constant - the constant number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare|boolean} a secret share of 1 if bits are greater or equal to constant, 0 otherwise, if result is known
     *                                (e.g. constant has greater non-zero bit than bits' most significant bit or constant is zero), the result is
     *                                returned immediately as a boolean.
     */
    jiff.protocols.bits.cgteq = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.cgteq)');
      }

      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.cgteq', bits[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits = bits.slice();

      // Optimization: the bits are a share of non-negative number, if constant <= 0, return true
      if (constant.toString().startsWith('-') || constant.toString() === '0') {
        return true;
      }

      // decompose result into bits
      var constant_bits = jiff.helpers.number_to_bits(constant, bits.length);
      if (constant_bits.length > bits.length) {
        // Optimization: if constant has more bits, one of them must be 1, constant must be greater than bits.
        return false;
      }

      // initialize result
      var deferred = new jiff.helpers.Deferred();
      var result = jiff.secret_share(jiff, false, deferred.promise, undefined, bits[0].holders, bits[0].threshold, bits[0].Zp);

      // Subtract bits2 from bits1, only keeping track of borrow
      var borrow = bits[0].inot().icmult(constant_bits[0]);

      // compute one bit at a time, propagating borrow
      bit_combinator(deferred, 1, bits.length, borrow, function (i, borrow) {
        var xor = bits[i].icxor_bit(constant_bits[i]);
        var andNot = bits[i].inot().icmult(constant_bits[i]);

        // save and update borrow
        borrow = xor.inot().ismult(borrow, op_id + ':smult:' + (i - 1));
        return borrow.isadd(andNot);
      });

      return result.inot();
    };

    /**
     * Checks whether given secret shared bits are less than the given constant.
     * @method clt
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - an array of the secret shares of bits, starting from least to most significant bits.
     * @param {number} constant - the constant number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare|boolean} a secret share of 1 if bits are less than the constant, 0 otherwise, if result is known
     *                                (e.g. constant has greater non-zero bit than bits' most significant bit), the result is
     *                                returned immediately as a boolean.
     */
    jiff.protocols.bits.clt = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.clt)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.clt', bits[0].holders);
      }
      var result = jiff.protocols.bits.cgteq(bits, constant, op_id);
      if (result === true || result === false) {
        return !result;
      }
      return result.inot();
    };

    /**
     * Checks whether given secret shared bits are less or equal to the given constant.
     * @method clteq
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - an array of the secret shares of bits, starting from least to most significant bits.
     * @param {number} constant - the constant number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare|boolean} a secret share of 1 if bits are less or equal to constant, 0 otherwise, if result is known
     *                                (e.g. constant has greater non-zero bit than bits' most significant bit), the result is
     *                                returned immediately as a boolean.
     */
    jiff.protocols.bits.clteq = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.clteq)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.clteq', bits[0].holders);
      }
      var result = jiff.protocols.bits.cgt(bits, constant, op_id);
      if (result === true || result === false) {
        return !result;
      }
      return result.inot();
    };

    // private
    var __rejection_sampling = function (lower_bound, upper_bound, compute_list, Zp, params, protocols) {
      // Figure out sampling range
      var range;
      if (upper_bound.isBigNumber === true) {
        range = upper_bound.minus(lower_bound);
      } else {
        range = upper_bound - lower_bound;
      }

      // Figure out final bit size (after adding back lower)
      var finalLength = jiff.helpers.ceil(jiff.helpers.bLog(upper_bound, 2));
      finalLength = parseInt(finalLength.toString(), 10);
      finalLength = Math.max(finalLength, 1); // special case: when upper_bound is 1!

      // Special cases
      if (range.toString() === '0') {
        throw new Error('rejection sampling called with range 0, no numbers to sample!');
      }
      if (range.toString() === '1') {
        var zero = protocols.generate_zero(params.compute_threshold, compute_list, compute_list, Zp, params, protocols).share;
        // special case: cadd can be performed locally on bit arrays of length 1!
        var resultOne = jiff.protocols.bits.cadd([zero], lower_bound);
        while (resultOne.length > finalLength) {
          resultOne.pop();
        }
        return resultOne;
      }

      // Transform sampling range into bit size
      var bitLength = jiff.helpers.ceil(jiff.helpers.bLog(range, 2));
      bitLength = parseInt(bitLength.toString(), 10);

      // Create output array of bit shares
      var many_shares = many_secret_shares(jiff, finalLength, compute_list, params.compute_threshold, Zp);
      var deferreds = many_shares.deferreds;
      var result = many_shares.shares;

      // Sample and resample output
      (function resample(reject_count) {
        var paramsCopy = Object.assign({}, params);
        paramsCopy['count'] = bitLength;
        paramsCopy['op_id'] = params.op_id + ':sampling:' + reject_count;
        var bits = protocols.generate_random_bits(params.compute_threshold, compute_list, compute_list, Zp, paramsCopy, protocols).share;

        // Rejection protocol
        var online_resample = function () {
          var bits_add = bits;
          if (lower_bound.toString() !== '0') {
            bits_add = jiff.protocols.bits.cadd(bits, lower_bound, params.op_id + ':bits.cadd:' + reject_count);
          }

          var cmp = jiff.protocols.bits.clt(bits, range, params.op_id + ':bits.clt:' + reject_count);
          if (cmp === true) { // need to resample
            return resolve_many_secrets(deferreds, bits_add);
          } else if (cmp === false) {
            return resample(reject_count+1);
          }

          var promise = jiff.internal_open(cmp, compute_list, params.op_id + ':open:' + reject_count);
          promise.then(function (cmp) {
            if (cmp.toString() === '1') {
              return resolve_many_secrets(deferreds, bits_add);
            }
            resample(reject_count+1);
          });
        };

        // if run with pre-processing, do the pre-processing on demand
        if (jiff.crypto_provider === true) {
          online_resample();
        } else {
          // Request pre-processing during the protocol, since this protocol is meant to run in pre-processing itself,
          // and because we cannot know ahead of time how many rejections are needed to be pre-processed.
          paramsCopy = Object.assign({}, params);
          paramsCopy['namespace'] = 'base';
          paramsCopy['bitLength'] = bits.length;
          paramsCopy['op_id'] = params.op_id + ':preprocessing:bits.clt';

          var promises = [];
          if (jiff.helpers.bLog(range, 2).toString().indexOf('.') > -1) { // this is ok since range > 1 here.
            // we do not need to really do a comparison when range is a power of 2, we know the result is true!
            var promise1 = jiff.__preprocessing('bits.clt', 1, protocols, params.compute_threshold, compute_list, compute_list, Zp, [params.op_id + ':bits.clt:' + reject_count], paramsCopy);
            var promise2 = jiff.__preprocessing('open', 1, protocols, params.compute_threshold, compute_list, compute_list, Zp, [params.op_id + ':open:' + reject_count], paramsCopy);
            promises = [promise1, promise2];
          }

          if (lower_bound.toString() !== '0' && bitLength > 1) {
            // bits.cadd is free for arrays of length 1!
            paramsCopy['op_id'] = params.op_id + ':preprocessing:bits.cadd';
            var promise3 = jiff.__preprocessing('bits.cadd', 1, protocols, params.compute_threshold, compute_list, compute_list, Zp, [params.op_id + ':bits.cadd:' + reject_count], paramsCopy);
            promises.push(promise3);
          }
          Promise.all(promises).then(online_resample);
        }
      })(0);

      return result;
    };

    /**
     * Wrapper for when doing rejection sampling during pre processing.
     * @method rejection_sampling
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {number} [threshold=receivers_list.length] - the threshold of the resulting shares after sampling.
     * @param {Array} [receivers_list=all_parties] - array of party ids that want to receive the sampling shares, by default, this includes all parties.
     * @param {Array} [compute_list=all_parties] - array of party ids that will perform this protocol, by default, this includes all parties.
     * @param {number} [Zp=jiff-instance.Zp] - the mod (if null then the default Zp for the instance is used).
     * @param {string} [op_id=auto_gen()] - the operation id which is used to identify this operation.
     *                         This id must be unique, and must be passed by all parties to the same instruction, to
     *                         ensure that corresponding instructions across different parties are matched correctly.
     * @param {object} [params={}] - an object containing extra parameters passed by the user.
     *                               Expects:
     *                               - an optional number compute_threshold parameter, which specifies threshold used
     *                               during the protocol execution. By default, this is (|compute_list|+1)/2.
     *                               - optional 'lower_bound' and 'upper_bound' numeric parameters, default to 0 and Zp respectively.
     *                               - op_id, the base op_id to tag operations inside this protocol with, defaults to auto generated.
     * @param {object} [protocols=defaults] - the protocols to use for preprocessing, any protocol(s) not provided will be replaced with defaults.
     * @returns {Object} an object containing keys: 'share', and 'promise'. The promise is resolved when the rejection sampling is completed.
     *                   The object is consumed by <jiff_instance>.preprocessing:
     *                        - 'share' attribute contains the resulting array of secret shared bits representing the sampled value, and is stored in the preprocessing table internally.
     *                        - The promise is consumed and a new promise is returned by <jiff_instance>.preprocessing that is resolved after this returned promise (and all other promise generated by that .preprocessing call) are resolved.
     */
    jiff.protocols.bits.rejection_sampling = function (threshold, receivers_list, compute_list, Zp, params, protocols) {
      // rejection sampling is both an internal preprocessing function and also user facing
      // must have defaults for simplicity of user-facing API!
      protocols = Object.assign({}, jiff.default_preprocessing_protocols, protocols);

      // Defaults (only for user facing case)
      if (compute_list == null) {
        compute_list = [];
        for (var p = 1; p <= jiff.party_count; p++) {
          compute_list.push(p);
        }
      }
      if (receivers_list == null) {
        receivers_list = [];
        for (p = 1; p <= jiff.party_count; p++) {
          receivers_list.push(p);
        }
      }
      threshold = threshold != null ? threshold : receivers_list.length;
      Zp = Zp != null ? Zp : jiff.Zp;
      params = params != null ? params : {};

      // If not a compute nor receiver party, return null (only for user facing case)
      if (compute_list.indexOf(jiff.id) === -1 && receivers_list.indexOf(jiff.id) === -1) {
        return null;
      }

      // More defaults (both user-facing and internal preprocessing)
      var lower_bound = params.lower_bound != null ? params.lower_bound : 0;
      var upper_bound = params.upper_bound != null ? params.upper_bound : Zp;
      if (params.compute_threshold == null) { // honest majority BGW
        params.compute_threshold = Math.floor((compute_list.length + 1) / 2);
      }
      if (params.op_id == null) { // op_id must be unique to both compute and receivers
        params.op_id = jiff.counters.gen_op_id2('rejection_sampling', receivers_list, compute_list);
      }
      var op_id = params.op_id;

      // execute protocol
      var result = [];
      var promises = [];
      if (compute_list.indexOf(jiff.id) > -1) {
        result = __rejection_sampling(lower_bound, upper_bound, compute_list, Zp, params, protocols);
        for (var j = 0; j < result.length; j++) {
          promises.push(result[j].promise);
        }
      }

      // fix threshold
      for (var i = 0; i < result.length; i++) {
        result[i] = jiff.protocols.reshare(result[i], threshold, receivers_list, compute_list, Zp, op_id + ':reshare:' + i);
        if (receivers_list.indexOf(jiff.id) > -1) {
          promises[i] = result[i].promise;
        }
      }

      // return output
      if (receivers_list.indexOf(jiff.id) === -1) {
        result = null;
      }
      return { share: result, promise: Promise.all(promises) };
    };

    /**
     * Compute sum of bitwise secret shared number and a constant.
     * @method cadd
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - the bit wise secret shares.
     * @param {number} constant - the constant.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for communication.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare[]} bitwise sharing of the result. Note that the length here will be max(|bits|, |constant|) + 1
     *                          in case of potential overflow / carry.
     */
    jiff.protocols.bits.cadd = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.cadd)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.cadd', bits[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits = bits.slice();

      // decompose constant into bits
      var constant_bits = jiff.helpers.number_to_bits(constant, bits.length); // pads with zeros to bits.length

      // initialize results
      var result = many_secret_shares(jiff, Math.max(constant_bits.length, bits.length), bits[0].holders, bits[0].threshold, bits[0].Zp);
      var deferreds = result.deferreds;
      result = result.shares;

      var sum = bits[0].icxor_bit(constant_bits[0]);
      var carry = bits[0].icmult(constant_bits[0]);

      // put initial bit at head of result array
      result.unshift(sum);
      deferreds.unshift(null);

      // compute sum one bit at a time, propagating carry
      bit_combinator(deferreds[deferreds.length-1], 1, deferreds.length-1, carry, function (i, carry) {
        var sum;
        if (i < bits.length) {
          var and = bits[i].icmult(constant_bits[i]);
          var xor = bits[i].icxor_bit(constant_bits[i]);
          var xorAndCarry = xor.ismult(carry, op_id + ':smult:' + (i - 1));

          sum = xor.isxor_bit(carry, op_id + ':sxor_bit:' + (i - 1));
          carry = and.isadd(xorAndCarry); // cheap or, xor and and cannot both be true!
        } else {
          // bits.length <= i < constant_bits.length
          // and is zero, xor is constant_bits[i]
          sum = carry.icxor_bit(constant_bits[i]);
          carry = carry.icmult(constant_bits[i]);
        }

        sum.wThen(deferreds[i].resolve);
        return carry;
      });

      return result;
    };

    /**
     * Compute [secret bits] - [constant bits].
     * @method csubl
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {number} constant - the constant.
     * @param {SecretShare[]} bits - the bit wise secret shares.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for communication.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare[]} bitwise sharing of the result. Note that the length of the returned result is |bits|+1, where
     *                          the bit at index 0 is the least significant bit. The bit at index 1 is the most significant bit,
     *                          and the bit at index |bits| is 1 if the result overflows, or 0 otherwise.
     */
    jiff.protocols.bits.csubl = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.csubl)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.csubl', bits[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits = bits.slice();

      // decompose constant into bits
      var constant_bits = jiff.helpers.number_to_bits(constant, bits.length); // pads with zeros to bits.length

      // initialize results
      var result = many_secret_shares(jiff, Math.max(constant_bits.length, bits.length), bits[0].holders, bits[0].threshold, bits[0].Zp);
      var deferreds = result.deferreds;
      result = result.shares;

      var diff = bits[0].icxor_bit(constant_bits[0]);
      var borrow = bits[0].inot().icmult(constant_bits[0]);

      // put initial bit at head of result array
      result.unshift(diff);
      deferreds.unshift(null);

      // compute diff one bit at a time, propagating borrow
      bit_combinator(deferreds[deferreds.length-1], 1, deferreds.length-1, borrow, function (i, borrow) {
        var diff;
        if (i < bits.length) {
          var xor = bits[i].icxor_bit(constant_bits[i]);
          var andNot = bits[i].inot().icmult(constant_bits[i]);

          // save and update borrow
          diff = xor.isxor_bit(borrow, op_id + ':sxor_bit:' + (i - 1));
          borrow = xor.inot().ismult(borrow, op_id + ':smult:' + (i - 1));
          borrow = borrow.isadd(andNot);
        } else {
          // bits.length <= i < constant_bits.length
          // xor and andNot are equal to the constant bit value since secret bit is always zero here
          diff = borrow.icxor_bit(constant_bits[i]);
          borrow = borrow.issub(borrow.icmult(constant_bits[i]));
          borrow = borrow.icadd(constant_bits[i]);
        }

        diff.wThen(deferreds[i].resolve);
        return borrow;
      });

      return result;
    };

    /**
     * Compute [constant bits] - [secret bits].
     * @method csubr
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {number} constant - the constant.
     * @param {SecretShare[]} bits - the bit wise secret shares.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for communication.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare[]} bitwise sharing of the result. Note that the length of the returned result is |bits|+1, where
     *                          the bit at index 0 is the least significant bit. The bit at index 1 is the most significant bit,
     *                          and the bit at index |bits| is 1 if the result overflows, or 0 otherwise.
     */
    jiff.protocols.bits.csubr = function (constant, bits, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.csubr)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.csubr', bits[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits = bits.slice();

      // decompose constant into bits
      var constant_bits = jiff.helpers.number_to_bits(constant, bits.length); // pads with zeros to bits.length

      // initialize results
      var result = many_secret_shares(jiff, Math.max(constant_bits.length, bits.length), bits[0].holders, bits[0].threshold, bits[0].Zp);
      var deferreds = result.deferreds;
      result = result.shares;

      var diff = bits[0].icxor_bit(constant_bits[0]);
      var borrow = bits[0].issub(bits[0].icmult(constant_bits[0]));

      // put initial bit at head of result array
      result.unshift(diff);
      deferreds.unshift(null);

      // compute diff one bit at a time, propagating borrow
      bit_combinator(deferreds[deferreds.length-1], 1, deferreds.length-1, borrow, function (i, borrow) {
        var diff;
        if (i < bits.length) {
          var xor = bits[i].icxor_bit(constant_bits[i]);
          var andNot = bits[i].issub(bits[i].icmult(constant_bits[i]));

          // save and update borrow
          diff = xor.isxor_bit(borrow, op_id + ':sxor_bit:' + (i - 1));
          borrow = xor.inot().ismult(borrow, op_id + ':smult:' + (i - 1));
          borrow = borrow.isadd(andNot);
        } else {
          // andNot is zero and xor is equal to the constant bit since secret bit is always zero here.
          diff = borrow.icxor_bit(constant_bits[i]);
          borrow = borrow.icmult(constant_bits[i] === 1 ? 0 : 1);
        }

        diff.wThen(deferreds[i].resolve);
        return borrow;
      });

      return result;
    };

    /**
     *
     * Compute [secret bits1] + [secret bits2].
     * @method sadd
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - the first bitwise shared number: array of secrets with index 0 being least significant bit.
     * @param {SecretShare[]} bits2 - the second bitwise shared number (length may be different).
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for communication.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare[]} bitwise sharing of the result. Note that the length of the returned result is |bits|+1, where
     *                          the bit at index 0 is the least significant bit.
     */
    jiff.protocols.bits.sadd = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.sadd', bits1[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits1 = bits1.slice();
      bits2 = bits2.slice();

      var tmp = bits1.length > bits2.length ? bits1 : bits2;
      bits2 = bits1.length > bits2.length ? bits2 : bits1; // shortest array
      bits1 = tmp; // longest array

      // initialize results
      var result = many_secret_shares(jiff, bits1.length, bits1[0].holders, Math.max(bits1[0].threshold, bits2[0].threshold), bits1[0].Zp);
      var deferreds = result.deferreds;
      result = result.shares;

      var sum = bits1[0].isxor_bit(bits2[0], op_id + ':sxor_bit:initial');
      var carry = bits1[0].ismult(bits2[0], op_id + ':smult:initial');

      // put initial bit at head of result array
      result.unshift(sum);
      deferreds.unshift(null);

      // compute sum one bit at a time, propagating carry
      bit_combinator(deferreds[deferreds.length-1], 1, deferreds.length-1, carry, function (i, carry) {
        var sum;
        if (i < bits2.length) {
          var and = bits1[i].ismult(bits2[i], op_id + ':smult1:' + (i - 1));
          var xor = bits1[i].isxor_bit(bits2[i], op_id + ':sxor_bit1:' + (i - 1));
          var xorAndCarry = xor.ismult(carry, op_id + ':smult2:' + (i - 1));

          sum = xor.isxor_bit(carry, op_id + ':sxor_bit2:' + (i - 1));
          carry = and.isadd(xorAndCarry); // cheap or, xor and and cannot both be true!
        } else {
          // and is always zero, xor is equal to bits1[i]
          sum = bits1[i].isxor_bit(carry, op_id + ':sxor_bit1:' + (i - 1));
          carry = bits1[i].ismult(carry, op_id + ':smult1:' + (i - 1));
        }

        sum.wThen(deferreds[i].resolve);
        return carry;
      });

      return result;
    };

    /**
     * Compute [secret bits1] - [secret bits2].
     * @method ssub
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - first bitwise secret shared number: lower indices represent less significant bits.
     * @param {SecretShare[]} bits2 - second bitwise secret shared number (length may be different).
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for communication.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare[]} bitwise sharing of the result. Note that the length of the returned result is |bits|+1, where
     *                          the bit at index 0 is the least significant bit. The bit at index 1 is the most significant bit,
     *                          and the bit at index |bits| is 1 if the result overflows, or 0 otherwise.
     */
    jiff.protocols.bits.ssub = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.ssub', bits1[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits1 = bits1.slice();
      bits2 = bits2.slice();

      // initialize results
      var result = many_secret_shares(jiff, Math.max(bits1.length, bits2.length), bits1[0].holders, Math.max(bits1[0].threshold, bits2[0].threshold), bits1[0].Zp);
      var deferreds = result.deferreds;
      result = result.shares;

      var diff = bits1[0].isxor_bit(bits2[0], op_id + ':sxor_bit:initial');
      var borrow = bits1[0].inot().ismult(bits2[0], op_id + ':smult:initial');

      // put initial bit at head of result array
      result.unshift(diff);
      deferreds.unshift(null);

      // compute diff one bit at a time, propagating borrow
      bit_combinator(deferreds[deferreds.length-1], 1, deferreds.length-1, borrow, function (i, borrow) {
        var diff;
        if (i < bits1.length && i < bits2.length) {
          var xor = bits1[i].isxor_bit(bits2[i], op_id + ':sxor_bit1:' + (i - 1));
          var andNot = bits1[i].inot().ismult(bits2[i], op_id + ':smult1:' + (i - 1));

          // save and update borrow
          diff = xor.isxor_bit(borrow, op_id + ':sxor_bit2:' + (i - 1));
          borrow = xor.inot().ismult(borrow, op_id + ':smult2:' + (i - 1));
          borrow = borrow.isadd(andNot);
        } else if (i < bits1.length) {
          // xor is equal to the value of bits1[i], andNot is equal to 0, since bits[2] is all zeros here
          diff = bits1[i].isxor_bit(borrow, op_id + ':sxor_bit1:' + (i - 1));
          borrow = bits1[i].inot().ismult(borrow, op_id + ':smult1:' + (i - 1));
        } else { // i < bits2.length
          // xor and andNot are equal to the value of bits2[i]
          diff = bits2[i].isxor_bit(borrow, op_id + ':sxor_bit1:' + (i - 1));
          borrow = bits2[i].inot().ismult(borrow, op_id + ':smult1:' + (i - 1));
          borrow = borrow.isadd(bits2[i]);
        }

        diff.wThen(deferreds[i].resolve);
        return borrow;
      });

      return result;
    };

    /**
     * Compute [secret bits] * constant.
     * @method cmult
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - bitwise shared secret to multiply: lower indices represent less significant bits.
     * @param {number} constant - constant to multiply with.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for communication.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare[]} bitwise sharing of the result, the length of the result will be bits.length + ceil(log2(constant)), except
     *                          if constant is zero, the result will then be [ zero share ].
     */
    jiff.protocols.bits.cmult = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.cmult)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.cmult', bits[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits = bits.slice();

      // decompose constant into bits
      var constant_bits = jiff.helpers.number_to_bits(constant); // do not pad

      // Initialize the result
      var result = many_secret_shares(jiff, bits.length + constant_bits.length, bits[0].holders, bits[0].threshold, bits[0].Zp);
      var deferreds = result.deferreds;
      result = result.shares;

      // Resolve result when ready
      var final_deferred = new jiff.helpers.Deferred();
      final_deferred.promise.then(resolve_many_secrets.bind(null, deferreds));

      // get useless share of zero (just for padding)
      var zero = jiff.secret_share(jiff, true, null, 0, bits[0].holders, bits[0].threshold, bits[0].Zp);
      var initial = [ zero ];

      // special case
      if (constant.toString() === '0') {
        return initial;
      }

      // main function
      bit_combinator(final_deferred, 0, constant_bits.length, initial, function (i, intermediate) {
        // Shift bits to create the intermediate values,
        // and sum if the corresponding bit in a is 1
        if (constant_bits[i].toString() === '1') {
          intermediate = jiff.protocols.bits.sadd(intermediate, bits, op_id + ':bits.sadd:' + i);
        }

        bits.unshift(zero);
        return intermediate;
      }, function (intermediate) {
        // promise-ify an array of intermediate results
        var promises = [];
        for (var i = 0; i < intermediate.length; i++) {
          promises.push(intermediate[i].promise);
        }
        return Promise.all(promises);
      }, function (result) {
        // identity
        return result;
      });

      return result;
    };

    /**
     * Compute [secret bits1] * [secret bits2].
     * @method smult
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - bitwise shared secret to multiply: lower indices represent less significant bits.
     * @param {SecretShare[]} bits2 - bitwise shared secret to multiply.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for communication.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare[]} bitwise sharing of the result, the length of the result will be bits1.length + bits2.length.
     */
    jiff.protocols.bits.smult = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.smult', bits1[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits1 = bits1.slice();
      bits2 = bits2.slice();

      // bits1 will be the longest array, bits2 will be the shortest
      var tmp = bits1.length > bits2.length ? bits1 : bits2;
      bits2 = bits1.length > bits2.length ? bits2 : bits1;
      bits1 = tmp;

      // Initialize the result
      var offset = bits2.length === 1 ? -1 : 0;
      var result = many_secret_shares(jiff, bits1.length + bits2.length + offset, bits1[0].holders, Math.max(bits1[0].threshold, bits2[0].threshold), bits1[0].Zp);
      var deferreds = result.deferreds;
      result = result.shares;

      // Resolve result when ready
      var final_deferred = new jiff.helpers.Deferred();
      final_deferred.promise.then(resolve_many_secrets.bind(null, deferreds));

      // Loop over *shortest* array one bit at a time
      bit_combinator(final_deferred, 0, bits2.length, bits2, function (i, intermediate) {
        var this_bit = bits2[i];
        var bit_mult = []; // add bits1 or 0 to the result according to this bit
        for (var j = 0; j < bits1.length; j++) {
          bit_mult[j] = this_bit.iif_else(bits1[j], 0, op_id + ':if_else:' + i + ':' + j);
        }
        bits1.unshift(0); // increase magnitude

        if (i === 0) {
          return bit_mult;
        }

        return jiff.protocols.bits.sadd(intermediate, bit_mult, op_id + ':bits.sadd:' + i);
      }, function (intermediate) {
        // promise-ify an array of intermediate results
        var promises = [];
        for (var i = 0; i < intermediate.length; i++) {
          promises.push(intermediate[i].promise);
        }
        return Promise.all(promises);
      }, function (result) {
        // identity
        return result;
      });

      return result;
    };

    /**
     * Checks whether the two given bitwise secret shared numbers are equal.
     * @method seq
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - an array of secret shares of bits, starting from least to most significant bits.
     * @param {SecretShare[]} bits2 - the second bitwise shared number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare} a secret share of 1 if bits are equal, 0 otherwise.
     */
    jiff.protocols.bits.seq = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.seq', bits1[0].holders);
      }
      return jiff.protocols.bits.sneq(bits1, bits2, op_id).inot();
    };

    /**
     * Checks whether the two given bitwise secret shared numbers are not equal.
     * @method sneq
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - an array of secret shares of bits, starting from least to most significant bits.
     * @param {SecretShare[]} bits2 - the second bitwise shared number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare} a secret share of 1 if bits are not equal, 0 otherwise.
     */
    jiff.protocols.bits.sneq = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.sneq', bits1[0].holders);
      }

      var tmp = bits1.length > bits2.length ? bits1 : bits2;
      bits2 = bits1.length > bits2.length ? bits2 : bits1; // shortest array
      bits1 = tmp; // longest array

      // copy to avoid aliasing problems during execution
      bits1 = bits1.slice();
      bits2 = bits2.slice();

      // initialize result
      var deferred = new jiff.helpers.Deferred();
      var result = jiff.secret_share(jiff, false, deferred.promise, undefined, bits1[0].holders, Math.max(bits1[0].threshold, bits2[0].threshold), bits1[0].Zp);

      // big or of bitwise XORs
      var initial = bits1[0].isxor_bit(bits2[0], op_id + ':sxor_bit:initial');
      bit_combinator(deferred, 1, bits1.length, initial, function (i, prev) {
        var next;
        if (i < bits2.length) {
          var xor = bits1[i].isxor_bit(bits2[i], op_id + ':sxor_bit:' + (i - 1));
          next = prev.isor_bit(xor, op_id + ':sor_bit:' + (i - 1));
        } else {
          // xor is equal to bits1[i] since bits2[i] is zero
          next = prev.isor_bit(bits1[i], op_id + ':sor_bit:' + (i - 1));
        }
        return next;
      });

      return result;
    };

    /**
     * Checks whether the first given bitwise secret shared number is greater than the second bitwise secret shared number.
     * @method sgt
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - an array of secret shares of bits, starting from least to most significant bits.
     * @param {SecretShare[]} bits2 - the second bitwise shared number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare} a secret share of 1 if the first number is greater than the second, 0 otherwise.
     */
    jiff.protocols.bits.sgt = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.sgt', bits1[0].holders);
      }

      var gteq = jiff.protocols.bits.sgteq(bits1, bits2, op_id + ':bits.sgteq');
      var neq = jiff.protocols.bits.sneq(bits1, bits2, op_id + ':bits.sneq');
      return gteq.ismult(neq, op_id + ':smult');
    };

    /**
     * Checks whether the first given bitwise secret shared number is greater than or equal to the second bitwise secret shared number.
     * @method sgteq
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - an array of secret shares of bits, starting from least to most significant bits.
     * @param {SecretShare[]} bits2 - the second bitwise shared number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare} a secret share of 1 if the first number is greater or equal to the second, 0 otherwise.
     */
    jiff.protocols.bits.sgteq = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.sgteq', bits1[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits1 = bits1.slice();
      bits2 = bits2.slice();

      // initialize result
      var deferred = new jiff.helpers.Deferred();
      var result = jiff.secret_share(jiff, false, deferred.promise, undefined, bits1[0].holders, Math.max(bits1[0].threshold, bits2[0].threshold), bits1[0].Zp);

      // Subtract bits2 from bits1, only keeping track of borrow
      var borrow = bits1[0].inot().ismult(bits2[0], op_id + ':smult:initial');
      var n = Math.max(bits1.length, bits2.length);
      bit_combinator(deferred, 1, n, borrow, function (i, borrow) {
        if (i < bits1.length && i < bits2.length) {
          var xor = bits1[i].isxor_bit(bits2[i], op_id + ':sxor_bit1:' + (i - 1));
          var andNot = bits1[i].inot().ismult(bits2[i], op_id + ':smult1:' + (i - 1));

          // save and update borrow
          borrow = xor.inot().ismult(borrow, op_id + ':smult2:' + (i - 1));
          borrow = borrow.isadd(andNot);
        } else if (i < bits1.length) {
          // xor is equal to the value of bits1[i], andNot is equal to 0, since bits[2] is all zeros here
          borrow = bits1[i].inot().ismult(borrow, op_id + ':smult1:' + (i - 1));
        } else { // i < bits2.length
          // xor and andNot are equal to the value of bits2[i]
          borrow = bits2[i].inot().ismult(borrow, op_id + ':smult1:' + (i - 1));
          borrow = borrow.isadd(bits2[i]);
        }

        return borrow;
      });

      return result.inot();
    };

    /**
     * Checks whether the first given bitwise secret shared number is less than the second bitwise secret shared number.
     * @method slt
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - an array of secret shares of bits, starting from least to most significant bits.
     * @param {SecretShare[]} bits2 - the second bitwise shared number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare} a secret share of 1 if the first number is less than the second, 0 otherwise.
     */
    jiff.protocols.bits.slt = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.slt', bits1[0].holders);
      }
      var result = jiff.protocols.bits.sgteq(bits1, bits2, op_id);
      return result.inot();
    };

    /**
     * Checks whether the first given bitwise secret shared number is less or equal to the second bitwise secret shared number.
     * @method slteq
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - an array of secret shares of bits, starting from least to most significant bits.
     * @param {SecretShare[]} bits2 - the second bitwise shared number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {SecretShare} a secret share of 1 if the first number is less than or equal to the second, 0 otherwise.
     */
    jiff.protocols.bits.slteq = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.slteq', bits1[0].holders);
      }
      var result = jiff.protocols.bits.sgt(bits1, bits2, op_id);
      return result.inot();
    };

    /**
     * Computes integer division of [secret bits 1] / [secret bits 2].
     * @method sdiv
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits1 - an array of secret shares of bits, starting from least to most significant bits.
     * @param {SecretShare[]} bits2 - the second bitwise shared number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {{quotient: SecretShare[], remainder: SecretShare[]}} the quotient and remainder bits arrays, note that
     *                                                                the quotient array has the same length as bits1,
     *                                                                and the remainder array has the same length as bits2 or bits1, whichever is smaller.
     *                                                                Note: if bits2 represent 0, the returned result is the maximum
     *                                                                number that fits in the number of bits (all 1), and the remainder
     *                                                                is equal to bits1.
     */
    jiff.protocols.bits.sdiv = function (bits1, bits2, op_id) {
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.sdiv', bits1[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits1 = bits1.slice();
      bits2 = bits2.slice();

      // Initialize the result
      var quotient = many_secret_shares(jiff, bits1.length, bits1[0].holders, Math.max(bits1[0].threshold, bits2[0].threshold), bits1[0].Zp);
      var quotientDeferreds = quotient.deferreds;
      quotient = quotient.shares;

      var remainder = many_secret_shares(jiff, Math.min(bits1.length, bits2.length), bits1[0].holders, Math.max(bits1[0].threshold, bits2[0].threshold), bits1[0].Zp);
      var remainderDeferreds = remainder.deferreds;
      remainder = remainder.shares;

      // Resolve result when ready
      var final_deferred = new jiff.helpers.Deferred();
      final_deferred.promise.then(function (result) {
        resolve_many_secrets(remainderDeferreds, result);
      });

      var initial = []; // initial remainder
      bit_combinator(final_deferred, bits1.length-1, -1, initial, function (i, _remainder) {
        var iterationCounter = (bits1.length - i - 1);

        // add bit i to the head of remainder (least significant bit)
        _remainder.unshift(bits1[i]);

        // Get the next bit of the quotient
        // and conditionally subtract b from the
        // intermediate remainder to continue
        var sub = jiff.protocols.bits.ssub(_remainder, bits2, op_id + ':bits.ssub:' + iterationCounter);
        var noUnderflow = sub.pop().inot(); // get the overflow bit, sub is now the result of subtraction

        // Get next bit of quotient
        noUnderflow.wThen(quotientDeferreds[i].resolve);

        // Update remainder
        for (var j = 0; j < _remainder.length; j++) {
          // note, if noUnderflow, then |# bits in sub| <= |# bits in remainder|
          _remainder[j] = noUnderflow.iif_else(sub[j], _remainder[j], op_id + ':if_else:' + iterationCounter + ':' + j);
        }

        // Remainder cannot be greater than divisor at this point
        while (_remainder.length > remainder.length) {
          _remainder.pop();
        }

        return _remainder;
      }, function (intermediate) {
        // promise-ify an array of intermediate results
        var promises = [];
        for (var i = 0; i < intermediate.length; i++) {
          promises.push(intermediate[i].promise);
        }
        return Promise.all(promises);
      }, function (result) {
        // identity
        return result;
      });

      return {quotient: quotient, remainder: remainder}
    };

    /**
     * Computes integer division of [secret bits] / constant.
     * @method cdivl
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {SecretShare[]} bits - numerator: an array of secret shares of bits, starting from least to most significant bits.
     * @param {number} constant - the denominator number.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {{quotient: SecretShare[], remainder: SecretShare[]}} the quotient and remainder bits arrays, note that
     *                                                                the quotient array has the same length as bits,
     *                                                                and the remainder array has the same length as
     *                                                                constant or bits, whichever is smaller.
     * @throws if constant is 0.
     */
    jiff.protocols.bits.cdivl = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.cdivl)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.cdivl', bits[0].holders);
      }

      if (constant.toString() === '0') {
        throw new Error('constant cannot be 0 in bits.cdiv');
      }

      // copy to avoid aliasing problems during execution
      bits = bits.slice();

      // special case, divide by 1
      if (constant.toString() === '1') {
        return {
          quotient: bits,
          remainder: [jiff.secret_share(jiff, true, null, 0, bits[0].holders, bits[0].threshold, bits[0].Zp)]
        }
      }

      // Initialize the result
      var quotient = many_secret_shares(jiff, bits.length, bits[0].holders, bits[0].threshold, bits[0].Zp);
      var quotientDeferreds = quotient.deferreds;
      quotient = quotient.shares;

      var constantLessBits = jiff.helpers.ceil(jiff.helpers.bLog(constant, 2));
      constantLessBits = parseInt(constantLessBits.toString(), 10);
      var remainder = many_secret_shares(jiff, Math.min(constantLessBits, bits.length), bits[0].holders, bits[0].threshold, bits[0].Zp);
      var remainderDeferreds = remainder.deferreds;
      remainder = remainder.shares;

      // Resolve result when ready
      var final_deferred = new jiff.helpers.Deferred();
      final_deferred.promise.then(resolve_many_secrets.bind(null, remainderDeferreds));

      var initial = []; // initial remainder
      bit_combinator(final_deferred, bits.length-1, -1, initial, function (i, _remainder) {
        var iterationCounter = (bits.length - i - 1);

        // add bit i to the head of remainder (least significant bit)
        _remainder.unshift(bits[i]);

        // Get the next bit of the quotient
        // and conditionally subtract b from the
        // intermediate remainder to continue
        var sub = jiff.protocols.bits.csubl(_remainder, constant, op_id + ':bits.csubl:' + iterationCounter);
        var noUnderflow = sub.pop().inot(); // get the overflow bit, sub is now the result of subtraction

        // Get next bit of quotient
        noUnderflow.wThen(quotientDeferreds[i].resolve);

        // Update remainder
        for (var j = 0; j < _remainder.length; j++) {
          // note, if noUnderflow, then |# bits in sub| <= |# bits in remainder|
          _remainder[j] = noUnderflow.iif_else(sub[j], _remainder[j], op_id + ':if_else:' + iterationCounter + ':' + j);
        }

        // Remainder cannot be greater than constant at this point
        while (_remainder.length > remainder.length) {
          _remainder.pop();
        }

        return _remainder;
      }, function (intermediate) {
        // promise-ify an array of intermediate results
        var promises = [];
        for (var i = 0; i < intermediate.length; i++) {
          promises.push(intermediate[i].promise);
        }
        return Promise.all(promises);
      }, function (result) {
        // identity
        return result;
      });

      return {quotient: quotient, remainder: remainder};
    };

    /**
     * Computes integer division of constant / [secret bits].
     * @method cdivr
     * @memberof jiff-instance.protocols.bits
     * @instance
     * @param {number} constant - the numerator number.
     * @param {SecretShare[]} bits - denominator: an array of secret shares of bits, starting from least to most significant bits.
     * @param {string} [op_id=<auto-generate-id>] - the base operation id to use when generating unique ids for multiplications.
     *                                              default value should suffice when the code of all parties executes all instructions
     *                                              in the same exact order, otherwise, a unique base name is needed here.
     * @returns {{quotient: SecretShare[], remainder: SecretShare[]}} the quotient and remainder bits arrays, note that
     *                                                                the quotient array has the same length as the number of bits in constant.
     *                                                                and the remainder array has the same length as bits or constant, whichever is smaller.
     *                                                                Note: if bits represent 0, the returned result is the maximum
     *                                                                number that fits in its bits (all 1), and the remainder
     *                                                                is equal to constant.
     */
    jiff.protocols.bits.cdivr = function (constant, bits, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.cdivr)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.cdivr', bits[0].holders);
      }

      // copy to avoid aliasing problems during execution
      bits = bits.slice();

      // do not pad
      var constant_bits = jiff.helpers.number_to_bits(constant);

      // Initialize the result
      var quotient = many_secret_shares(jiff, constant_bits.length, bits[0].holders, bits[0].threshold, bits[0].Zp);
      var quotientDeferreds = quotient.deferreds;
      quotient = quotient.shares;

      var remainder = many_secret_shares(jiff, Math.min(constant_bits.length, bits.length), bits[0].holders, bits[0].threshold, bits[0].Zp);
      var remainderDeferreds = remainder.deferreds;
      remainder = remainder.shares;

      // Resolve result when ready
      var final_deferred = new jiff.helpers.Deferred();
      final_deferred.promise.then(resolve_many_secrets.bind(null, remainderDeferreds));

      var initial = []; // initial remainder
      bit_combinator(final_deferred, constant_bits.length-1, -1, initial, function (i, _remainder) {
        var iterationCounter = (constant_bits.length - i - 1);

        // add bit i to the head of remainder (least significant bit)
        // turn into a secret without communication, just for typing
        var cbit_share = jiff.secret_share(jiff, true, null, constant_bits[i], bits[0].holders, bits[0].threshold, bits[0].Zp);
        _remainder.unshift(cbit_share);

        // Get the next bit of the quotient
        // and conditionally subtract b from the
        // intermediate remainder to continue
        var sub = jiff.protocols.bits.ssub(_remainder, bits, op_id + ':bits.ssub:' + iterationCounter);
        var noUnderflow = sub.pop().inot(); // get the overflow bit, sub is now the result of subtraction

        // Get next bit of quotient
        noUnderflow.wThen(quotientDeferreds[i].resolve);

        // Update remainder
        for (var j = 0; j < _remainder.length; j++) {
          // note, if noUnderflow, then |# bits in sub| <= |# bits in remainder|
          _remainder[j] = noUnderflow.iif_else(sub[j], _remainder[j], op_id + ':if_else:' + iterationCounter + ':' + j);
        }

        // cannot be bigger than divisor at this point
        while (_remainder.length > remainder.length) {
          _remainder.pop();
        }

        return _remainder;
      }, function (intermediate) {
        // promise-ify an array of intermediate results
        var promises = [];
        for (var i = 0; i < intermediate.length; i++) {
          promises.push(intermediate[i].promise);
        }
        return Promise.all(promises);
      }, function (result) {
        // identity
        return result;
      });

      return {quotient: quotient, remainder: remainder};
    };

    /**
     * Flags whether to use the server as a fallback for objects that were not pre-processed properly
     * @member {boolean} barriers
     * @memberOf jiff-instance
     * @instance
     */
    jiff.crypto_provider = (options.crypto_provider === true);

    /**
     * Stores pre-computed values (beaver triples, random bits, etc) used to aid/speed up the main processes.
     * @member {Object} preprocessing_table
     * @memberof jiff-instance
     * @instance
     */
    jiff.preprocessing_table = {};

    // internal functions for use in preprocessing function map
    var bits_count = function (threshold, receivers_list, compute_list, Zp, op_id, params) {
      var bitLength = params.bitLength;
      if (bitLength == null) {
        bitLength = Zp.toString(2).length;
      }
      return bitLength;
    };
    var constant_bits_count = function () {
      return bits_count.apply(null, arguments) - 1;
    };
    var dynamic_bits_cmult = function (dependent_op, count, protocols, threshold, receivers_list, compute_list, Zp, id_list, params) {
      // constant bit length
      var constantBits = Zp.toString(2).length;
      if (params.constantBits != null) {
        constantBits = params.constantBits;
      }
      // secret bit length
      var bitLength = params.bitLength;
      if (bitLength == null) {
        bitLength = Zp.toString(2).length;
      }
      // for every bit from constant, pre-process for one bits.sadd of the right size
      var ops = [];
      for (var i = 0; i < constantBits; i++) {
        var accLength = i === 0 ? 1 : (bitLength + i);
        ops.push({ op: 'bits.sadd', op_id: ':bits.sadd:' + i, params: {bitLengthLeft: accLength, bitLengthRight: bitLength + i}});
      }
      return ops;
    };
    var dynamic_bits_smult = function (dependent_op, count, protocols, threshold, receivers_list, compute_list, Zp, id_list, params) {
      var bitLength = params.bitLength;
      if (bitLength == null) {
        bitLength = Zp.toString(2).length;
      }

      var left = params.bitLengthLeft;
      var right = params.bitLengthRight;
      left = left != null ? left : bitLength;
      right = right != null ? right : bitLength;
      var max = Math.max(left, right);
      var min = Math.max(left, right);

      var ops = [];
      for (var i = 0; i < min; i++) {
        for (var j = 0; j < max + i; j++) {
          ops.push({ op: 'if_else', op_id: ':if_else:' + i + ':' + j });
        }
        var accLength = i === 0 ? min : (max + i);
        ops.push({ op: 'bits.sadd', op_id: ':bits.sadd:'+i, params: {bitLengthLeft: accLength, bitLengthRight: max + i}});
      }
      return ops;
    };
    var choice_bits_count = function (choice, offset) {
      if (offset == null) {
        offset = 0;
      }
      return function (threshold, receivers_list, compute_list, Zp, op_id, params) {
        var bitLength = params.bitLength;
        if (bitLength == null) {
          bitLength = Zp.toString(2).length;
        }

        var left = params.bitLengthLeft;
        var right = params.bitLengthRight;
        left = left != null ? left : bitLength;
        right = right != null ? right : bitLength;

        return choice(left, right) + offset;
      };
    };
    var decomposition_ifelse_count = function (threshold, receivers_list, compute_list, Zp, op_id, params) {
      return Zp.toString(2).length;
    };
    var dynamic_bits_sdiv = function (dependent_op, count, protocols, threshold, receivers_list, compute_list, Zp, id_list, params) {
      var bitLength = params.bitLength;
      if (bitLength == null) {
        bitLength = Zp.toString(2).length;
      }

      var left = params.bitLengthLeft;
      var right = params.bitLengthRight;
      left = left != null ? left : bitLength;
      right = right != null ? right : bitLength;
      var min = Math.min(left, right);

      var ops = [];
      for (var i = 0; i < left; i++) {
        var accLength = Math.min(i+1, min+1);
        ops.push({ op: 'bits.ssub', op_id: ':bits.ssub:'+i, params: {bitLengthLeft: accLength, bitLengthRight: right}});
        for (var j = 0; j < accLength; j++) {
          ops.push({ op: 'if_else', op_id: ':if_else:' + i + ':' + j });
        }
      }
      return ops;
    };
    var dynamic_bits_cdiv = function (dir) {
      return function (dependent_op, count, protocols, threshold, receivers_list, compute_list, Zp, id_list, params) {
        var constantBits = Zp.toString(2).length;
        if (params.constantBits != null) {
          constantBits = params.constantBits;
        }
        var bitLength = params.bitLength;
        if (bitLength == null) {
          bitLength = Zp.toString(2).length;
        }
        var min = Math.min(bitLength, constantBits);

        var ops = [];
        var loopCounter = (dir === 'left') ? bitLength : constantBits;
        for (var i = 0; i < loopCounter; i++) {
          var accLength = Math.min(i+1, min+1);
          if (dir === 'left') {
            ops.push({ op: 'bits.csubl', op_id: ':bits.csubl:' + i, params: {bitLength: accLength, constantBits: constantBits} });
          } else {
            ops.push({ op: 'bits.ssub', op_id: ':bits.ssub:' + i, params: {bitLengthLeft: accLength, bitLengthRight: bitLength} });
          }

          for (var j = 0; j < accLength; j++) {
            ops.push({ op: 'if_else', op_id: ':if_else:' + i + ':' + j });
          }
        }
        return ops;
      }
    };

    /**
     * the default preprocessing protocols for each type of value
     * @member {Object} default_preprocessing_protocols
     * @memberof jiff-instance
     * @instance
     */
    jiff.default_preprocessing_protocols = {
      generate_beaver: jiff.protocols.generate_beaver_bgw,
      generate_random_number: jiff.protocols.generate_random_number,
      sampling: jiff.protocols.bits.rejection_sampling,
      generate_random_bits: jiff.protocols.generate_random_bits,
      generate_random_bit: jiff.protocols.generate_random_bit_bgw,
      generate_zero: jiff.protocols.generate_zero,
      generate_random_and_quotient: jiff.protocols.generate_random_and_quotient
    };

    /**
     * maps all primitive operations to the other operations they are dependent on, to be traversed during preprocessing
     * @member {Object} preprocessing_function_map
     * @memberof jiff-instance
     * @instance
     */
    jiff.preprocessing_function_map = {
      base: {
        // arithmetic sharing protocols
        'smult': [
          { op: 'generate_beaver', op_id: ':triplet' },
          { op: 'open', op_id: ':open1' },
          { op: 'open', op_id: ':open2' }
        ],
        'sxor_bit': [
          { op: 'smult', op_id: ':smult1' }
        ],
        'slt': [
          { op: 'lt_halfprime', op_id: ':halfprime:1' },
          { op: 'lt_halfprime', op_id: ':halfprime:2' },
          { op: 'lt_halfprime', op_id: ':halfprime:3' },
          { op: 'smult', op_id: ':smult1' },
          { op: 'smult', op_id: ':smult2' }
        ],
        'cgt': [
          { op: 'lt_halfprime', op_id: ':halfprime:1' },
          { op: 'lt_halfprime', op_id: ':halfprime:2' },
          { op: 'smult', op_id: ':smult1' }
        ],
        'clt': [
          { op: 'lt_halfprime', op_id: ':halfprime:1' },
          { op: 'lt_halfprime', op_id: ':halfprime:2' },
          { op: 'smult', op_id: ':smult1' }
        ],
        'lt_halfprime': [
          { op: 'sampling', op_id: ':sampling' },
          { op: 'smult', op_id: ':smult1' },
          { op: 'bits.cgt', op_id: ':bits.cgt' },
          { op: 'sxor_bit', op_id: ':sxor_bit' },
          { op: 'open', op_id: ':open' }
        ],
        'cdiv': [
          { op: 'cgt', op_id: ':wrap_cgt' },
          { op: 'cgteq', op_id: ':cor1' },
          { op: 'cgteq', op_id: ':cor2' },
          { op: 'smult', op_id: ':smult' },
          { op: 'clt', op_id: ':zero_check' },
          { op: 'smult', op_id: ':zero_it' },
          { op: 'open', op_id: ':open' },
          { op: 'generate_random_and_quotient', op_id: ':quotient' }
        ],
        'sdiv': [
          { op: 'bit_decomposition', op_id: ':decomposition1' },
          { op: 'bit_decomposition', op_id: ':decomposition2' },
          { op: 'bits.sdiv', op_id: ':bits.sdiv' }
        ],
        'if_else': [
          { op: 'smult', op_id: ':smult' }
        ],
        // bits protocols
        'bit_decomposition': [
          { op: 'sampling', op_id: ':sampling' },
          { op: 'bits.csubr', op_id: ':bits.csubr:1' },
          { op: 'bits.csubr', op_id: ':bits.csubr:2' },
          { op: 'if_else', op_id: ':if_else:', count: decomposition_ifelse_count },
          { op: 'open', op_id: ':open' }
        ],
        // comparisons
        'bits.cgteq': [
          { op: 'smult', op_id: ':smult:', count: constant_bits_count }
        ],
        'bits.cneq': [
          { op: 'sor_bit', op_id: ':sor_bit:', count: constant_bits_count }
        ],
        'bits.sneq': [
          { op: 'sxor_bit', op_id: ':sxor_bit:initial' },
          { op: 'sxor_bit', op_id: ':sxor_bit:', count: choice_bits_count(Math.min, -1) },
          { op: 'sor_bit', op_id: ':sor_bit:', count: choice_bits_count(Math.max, -1) }
        ],
        'bits.sgteq': [
          { op: 'smult', op_id: ':smult:initial' },
          { op: 'smult', op_id: ':smult1:', count: choice_bits_count(Math.max, -1) },
          { op: 'sxor_bit', op_id: ':sxor_bit1:', count: choice_bits_count(Math.min, -1) },
          { op: 'smult', op_id: ':smult2:', count: choice_bits_count(Math.min, -1) }
        ],
        'bits.sgt': [
          { op: 'bits.sgteq', op_id: ':bits.sgteq'},
          { op: 'bits.sneq', op_id: ':bits.sneq'},
          { op: 'smult', op_id: ':smult'}
        ],
        // constant arithmetic
        'bits.cadd': [
          { op: 'smult', op_id: ':smult:', count: constant_bits_count },
          { op: 'sxor_bit', op_id: ':sxor_bit:', count: constant_bits_count }
        ],
        'bits.cmult': dynamic_bits_cmult,
        'bits.cdivl': dynamic_bits_cdiv('left'),
        'bits.cdivr': dynamic_bits_cdiv('right'),
        // secret arithmetic
        'bits.sadd': [
          { op: 'sxor_bit', op_id: ':sxor_bit:initial' },
          { op: 'smult', op_id: ':smult:initial' },
          { op: 'smult', op_id: ':smult1:', count: choice_bits_count(Math.max, -1) },
          { op: 'sxor_bit', op_id: ':sxor_bit1:', count: choice_bits_count(Math.max, -1) },
          { op: 'smult', op_id: ':smult2:', count: choice_bits_count(Math.min, -1) },
          { op: 'sxor_bit', op_id: ':sxor_bit2:', count: choice_bits_count(Math.min, -1) }
        ],
        'bits.smult': dynamic_bits_smult,
        'bits.sdiv': dynamic_bits_sdiv,
        'bits.open': [
          { op: 'open', op_id: ':', count: bits_count }
        ],
        // refresh/open
        'refresh': [
          { op: 'generate_zero', op_id: '' }
        ],
        'open': [
          { op: 'refresh', op_id: ':refresh' }
        ],
        // generating a random number and its quotient / constant
        '__generate_random_and_quotient': [
          { op: 'bits.cgteq', op_id: ':bits_cgteq' },
          { op: 'if_else', op_id: ':ifelse1' },
          { op: 'if_else', op_id: ':ifelse2' },
          { op: 'sampling', op_id: ':rejection1' }
        ]
      }
    };

    // arithmetic protocols
    jiff.preprocessing_function_map['base']['sor_bit'] = jiff.preprocessing_function_map['base']['sxor_bit'];
    jiff.preprocessing_function_map['base']['smod'] = jiff.preprocessing_function_map['base']['sdiv'];
    jiff.preprocessing_function_map['base']['slteq'] = jiff.preprocessing_function_map['base']['slt'];
    jiff.preprocessing_function_map['base']['sgteq'] = jiff.preprocessing_function_map['base']['slt'];
    jiff.preprocessing_function_map['base']['sgt'] = jiff.preprocessing_function_map['base']['slt'];
    jiff.preprocessing_function_map['base']['clteq'] = jiff.preprocessing_function_map['base']['cgt'];
    jiff.preprocessing_function_map['base']['cgteq'] = jiff.preprocessing_function_map['base']['clt'];
    jiff.preprocessing_function_map['base']['seq'] = jiff.preprocessing_function_map['base']['clteq'];
    jiff.preprocessing_function_map['base']['sneq'] = jiff.preprocessing_function_map['base']['seq'];
    jiff.preprocessing_function_map['base']['ceq'] = jiff.preprocessing_function_map['base']['clteq'];
    jiff.preprocessing_function_map['base']['cneq'] = jiff.preprocessing_function_map['base']['ceq'];

    // bits protocols
    jiff.preprocessing_function_map['base']['bits.clt'] = jiff.preprocessing_function_map['base']['bits.cgteq'];
    jiff.preprocessing_function_map['base']['bits.clteq'] = jiff.preprocessing_function_map['base']['bits.cgteq'];
    jiff.preprocessing_function_map['base']['bits.cgt'] = jiff.preprocessing_function_map['base']['bits.cgteq'];
    jiff.preprocessing_function_map['base']['bits.ceq'] = jiff.preprocessing_function_map['base']['bits.cneq'];
    jiff.preprocessing_function_map['base']['bits.slt'] = jiff.preprocessing_function_map['base']['bits.sgteq'];
    jiff.preprocessing_function_map['base']['bits.slteq'] = jiff.preprocessing_function_map['base']['bits.sgt'];
    jiff.preprocessing_function_map['base']['bits.seq'] = jiff.preprocessing_function_map['base']['bits.sneq'];
    jiff.preprocessing_function_map['base']['bits.csubl'] = jiff.preprocessing_function_map['base']['bits.cadd'];
    jiff.preprocessing_function_map['base']['bits.csubr'] = jiff.preprocessing_function_map['base']['bits.cadd'];
    jiff.preprocessing_function_map['base']['bits.ssub'] = jiff.preprocessing_function_map['base']['bits.sadd'];

    /**
     * Checks if the given operation uses preprocessed values.
     * @method has_preprocessing
     * @memberof jiff-instance
     * @instance
     * @param {string} op - name of the operation to check.
     * @return {boolean} true if the op uses preprocessing, false otherwise.
     */
    jiff.has_preprocessing = function (op) {
      for (var i = 0; i < jiff.extensions.length; i++) {
        if (jiff.preprocessing_function_map[jiff.extensions[i]][op] != null) {
          return true;
        }
      }

      return false;
    };

    /**
     * Get a preprocessed share/value by associated op_id. If value does not exist
     * Fallback to some user specified way for creating it.
     * @method get_preprocessing
     * @memberof jiff-instance
     * @instance
     * @param {string} op_id - the op_id associated with the preprocessed value/share.
     * @return {object} the preprocessed share(s).
     */
    jiff.get_preprocessing = function (op_id) {
      var values = jiff.preprocessing_table[op_id];
      if (values != null) {
        return values;
      }
      if (jiff.crypto_provider === true) {
        return null;
      }
      throw new Error('No preprocessed value(s) that correspond to the op_id "' + op_id + '"');
    };

    /**
     * Store a pair of op_id and associated pre-processed value/share.
     * The value/share can be accessed later during the computation through jiff.get_preprocessing(op_id).
     * @method store_preprocessing
     * @memberof jiff-instance
     * @instance
     * @param {string} op_id - the op_id associated with the preprocessed value/share.
     * @param {SecretShare} share - the share/value to store.
     */
    jiff.store_preprocessing = function (op_id, share) {
      jiff.preprocessing_table[op_id] = share;
    };

    /**
     * Generate values used for jiff operations in advance of the general computation
     * @method __preprocessing
     * @memberof jiff-instance
     * @instance
     * @param {string} dependent_op - name of the operation that will later use the pre_processed values
     * @param {Number} count - number of times the protocol should be performed, number of values that will be generated
     * @param {Object} [protocols=defaults] - a mapping from base preprocessing elements (triplets, bit arrays) to functions that can pre-process them
     *                               the function must implement the same interface as the JIFF provided protocols (e.g. jiff.protocols.generate_beaver_bgw).
     *                               missing mappings indicate that JIFF must use the default protocols.
     * @param {Number} [threshold=receivers_list.length] - the threshold of the preprocessed shares.
     * @param {Array} [receivers_list=all_parties] - the parties that will receive the preprocsssed shares.
     * @param {Array} [compute_list=all_parties] - the parties that will compute the preprocsssed shares.
     * @param {Array} [Zp=jiff.Zp] - the Zp of the preprocessed shares.
     * @param {Array} [id_list=auto_gen()] - array of ids to be used sequentially to identify the pre_processed values. Optional.
     * @param {Object} params - any additional protocol-specific parameters.
     * @return {promise} a promise that is resolved when preprocessing is completed.
     */
    jiff.__preprocessing = function (dependent_op, count, protocols, threshold, receivers_list, compute_list, Zp, id_list, params) {
      var find_closest_namespace = function (op, starting_namespace) {
        var namespace_index = jiff.extensions.indexOf(starting_namespace);
        while (namespace_index >= 0) {
          var namespace = jiff.extensions[namespace_index];
          if (jiff.preprocessing_function_map[namespace] != null && jiff.preprocessing_function_map[namespace][op] != null) {
            return namespace;
          }
          namespace_index--;
        }

        return null;
      };

      // read only copy of params
      var _params = params;

      // Recursively follow jiff.preprocessing_function_map
      // to figure out the sub-components/nested primitives of the given operation
      // and pre-process those with the right op_ids.
      var promises = [];
      for (var i = 0; i < count; i++) {
        params = Object.assign({}, _params);
        if (params.op_id != null) {
          params.op_id = params.op_id + i;
        }

        var id = id_list[i];
        if (id == null) {
          // Two kinds of operations: one that relies on different sets of senders and receivers, and one that has a set of holders
          if (dependent_op === 'open' || dependent_op === 'bits.open') {
            var open_parties = params['open_parties'] != null ? params['open_parties'] : receivers_list;
            id = jiff.counters.gen_op_id2(dependent_op, open_parties, receivers_list);
          } else {
            id = jiff.counters.gen_op_id(dependent_op, receivers_list);
          }
        }

        var namespace = find_closest_namespace(dependent_op, params['namespace']);
        if (namespace == null) {
          var protocol = protocols[dependent_op];
          params.output_op_id = id;
          var result = protocol(threshold, receivers_list, compute_list, Zp, params, protocols);
          promises.push(result.promise);
          if (receivers_list.indexOf(jiff.id) > -1) {
            jiff.store_preprocessing(id, result.share);
          }
        } else {
          var preprocessing_dependencies = jiff.preprocessing_function_map[namespace][dependent_op];
          if (typeof(preprocessing_dependencies) === 'function') {
            preprocessing_dependencies = preprocessing_dependencies(dependent_op, count, protocols, threshold, receivers_list, compute_list, Zp, id_list, params);
          }
          for (var k = 0; k < preprocessing_dependencies.length; k++) {
            var dependency = preprocessing_dependencies[k];
            var next_op = dependency['op'];

            // copy both the originally given extra_params and the extra params of the dependency and merge them
            // together, dependency params overwrite duplicate keys.
            // If params are ever needed in non-leaf operations, this must be changed to accommodate
            var extra_params = Object.assign({}, params, dependency['params']);
            extra_params['namespace'] = dependency['namespace'] != null ? dependency['namespace'] : 'base';
            if (dependency.handler != null) {
              extra_params = dependency.handler(threshold, receivers_list, compute_list, Zp, id, extra_params);
            }
            if (extra_params.ignore === true) {
              continue;
            }

            // compose ids similar to how the actual operation is implemented
            var next_id_list = [];
            var next_count = dependency['count'];

            if (next_count == null) {
              next_count = 1;
              next_id_list[0] = id + dependency['op_id'];
            } else {
              next_count = next_count(threshold, receivers_list, compute_list, Zp, id, extra_params);
              for (var j = 0; j < next_count; j++) {
                next_id_list.push(id + dependency['op_id'] + j);
              }
            }

            if (extra_params['op_id'] != null) {
              extra_params['op_id'] = extra_params['op_id'] + dependency['op_id'];
            }

            promises.push(jiff.__preprocessing(next_op, next_count, protocols, threshold, receivers_list, compute_list, Zp, next_id_list, extra_params));
          }
        }
      }

      return Promise.all(promises);
    };

    /**
     * Stores all submitted and pending preprocessing tasks.
     * @member {Array} preprocessingTasks
     * @memberof jiff-instance
     * @instance
     */
    jiff.preprocessingTasks = [];

    /**
     * Callback to execute when preprocessing is done!
     * @member {function} preprocessingCallback
     * @memberof jiff-instance
     * @instance
     */
    jiff.preprocessingCallback = null;

    /**
     * Generate values used for jiff operations in advance of the general computation
     * @method preprocessing
     * @memberof jiff-instance
     * @instance
     * @param {string} dependent_op - name of the operation that will later use the pre_processed values
     * @param {Number} [count=1] - number of times the protocol should be performed, number of values that will be generated
     * @param {Number} [batch=count] - maximum number of parallel preprocessing tasks to execute in a single batch.
     * @param {Object} [protocols=defaults] - a mapping from base preprocessing elements ('beaver', 'bits', 'sampling') to functions that can pre-process them
     *                               the function must implement the same interface as the JIFF provided protocols (e.g. jiff.protocols.generate_beaver_bgw).
     *                               missing mappings indicate that JIFF must use the default protocols.
     * @param {Number} [threshold=receivers_list.length] - the threshold of the preprocessed shares.
     * @param {Array} [receivers_list=all_parties] - the parties that will receive the preprocsssed shares.
     * @param {Array} [compute_list=all_parties] - the parties that will compute the preprocsssed shares.
     * @param {Array} [Zp=jiff.Zp] - the Zp of the preprocessed shares.
     * @param {Array} [id_list=auto_gen()] - array of ids to be used sequentially to identify the pre_processed values. Optional.
     * @param {Object} [params={}] - any additional protocol-specific parameters.
     * @return {promise} a promise that is resolved when preprocessing is completed, null if this is called by a party that is neither a compute nor receiver party.
     */
    jiff.preprocessing = function (dependent_op, count, batch, protocols, threshold, receivers_list, compute_list, Zp, id_list, params) {
      var start = jiff.preprocessingTasks.length === 0;

      // defaults!
      if (receivers_list == null) {
        receivers_list = [];
        for (var p = 1; p <= jiff.party_count; p++) {
          receivers_list.push(p);
        }
      }
      if (compute_list == null) {
        compute_list = [];
        for (var c = 1; c <= jiff.party_count; c++) {
          compute_list.push(c);
        }
      }

      // not a receiver nor a sender
      if (receivers_list.indexOf(jiff.id) === -1 && compute_list.indexOf(jiff.id) === -1) {
        return null;
      }

      // more defaults
      if (params == null) {
        params = {};
      }
      if (Zp == null) {
        Zp = jiff.Zp;
      }
      if (threshold == null) {
        threshold = receivers_list.length;
      }
      if (id_list == null) {
        id_list = [];
      }
      protocols = Object.assign({}, jiff.default_preprocessing_protocols, protocols);

      // actual preprocessing
      if (count == null || count <= 0) {
        count = 1;
      }
      if (params == null) {
        params = {};
      }
      if (params['namespace'] == null) {
        params['namespace'] = jiff.extensions[jiff.extensions.length - 1];
      }
      batch = batch == null ? count : batch;

      // Create preprocessing tasks
      for (var i = 0; i < count; i += batch) {
        jiff.preprocessingTasks.push([dependent_op, Math.min(batch, count - i), protocols, threshold, receivers_list, compute_list, Zp, id_list, params]);
      }

      // Start daemon if not running!
      if (start) {
        jiff.preprocessingDaemon();
      }
    };

    /**
     * Preprocessing Daemon that executes all currently scheduled preprocessing tasks (entries in jiff.preprocessingTasks array) in order.
     * @method preprocessingDaemon
     * @memberof jiff-instance
     * @instance
     */
    jiff.preprocessingDaemon = function () {
      if (jiff.preprocessingTasks.length === 0) {
        if (jiff.preprocessingCallback != null) {
          jiff.counters.reset();

          var callback = jiff.preprocessingCallback;
          jiff.preprocessingCallback = null;
          callback(jiff);
        }
        return;
      }

      // execute a single preprocessing task!
      (function () {
        var args = arguments;
        console.log(jiff.id, 'Batch starting', args[0], args[1]);
        var promise = jiff.__preprocessing.apply(jiff, arguments);
        promise.then(function () {
          console.log(jiff.id, 'Batch done', args[0], args[1]);
          if (jiff.inspectDebug != null) {
            jiff.inspectDebug(Number.MAX_VALUE);
          }
          jiff.preprocessingTasks.shift();
          jiff.preprocessingDaemon();
        });
      }).apply(jiff, jiff.preprocessingTasks[0]);
    };

    /**
     * Calls the given callback when all preprocessing tasks have finished!
     * @method onFinishPreprocessing
     * @memberof jiff-instance
     * @instance
     */
    jiff.onFinishPreprocessing = function (callback) {
      if (jiff.preprocessingTasks.length === 0) {
        jiff.counters.reset();
        callback(jiff);
      } else {
        jiff.preprocessingCallback = callback;
      }
    };

    /**
     * Starts a new barrier, all promises and secret shares created between this call and the corresponding start_barrier
     * call will be part of this barrier. start_barrier may be called before previous barriers are resolved, in which
     * case promises / secret shares created will be part of the new barrier as well as any previous barriers.
     * @returns {number} a barrier id that identifies this barrier.
     */
    jiff.start_barrier = function () {
      jiff.barriers.push([]);
      return jiff.barriers.length - 1;
    };

    /**
     * Adds given promise to all active barriers.
     * @param {promise} promise - the promise to add.
     */
    jiff.add_to_barriers = function (promise) {
      for (var i = 0; i < jiff.barriers.length; i++) {
        jiff.barriers[i].push(promise);
      }
    };

    /**
     * Executes the callback only after all promises / secret shares in the barrier were resolved.
     * @param {number} [barrier_id=jiff.barriers.length - 1] - identifies the barrier, should be returned by start_barrier.
     *                                                         by default, barrier_id will refer to the last barrier.
     * @returns {promise} a promise that resolves after the secret shares are resolved.
     */
    jiff.end_barrier = function (barrier_id) {
      var barrier;
      if (barrier_id == null) {
        barrier = jiff.barriers.pop();
      } else {
        barrier = jiff.barriers[barrier_id];
        jiff.barriers.splice(barrier_id, 1);
      }

      return Promise.all(barrier);
    };


    /**
     * Disconnects from the computation.
     * Allows the client program to exit.
     * @method disconnect
     * @memberof jiff-instance
     * @instance
     * @param {boolean} [safe=false] - if true, jiff will disconnect safely (i.e. after ensuring all
     *                                 outgoing pending messages were delivered).
     * @param {boolean} [free=false] - if set to true, it means this party's disconnection is final, and all resources
     *                                 associated with this party must be freed.
     *                                 If all parties in a computation are freed, then all resources associated with the
     *                                 computation are freed, and any subsequent reconnection to the computation is as
     *                                 if a the connection is for a fresh new computation.
     * @param {function()} [callback] - executed after the instance safely disconnects, if safe is set to false, this
     *                                  parameter is ignored.
     */
    jiff.disconnect = function (safe, free, callback) {
      if (safe) {
        jiff.socket.safe_disconnect(free, callback);
      } else {
        if (free) {
          jiff.free();
        }
        jiff.socket.disconnect();
      }
    };

    /**
     * Emits event to free up all the resources allocated for this party on the server.
     * Best not to call this function directly, as it can break things if resources still need to be used.
     * Instead, use jiff.disconnect(safe, free, callback) to free after safely disconnecting.
     * @param {io.socket} socket - the socket through which to free.
     */
    jiff.free = function () {
      var msg = jiff.execute_array_hooks('beforeOperation', [jiff, 'free', {}], 2);
      if (options.__internal_socket == null) {
        jiff.socket.safe_emit('free', JSON.stringify(msg));
      } else {
        jiff.execute_array_hooks('afterOperation', [jiff, 'free', msg], 2);
      }
    };

    // Store the id when server sends it back
    jiff.socket.on('initialization', function (msg) {
      jiff.__initialized = true;
      jiff.initialization_counter = 0;

      msg = JSON.parse(msg);
      msg = jiff.execute_array_hooks('afterOperation', [jiff, 'initialization', msg], 2);

      if (jiff.id == null) {
        jiff.id = msg.party_id;
      }

      if (jiff.party_count == null) {
        jiff.party_count = msg.party_count;
      }

      // Now: (1) this party is connect (2) server (and other parties) know this public key
      // Resend all pending messages
      jiff.socket.resend_mailbox();

      // store the received public keys and resolve wait callbacks
      jiff.store_public_keys(msg.public_keys);
    });

    // Public keys were updated on the server, and it sent us the updates
    jiff.socket.on('public_keys', function (msg, callback) {
      callback(true);

      msg = JSON.parse(msg);
      msg = jiff.execute_array_hooks('afterOperation', [jiff, 'public_keys', msg], 2);

      jiff.store_public_keys(msg.public_keys);
    });

    // Store sharing and shares counter which keeps track of the count of
    // sharing operations (share and open) and the total number of shares
    // respectively (used to get a unique id for each share operation and
    // share object).
    jiff.counters = {};

    jiff.counters.reset = function () {
      jiff.counters.triplet_op_count = {};
      jiff.counters.number_op_count = {};
      jiff.counters.op_count = {};

      if (jiff.counters.pending_opens == null) {
        jiff.counters.pending_opens = 0;
      }

      //stores a seed for generating unique op_ids.
      jiff.op_id_seed = '';
    };

    // initialize counters
    jiff.counters.reset();

    /**
     * Shorthand for generating unique operation ids.
     * All primitives called after this seed will use their usual default ids prefixed by the seed.
     * Helpful when we have nested callbacks/functions (e.g. share_arrays) that may be executed in arbitrary order,
     * using this function as a the first call inside such callbacks with an appropriate deterministic unique base_op_id
     * ensures that regardless of the order of execution, operations in the same callback are matched correctly across
     * all parties.
     * Check out demos/graph-pip/mpc.js for an example on using this.
     * @method seed_ids
     * @memberof jiff-instance
     * @instance
     * @param {string|number} base_op_id - the base seed to use as a prefix for all future op_ids.
     */
    jiff.seed_ids = function (base_op_id) {
      if (base_op_id == null || base_op_id === '') {
        jiff.op_id_seed = '';
      } else {
        jiff.op_id_seed = base_op_id.toString() + ':';
      }
    };

    /**
     * Generate a unique operation id for a new operation object.
     * The returned op_id will be unique with respect to other operations, and identifies the same
     * operation across all parties, as long as all parties are executing instructions in the same order.
     * @param {string} op - the type/name of operation performed.
     * @param {Array} holders - an array containing the ids of all the parties carrying out the operation.
     * @return {string} the op_id for the operation.
     */
    jiff.counters.gen_op_id = function (op, holders) {
      var label = jiff.op_id_seed + op + ':' + holders.join(',');
      if (jiff.counters.op_count[label] == null) {
        jiff.counters.op_count[label] = 0;
      }
      return label + ':' + (jiff.counters.op_count[label]++);
    };

    /**
     * Generate a unique operation id for a new operation object given two distinct executing parties lists.
     * For example, when sharing, this is given two potentially different lists of senders and receivers.
     * The returned op_id will be unique with respect to other operations, and identifies the same
     * operation across all parties, as long as all parties are executing instructions in the same order.
     * @param {string} op - the type/name of operation performed.
     * @param {Array} receivers - an array containing the ids of all the parties carrying out the receiving portion of the operation.
     * @param {Array} senders - an array containing the ids of all the parties carrying out the sending portion of the operation.
     * @return {string} the op_id for the operation.
     */
    jiff.counters.gen_op_id2 = function (op, receivers, senders) {
      var label = jiff.op_id_seed + op + ':' + senders.join(',') + ':' + receivers.join(',');
      if (jiff.counters.op_count[label] == null) {
        jiff.counters.op_count[label] = 0;
      }
      return label + ':' + (jiff.counters.op_count[label]++);
    };

    // For logging / debugging
    jiff.logs = [];

    // Store a map from a sharing id (which share operation) to the
    // corresponding deferred and shares array.
    jiff.shares = {}; // Stores receive shares for open purposes.
    jiff.deferreds = {}; // Stores deferred that are resolved when required messages arrive.

    // Setup receiving matching shares
    jiff.socket.on('share', function (msg, callback) {
      callback(true); // send ack to server

      // parse message
      var json_msg = JSON.parse(msg);
      var sender_id = json_msg['party_id'];

      if (jiff.keymap[sender_id] != null) {
        receive_share(jiff, json_msg);
      } else {
        if (jiff.messagesWaitingKeys[sender_id] == null) {
          jiff.messagesWaitingKeys[sender_id] = [];
        }
        jiff.messagesWaitingKeys[sender_id].push({label: 'share', msg: json_msg});
      }
    });

    jiff.socket.on('open', function (msg, callback) {
      callback(true); // send ack to server

      // parse message
      var json_msg = JSON.parse(msg);
      var sender_id = json_msg['party_id'];

      if (jiff.keymap[sender_id] != null) {
        receive_open(jiff, json_msg);
      } else {
        if (jiff.messagesWaitingKeys[sender_id] == null) {
          jiff.messagesWaitingKeys[sender_id] = [];
        }
        jiff.messagesWaitingKeys[sender_id].push({ label: 'open', msg: json_msg });
      }
    });

    // handle custom messages
    jiff.socket.on('custom', function (msg, callback) {
      callback(true); // send ack to server

      var json_msg = JSON.parse(msg);
      var sender_id = json_msg['party_id'];
      var encrypted = json_msg['encrypted'];

      if (jiff.keymap[sender_id] != null || encrypted !== true) {
        receive_custom(jiff, json_msg);
      } else {
        // key must not exist yet for sender_id, and encrypted must be true
        if (jiff.messagesWaitingKeys[sender_id] == null) {
          jiff.messagesWaitingKeys[sender_id] = [];
        }
        jiff.messagesWaitingKeys[sender_id].push({ label: 'custom', msg: json_msg });
      }
    });

    jiff.socket.on('crypto_provider', function (msg, callback) {
      callback(true); // send ack to server

      msg = JSON.parse(msg);
      receive_crypto_provider(jiff, msg);
    });

    jiff.socket.on('error', function (msg) {
      try {
        msg = JSON.parse(msg);
        jiff.error(msg['label'], msg['error']);
      } catch (error) {
        jiff.error('socket.io', msg);
      }
    });

    jiff.socket.on('disconnect', function (reason) {
      if (reason !== 'io client disconnect') {
        // check that the reason is an error and not a user initiated disconnect
        console.log('Disconnected!', jiff.id, reason);
      }

      jiff.execute_array_hooks('afterOperation', [jiff, 'disconnect', reason], -1);
    });

    // Connect when all is done
    if (!(options.autoConnect === false)) {
      jiff.connect();
    }

    return jiff;
  }

  // Exported API
  exports.make_jiff = make_jiff;

  /**
   * Contains utility functions that may be useful outside of the instance code.
   * @memberof jiff
   * @type {object}
   * @namespace jiff.utils
   */
  exports.utils = {
    encrypt_and_sign: encrypt_and_sign,
    decrypt_and_sign: decrypt_and_sign,
    is_prime: is_prime
  };

  /**
   * Contains builtin sharing schemes provided by jiff.
   * @memberof jiff
   * @type {object}
   * @namespace jiff.sharing_schemes
   */
  exports.sharing_schemes = {
    shamir_share: jiff_compute_shares,
    shamir_reconstruct: jiff_lagrange
  };
}((typeof exports === 'undefined' ? this.jiff = {} : exports), typeof exports !== 'undefined'));
/**
 * This defines a library extension for for bignumbers in JIFF.
 * This wraps and exposes the jiff-client-bignumber API. Exposed members can be accessed with jiff_bignumber.&lt;member-name&gt;
 * in browser JS, or by using require('<path>/lib/ext/jiff-client-bignumber').&lt;member-name&gt; as usual in nodejs.
 * @namespace jiff_bignumber
 * @version 1.0
 *
 * FEATURES: supports all of the regular JIFF API.
 *
 * EXTENSION DESIGN INSTRUCTIONS AND EXPLANATION:
 *     1) write a top-level function like the one here: [i.e. (function(exports, node) { .... })(typeof(exports) ....)]
 *        this function acts as the scope for the extension, which forbids name conflicts as well as forbid others from
 *        modifying or messing around with the functions and constants inside. Additionally, it makes the code useable
 *        from the browsers and nodejs.
 *
 *     2) In the very last line replace this.jiff_bignumber = {} with this.jiff_<extension_name> = {}. This is the defacto
 *        name space for this extension. Calling code on the user-side will use that name (jiff_<extension_name>) to access the
 *        functions you choose to expose. For nodejs the name space will be ignored and calling code can use the object
 *        returned by the require() call corresponding to this extension.
 *
 *     3) Inside the top-level function, create a function called make_jiff. The function should take two parameters:
 *            (a) base_instance, (b) options.
 *        base_instance: the base instance to wrap the extension around, it can be a basic jiff-client.js instance or
 *            an instance of another extension, you can use this instance to perform the basic operation that build
 *            your extensions (sharing of integers, simple operations on ints, etc)
 *        options: should be an object that provides your extension with whatever options it requires. The options for
 *            the base_instance will be passed to it prior to calling your extensions and may not be inside the options
 *            object, but you can access them using base_instance.
 *
 *     4) If your extension requires other extensions be applied to the base instance, you can force this by performing a
 *        a check, by calling <base_instance>.has_extension(<extension_name>).
 *
 *     5) Adding functionality: You have two options:
 *            (A) use hooks to modify the functionality of the base instance "in place"
 *                and then return the base instance.
 *            (B) Create a new object that contains the base_instance (perhaps as an attribute named "base"), you will
 *                need to recreate the JIFF API at the new object level. The implementation of this API can use functionality
 *                from base_instance. Return the new object.
 *
 *     6) If you need to override any feature in jiff (change how share work, or how open work, or how some primitive
 *        work etc), look at the hooks documentation to see if it is available as a hook. If it is, your best bet would
 *        be to use hooks on top of the base_instance. Another approach could be to override functions inside the base_instance
 *        or to create a new object with brand new functions (that may or may not refer to base_instance). These approaches
 *        can be mixed.
 *
 *     7) If you want to add additional feature that does not override any other feature in jiff, implement that in a
 *        function under a new appropriate name, make sure to document the function properly.
 *
 *     8) at the end of the top-level function and after make_jiff is done, make sure to have an
 *        if(node) { ... } else { ... } block, in which you expose the make_jiff function.
 *
 *     9) do not forget to export the name of the extension.
 *
 * Keep in mind that others may base extensions on your extension, or that clients may want to combine functionality from two extensions
 * together. If you have specific dependencies or if you know that the extension will be incompatible with other extensions, make sure
 * to enforce it by performing checks and throwing errors, as well as potentially overriding the can_apply_extension function
 * which will be called when future extensions are applied after your extension.
 */
(function (exports, node) {
  /**
   * The name of this extension: 'bignumber'
   * @type {string}
   * @memberOf jiff_bignumber
   */
  exports.name = 'bignumber';

  var BigNumber_;
  if (node) {
    // has to be global to make sure BigNumber library sees it.
    global.crypto = require('crypto');
    BigNumber_ = require('bignumber.js');
  } else {
    window.crypto = window.crypto || window.msCrypto;
    BigNumber_ = window.BigNumber;
  }

  // dependencies = { 'BigNumber': <BigNumber.js> }
  exports.dependencies = function (dependencies) {
    BigNumber_ = dependencies['BigNumber'] != null ? dependencies['BigNumber'] : BigNumber_;
  };

  /**
   * Check that an integer is prime. Used to safely set the modulus Zp.
   * @memberof jiff_bignumber.utils
   * @param {number} p - the prime number candidate.
   * @returns {boolean} true if p is prime, false otherwise.
   */
  function is_prime(p) {
    // AKS Primality Test
    p = new BigNumber_(p);

    if (p.eq(2)) {
      return true;
    } else if (p.eq(3)) {
      return true;
    } else if (p.mod(2).eq(0)) {
      return false;
    } else if (p.mod(3).eq(0)) {
      return false;
    }

    var i = new BigNumber_(5);
    var n = new BigNumber_(2);
    var six6 = new BigNumber_(6);
    while (i.times(i).lte(p)) {
      if (p.mod(i).eq(0)) {
        return false;
      }
      i = i.plus(n);
      n = six6.minus(n);
    }

    return true;
  }

  /* Equivalent Shamir Sharing for BigNumbers */
  function jiff_compute_shares(jiff, secret, parties_list, threshold, Zp) {
    var shares = {}; // Keeps the shares
    var i;

    secret = jiff.helpers.BigNumber(secret);
    Zp = jiff.helpers.BigNumber(Zp);

    // Each player's random polynomial f must have
    // degree threshold - 1, so that threshold many points are needed
    // to interpolate/reconstruct.
    var t = threshold - 1;
    var polynomial = Array(t + 1); // stores the coefficients

    // Each players's random polynomial f must be constructed
    // such that f(0) = secret
    polynomial[0] = secret;

    // Compute the random polynomial f's coefficients
    for (i = 1; i <= t; i++) {
      polynomial[i] = jiff.helpers.random(Zp);
    }

    // Compute each players share such that share[i] = f(i)
    for (i = 0; i < parties_list.length; i++) {
      var p_id = parties_list[i];
      shares[p_id] = polynomial[0];
      var power = jiff.helpers.BigNumber(jiff.helpers.get_party_number(p_id));

      for (var j = 1; j < polynomial.length; j++) {
        var tmp = jiff.helpers.mod(polynomial[j].times(power), Zp);
        shares[p_id] = jiff.helpers.mod(shares[p_id].plus(tmp), Zp);
        power = jiff.helpers.mod(power.times(jiff.helpers.get_party_number(p_id)), Zp);
      }
    }

    return shares;
  }

  /* Equivalent lagrange interpolation for BigNumbers */
  function jiff_lagrange(jiff, shares) {
    var lagrange_coeff = []; // will contain shares.length many elements.
    var i, pi;

    // Compute the Lagrange coefficients at 0.
    for (i = 0; i < shares.length; i++) {
      shares[i].Zp = jiff.helpers.BigNumber(shares[i].Zp);

      pi = jiff.helpers.get_party_number(shares[i].sender_id);
      lagrange_coeff[pi] = jiff.helpers.BigNumber(1);

      for (var j = 0; j < shares.length; j++) {
        var pj = jiff.helpers.get_party_number(shares[j].sender_id);
        if (pj !== pi) {
          var inv = jiff.helpers.extended_gcd(pi - pj, shares[i].Zp)[0];
          lagrange_coeff[pi] = jiff.helpers.mod(lagrange_coeff[pi].times(0 - pj), shares[i].Zp).times(inv);
          lagrange_coeff[pi] = jiff.helpers.mod(lagrange_coeff[pi], shares[i].Zp);
        }
      }
    }

    // Reconstruct the secret via Lagrange interpolation
    var recons_secret = jiff.helpers.BigNumber(0);
    for (i = 0; i < shares.length; i++) {
      pi = jiff.helpers.get_party_number(shares[i].sender_id);
      var tmp = jiff.helpers.mod(shares[i].value.times(lagrange_coeff[pi]), shares[i].Zp);
      recons_secret = jiff.helpers.mod(recons_secret.plus(tmp), shares[i].Zp);
    }

    return recons_secret;
  }

  // modify secret share implementations to use BigNumber
  function createSecretShare(jiff, share, share_helpers) {
    var self = share;

    var oldIsConstant = self.isConstant;
    self.isConstant = function (o) {
      return oldIsConstant(o) || o.isBigNumber === true;
    };

    // Avoid having to rewrite all the primitives: just override the helpers with bignumber equivalent!
    share_helpers['+'] = function (v1, v2) {
      return v1.plus(v2);
    };
    share_helpers['-'] = function (v1, v2) {
      return v1.minus(v2);
    };
    share_helpers['*'] = function (v1, v2) {
      return v1.times(v2);
    };
    share_helpers['/'] = function (v1, v2) {
      return v1.div(v2);
    };
    share_helpers['<'] = function (v1, v2) {
      return jiff.helpers.BigNumber(v1).lt(v2);
    };
    share_helpers['<='] = function (v1, v2) {
      return jiff.helpers.BigNumber(v1).lte(v2);
    };
    share_helpers['=='] = function (v1, v2) {
      return jiff.helpers.BigNumber(v1).eq(v2);
    };
    share_helpers['floor/'] = function (v1, v2) {
      return v1.div(v2).floor();
    };
    share_helpers['pow'] = function (v1, v2) {
      return self.jiff.helpers.BigNumber(v1).pow(v2);
    };
    share_helpers['binary'] = function (v) {
      return v.toString() === '1' || v.toString() === '0';
    };
    share_helpers['floor'] = function (v) {
      if (typeof(v) === 'number') {
        return Math.floor(v);
      }
      return v.floor();
    };
    share_helpers['ceil'] = function (v) {
      if (typeof(v) === 'number') {
        return Math.ceil(v);
      }
      return v.ceil();
    };
    share_helpers['abs'] = function (v) {
      return v.abs();
    };

    return self;
  }

  // Take the jiff-client base instance and options for this extension, and use them
  // to construct an instance for this extension.
  function make_jiff(base_instance, options) {
    var jiff = base_instance;

    // Parse options
    if (options == null) {
      options = {};
    }
    if (options.Zp != null) {
      jiff.Zp = options.Zp;
      if (options.safemod === true && !is_prime(options.Zp)) {
        throw new Error('Zp = ' + options.Zp.toString() + ' is not prime.  Please use a prime number for the modulus or set safemod to false.');
      }
    }

    if (jiff.has_extension('negativenumber')) {
      throw new Error('Please apply bignumber before negative number extensions');
    }
    if (jiff.has_extension('fixedpoint')) {
      throw new Error('Please apply bignumber before negative number extensions');
    }

    // Turn things into their BigNumber equivalent

    /* HELPERS */
    jiff.helpers._BigNumber = BigNumber_;
    jiff.helpers._BigNumber.config({CRYPTO: true});
    jiff.helpers.BigNumber = function (n) {
      // eslint-disable-next-line no-undef
      return new jiff.helpers._BigNumber(n);
    };

    jiff.helpers.mod = function (x, y) {
      x = jiff.helpers.BigNumber(x);
      y = jiff.helpers.BigNumber(y);
      if (x.isNeg()) {
        return x.mod(y).plus(y);
      }
      return x.mod(y);
    };

    jiff.helpers.pow_mod = function (a, b, n) {
      a = jiff.helpers.BigNumber(a);
      return a.pow(b, n);
    };

    jiff.helpers.extended_gcd = function (a, b) {
      a = jiff.helpers.BigNumber(a);
      b = jiff.helpers.BigNumber(b);
      return (
        function recursive_helper(a, b) {
          if (b.isZero()) {
            return [jiff.helpers.BigNumber(1), jiff.helpers.BigNumber(0), a];
          }

          var temp = recursive_helper(b, jiff.helpers.mod(a, b));
          var x = temp[0];
          var y = temp[1];
          var d = temp[2];
          return [y, x.minus(y.times(a.div(b).floor())), d];
        }
      )(a, b);
    };

    jiff.helpers.bLog = function (value, base) {
      // Not really log, but good enough since all we need is either floor or ceil of log.
      if (base == null) {
        base = 2;
      }
      var blog = value.toString(base).length;
      var test = jiff.helpers.BigNumber(base).pow(blog - 1);
      if (test.eq(value)) {
        return blog - 1;
      }
      return blog - 0.5;
    };

    jiff.helpers.Zp_equals = function (s1, s2) {
      return s1.Zp.eq(s2.Zp);
    };

    jiff.helpers.random = function (max) {
      if (max == null) {
        max = jiff.Zp;
      }

      var precision = max.toString().length;
      // eslint-disable-next-line no-undef
      var magnitude = jiff.helpers.BigNumber(10).pow(precision);
      var multiple = magnitude.div(max).floor().times(max);

      var rand;
      do {
        // eslint-disable-next-line no-undef
        rand = jiff.helpers._BigNumber.random(precision).times(magnitude).floor();
      } while (rand.gte(multiple));

      return rand.mod(max);
    };

    // eslint-disable-next-line no-undef
    jiff.Zp = jiff.helpers.BigNumber(jiff.Zp);

    /* SUB-PROTOCOLS */
    jiff.protocols.bit_composition = function (bits) {
      var result = bits[0];
      var pow = jiff.helpers.BigNumber(1);
      for (var i = 1; i < bits.length; i++) {
        pow = pow.times(2);
        result = result.isadd(bits[i].icmult(pow));
      }
      return result;
    };

    jiff.protocols.bits.cgt = function (bits, constant, op_id) {
      if (!(bits[0].isConstant(constant))) {
        throw new Error('parameter should be a number (bits.cgt)');
      }
      if (op_id == null) {
        op_id = jiff.counters.gen_op_id('bits.cgt', bits[0].holders);
      }
      constant = jiff.helpers.BigNumber(constant);
      return jiff.protocols.bits.cgteq(bits, constant.plus(1), op_id);
    };

    /* SHARE CHECKS */
    jiff.share = function (secret, threshold, receivers_list, senders_list, Zp, share_id) {
      secret = secret != null ? jiff.helpers.BigNumber(secret) : secret;
      if (secret != null && (!secret.floor().eq(secret) || secret.lt(0))) {
        throw new Error('secret must be a non-negative whole number');
      }
      if (secret != null && (secret.gte(Zp == null ? jiff.Zp : Zp))) {
        throw new Error('secret must fit inside Zp');
      }
      return jiff.internal_share(secret, threshold, receivers_list, senders_list, Zp, share_id);
    };

    /* PREPROCESSING IS THE SAME */
    jiff.preprocessing_function_map[exports.name] = {};

    /* HOOKS */
    jiff.hooks.computeShares = jiff_compute_shares;
    jiff.hooks.reconstructShare = jiff_lagrange;

    jiff.hooks.createSecretShare.push(createSecretShare);
    // parse content of share/open messages to be bigNumbers (instead of strings due to encryption/decryption)
    jiff.hooks.afterOperation[0] = function (jiff, label, msg) {
      if (label === 'share' || label === 'open') {
        msg['share'] = jiff.helpers.BigNumber(msg['share']);
      } else if (label === 'crypto_provider' && msg['shares'] != null) {
        msg['Zp'] = jiff.helpers.BigNumber(msg['Zp']);
        for (var i = 0; i < msg['shares'].length; i++) {
          msg['shares'][i] = jiff.helpers.BigNumber(msg['shares'][i]);
        }
      }
      return msg;
    };

    return jiff;
  }

  // Expose the API for this extension.
  exports.make_jiff = make_jiff;
  exports.sharing_schemes = {shamir_share: jiff_compute_shares, shamir_reconstruct: jiff_lagrange};
  exports.utils = {is_prime: is_prime};
}((typeof exports === 'undefined' ? this.jiff_bignumber = {} : exports), typeof exports !== 'undefined'));

/**
 * This defines a library extension for for fixed point arithmetic in JIFF.
 * This wraps and exposes the jiff_fixedpoint API. Exposed members can be accessed with jiff_fixedpoint.&lt;member-name&gt;
 * in browser JS, or by using require('<path>/lib/ext/jiff-client-fixedpoint').&lt;member-name&gt; as usual in nodejs.
 *
 * @namespace jiff_fixedpoint
 * @version 1.0
 */
(function (exports, node) {
  /**
   * The name of this extension: 'fixedpoint'
   * @type {string}
   * @memberOf jiff_fixedpoint
   */
  exports.name = 'fixedpoint';

  function createFixedpointSecretShare(jiff_instance, share, share_helpers) {
    share.legacy = {};
    var internals = ['cadd', 'csub', 'cmult',
      'sadd', 'ssub', 'smult', 'smult_bgw',
      'cdivfac', 'cdiv', 'sdiv', 'smod',
      'cxor_bit', 'sxor_bit', 'cor_bit', 'sor_bit', 'not',
      'slt', 'slteq', 'sgt', 'sgteq', 'seq', 'sneq',
      'clt', 'clteq', 'cgt', 'cgteq', 'ceq', 'cneq',
      'lt_halfprime', 'if_else' ];
    for (var i = 0; i < internals.length; i++) {
      var key = internals[i];
      share.legacy[key] = share[key];
    }

    var magnitude = share.jiff.helpers.magnitude(share.jiff.decimal_digits);

    // Modify generic mult function to pass op_id to both cmult and smult
    share.mult = function (o, op_id) {
      if (share.isConstant(o)) {
        return share.cmult(o, op_id);
      }
      return share.smult(o, op_id);
    };

    // Constant arithmetic operations
    share.cadd = function (cst) {
      if (!(share.isConstant(cst))) {
        throw new Error('parameter should be a number (+)');
      }

      cst = share.jiff.helpers.BigNumber(cst);
      cst = share_helpers['floor'](share_helpers['*'](cst, magnitude));
      return share.legacy.cadd(cst);
    };
    share.csub = function (cst) {
      if (!(share.isConstant(cst))) {
        throw new Error('parameter should be a number (-)');
      }

      cst = share.jiff.helpers.BigNumber(cst);
      cst = share_helpers['floor'](share_helpers['*'](cst, magnitude));
      return share.legacy.csub(cst);
    };
    share.cmult = function (cst, op_id, div) {
      if (!(share.isConstant(cst))) {
        throw new Error('parameter should be a number (-)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('cmult', share.holders);
      }

      // turn to big number and multiply by magnitude
      cst = share.jiff.helpers.BigNumber(cst);
      var isInteger = cst.toString().indexOf('.') === -1;
      var cstDecimal = share_helpers['floor'](share_helpers['*'](cst, magnitude));

      // Different offset fixes if negative number is applied
      if (!share.jiff.has_extension('negativenumber')) {
        // Regular fixedpoint
        if (isInteger && div !== false) {
          return share.legacy.cmult(cst);
        }

        // multiply and move fixed point back
        var result = share.legacy.cmult(cstDecimal);
        if (div !== false) {
          result = result.legacy.cdiv(magnitude, op_id);
        }
        return result;
      } else {
        // With negative number
        var mOffset = magnitude.times(share.jiff.offset);
        if (isInteger && div !== false) {
          var tmp = share.legacy.cmult(cst);
          tmp = tmp.legacy.csub(mOffset.times(cst));
          tmp = tmp.legacy.cadd(mOffset);
          return tmp;
        }

        var resultNegative = share.legacy.cmult(cstDecimal);
        resultNegative = resultNegative.legacy.csub(mOffset.times(cstDecimal));
        resultNegative = resultNegative.legacy.cadd(mOffset.times(magnitude));
        if (div !== false) {
          resultNegative = resultNegative.legacy.cdiv(magnitude, op_id);
        }
        return resultNegative;
      }
    };

    share.cdivfac = function (cst) {
      if (!(share.isConstant(cst))) {
        throw new Error('Parameter should be a number (cdivfac)');
      }

      cst = share.jiff.helpers.BigNumber(cst).times(magnitude);
      var result = share.legacy.cdivfac(cst);
      return result.legacy.cmult(magnitude);
    };

    // secret arithmetic operations
    share.smult = function (o, op_id, div) {
      if (!(o.jiff === share.jiff)) {
        throw new Error('shares do not belong to the same instance (*)');
      }
      if (!share.jiff.helpers.Zp_equals(share, o)) {
        throw new Error('shares must belong to the same field (*)');
      }
      if (!share.jiff.helpers.array_equals(share.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (*)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('smult', share.holders);
      }

      var result = share.legacy.smult(o, op_id);

      // Negative number composing
      if (share.jiff.has_extension('negativenumber')) {
        var offset = share_helpers['*'](magnitude, share.jiff.offset);

        // Subtract x*offset*mag^2, y*offset*mag^2, offset^2*mag^2
        var subshare1 = share.icsub(offset).icmult(offset);
        var subshare2 = o.icsub(offset).icmult(offset);

        result = result.icsub(offset.pow(2));
        result = result.issub(subshare1).issub(subshare2);

        // Add offset term back on before dividing
        if (div === false) {
          result = result.icadd(offset);
        } else {
          result = result.icadd(offset.times(magnitude));
        }
      }

      if (div === false) {
        return result;
      }
      return result.legacy.cdiv(magnitude, op_id + ':reduce');
    };

    // BGW based secret multiplication
    share.smult_bgw = function (o, op_id, reshare, div) {
      if (!(o.jiff === share.jiff)) {
        throw new Error('shares do not belong to the same instance (bgw*)');
      }
      if (!share.jiff.helpers.Zp_equals(share, o)) {
        throw new Error('shares must belong to the same field (bgw*)');
      }
      if (!share.jiff.helpers.array_equals(share.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (bgw*)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('smult_bgw', share.holders);
      }

      var result = share.legacy.smult_bgw(o, op_id, reshare);

      // Negative number composing
      if (share.jiff.has_extension('negativenumber')) {
        var offset = share_helpers['*'](magnitude, share.jiff.offset);

        // Subtract x*offset*mag^2, y*offset*mag^2, offset^2*mag^2
        var subshare1 = share.icsub(offset).icmult(offset);
        var subshare2 = o.icsub(offset).icmult(offset);

        result = result.icsub(offset.pow(2));
        result = result.issub(subshare1).issub(subshare2);

        // Add offset term back on before dividing
        if (div === false) {
          result = result.icadd(offset);
        } else {
          result = result.icadd(offset.times(magnitude));
        }
      }

      if (div === false) {
        return result;
      }
      return result.legacy.cdiv(magnitude, op_id + ':reduce');
    };

    share.floor = function (o, op_id) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('floor', share.holders);
      }

      return share.legacy.cdiv(magnitude, op_id).legacy.cmult(magnitude);
    };

    // boolean operations on BINARY shares
    share.cxor_bit = function (cst) {
      if (!(share.isConstant(cst))) {
        throw new Error('parameter should be a number (^)');
      }
      if (!share_helpers['binary'](cst)) {
        throw new Error('parameter should be binary (^)');
      }

      // share should be both binary integers => our representation of it should be either 0 or 1 * 10^{decimal_digits}
      // In both cases, multiplying by the inverse of 10^{decimal_digits} should be enough to reduce it to either 0 or 1.
      var reduced_share = share.legacy.cdivfac(magnitude);
      var reduced_xor = reduced_share.legacy.cadd(cst).legacy.ssub(reduced_share.legacy.cmult(cst).legacy.cmult(2));
      return reduced_xor.legacy.cmult(magnitude);
    };
    share.cor_bit = function (cst) {
      if (!(share.isConstant(cst))) {
        throw new Error('parameter should be a number (|)');
      }
      if (!share_helpers['binary'](cst)) {
        throw new Error('parameter should be binary (|)');
      }

      // share should be both binary integers => our representation of it should be either 0 or 1 * 10^{decimal_digits}
      // In both cases, multiplying by the inverse of 10^{decimal_digits} should be enough to reduce it to either 0 or 1.
      var reduced_share = share.legacy.cdivfac(magnitude);
      var reduced_xor = reduced_share.legacy.cadd(cst).legacy.ssub(reduced_share.legacy.cmult(cst));
      return reduced_xor.legacy.cmult(magnitude);
    };
    share.sxor_bit = function (o, op_id) {
      if (!(o.jiff === share.jiff)) {
        throw new Error('shares do not belong to the same instance (^)');
      }
      if (!share.jiff.helpers.Zp_equals(share, o)) {
        throw new Error('shares must belong to the same field (^)');
      }
      if (!share.jiff.helpers.array_equals(share.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (^)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('sxor_bit', share.holders);
      }

      // share and o should be both binary integers => our representation of them should be either 0 or 1 * 10^{decimal_digits}
      // In both cases, multiplying by the inverse of 10^{decimal_digits} should be enough to reduce it to either 0 or 1.
      var reduced_share = share.legacy.cdivfac(magnitude);
      var reduced_o = o.legacy.cdivfac(magnitude);
      var reduced_xor = reduced_share.legacy.sadd(reduced_o).legacy.ssub(reduced_share.legacy.smult(reduced_o, op_id + ':smult1').legacy.cmult(2));
      return reduced_xor.legacy.cmult(magnitude);
    };
    share.sor_bit = function (o, op_id) {
      if (!(o.jiff === share.jiff)) {
        throw new Error('shares do not belong to the same instance (|)');
      }
      if (!share.jiff.helpers.Zp_equals(share, o)) {
        throw new Error('shares must belong to the same field (|)');
      }
      if (!share.jiff.helpers.array_equals(share.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (|)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('sor_bit', share.holders);
      }

      // share and o should be both binary integers => our representation of them should be either 0 or 1 * 10^{decimal_digits}
      // In both cases, multiplying by the inverse of 10^{decimal_digits} should be enough to reduce it to either 0 or 1.
      var reduced_share = share.legacy.cdivfac(magnitude);
      var reduced_o = o.legacy.cdivfac(magnitude);
      var reduced_or = reduced_share.legacy.sadd(reduced_o).legacy.ssub(reduced_share.legacy.smult(reduced_o, op_id + ':smult1'));
      return reduced_or.legacy.cmult(magnitude);
    };
    share.not = function () {
      return share.legacy.cmult(-1).legacy.cadd(magnitude);
    };

    // secret and constant comparisons
    var comparisons = [
      'slt', 'slteq', 'sgt', 'sgteq', 'seq', 'sneq',
      'clt', 'clteq', 'cgt', 'cgteq', 'ceq', 'cneq',
      'lt_halfprime'
    ];
    for (i = 0; i < comparisons.length; i++) {
      key = comparisons[i];
      share[key] = (function (key, i) {
        return function () {
          if (i > 5 && i < 12) {
            if (!(share.isConstant(arguments[0]))) {
              throw new Error('Parameter should be a number (' + key + ')');
            }
            arguments[0] = share.jiff.helpers.BigNumber(arguments[0]);
            arguments[0] = share_helpers['floor'](share_helpers['*'](arguments[0], magnitude));
          }
          var result = share.legacy[key].apply(share, arguments);
          return result.legacy.cmult(magnitude);
        };
      })(key, i);
    }

    // Fixedpoint division
    share.sdiv = function (o, l, op_id) {
      if (!(o.jiff === share.jiff)) {
        throw new Error('shares do not belong to the same instance (/)');
      }
      if (!share.jiff.helpers.Zp_equals(share, o)) {
        throw new Error('shares must belong to the same field (/)');
      }
      if (!share.jiff.helpers.array_equals(share.holders, o.holders)) {
        throw new Error('shares must be held by the same parties (/)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('sdiv', share.holders);
      }

      var increased = share.legacy.cmult(magnitude);

      if (l != null) {
        l = l + share_helpers['ceil'](share.jiff.helpers.bLog(magnitude));
      }
      return increased.legacy.sdiv(o, l, op_id);
    };
    share.cdiv = function (cst, op_id) {
      if (!(share.isConstant(cst))) {
        throw new Error('parameter should be a number (/)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('cdiv', share.holders);
      }

      // if cst is an integer, do same old constant division
      if (cst.toString().indexOf('.') === -1) {
        return share.legacy.cdiv(cst, op_id);
      }

      cst = share.jiff.helpers.BigNumber(cst);
      cst = share_helpers['floor'](share_helpers['*'](cst, magnitude));

      var increased = share.legacy.cmult(magnitude);
      return increased.legacy.cdiv(cst, op_id);
    };

    // optimized if_else
    share.if_else = function (val1, val2, op_id) {
      if (share.isConstant(val1)) {
        val1 = magnitude.times(val1).floor();
      }
      if (share.isConstant(val2)) {
        val2 = magnitude.times(val2).floor();
      }

      var reduce_share = share.legacy.cdivfac(magnitude);
      return reduce_share.legacy.if_else(val1, val2, op_id);
    };

    return share;
  }

  // Take the jiff-client base instance and options for this extension, and use them
  // to construct an instance for this extension.
  function make_jiff(base_instance, options) {
    if (!base_instance.has_extension('bignumber')) {
      throw new Error('Fixedpoint extension must be applied on top of bignumber extension.');
    }

    if (base_instance.has_extension('negativenumber')) {
      throw new Error('Fixedpoint extension must be applied before negativenumber extension.');
    }

    /*
     * PARSE OPTIONS
     */
    if (options == null) {
      options = {};
    }
    if (options.Zp != null) {
      base_instance.Zp = base_instance.helpers.BigNumber(options.Zp);
    }

    // Determine the digits allocation, produce errors or warnings if not enough digits exists in Zp
    base_instance.total_digits = Math.floor(base_instance.helpers.bLog(base_instance.Zp, 10));
    if (options.decimal_digits == null && options.integer_digits == null) {
      options.decimal_digits = Math.floor(base_instance.total_digits / 3);
      options.integer_digits = Math.floor(base_instance.total_digits / 3);
    } else if (options.decimal_digits == null) {
      options.decimal_digits = Math.floor((base_instance.total_digits - options.integer_digits) / 2);
    } else if (options.integer_digits == null) {
      options.integer_digits = base_instance.total_digits - 2 * options.decimal_digits;
    }

    if (options.free_digits == null) {
      options.free_digits = Math.min(base_instance.total_digits - options.decimal_digits - options.integer_digits, options.decimal_digits);
    }

    base_instance.decimal_digits = options.decimal_digits;
    base_instance.integer_digits = options.integer_digits;
    base_instance.free_digits = options.free_digits;
    if (base_instance.free_digits + base_instance.decimal_digits + base_instance.integer_digits > base_instance.total_digits || base_instance.free_digits < 0) {
      throw new Error('Fixedpoint: Zp is not large enough to fit given integer, decimal, and free parts size');
    }
    if (base_instance.free_digits < options.decimal_digits) {
      if (!(options.warn === false)) {
        console.log('Warning: Fixedpoint extension: not enough free_digits to perform secret multiplications/divisions/mod or constant multiplications/divisions against non-integer constants safely. Need ' + (options.decimal_digits - base_instance.free_digits) + ' more digits in Zp.');
      }
      base_instance.free_digits = 0;
    }

    /* HELPERS */
    base_instance.helpers.magnitude = function (m) {
      return base_instance.helpers.BigNumber(10).pow(m).floor();
    };
    base_instance.helpers.fits_in_digits = function (num) {
      var magnitude = base_instance.helpers.magnitude(base_instance.decimal_digits + base_instance.integer_digits);
      return magnitude.gt(num);
    };
    base_instance.helpers.format_as_float = function (v) {
      /* if (!(options.warn === false)) {
        var max_value = base_instance.helpers.magnitude(base_instance.decimal_digits + base_instance.integer_digits);
        if (v.gte(max_value)) {
          console.log('warning: Fixedpoint extension: open result is not accurate: integer part grew too big.');
        }
      } */
      var magnitude = base_instance.helpers.magnitude(base_instance.decimal_digits);
      return v.div(magnitude);
    };
    base_instance.helpers.format_as_fixed = function (v) {
      if (!base_instance.helpers.fits_in_digits(v)) {
        throw new Error('Fixedpoint share: integer part is too big');
      }
      var magnitude = base_instance.helpers.magnitude(base_instance.decimal_digits);
      return magnitude.times(v).floor();
    };
    base_instance.helpers.to_fixed = function (v) {
      v = base_instance.helpers.BigNumber(v);
      var str = v.toFixed(base_instance.decimal_digits, base_instance.helpers._BigNumber.ROUND_FLOOR);
      return base_instance.helpers.BigNumber(str);

    };

    // Speed up calculating certain popular inverses by pre-computing
    var stored_magnitude = base_instance.helpers.magnitude(base_instance.decimal_digits);
    var stored_maginv = base_instance.helpers.extended_gcd(stored_magnitude, base_instance.Zp);
    var old_extended_gcd = base_instance.helpers.extended_gcd;
    base_instance.helpers.extended_gcd = function (a, b) {
      if (stored_magnitude.eq(a) && base_instance.Zp.eq(b)) {
        return stored_maginv;
      }
      return old_extended_gcd(a, b);
    };

    /* OPEN */
    var old_open = base_instance.open;
    base_instance.open = function () {
      var promise = old_open.apply(base_instance, arguments);
      if (promise == null) {
        return null;
      }
      return promise.then(base_instance.helpers.format_as_float);
    };
    var old_receive_open = base_instance.receive_open;
    base_instance.receive_open = function () {
      var promise = old_receive_open.apply(base_instance, arguments);
      return promise.then(base_instance.helpers.format_as_float);
    };

    /* SHARE */
    var old_share = base_instance.share;
    base_instance.share = function (secret, threshold, receivers_list, senders_list, Zp, share_id) {
      if (secret != null) {
        secret = base_instance.helpers.format_as_fixed(secret);
      }
      return old_share(secret, threshold, receivers_list, senders_list, Zp, share_id);
    };

    /* changes to preprocessing */
    var previous_namespace = base_instance.extensions[base_instance.extensions.indexOf(exports.name)-1];
    var optional_div = function (threshold, receivers_list, compute_list, Zp, op_id, params) {
      if (params.div === false) {
        params.ignore = true;
      } else {
        params = cdiv_constant(threshold, receivers_list, compute_list, Zp, op_id, params);
      }
      return params;
    };
    var cdiv_constant = function (threshold, receivers_list, compute_list, Zp, op_id, params) {
      if (params.constant == null) {
        params.constant = base_instance.helpers.magnitude(base_instance.decimal_digits);
      }
      return params;
    };

    base_instance.preprocessing_function_map[exports.name] = {
      cmult: [
        { op: 'cdiv', op_id: '', namespace: previous_namespace, handler: optional_div }
      ],

      smult: [
        { op: 'smult', op_id: '', namespace: previous_namespace },
        { op: 'cdiv', op_id: ':reduce', namespace: previous_namespace, handler: optional_div }
      ],

      smult_bgw: [
        { op: 'cdiv', op_id: ':reduce', namespace: previous_namespace, handler: optional_div }
      ],

      floor: [
        { op: 'cdiv', op_id: '', namespace: previous_namespace, handler: cdiv_constant }
      ]
    };

    /* HOOKS */
    base_instance.hooks.createSecretShare.push(createFixedpointSecretShare);

    return base_instance;
  }

  // Expose API
  exports.make_jiff = make_jiff;
}((typeof exports === 'undefined' ? this.jiff_fixedpoint = {} : exports), typeof exports !== 'undefined'));

/**
 * This defines a library extension for for negativenumber in JIFF.
 * This wraps and exposes the jiff-client-negativenumber API. Exposed members can be accessed with jiff_negativenumber.&lt;member-name&gt;
 * in browser JS, or by using require('<path>/lib/ext/jiff-client-negativenumber').&lt;member-name&gt; as usual in nodejs.
 * @namespace jiff_negativenumber
 * @version 1.0
 *
 * FEATURES: supports all of the regular JIFF API.
 * COMPOSITION: composes with bignumber and fixedpoint extensions.
 *
 */

(function (exports, node) {
  /**
   * The name of this extension: 'negativenumber'
   * @type {string}
   * @memberOf jiff_negativenumber
   */
  exports.name = 'negativenumber';

  // secret share implementation
  function createNegativeNumberSecretShare(jiff, share, share_helpers) {
    var hasBigNumber = jiff.has_extension('bignumber');
    var hasFixedPoint = jiff.has_extension('fixedpoint');
    var offset = share.jiff.offset;

    // Keep a copy of the previous implementation of changed primitives
    share.negative_legacy = {};
    var internals = ['cadd', 'csub', 'cmult',
      'sadd', 'ssub', 'smult', 'smult_bgw',
      'cdivfac', 'cdiv', 'sdiv', 'smod',
      'cxor_bit', 'sxor_bit', 'cor_bit', 'sor_bit', 'not',
      'slt', 'slteq', 'sgt', 'sgteq', 'seq', 'sneq',
      'clt', 'clteq', 'cgt', 'cgteq', 'ceq', 'cneq',
      'lt_halfprime', 'if_else' ];
    for (var i = 0; i < internals.length; i++) {
      var key = internals[i];
      share.negative_legacy[key] = share[key];
    }

    // Constant arithmetic and boolean operations
    share.cmult = function (cst, op_id, div) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('cmult', share.holders);
      }

      var result = share.negative_legacy.cmult(cst, op_id, div);
      if (hasFixedPoint) {
        return result;
      }
      // Works for regular and bigNumbers
      result = result.negative_legacy.csub(share_helpers['*'](offset, cst));
      return result.negative_legacy.cadd(offset);
    };

    // Secret arithmetic operations
    share.sadd = function (o) {
      var result = share.negative_legacy.sadd(o);
      return result.negative_legacy.csub(offset);
    };
    share.ssub = function (o) {
      // The offset will cancel with the normal ssub, so we add it back on
      var result = share.negative_legacy.ssub(o);
      return result.negative_legacy.cadd(offset);
    };
    share.smult = function (o, op_id, div) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('smult', share.holders);
      }

      var result;
      if (hasFixedPoint) {
        // Regular multiplication
        // Result: x*y*mag^2 + x*offset*mag^2 + y*offset*mag^2 + offset^2*mag^2
        result = share.negative_legacy.smult(o, op_id, div);
      } else {
        result = share.negative_legacy.csub(offset);
        o = o.negative_legacy.csub(offset);
        result = result.negative_legacy.smult(o, op_id);
        result = result.negative_legacy.cadd(offset);
      }
      return result;
    };
    share.smult_bgw = function (o, op_id, reshare, div) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('smult_bgw', share.holders);
      }

      var result;
      if (hasFixedPoint) {
        // Regular multiplication
        // Result: x*y*mag^2 + x*offset*mag^2 + y*offset*mag^2 + offset^2*mag^2
        result = share.negative_legacy.smult_bgw(o, op_id, reshare, div);
      } else {
        result = share.negative_legacy.csub(offset);
        o = o.negative_legacy.csub(offset);
        result = result.negative_legacy.smult_bgw(o, op_id, reshare);
        result = result.negative_legacy.cadd(offset);
      }
      return result;
    };

    // bit operations
    share.cxor_bit = function (cst) {
      var result = share.negative_legacy.csub(offset);
      result = result.negative_legacy.cxor_bit(cst);
      return result.negative_legacy.cadd(offset);
    };
    share.cor_bit = function (cst_bit) {
      var result = share.negative_legacy.csub(offset);
      result = result.negative_legacy.cor_bit(cst_bit);
      return result.negative_legacy.cadd(offset);
    };
    // secret boolean operations
    share.sxor_bit = function (o, op_id) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('sxor_bit', share.holders);
      }

      var result = share.negative_legacy.csub(offset);
      o = o.negative_legacy.csub(offset);
      result = result.negative_legacy.sxor_bit(o, op_id);
      return result.negative_legacy.cadd(offset);
    };
    share.sor_bit = function (o, op_id) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('sor_bit', share.holders);
      }

      var result = share.negative_legacy.csub(offset);
      o = o.negative_legacy.csub(offset);
      result = result.negative_legacy.sor_bit(o, op_id);
      return result.negative_legacy.cadd(offset);
    };
    // not operator
    share.not = function () {
      var reduced = share.negative_legacy.csub(offset);
      reduced = reduced.icmult(-1).negative_legacy.cadd(1);
      return reduced.negative_legacy.cadd(offset);
    };

    // secret and constant comparisons
    var comparisons = [
      'slt', 'slteq', 'sgt', 'sgteq', 'seq', 'sneq',
      'clt', 'clteq', 'cgt', 'cgteq', 'ceq', 'cneq',
      'lt_halfprime'
    ];
    for (i = 0; i < comparisons.length; i++) {
      key = comparisons[i];
      share[key] = (function (key, i) {
        return function () {
          if (i > 5 && i < 12) {
            if (!(share.isConstant(arguments[0]))) {
              throw new Error('Parameter should be a number (' + key + ')');
            }
            arguments[0] = share_helpers['+'](offset, arguments[0]);
          }
          var result = share.negative_legacy[key].apply(share, arguments);
          return result.negative_legacy.cadd(offset);
        };
      })(key, i);
    }

    // Divisions will utilize this function to reduce the underlying representation
    // of shares that are known to be whole non-negative numbers to the base representation
    // so that they are compatible with base legacy operations.
    function reduce_representation(share) {
      share = share.negative_legacy.csub(offset);
      if (hasFixedPoint) {
        var magnitude = share.jiff.helpers.magnitude(share.jiff.decimal_digits);
        share = share.negative_legacy.cdivfac(magnitude);
      }
      return share;
    }

    // Divisions
    share.cdivfac = function (cst, op_id) {
      if (!(share.isConstant(cst))) {
        throw new Error('Parameter should be a number (cdivfac)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('cdivfac', share.holders);
      }

      // Absolute value of share and cst
      var shareAbs = share.iabs(op_id + ':abs', true);
      var selfNegative = shareAbs.isNegative;
      shareAbs = shareAbs.result.negative_legacy.csub(offset);

      cst = hasBigNumber ? share.jiff.helpers.BigNumber(cst) : cst;
      var otherNegative = share_helpers['<'](cst, 0);
      cst = share_helpers['abs'](cst);

      // This is the result assuming both share and o are non-negative
      var result = shareAbs.negative_legacy.cdivfac(cst);

      // For efficiency, since we know that selfNegative is a bit (i.e. non-negative integer)
      // reduce selfNegative to base representation (either 0 or 1 without offset or magnitude)
      // then use it to correct the sign of the result.
      selfNegative = reduce_representation(selfNegative);
      var signUnit = selfNegative.icmult(-2).icadd(1); // if negative this is -1, if positive this is 1

      // o is positive
      if (!otherNegative) { // only need to correct for if share is negative
        result = result.ismult(signUnit, op_id + ':cor1');
      } else { // o is negative, correct if share is positive
        result = result.ismult(signUnit.icmult(-1), op_id + ':cor1');
      }
      return result.negative_legacy.cadd(offset);
    };
    share.cdiv = function (cst, op_id, floor_down) {
      if (!(share.isConstant(cst))) {
        throw new Error('Parameter should be a number (cdiv)');
      }
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('cdiv', share.holders);
      }

      // Absolute value of share and cst
      var shareAbs = share.iabs(op_id + ':abs', true);
      var selfNegative = shareAbs.isNegative;
      shareAbs = shareAbs.result.negative_legacy.csub(offset);

      cst = hasBigNumber ? share.jiff.helpers.BigNumber(cst) : cst;
      var otherNegative = share_helpers['<'](cst, 0);
      var cstAbs = share_helpers['abs'](cst);

      // This is the result assuming both share and o are non-negative
      var resultAbs = shareAbs.negative_legacy.cdiv(cstAbs, op_id + ':cdiv');

      // Sign correction
      selfNegative = reduce_representation(selfNegative);
      var signUnit = selfNegative.icmult(-2).icadd(1); // if negative this is -1, if positive this is 1
      var result;
      if (!otherNegative) { // only need to correct for if share is negative
        result = resultAbs.ismult(signUnit, op_id + ':cor1');
      } else {
        result = resultAbs.ismult(signUnit.icmult(-1), op_id + ':cor1');
      }
      result = result.negative_legacy.cadd(offset);

      // Floor correction
      if (floor_down === false) { // Round to zero
        return result;
      } else { // Round down
        var magnitude = hasFixedPoint ? share.jiff.helpers.magnitude(share.jiff.decimal_digits) : 1;
        magnitude = cstAbs.toString().indexOf('.') > -1 ? magnitude : 1;
        magnitude = hasBigNumber ? share.jiff.helpers.BigNumber(magnitude) : magnitude;
        cstAbs = share_helpers['floor'](share_helpers['*'](magnitude, cstAbs));

        var need_round = resultAbs.icmult(cstAbs).isneq(shareAbs.icmult(magnitude), op_id + ':floor:sneq');
        var xorNegative = selfNegative.icxor_bit(otherNegative ? 1 : 0);

        // we must correct if (1) need rounding (i.e. cst does not divide share) (2) xorNegative (i.e. result is negative)
        var and = need_round.ismult(xorNegative, op_id+':floor:and');
        return result.issub(and);
      }
    };
    share.smod = function (o, l, op_id) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('smod', share.holders);
      }

      // Absolute value of share and o
      var shareAbs = share.iabs(op_id+':abs1', true);
      var negative = shareAbs.isNegative;
      shareAbs = shareAbs.result.negative_legacy.csub(offset);
      var oAbs = o.iabs(op_id+':abs2').negative_legacy.csub(offset);

      // |share| % |o|
      var result = shareAbs.negative_legacy.smod(oAbs, l, op_id + ':smod');
      negative = reduce_representation(negative);

      // Sign correction
      negative = negative.icmult(-2).icadd(1); // if negative = -1, else = 1
      result = result.ismult(negative, op_id+':smult');
      return result.negative_legacy.cadd(offset);
    };
    share.sdiv = function (o, l, op_id, floor_down) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('sdiv', share.holders);
      }

      // Absolute value of share and o
      var shareAbs = share.iabs(op_id + ':abs1', true);
      var selfNegative = shareAbs.isNegative;
      shareAbs = shareAbs.result.negative_legacy.csub(offset);

      var otherAbs = o.iabs(op_id + ':abs2', true);
      var otherNegative = otherAbs.isNegative;
      otherAbs = otherAbs.result.negative_legacy.csub(offset);

      // This is the result assuming both share and o are non-negative
      var resultAbs = shareAbs.negative_legacy.sdiv(otherAbs, l, op_id + ':sdiv');

      // Sign correction: if either share or o are negative but not both.
      selfNegative = reduce_representation(selfNegative);
      otherNegative = reduce_representation(otherNegative);
      var xorNegative = selfNegative.isxor_bit(otherNegative, op_id + ':sxor');
      var sign = xorNegative.icmult(-2).icadd(1); // if negative = -1, else = 1
      var result = resultAbs.ismult(sign, op_id + ':cor1');
      result = result.negative_legacy.cadd(offset);

      // Floor correction
      if (floor_down === false) { // Round to zero
        return result;
      } else { // Round down
        var magnitude = hasFixedPoint ? share.jiff.helpers.magnitude(share.jiff.decimal_digits) : 1;
        var need_round = resultAbs.ismult(otherAbs, op_id+':floor:smult').isneq(shareAbs.icmult(magnitude), op_id+':floor:sneq');

        // we must correct if (1) need rounding (i.e. cst does not divide share) (2) xorNegative (i.e. result is negative)
        var and = xorNegative.ismult(need_round, op_id + ':floor:and');
        return result.issub(and);
      }
    };

    // New Operations
    // absolute value
    share.abs = function (op_id, return_intermediate) {
      if (op_id == null) {
        op_id = share.jiff.counters.gen_op_id('abs', share.holders);
      }

      var _offset = offset;
      if (hasFixedPoint) {
        var magnitude = share.jiff.helpers.magnitude(share.jiff.decimal_digits);
        _offset = share_helpers['*'](magnitude, _offset);
      }

      var isNegative = share.iclt(_offset, op_id + ':clt'); // 0 or 1, no offset or magnitude
      var correction = share.icsub(_offset).icmult(2);
      var result = share.issub(correction.ismult(isNegative, op_id + ':smult'));

      if (return_intermediate === true) {
        if (hasFixedPoint) {
          isNegative = isNegative.icmult(share.jiff.helpers.magnitude(share.jiff.decimal_digits));
        }
        return { result: result, isNegative: isNegative.icadd(_offset) };
      } else {
        return result;
      }
    };
    share.iabs = share.abs;

    // optimized if_else
    share.if_else = function (val1, val2, op_id) {
      if (share.isConstant(val1)) {
        val1 = share_helpers['+'](offset, val1);
      }
      if (share.isConstant(val2)) {
        val2 = share_helpers['+'](offset, val2);
      }

      var reduce_share = share.negative_legacy.csub(offset);
      return reduce_share.negative_legacy.if_else(val1, val2, op_id);
    };

    return share;
  }

  // Take the jiff-client base instance and options for this extension, and use them
  // to construct an instance for this extension.
  function make_jiff(base_instance, options) {
    var jiff = base_instance;

    // Parse options
    if (options == null) {
      options = {};
    }

    // Offset 'scales' negative numbers
    jiff.offset = options.offset;
    if (jiff.offset == null) {
      if (jiff.has_extension('fixedpoint')) {
        jiff.offset = jiff.helpers.magnitude(jiff.integer_digits);

        // Sanity Checks
        var maxNoMult = jiff.helpers.magnitude(jiff.integer_digits + jiff.decimal_digits).times(2);
        if (!maxNoMult.lte(jiff.Zp)) {
          var msg = 'Fixedpoint|NegativeNumber: Zp is not large enough to fit given integer and decimal parts with negative numbers. ';
          msg += 'Need Zp >= ' + maxNoMult.toString() + ' to fit parameters.';
          throw msg;
        }
        var maxWithMult = jiff.helpers.magnitude(jiff.integer_digits + 2*jiff.decimal_digits).times(2);
        if (!maxWithMult.lte(jiff.Zp) && !(options.warn === false)) {
          var warnMsg = 'Warning: Fixedpoint|NegativeNumber extension: not enough free_digits to perform secret multiplications/divisions or constant multiplications/divisions against non-integer constants safely. ';
          warnMsg += 'Need Zp >= ' +maxWithMult.toString();
          console.log(warnMsg);
        }
      } else if (jiff.has_extension('bignumber')) {
        jiff.offset = jiff.Zp.div(2).floor();
      } else {
        jiff.offset = Math.floor(jiff.Zp / 2);
      }
    }

    var old_open = jiff.open;
    jiff.open = function () {
      var promise = old_open.apply(jiff, arguments);
      if (promise == null) {
        return null;
      } else {
        return promise.then(
          function (v) {
            if (jiff.has_extension('bignumber')) {
              return v.minus(jiff.offset);
            } else {
              return v - jiff.offset;
            }
          }
        );
      }
    };

    var old_receive_open = jiff.receive_open;
    jiff.receive_open = function () {
      var promise = old_receive_open.apply(jiff, arguments);
      return promise.then(
        function (v) {
          if (jiff.has_extension('bignumber')) {
            return v.minus(jiff.offset);
          } else {
            return v - jiff.offset;
          }
        }
      );
    };

    /* SHARE */
    var old_share = jiff.share;
    jiff.share = function (secret, threshold, receivers_list, senders_list, Zp, share_id) {
      if (secret != null) {
        if (jiff.has_extension('bignumber')) {
          secret = jiff.offset.plus(secret);
        } else {
          secret = secret + jiff.offset;
        }
      }
      return old_share(secret, threshold, receivers_list, senders_list, Zp, share_id);
    };

    /* changes to preprocessing */
    var previous_namespace = jiff.extensions[jiff.extensions.indexOf(exports.name)-1];
    var should_floor_down_preprocessing = function (threshold, receivers_list, compute_list, Zp, op_id, params) {
      if (params.floor_down === false) {
        params.ignore = true;
      }
      return params;
    };

    jiff.preprocessing_function_map[exports.name] = {
      abs: [
        { op: 'clt', op_id: ':clt' },
        { op: 'smult', op_id: ':smult' }
      ],
      cdivfac: [
        { op: 'abs', op_id: ':abs', namespace: exports.name },
        { op: 'smult', op_id: ':cor1' }
      ],
      cdiv: [
        { op: 'abs', op_id: ':abs', namespace: exports.name },
        { op: 'cdiv', op_id: ':cdiv', namespace: previous_namespace },
        { op: 'smult', op_id: ':cor1' },
        { op: 'sneq', op_id: ':floor:sneq', handler: should_floor_down_preprocessing },
        { op: 'smult', op_id: ':floor:and', handler: should_floor_down_preprocessing }
      ],
      sdiv: [
        { op: 'abs', op_id: ':abs1', namespace: exports.name },
        { op: 'abs', op_id: ':abs2', namespace: exports.name },
        { op: 'sdiv', op_id: ':sdiv', namespace: previous_namespace },
        { op: 'sxor_bit', op_id: ':sxor' },
        { op: 'smult', op_id: ':cor1' },
        { op: 'smult', op_id: ':floor:smult', handler: should_floor_down_preprocessing },
        { op: 'sneq', op_id: ':floor:sneq', handler: should_floor_down_preprocessing },
        { op: 'smult', op_id: ':floor:and', handler: should_floor_down_preprocessing }
      ],
      smod: [
        { op: 'abs', op_id: ':abs1', namespace: exports.name },
        { op: 'abs', op_id: ':abs2', namespace: exports.name },
        { op: 'smod', op_id: ':smod', namespace: previous_namespace },
        { op: 'smult', op_id: ':smult' }
      ]
    };

    /* HOOKS */
    jiff.hooks.createSecretShare.push(createNegativeNumberSecretShare);

    return jiff;
  }

  // Expose API
  exports.make_jiff = make_jiff;

}((typeof exports === 'undefined' ? this.jiff_negativenumber = {} : exports), typeof exports !== 'undefined'));


    </script>
    <script type="text/javascript">
      
      window.$__offline__$ = true;
      
      // neptune.js
      (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Exports a document to an HTML page with all outputs and interactions stored (minus scopes)
const markup = document.documentElement.innerHTML;

const getAllOutputs = function () {
  const outputs = {
    defaultPanels: {},
    customPanels: {}
  };

  const defaultPanels = document.getElementsByClassName('output-panel');
  for (let i = 0; i < defaultPanels.length; i++) {
    outputs.defaultPanels[defaultPanels[i].id] = defaultPanels[i].innerHTML;
  }

  const customPanels = document.getElementsByClassName('custom-output-div');
  for (let i = 0; i < customPanels.length; i++) {
    outputs.customPanels[customPanels[i].id] = customPanels[i].innerHTML;
  }

  return outputs;
};

const fillOutputs = function (outputs) {
  const defaultOutputs = outputs.defaultPanels;
  const customOutputs = outputs.customPanels;
  
  for (let key in defaultOutputs) {
    if (defaultOutputs.hasOwnProperty(key)) {
      const panel = document.getElementById(key);
      panel.reset();
      panel.innerHTML = defaultOutputs[key];
    }
  }
  for (let key in customOutputs) {
    if (customOutputs.hasOwnProperty(key)) {
      const panel = document.getElementById(key);
      panel.innerHTML = customOutputs[key];
    }
  }
};

const genCode = function (outputs) {
  return '<script type="text/javascript">' +
  'window.$__offline__$ = true;' +
  '(' + fillOutputs.toString() + ')(' + JSON.stringify(outputs) + ');' +
  '<' + '/' + 'script>';
};

module.exports = function () {
  const suffix = "\n<script type='text/javascipt'>window.$__offline__$ = true;<" + "/script>\n";
  const content = "<html>\n" + markup + genCode(getAllOutputs()) + "<" + "/html>";

  const blob = new Blob([content], {type: 'text/javascript;charset=utf-8'});
  saveAs(blob, 'output.html');
};

},{}],2:[function(require,module,exports){
(function (global){
/*
 * Handles scoped evaluation of user code.
 * Uses eval within function closures to isolate the different scope and persist eval variables
 * and scope after execution in case the scope must be re-used!
 *
 * Code running inside eval has access to the following global variables:
 *   Constants: $__scopes__$, $__logMiddlewareBrowser__$, $__logMiddlewareServer__$
 *   Variables: $__eval__$, $__code__$, Console
 *   Browser-only: require, module, exports from browserify.
 * It is unsafe to modify any of these variables inside user code. Console should be used to log outputs to the UI.
 *
 */

// Store all scopes
const $__scopes__$ = {};

// creates the function without a closure (in global scope)
// protects the scope of this file and other neptune files from interferance from inside eval
const $__eval__$ = function $__eval__$(Console, $__code__$) {
  // Quine for scoping evals: relies on function closures to return a handler to the scope after an eval is executed!
  // Simplified fiddle to help understand why this quine is useful: https://jsfiddle.net/kjvo6h2x/
  try {
    $__code__$ += '\n';
    $__code__$ += $__eval__$.toString();
    $__code__$ += '$__eval__$;';
    return eval($__code__$);
  } catch (exception) {
    Console.log(exception);
    return $__eval__$;
  }
};

const $__logMiddlewareBrowser__$ = function (tabID) {
  return document.getElementById(tabID+'-output').Console;
}

const $__logMiddlewareServer__$ = function () {
  const Console = {};
  Console.log = function () {
    global.$__logs__$.push(arguments);
  };
  return Console;
}

// determine scope and eval within it!
module.exports = function (code, scopeName, tabID) {
  const Console = tabID ? $__logMiddlewareBrowser__$(tabID) : $__logMiddlewareServer__$();

  if (scopeName == null) {
    scopeName = '$__DEFAULT__$';
  }

  // create empty scope if it does not exist
  if ($__scopes__$[scopeName] == null) {
    $__scopes__$[scopeName] = $__eval__$;
  }

  // eval within scope
  $__scopes__$[scopeName] = $__scopes__$[scopeName](Console, code);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){
// format arguments as if console.log
module.exports = function () {
  let msg = '';

  // loop over arguments and format each
  for (let i = 0; i < arguments.length; i++) {
    // argument is an error: display error name and stack information if available
    if (arguments[i] instanceof Error) {
      msg += arguments[i].toString();

      // vendo-specific error API
      if (arguments[i].lineNumber) {
        msg += '\t' + arguments[i].lineNumber;
        if (arguments[i].columnNumber) {
          msg += ':' + arguments[i].columnNumber;
        }
      }
      if (arguments[i].stack) {
        let stackStr = arguments[i].stack.toString().split('\n').join('\n\t\t');
        msg += '\nStack:\t' + stackStr;
      }

      msg += '\n';
    } else if (typeof(arguments[i]) === 'object') {
      // Object, use JSON
      msg += JSON.stringify(arguments[i]) + ' ';
    } else {
      // Primitive type, use toString
      msg += arguments[i].toString() + ' ';
    }
  }

  return msg;
};

},{}],4:[function(require,module,exports){
module.exports = function (preTag, codeTag) {
  // Parse options from markdown
  const options = JSON.parse(codeTag.dataset.options);

  // create placeholder span element and put code inside it!
  let element;
  if (options['language'] === 'javascript') {
    element = document.createElement('script');
    element.type = 'text/javascript';
    element.innerHTML = codeTag.textContent;
  } else if (options['language'] === 'css') {
    element = document.createElement('style');
    element.innerHTML = codeTag.textContent;
  } else {
    element = document.createElement('span');
    element.innerHTML = codeTag.textContent;
  }

  // replace <pre> with this
  preTag.parentNode.replaceChild(element, preTag);
};

},{}],5:[function(require,module,exports){
(function () {
  const Tabs = require('./tabs.js');
  const Inject = require('./inject.js');
  document.getElementById('neptune-download').onclick = require('./download.js');

  const outputIDs = []; // stores all reserved output <div> IDs

  /*
   * Detect <pre> and <code> tags of interest
   */
  const preTags = Array.from(document.getElementsByTagName('pre'));
  const codeTags = preTags.map(function (preTag) {
    return Array.from(preTag.getElementsByTagName('code'));
  }).reduce(function (codeTags1, codeTags2) {
    return codeTags1.concat(codeTags2);
  }, []).filter(function (codeTag) {
    return codeTag.className.indexOf('language-neptune') > -1;
  });

  /*
   * Helper functions
   */
  const getOptions = function (codeTag) {
    const defaultOptions = {
      title: 'Javascript',
      env: 'browser',
      language: 'javascript',
      inject: false
    };

    // result
    const options = Object.assign({}, defaultOptions);
    const addOption = function (key, val) {
      console.log(key, val);
      options[key] = val;

      if (key === 'env' && options['title'] === defaultOptions['title']) {
        options['title'] = val;
      } else if (key === 'language') {
        options['language'] = options['language'].toLowerCase();
      } else if (key === 'outputID') {
        const id = options['outputID'];
        if (outputIDs.indexOf(id) > -1) {
          throw new Error('Duplicated outputID ' + id);
        }
        outputIDs.push(id);
      }
    };

    // parse options
    for (let className of codeTag.classList) {
      className = className.trim();
      if (!className.startsWith('neptune') || className.indexOf('[') === -1) {
        continue;
      }

      className = className.substring(('neptune[').length, className.length-1);
      className.split(',').map(function (option) {
        const index = option.indexOf('=');
        const key = option.substring(0, index);
        const val = option.substring(index + 1);
        addOption(key, val);
      });
    }

    return options;
  };

  const styleCodeBlock = function (codeTag) {
    const preTag = codeTag.parentNode;

    // get neptune code options from markdown
    const options = getOptions(codeTag);
    codeTag.dataset.options = JSON.stringify(options);

    // Make sure PRISM understands that this is JS
    codeTag.className = 'language-' + options['language'];
    preTag.className = 'language-' + options['language'];
    preTag.classList.add('line-numbers'); // add line numbering

    // If inject property is true, then inject code into page at this point without displaying it
    if (options['inject']) {
      Inject(preTag, codeTag);
    } else {
      // Style code as a tabbed frame with a toolbar and editor!
      Tabs(preTag, codeTag);
    }
  };

  /*
   * Apply styling and functionality
   */
  codeTags.map(function (codeTag) {
    styleCodeBlock(codeTag);
  });
})();

},{"./download.js":1,"./inject.js":4,"./tabs.js":8}],6:[function(require,module,exports){
const formatter = require('./formatter.js');

function lineHeader () {
  const user = this.dataset.user;
  const host = this.dataset.host;
  return '<span class="output-line-span">[' + user + '@' + host + '] $</span> | ';
}

function reset(hideOutput) {
  this.dataset.shown = true;
  if (this.dataset.hideOutput !== 'true') {
    this.style.display = 'block';
  }
  if (this.dataset.language === 'javascript') {
    this.children[0].innerHTML = 'Running...';
  }
}

function display(output) {
  if (this.children[0].textContent === 'Running...') {
    this.children[0].innerHTML = '';
  } else {
    this.children[0].innerHTML += '\n';
  }

  const lineHeader = this.lineHeader();
  this.children[0].innerHTML += lineHeader + output.split('\n').join('\n' + lineHeader);
}

function hide() {
  this.style.display = 'none';
  this.dataset.hideOutput = 'true';
}

function unhide() {
  this.dataset.hideOutput = 'false';
  if (this.dataset.shown) {
    this.style.display = 'block';
  }
}

// mimic console.log / console.time / etc
const Console = {
  // this here is bound to the output panel HTML element
  log: function () {
    console.log.apply(console, arguments);
    this.display(formatter.apply(null, arguments));
  }
};

// Creates a terminal-like area for javascript or an empty div for HTML/CSS
module.exports = function (tabID, options) {
  let outputElement;
  if (options['language'] === 'javascript') {
    outputElement = document.createElement('pre');

    outputElement.classList.add('command-line');
    outputElement.dataset.user = options['title'].toLowerCase();
    outputElement.dataset.host = options['env'].toLowerCase();

    // create code tag
    const codeElement = document.createElement('code');
    codeElement.className = 'language-bash';
    outputElement.appendChild(codeElement);

    // bind util functions to HTML element
    outputElement.display = display.bind(outputElement);
    outputElement.Console = {};
    for (const attr in Console) {
      outputElement.Console[attr] = Console[attr].bind(outputElement);
    }
  } else {
    outputElement = document.createElement('div');
  }

  // style output area
  outputElement.id = tabID + '-output';
  outputElement.classList.add('output-panel');
  outputElement.dataset.language = options['language'];

  // bind logging functions to output panel HTML element
  outputElement.reset = reset.bind(outputElement);
  outputElement.hide = hide.bind(outputElement);
  outputElement.unhide = unhide.bind(outputElement);
  outputElement.lineHeader = lineHeader.bind(outputElement);

  return outputElement;
};

},{"./formatter.js":3}],7:[function(require,module,exports){
// Execute this code using in the given scope name in the server via node, and get back results!
module.exports = function (code, scopeName, tabID) {
  const xhr = new XMLHttpRequest();
  xhr.open('POST', window.location.href + '/__exec');
  xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
  xhr.onreadystatechange = function (e) {
    if (xhr.readyState === 4 && xhr.status === 200) {
      const outputPanel = document.getElementById(tabID + '-output');
      for (const record of JSON.parse(xhr.responseText)) {
        outputPanel.Console.log(record);
      }
    }
  };
  xhr.send(JSON.stringify({scopeName: scopeName, code: code}));
};

},{}],8:[function(require,module,exports){
/*
 * dependencies
 */
const Toolbar = require('./toolbar.js');
const OutputPanel = require('./outputPanel.js');

let autoCounter = 0;

const createTab = function (title, tabsContainer, code, options) {
  const tabRadio = document.createElement('input');
  const tabLabel = document.createElement('label');
  const codeTab = document.createElement('div');

  // create ID for radio
  const count = tabsContainer.getElementsByTagName('input').length;
  const tabID = tabsContainer.id + '-tab-' + (count + 1);

  // Code mirror HTML elements
  const editorDiv = document.createElement('div');
  editorDiv.classList.add('code-mirror-div');
  editorDiv.dataset.options = JSON.stringify(options);

  let mode = options['language'].toLowerCase();
  if (mode === 'html') {
    mode += 'mixed';
  }
  editorDiv.codeMirrorInstance = CodeMirror(editorDiv, {
    value: code.trim(),
    mode: mode,
    lineNumbers: true,
    theme: 'darcula',
    viewportMargin: Infinity
  });
  if (count === 0) {
    setTimeout(function () {
      editorDiv.codeMirrorInstance.refresh();
    }, 1);
  }

  // style lable and radio
  tabRadio.className = 'tab-input';
  tabRadio.id = tabID;
  tabRadio.name = tabsContainer.id;
  tabRadio.type = 'radio';

  tabLabel.className = 'tab-label';
  tabLabel.id = tabID + '-label';
  tabLabel.setAttribute('for', tabID);
  tabLabel.innerHTML = title;
  if (count === 0) {
    tabRadio.setAttribute('checked', 'checked');
    tabLabel.classList.add('tab-label-selected');
    tabsContainer.dataset.selected = tabID;
  }

  tabRadio.onclick = function (e) {
    // remove selection from previous label
    const lastVal = tabsContainer.dataset.selected;
    const prevLabel = document.getElementById(lastVal + '-label');
    prevLabel.classList.remove('tab-label-selected');
    // select this label
    tabsContainer.dataset.selected = tabID;
    tabLabel.classList.add('tab-label-selected');
    // unminize icon if needed
    const topToolbar = tabsContainer.getElementsByClassName('code-top-toolbar')[0];
    const minimizeIcon = topToolbar.children[topToolbar.children.length - 1].children[0];
    minimizeIcon.classList.remove('fa-arrow-down');
    minimizeIcon.classList.add('fa-arrow-up');
    // refresh code mirror
    editorDiv.codeMirrorInstance.refresh();
  };

  // style container
  codeTab.id = tabID + '-tab';
  codeTab.classList.add('code-tab');

  // append code mirror
  codeTab.appendChild(editorDiv);

  // built-in default ouput panel
  codeTab.appendChild(OutputPanel(tabID, options));

  // create output div if requested
  if (options['outputID']) {
    const outputDiv = document.createElement('div');
    outputDiv.id = options['outputID'];
    outputDiv.classList.add('custom-output-div');
    codeTab.appendChild(outputDiv);
  }

  // add the code container to the tabs
  tabsContainer.insertBefore(tabLabel, tabsContainer.children[count]);
  tabsContainer.appendChild(tabRadio);
  tabsContainer.appendChild(codeTab);
};

const createTabsContainer = function (frameID) {
  const container = document.createElement('div');
  container.id = frameID;
  container.classList.add('code-tabs');
  return container;
};

const getOrCreateTabsContainer = function (frameID, preTag) {
  frameID = frameID || 'neptune-frame-' + (autoCounter++);
  let container = document.getElementById(frameID);

  if (container == null) {
    container = createTabsContainer(frameID);
    preTag.parentNode.replaceChild(container, preTag);
    container.appendChild(Toolbar());
  } else {
    preTag.parentNode.removeChild(preTag);
  }

  return container;
};

module.exports = function (preTag, codeTag) {
  // Parse options from markdown
  const options = JSON.parse(codeTag.dataset.options);
  const frameID = options['frame'];
  const title = options['title'];

  // Create (or get if exists) the tabs frame container
  const tabsContainer = getOrCreateTabsContainer(frameID, preTag);

  // Add this <pre><code> tags as a tab to the container
  createTab(title, tabsContainer, codeTag.textContent, options);
};

},{"./outputPanel.js":6,"./toolbar.js":9}],9:[function(require,module,exports){
const scopedEval = require('./eval.js');
const serverExec = require('./serverExec.js');

// handles clicking on a run icon for non-javascript code!
const executeNonJavascript = function (code, language, tabID) {
  if (language === 'css') {
    code = '<style>'+code+'</style>';
  }

  document.getElementById(tabID + '-output').innerHTML = code;
}

// handles clicking on an icon in the code toolbar
const toolbarClick = function () {
  const type = this.children[0].classList[1].split('-').slice(1).join('-');

  const tabID = this.parentNode.parentNode.dataset.selected;
  const tabRadio = document.getElementById(tabID);
  const tabLabel = document.getElementById(tabID + '-label');
  const codeTab = document.getElementById(tabID + '-tab');
  const outputPanel = document.getElementById(tabID + '-output');
  const codeMirrorDiv = codeTab.getElementsByClassName('code-mirror-div')[0];
  const codeMirrorInstance = codeMirrorDiv.codeMirrorInstance;

  const options = JSON.parse(codeMirrorDiv.dataset.options);

  let range;
  switch (type) {
    case 'copy':
      window.getSelection().removeAllRanges();
      range = document.createRange();
      range.selectNode(codeMirrorDiv);
      window.getSelection().addRange(range);
      document.execCommand('copy');
      window.getSelection().removeAllRanges();
      break;

    case 'trash':
      codeMirrorInstance.setValue('');
      break;

    case 'play':
      if ((options['offline'] === 'false' || options['offline'] === false || options['env'] === 'server') && window.$__offline__$) {
        alert('Cannot execute this piece of code while offline! Please run this document locally via a neptune server..');
        break;
      }

      outputPanel.reset();
      if (options['language'] === 'javascript') {
        if (options['env'] === 'server') {
          serverExec(codeMirrorInstance.getValue(), options['scope'], tabID);
        } else {
          scopedEval(codeMirrorInstance.getValue(), options['scope'], tabID);
        }
      } else {
        executeNonJavascript(codeMirrorInstance.getValue(), options['language'], tabID);
      }
      break;

    case 'arrow-up':
      tabRadio.checked = false;
      tabLabel.classList.remove('tab-label-selected');
      this.children[0].classList.remove('fa-arrow-up');
      this.children[0].classList.add('fa-arrow-down');
      break;

    case 'arrow-down':
      tabRadio.checked = true;
      tabLabel.classList.add('tab-label-selected');
      this.children[0].classList.remove('fa-arrow-down');
      this.children[0].classList.add('fa-arrow-up');
      break;

    case 'eye-slash':
      this.children[0].classList.remove('fa-eye-slash');
      this.children[0].classList.add('fa-eye');
      Array.from(this.parentNode.parentNode.getElementsByClassName('output-panel')).map(function (panel) {
        panel.hide();
      });
      break;

    case 'eye':
      this.children[0].classList.remove('fa-eye');
      this.children[0].classList.add('fa-eye-slash');
      Array.from(this.parentNode.parentNode.getElementsByClassName('output-panel')).map(function (panel) {
        panel.unhide();
      });
      break;
  }
};

// creates HTML elements for the toolbar on top of <code> tags
module.exports = function () {
  const element = document.createElement('span');
  element.classList.add('code-top-toolbar');
  element.innerHTML = '<a href="javascript:void(0)"><i class="fa fa-play"></i></a>' +
    '<a href="javascript:void(0)"><i class="fa fa-copy"></i></a>' +
    '<a href="javascript:void(0)"><i class="fa fa-trash"></i></a>' +
    '<a href="javascript:void(0)"><i class="fa fa-eye-slash"></i></a>' +
    '<a href="javascript:void(0)"><i class="fa fa-arrow-up"></i></a>';

  Array.from(element.children).map(function (aTag) {
    aTag.onclick = toolbarClick;
  });

  return element;
};

},{"./eval.js":2,"./serverExec.js":7}]},{},[5]);

    </script>
  </body>
</html>
  
